/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./node_modules/comlink/dist/esm/comlink.mjs":
/*!***************************************************!*\
  !*** ./node_modules/comlink/dist/esm/comlink.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   expose: () => (/* binding */ expose),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* unused harmony exports createEndpoint, finalizer, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint */\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously Â¯\\_(ãƒ„)_/Â¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didnâ€™t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\n\n//# sourceMappingURL=comlink.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tbGluay9kaXN0L2VzbS9jb21saW5rLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUIsa0JBQWtCLFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCLElBQUk7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlEQUF5RCxnQkFBZ0IsSUFBSTtBQUM3RSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpSTtBQUNqSSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1weXRob24ta2VybmVsLy4vbm9kZV9tb2R1bGVzL2NvbWxpbmsvZGlzdC9lc20vY29tbGluay5tanM/Mjc5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBwcm94eU1hcmtlciA9IFN5bWJvbChcIkNvbWxpbmsucHJveHlcIik7XG5jb25zdCBjcmVhdGVFbmRwb2ludCA9IFN5bWJvbChcIkNvbWxpbmsuZW5kcG9pbnRcIik7XG5jb25zdCByZWxlYXNlUHJveHkgPSBTeW1ib2woXCJDb21saW5rLnJlbGVhc2VQcm94eVwiKTtcbmNvbnN0IGZpbmFsaXplciA9IFN5bWJvbChcIkNvbWxpbmsuZmluYWxpemVyXCIpO1xuY29uc3QgdGhyb3dNYXJrZXIgPSBTeW1ib2woXCJDb21saW5rLnRocm93blwiKTtcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsKSB8fCB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCI7XG4vKipcbiAqIEludGVybmFsIHRyYW5zZmVyIGhhbmRsZSB0byBoYW5kbGUgb2JqZWN0cyBtYXJrZWQgdG8gcHJveHkuXG4gKi9cbmNvbnN0IHByb3h5VHJhbnNmZXJIYW5kbGVyID0ge1xuICAgIGNhbkhhbmRsZTogKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiB2YWxbcHJveHlNYXJrZXJdLFxuICAgIHNlcmlhbGl6ZShvYmopIHtcbiAgICAgICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBleHBvc2Uob2JqLCBwb3J0MSk7XG4gICAgICAgIHJldHVybiBbcG9ydDIsIFtwb3J0Ml1dO1xuICAgIH0sXG4gICAgZGVzZXJpYWxpemUocG9ydCkge1xuICAgICAgICBwb3J0LnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB3cmFwKHBvcnQpO1xuICAgIH0sXG59O1xuLyoqXG4gKiBJbnRlcm5hbCB0cmFuc2ZlciBoYW5kbGVyIHRvIGhhbmRsZSB0aHJvd24gZXhjZXB0aW9ucy5cbiAqL1xuY29uc3QgdGhyb3dUcmFuc2ZlckhhbmRsZXIgPSB7XG4gICAgY2FuSGFuZGxlOiAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiB0aHJvd01hcmtlciBpbiB2YWx1ZSxcbiAgICBzZXJpYWxpemUoeyB2YWx1ZSB9KSB7XG4gICAgICAgIGxldCBzZXJpYWxpemVkO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgc2VyaWFsaXplZCA9IHtcbiAgICAgICAgICAgICAgICBpc0Vycm9yOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHZhbHVlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiB2YWx1ZS5zdGFjayxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSB7IGlzRXJyb3I6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc2VyaWFsaXplZCwgW11dO1xuICAgIH0sXG4gICAgZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgICAgICBpZiAoc2VyaWFsaXplZC5pc0Vycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihzZXJpYWxpemVkLnZhbHVlLm1lc3NhZ2UpLCBzZXJpYWxpemVkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBzZXJpYWxpemVkLnZhbHVlO1xuICAgIH0sXG59O1xuLyoqXG4gKiBBbGxvd3MgY3VzdG9taXppbmcgdGhlIHNlcmlhbGl6YXRpb24gb2YgY2VydGFpbiB2YWx1ZXMuXG4gKi9cbmNvbnN0IHRyYW5zZmVySGFuZGxlcnMgPSBuZXcgTWFwKFtcbiAgICBbXCJwcm94eVwiLCBwcm94eVRyYW5zZmVySGFuZGxlcl0sXG4gICAgW1widGhyb3dcIiwgdGhyb3dUcmFuc2ZlckhhbmRsZXJdLFxuXSk7XG5mdW5jdGlvbiBpc0FsbG93ZWRPcmlnaW4oYWxsb3dlZE9yaWdpbnMsIG9yaWdpbikge1xuICAgIGZvciAoY29uc3QgYWxsb3dlZE9yaWdpbiBvZiBhbGxvd2VkT3JpZ2lucykge1xuICAgICAgICBpZiAob3JpZ2luID09PSBhbGxvd2VkT3JpZ2luIHx8IGFsbG93ZWRPcmlnaW4gPT09IFwiKlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dlZE9yaWdpbiBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBhbGxvd2VkT3JpZ2luLnRlc3Qob3JpZ2luKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXhwb3NlKG9iaiwgZXAgPSBnbG9iYWxUaGlzLCBhbGxvd2VkT3JpZ2lucyA9IFtcIipcIl0pIHtcbiAgICBlcC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBjYWxsYmFjayhldikge1xuICAgICAgICBpZiAoIWV2IHx8ICFldi5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FsbG93ZWRPcmlnaW4oYWxsb3dlZE9yaWdpbnMsIGV2Lm9yaWdpbikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBvcmlnaW4gJyR7ZXYub3JpZ2lufScgZm9yIGNvbWxpbmsgcHJveHlgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlkLCB0eXBlLCBwYXRoIH0gPSBPYmplY3QuYXNzaWduKHsgcGF0aDogW10gfSwgZXYuZGF0YSk7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50TGlzdCA9IChldi5kYXRhLmFyZ3VtZW50TGlzdCB8fCBbXSkubWFwKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICBsZXQgcmV0dXJuVmFsdWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLnNsaWNlKDAsIC0xKS5yZWR1Y2UoKG9iaiwgcHJvcCkgPT4gb2JqW3Byb3BdLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgcmF3VmFsdWUgPSBwYXRoLnJlZHVjZSgob2JqLCBwcm9wKSA9PiBvYmpbcHJvcF0sIG9iaik7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiR0VUXCIgLyogTWVzc2FnZVR5cGUuR0VUICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJhd1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJTRVRcIiAvKiBNZXNzYWdlVHlwZS5TRVQgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFtwYXRoLnNsaWNlKC0xKVswXV0gPSBmcm9tV2lyZVZhbHVlKGV2LmRhdGEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBUFBMWVwiIC8qIE1lc3NhZ2VUeXBlLkFQUExZICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJhd1ZhbHVlLmFwcGx5KHBhcmVudCwgYXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQ09OU1RSVUNUXCIgLyogTWVzc2FnZVR5cGUuQ09OU1RSVUNUICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyByYXdWYWx1ZSguLi5hcmd1bWVudExpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBwcm94eSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkVORFBPSU5UXCIgLyogTWVzc2FnZVR5cGUuRU5EUE9JTlQgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9zZShvYmosIHBvcnQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJhbnNmZXIocG9ydDEsIFtwb3J0MV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJSRUxFQVNFXCIgLyogTWVzc2FnZVR5cGUuUkVMRUFTRSAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKVxuICAgICAgICAgICAgLmNhdGNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIFt0aHJvd01hcmtlcl06IDAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXR1cm5WYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdpcmVWYWx1ZSksIHsgaWQgfSksIHRyYW5zZmVyYWJsZXMpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiUkVMRUFTRVwiIC8qIE1lc3NhZ2VUeXBlLlJFTEVBU0UgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBkZXRhY2ggYW5kIGRlYWN0aXZlIGFmdGVyIHNlbmRpbmcgcmVsZWFzZSByZXNwb25zZSBhYm92ZS5cbiAgICAgICAgICAgICAgICBlcC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgY2xvc2VFbmRQb2ludChlcCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsaXplciBpbiBvYmogJiYgdHlwZW9mIG9ialtmaW5hbGl6ZXJdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2ZpbmFsaXplcl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBTZW5kIFNlcmlhbGl6YXRpb24gRXJyb3IgVG8gQ2FsbGVyXG4gICAgICAgICAgICBjb25zdCBbd2lyZVZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IHRvV2lyZVZhbHVlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFR5cGVFcnJvcihcIlVuc2VyaWFsaXphYmxlIHJldHVybiB2YWx1ZVwiKSxcbiAgICAgICAgICAgICAgICBbdGhyb3dNYXJrZXJdOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdpcmVWYWx1ZSksIHsgaWQgfSksIHRyYW5zZmVyYWJsZXMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoZXAuc3RhcnQpIHtcbiAgICAgICAgZXAuc3RhcnQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc01lc3NhZ2VQb3J0KGVuZHBvaW50KSB7XG4gICAgcmV0dXJuIGVuZHBvaW50LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiTWVzc2FnZVBvcnRcIjtcbn1cbmZ1bmN0aW9uIGNsb3NlRW5kUG9pbnQoZW5kcG9pbnQpIHtcbiAgICBpZiAoaXNNZXNzYWdlUG9ydChlbmRwb2ludCkpXG4gICAgICAgIGVuZHBvaW50LmNsb3NlKCk7XG59XG5mdW5jdGlvbiB3cmFwKGVwLCB0YXJnZXQpIHtcbiAgICBjb25zdCBwZW5kaW5nTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIGVwLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXYpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBldjtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBwZW5kaW5nTGlzdGVuZXJzLmdldChkYXRhLmlkKTtcbiAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNvbHZlcihkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHBlbmRpbmdMaXN0ZW5lcnMuZGVsZXRlKGRhdGEuaWQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBbXSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUmVsZWFzZWQpIHtcbiAgICBpZiAoaXNSZWxlYXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm94eSBoYXMgYmVlbiByZWxlYXNlZCBhbmQgaXMgbm90IHVzZWFibGVcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVsZWFzZUVuZHBvaW50KGVwKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIG5ldyBNYXAoKSwge1xuICAgICAgICB0eXBlOiBcIlJFTEVBU0VcIiAvKiBNZXNzYWdlVHlwZS5SRUxFQVNFICovLFxuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBjbG9zZUVuZFBvaW50KGVwKTtcbiAgICB9KTtcbn1cbmNvbnN0IHByb3h5Q291bnRlciA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBwcm94eUZpbmFsaXplcnMgPSBcIkZpbmFsaXphdGlvblJlZ2lzdHJ5XCIgaW4gZ2xvYmFsVGhpcyAmJlxuICAgIG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoZXApID0+IHtcbiAgICAgICAgY29uc3QgbmV3Q291bnQgPSAocHJveHlDb3VudGVyLmdldChlcCkgfHwgMCkgLSAxO1xuICAgICAgICBwcm94eUNvdW50ZXIuc2V0KGVwLCBuZXdDb3VudCk7XG4gICAgICAgIGlmIChuZXdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmVsZWFzZUVuZHBvaW50KGVwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuZnVuY3Rpb24gcmVnaXN0ZXJQcm94eShwcm94eSwgZXApIHtcbiAgICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSArIDE7XG4gICAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpO1xuICAgIGlmIChwcm94eUZpbmFsaXplcnMpIHtcbiAgICAgICAgcHJveHlGaW5hbGl6ZXJzLnJlZ2lzdGVyKHByb3h5LCBlcCwgcHJveHkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJQcm94eShwcm94eSkge1xuICAgIGlmIChwcm94eUZpbmFsaXplcnMpIHtcbiAgICAgICAgcHJveHlGaW5hbGl6ZXJzLnVucmVnaXN0ZXIocHJveHkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBwYXRoID0gW10sIHRhcmdldCA9IGZ1bmN0aW9uICgpIHsgfSkge1xuICAgIGxldCBpc1Byb3h5UmVsZWFzZWQgPSBmYWxzZTtcbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIHtcbiAgICAgICAgZ2V0KF90YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gcmVsZWFzZVByb3h5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3RlclByb3h5KHByb3h5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZUVuZHBvaW50KGVwKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0xpc3RlbmVycy5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICBpc1Byb3h5UmVsZWFzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJ0aGVuXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGhlbjogKCkgPT4gcHJveHkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJHRVRcIiAvKiBNZXNzYWdlVHlwZS5HRVQgKi8sXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIudGhlbi5iaW5kKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBbLi4ucGF0aCwgcHJvcF0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoX3RhcmdldCwgcHJvcCwgcmF3VmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICAgICAgICAvLyBGSVhNRTogRVM2IFByb3h5IEhhbmRsZXIgYHNldGAgbWV0aG9kcyBhcmUgc3VwcG9zZWQgdG8gcmV0dXJuIGFcbiAgICAgICAgICAgIC8vIGJvb2xlYW4uIFRvIHNob3cgZ29vZCB3aWxsLCB3ZSByZXR1cm4gdHJ1ZSBhc3luY2hyb25vdXNseSDCr1xcXyjjg4QpXy/Cr1xuICAgICAgICAgICAgY29uc3QgW3ZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IHRvV2lyZVZhbHVlKHJhd1ZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJTRVRcIiAvKiBNZXNzYWdlVHlwZS5TRVQgKi8sXG4gICAgICAgICAgICAgICAgcGF0aDogWy4uLnBhdGgsIHByb3BdLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGx5KF90YXJnZXQsIF90aGlzQXJnLCByYXdBcmd1bWVudExpc3QpIHtcbiAgICAgICAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICAgICAgICBjb25zdCBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGxhc3QgPT09IGNyZWF0ZUVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJFTkRQT0lOVFwiIC8qIE1lc3NhZ2VUeXBlLkVORFBPSU5UICovLFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBqdXN0IHByZXRlbmQgdGhhdCBgYmluZCgpYCBkaWRu4oCZdCBoYXBwZW4uXG4gICAgICAgICAgICBpZiAobGFzdCA9PT0gXCJiaW5kXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFthcmd1bWVudExpc3QsIHRyYW5zZmVyYWJsZXNdID0gcHJvY2Vzc0FyZ3VtZW50cyhyYXdBcmd1bWVudExpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkFQUExZXCIgLyogTWVzc2FnZVR5cGUuQVBQTFkgKi8sXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgYXJndW1lbnRMaXN0LFxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uc3RydWN0KF90YXJnZXQsIHJhd0FyZ3VtZW50TGlzdCkge1xuICAgICAgICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgICAgICAgIGNvbnN0IFthcmd1bWVudExpc3QsIHRyYW5zZmVyYWJsZXNdID0gcHJvY2Vzc0FyZ3VtZW50cyhyYXdBcmd1bWVudExpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkNPTlNUUlVDVFwiIC8qIE1lc3NhZ2VUeXBlLkNPTlNUUlVDVCAqLyxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudExpc3QsXG4gICAgICAgICAgICB9LCB0cmFuc2ZlcmFibGVzKS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJlZ2lzdGVyUHJveHkocHJveHksIGVwKTtcbiAgICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiBteUZsYXQoYXJyKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycik7XG59XG5mdW5jdGlvbiBwcm9jZXNzQXJndW1lbnRzKGFyZ3VtZW50TGlzdCkge1xuICAgIGNvbnN0IHByb2Nlc3NlZCA9IGFyZ3VtZW50TGlzdC5tYXAodG9XaXJlVmFsdWUpO1xuICAgIHJldHVybiBbcHJvY2Vzc2VkLm1hcCgodikgPT4gdlswXSksIG15RmxhdChwcm9jZXNzZWQubWFwKCh2KSA9PiB2WzFdKSldO1xufVxuY29uc3QgdHJhbnNmZXJDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB0cmFuc2ZlcihvYmosIHRyYW5zZmVycykge1xuICAgIHRyYW5zZmVyQ2FjaGUuc2V0KG9iaiwgdHJhbnNmZXJzKTtcbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gcHJveHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCB7IFtwcm94eU1hcmtlcl06IHRydWUgfSk7XG59XG5mdW5jdGlvbiB3aW5kb3dFbmRwb2ludCh3LCBjb250ZXh0ID0gZ2xvYmFsVGhpcywgdGFyZ2V0T3JpZ2luID0gXCIqXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3N0TWVzc2FnZTogKG1zZywgdHJhbnNmZXJhYmxlcykgPT4gdy5wb3N0TWVzc2FnZShtc2csIHRhcmdldE9yaWdpbiwgdHJhbnNmZXJhYmxlcyksXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGNvbnRleHQuYWRkRXZlbnRMaXN0ZW5lci5iaW5kKGNvbnRleHQpLFxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBjb250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZChjb250ZXh0KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9XaXJlVmFsdWUodmFsdWUpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBoYW5kbGVyXSBvZiB0cmFuc2ZlckhhbmRsZXJzKSB7XG4gICAgICAgIGlmIChoYW5kbGVyLmNhbkhhbmRsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtzZXJpYWxpemVkVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gaGFuZGxlci5zZXJpYWxpemUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiSEFORExFUlwiIC8qIFdpcmVWYWx1ZVR5cGUuSEFORExFUiAqLyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNlcmlhbGl6ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUkFXXCIgLyogV2lyZVZhbHVlVHlwZS5SQVcgKi8sXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmZXJDYWNoZS5nZXQodmFsdWUpIHx8IFtdLFxuICAgIF07XG59XG5mdW5jdGlvbiBmcm9tV2lyZVZhbHVlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJIQU5ETEVSXCIgLyogV2lyZVZhbHVlVHlwZS5IQU5ETEVSICovOlxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZmVySGFuZGxlcnMuZ2V0KHZhbHVlLm5hbWUpLmRlc2VyaWFsaXplKHZhbHVlLnZhbHVlKTtcbiAgICAgICAgY2FzZSBcIlJBV1wiIC8qIFdpcmVWYWx1ZVR5cGUuUkFXICovOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIG1zZywgdHJhbnNmZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVVVUlEKCk7XG4gICAgICAgIHBlbmRpbmdMaXN0ZW5lcnMuc2V0KGlkLCByZXNvbHZlKTtcbiAgICAgICAgaWYgKGVwLnN0YXJ0KSB7XG4gICAgICAgICAgICBlcC5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGVwLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oeyBpZCB9LCBtc2cpLCB0cmFuc2ZlcnMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuICAgIHJldHVybiBuZXcgQXJyYXkoNClcbiAgICAgICAgLmZpbGwoMClcbiAgICAgICAgLm1hcCgoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikudG9TdHJpbmcoMTYpKVxuICAgICAgICAuam9pbihcIi1cIik7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUVuZHBvaW50LCBleHBvc2UsIGZpbmFsaXplciwgcHJveHksIHByb3h5TWFya2VyLCByZWxlYXNlUHJveHksIHRyYW5zZmVyLCB0cmFuc2ZlckhhbmRsZXJzLCB3aW5kb3dFbmRwb2ludCwgd3JhcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbGluay5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/comlink/dist/esm/comlink.mjs\n\n}");

/***/ }),

/***/ "./src/_pypi.ts":
/*!**********************!*\
  !*** ./src/_pypi.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allJSONUrl: () => (/* binding */ allJSONUrl),\n/* harmony export */   ipykernelWheelUrl: () => (/* binding */ ipykernelWheelUrl),\n/* harmony export */   pipliteWheelUrl: () => (/* binding */ pipliteWheelUrl),\n/* harmony export */   pyodide_kernelWheelUrl: () => (/* binding */ pyodide_kernelWheelUrl),\n/* harmony export */   widgetsnbextensionWheelUrl: () => (/* binding */ widgetsnbextensionWheelUrl),\n/* harmony export */   widgetsnbextensionWheelUrl1: () => (/* binding */ widgetsnbextensionWheelUrl1)\n/* harmony export */ });\n// this file is autogenerated from the wheels in the pypi directory\nconst allJSONUrl = \"pypi/all.json\";\nconst ipykernelWheelUrl = \"pypi/ipykernel-6.9.2-py3-none-any.whl\";\nconst pipliteWheelUrl = \"pypi/piplite-0.6.0a5-py3-none-any.whl\";\nconst pyodide_kernelWheelUrl = \"pypi/pyodide_kernel-0.6.0a5-py3-none-any.whl\";\nconst widgetsnbextensionWheelUrl = \"pypi/widgetsnbextension-3.6.999-py3-none-any.whl\";\nconst widgetsnbextensionWheelUrl1 = \"pypi/widgetsnbextension-4.0.999-py3-none-any.whl\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvX3B5cGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxtRUFBbUU7QUFDNUQsTUFBTSxVQUFVLEdBQUcsZUFBZSxDQUFDO0FBQ25DLE1BQU0saUJBQWlCLEdBQUcsdUNBQXVDLENBQUM7QUFDbEUsTUFBTSxlQUFlLEdBQUcsdUNBQXVDLENBQUM7QUFDaEUsTUFBTSxzQkFBc0IsR0FBRyw4Q0FBOEMsQ0FBQztBQUM5RSxNQUFNLDBCQUEwQixHQUFHLGtEQUFrRCxDQUFDO0FBQ3RGLE1BQU0sMkJBQTJCLEdBQUcsa0RBQWtELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItcHl0aG9uLWtlcm5lbC8uL3NyYy9fcHlwaS50cz9lODZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRoaXMgZmlsZSBpcyBhdXRvZ2VuZXJhdGVkIGZyb20gdGhlIHdoZWVscyBpbiB0aGUgcHlwaSBkaXJlY3RvcnlcbmV4cG9ydCBjb25zdCBhbGxKU09OVXJsID0gXCJweXBpL2FsbC5qc29uXCI7XG5leHBvcnQgY29uc3QgaXB5a2VybmVsV2hlZWxVcmwgPSBcInB5cGkvaXB5a2VybmVsLTYuOS4yLXB5My1ub25lLWFueS53aGxcIjtcbmV4cG9ydCBjb25zdCBwaXBsaXRlV2hlZWxVcmwgPSBcInB5cGkvcGlwbGl0ZS0wLjYuMGE1LXB5My1ub25lLWFueS53aGxcIjtcbmV4cG9ydCBjb25zdCBweW9kaWRlX2tlcm5lbFdoZWVsVXJsID0gXCJweXBpL3B5b2RpZGVfa2VybmVsLTAuNi4wYTUtcHkzLW5vbmUtYW55LndobFwiO1xuZXhwb3J0IGNvbnN0IHdpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsID0gXCJweXBpL3dpZGdldHNuYmV4dGVuc2lvbi0zLjYuOTk5LXB5My1ub25lLWFueS53aGxcIjtcbmV4cG9ydCBjb25zdCB3aWRnZXRzbmJleHRlbnNpb25XaGVlbFVybDEgPSBcInB5cGkvd2lkZ2V0c25iZXh0ZW5zaW9uLTQuMC45OTktcHkzLW5vbmUtYW55LndobFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/_pypi.ts\n\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Kernel: () => (/* binding */ Kernel)\n/* harmony export */ });\n/* harmony import */ var _pyodide_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pyodide-loader */ \"./src/pyodide-loader.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _pypi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_pypi */ \"./src/_pypi.ts\");\n/* harmony import */ var _manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./manager */ \"./src/manager.ts\");\n// Kernel implementation for Deno using Pyodide directly\n// Based on the PyodideRemoteKernel but adapted for direct execution in main thread\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    }\n    off(eventName, listener) {\n        if (!this.events[eventName])\n            return;\n        const index = this.events[eventName].indexOf(listener);\n        if (index > -1) {\n            this.events[eventName].splice(index, 1);\n        }\n    }\n    emit(eventName, ...args) {\n        if (!this.events[eventName])\n            return;\n        this.events[eventName].forEach(listener => listener(...args));\n    }\n    setMaxListeners(n) {\n        // No-op for browser compatibility\n    }\n}\n// @ts-ignore Importing from npm\n\n// Import types and enums\n\n// Import PyPI URLs\n\n// Event types from JupyterLab\n// Re-export types to maintain backward compatibility\n\n\nclass Kernel extends EventEmitter {\n    constructor() {\n        super();\n        this.initialized = false;\n        this.initPromise = null;\n        // Filesystem options\n        this.filesystemOptions = {\n            enabled: false,\n            root: \".\",\n            mountPoint: \"/home/pyodide\"\n        };\n        // Input handling\n        this._resolveInputReply = null;\n        // Execution state\n        this._parent_header = {};\n        this.executionCount = 0;\n        this._status = \"unknown\";\n        // Interrupt handling\n        this._interruptBuffer = null;\n        this._interruptSupported = false;\n        // Environment variables\n        this.environmentVariables = {};\n        // Native filesystem handles\n        this.nativeFsHandles = new Map();\n        this.autoSyncFs = false;\n        super.setMaxListeners(20);\n        // Generate a unique ID for this kernel instance\n        this.kernelId = `kernel_${Math.random().toString(36).substring(2)}_${Date.now()}`;\n    }\n    // Async method for kernel status\n    async getStatus() {\n        return this._status;\n    }\n    /**\n     * Initialize the kernel with maximum performance optimizations\n     * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n     */\n    async initialize(options) {\n        if (this.initialized) {\n            return;\n        }\n        if (this.initPromise) {\n            return this.initPromise;\n        }\n        // Set filesystem options if provided\n        if (options?.filesystem) {\n            this.filesystemOptions = {\n                ...this.filesystemOptions,\n                ...options.filesystem\n            };\n        }\n        // Set environment variables if provided\n        if (options?.env) {\n            this.environmentVariables = { ...options.env };\n        }\n        // Set lockFileURL if provided\n        if (options?.lockFileURL) {\n            this.lockFileURL = options.lockFileURL;\n        }\n        // Set autoSyncFs if provided\n        if (options?.autoSyncFs !== undefined) {\n            this.autoSyncFs = options.autoSyncFs;\n        }\n        this.initPromise = this._initializeInternal();\n        return this.initPromise;\n    }\n    /**\n     * Initialize the kernel with maximum performance optimizations\n     * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n     */\n    async _initializeInternal() {\n        const startTime = Date.now();\n        console.log(\"ðŸš€ Starting optimized kernel initialization...\");\n        try {\n            // Load Pyodide from CDN\n            const pyodideStartTime = Date.now();\n            // Configure pyodide options\n            const pyodideConfig = {};\n            if (this.lockFileURL) {\n                pyodideConfig.lockFileURL = this.lockFileURL;\n                console.log(`ðŸ”’ Using lockFileURL: ${this.lockFileURL}`);\n            }\n            // Use our CDN loader - it will automatically handle main thread vs worker\n            this.pyodide = await (0,_pyodide_loader__WEBPACK_IMPORTED_MODULE_0__.loadPyodide)(pyodideConfig);\n            const pyodideTime = Date.now() - pyodideStartTime;\n            console.log(`âœ… Pyodide loaded in ${pyodideTime}ms`);\n            // Initialize core components in parallel\n            if (this.lockFileURL) {\n                // When using lockFileURL, packages are pre-installed, skip package installation\n                console.log(\"ðŸš€ Using lock file - skipping package installation\");\n                const [,] = await Promise.all([\n                    // 1. Filesystem mounting (if enabled)\n                    this.filesystemOptions.enabled ? this.mountFilesystem() : Promise.resolve(),\n                    // 2. Environment variables setup\n                    this.setEnvironmentVariables()\n                ]);\n                // Initialize globals directly (packages are already available)\n                await this.initGlobals();\n            }\n            else {\n                // Standard initialization with package installation\n                const [, ,] = await Promise.all([\n                    // 1. Filesystem mounting (if enabled)\n                    this.filesystemOptions.enabled ? this.mountFilesystem() : Promise.resolve(),\n                    // 2. Package manager initialization\n                    this.initPackageManager(),\n                    // 3. Environment variables setup\n                    this.setEnvironmentVariables()\n                ]);\n                // Install packages and initialize globals\n                await this.initKernel();\n                await this.initGlobals();\n            }\n            const totalTime = Date.now() - startTime;\n            console.log(`ðŸŽ¯ KERNEL INITIALIZATION COMPLETE in ${totalTime}ms`);\n            console.log(`âš¡ Performance: Pyodide(${pyodideTime}ms) + Setup(${totalTime - pyodideTime}ms)`);\n            // Mark as initialized\n            this.initialized = true;\n            this._status = \"active\";\n            console.log(\"ðŸŸ¢ Kernel is now ACTIVE and ready for execution!\");\n        }\n        catch (error) {\n            console.error(\"âŒ Kernel initialization failed:\", error);\n            this._status = \"unknown\";\n            throw error;\n        }\n    }\n    /**\n     * Mount the local filesystem to the Pyodide environment\n     */\n    async mountFilesystem() {\n        try {\n            console.log(`Mounting filesystem from ${this.filesystemOptions.root} to ${this.filesystemOptions.mountPoint}`);\n            // Use the same approach as in deno-demo-fs-asgi.js for maximum compatibility\n            // Simple and direct mounting of the filesystem\n            await this.pyodide.FS.mount(this.pyodide.FS.filesystems.NODEFS, { root: this.filesystemOptions.root || \".\" }, this.filesystemOptions.mountPoint || \"/home/pyodide\");\n            console.log(\"Filesystem mounted successfully\");\n            // Verify the mount by listing the directory\n            try {\n                const mountedFiles = this.pyodide.FS.readdir(this.filesystemOptions.mountPoint || \"/home/pyodide\");\n                console.log(`Files in ${this.filesystemOptions.mountPoint} directory: ${mountedFiles.join(\", \")}`);\n            }\n            catch (error) {\n                console.error(`Error listing mounted directory: ${error}`);\n            }\n        }\n        catch (error) {\n            console.error(\"Error mounting filesystem:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Initialize the Pyodide package manager with optimized wheel loading\n     * OPTIMIZED: Smart caching and parallel wheel installation\n     */\n    async initPackageManager() {\n        const startTime = Date.now();\n        console.log(\"âš¡ Initializing optimized package manager...\");\n        try {\n            // Load micropip and packaging in parallel\n            console.log(\"ðŸ“¦ Loading micropip, packaging...\");\n            await this.pyodide.loadPackage(['micropip', 'packaging']);\n            console.log(\"âœ… Loaded micropip, packaging\");\n            // Get the base URL - use window.location for browser or fallback for worker\n            let baseUrl;\n            if (typeof window !== 'undefined' && window.location) {\n                // In main thread - use window.location\n                baseUrl = new URL(\".\", window.location.href).href;\n            }\n            else if (typeof self !== 'undefined' && self.location) {\n                // In web worker - use self.location\n                baseUrl = new URL(\".\", self.location.href).href;\n            }\n            else {\n                // Fallback - assume current origin\n                baseUrl = \"/\";\n            }\n            const allJsonPath = new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.allJSONUrl, baseUrl).href;\n            // Prepare all wheel URLs for parallel loading\n            const wheelFiles = [\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.pipliteWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.pyodide_kernelWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.ipykernelWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.widgetsnbextensionWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.widgetsnbextensionWheelUrl1, baseUrl).href,\n            ];\n            console.log(`ðŸš€ Installing ${wheelFiles.length} wheel packages in parallel...`);\n            // Install all wheel packages in parallel for maximum speed\n            const wheelPromises = wheelFiles.map(async (wheelUrl, index) => {\n                const wheelStartTime = Date.now();\n                try {\n                    await this.pyodide.runPythonAsync(`\nimport micropip\nawait micropip.install('${wheelUrl}', keep_going=True)\nprint(f\"âœ… Wheel ${index + 1}/${wheelFiles.length} installed\")\n`);\n                    const wheelTime = Date.now() - wheelStartTime;\n                    console.log(`âš¡ Wheel ${index + 1} installed in ${wheelTime}ms`);\n                    return { index, success: true, time: wheelTime };\n                }\n                catch (error) {\n                    const wheelTime = Date.now() - wheelStartTime;\n                    console.warn(`âš ï¸ Wheel ${index + 1} failed after ${wheelTime}ms:`, error);\n                    return { index, success: false, time: wheelTime, error };\n                }\n            });\n            // Wait for all wheel installations\n            const wheelResults = await Promise.all(wheelPromises);\n            const successful = wheelResults.filter(r => r.success);\n            const failed = wheelResults.filter(r => !r.success);\n            console.log(`ðŸ“Š Wheels: ${successful.length}/${wheelFiles.length} successful`);\n            if (failed.length > 0) {\n                console.warn(`âš ï¸ Failed wheels: ${failed.map(f => f.index + 1).join(', ')}`);\n            }\n            // Set up piplite configuration with performance optimizations (if available)\n            try {\n                await this.pyodide.runPythonAsync(`\ntry:\n    import piplite.piplite\n    import json\n\n    # Load package index for faster lookups\n    try:\n        piplite.piplite.PIPLITE_URL = \"${allJsonPath}\"\n        # Pre-load package index for faster installation\n        print(\"ðŸ“‹ Package index configured\")\n    except Exception as e:\n        print(f\"âš ï¸ Package index setup warning: {e}\")\n\n    # Configure piplite for optimal performance\n    piplite.piplite.REPODATA_INFO = {}\n    print(\"âš¡ Piplite optimized for performance\")\nexcept ImportError:\n    print(\"âš ï¸ Piplite not available, continuing without it\")\nexcept Exception as e:\n    print(f\"âš ï¸ Piplite setup failed: {e}\")\n`);\n            }\n            catch (error) {\n                console.warn(\"âš ï¸ Piplite configuration failed, continuing without it:\", error);\n            }\n            const totalTime = Date.now() - startTime;\n            console.log(`ðŸŽ¯ Package manager initialized in ${totalTime}ms`);\n        }\n        catch (error) {\n            console.error(\"âŒ Package manager initialization failed:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Initialize the kernel with required Python packages\n     * OPTIMIZED: Maximum parallelization with intelligent dependency resolution\n     */\n    async initKernel() {\n        const startTime = Date.now();\n        console.log(\"ðŸš€ Initializing kernel packages with maximum optimization...\");\n        // All packages to install with priority and dependency information\n        const packageConfig = [\n            // High priority: CDN packages (fastest)\n            { name: 'pure-eval', priority: 1, source: 'pyodide' },\n            { name: 'stack-data', priority: 1, source: 'pyodide' },\n            { name: 'pygments', priority: 1, source: 'pyodide' },\n            { name: 'ssl', priority: 1, source: 'pyodide' },\n            { name: 'sqlite3', priority: 1, source: 'pyodide' },\n            { name: 'prompt_toolkit', priority: 1, source: 'pyodide' },\n            { name: 'jedi', priority: 1, source: 'pyodide' },\n            { name: 'ipython', priority: 1, source: 'pyodide' },\n            // Medium priority: pip packages\n            { name: 'comm', priority: 2, source: 'pip' },\n            { name: 'hypha-rpc', priority: 2, source: 'pip' },\n            { name: 'nbformat', priority: 2, source: 'pip' },\n            // Lower priority: complex packages\n            { name: 'ipykernel', priority: 3, source: 'pip' },\n            { name: 'pyodide_kernel', priority: 3, source: 'pip' }\n        ];\n        try {\n            console.log(`ðŸ“¦ Installing ${packageConfig.length} packages with intelligent optimization...`);\n            // Install ALL packages in parallel with advanced error handling and caching\n            await this.installPackagesWithIntelligentOptimization(packageConfig);\n            // Import the kernel (must be done after packages are installed)\n            console.log(\"ðŸ“¥ Importing pyodide_kernel...\");\n            const importStartTime = Date.now();\n            await this.pyodide.runPythonAsync('import pyodide_kernel');\n            const importTime = Date.now() - importStartTime;\n            console.log(`âœ… pyodide_kernel imported in ${importTime}ms`);\n            const totalTime = Date.now() - startTime;\n            console.log(`ðŸŽ¯ Kernel packages initialized in ${totalTime}ms`);\n        }\n        catch (error) {\n            console.error(\"âŒ Kernel package initialization failed:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Install packages with intelligent optimization and advanced caching\n     * OPTIMIZED: Smart source selection, parallel installation, and performance monitoring\n     */\n    async installPackagesWithIntelligentOptimization(packageConfig) {\n        console.log(`âš¡ Starting intelligent parallel installation of ${packageConfig.length} packages...`);\n        const installPromises = packageConfig.map(async (pkg) => {\n            const startTime = Date.now();\n            try {\n                console.log(`ðŸ”„ Installing ${pkg.name} (priority: ${pkg.priority}, preferred: ${pkg.source})...`);\n                // Try preferred source first, with intelligent fallback\n                if (pkg.source === 'pyodide') {\n                    try {\n                        await this.pyodide.loadPackage([pkg.name]);\n                        const duration = Date.now() - startTime;\n                        console.log(`âœ… ${pkg.name} loaded from Pyodide CDN (${duration}ms)`);\n                        return { package: pkg.name, method: 'pyodide', duration, success: true, priority: pkg.priority };\n                    }\n                    catch (pyodideError) {\n                        // Fallback to pip with enhanced error handling\n                        console.log(`ðŸ“¦ ${pkg.name} not available on CDN, trying pip...`);\n                        await this.installViaPipWithOptimizations(pkg.name);\n                        const duration = Date.now() - startTime;\n                        console.log(`âœ… ${pkg.name} installed via pip fallback (${duration}ms)`);\n                        return { package: pkg.name, method: 'pip-fallback', duration, success: true, priority: pkg.priority };\n                    }\n                }\n                else {\n                    // Direct pip installation with optimizations\n                    await this.installViaPipWithOptimizations(pkg.name);\n                    const duration = Date.now() - startTime;\n                    console.log(`âœ… ${pkg.name} installed via pip (${duration}ms)`);\n                    return { package: pkg.name, method: 'pip', duration, success: true, priority: pkg.priority };\n                }\n            }\n            catch (error) {\n                const duration = Date.now() - startTime;\n                console.warn(`âŒ Failed to install ${pkg.name} after ${duration}ms:`, error);\n                return { package: pkg.name, method: 'failed', duration, success: false, priority: pkg.priority, error };\n            }\n        });\n        // Wait for all installations with detailed analysis\n        const results = await Promise.all(installPromises);\n        // Comprehensive performance analysis\n        this.analyzeInstallationResults(results);\n    }\n    /**\n     * Install package via pip with performance optimizations\n     */\n    async installViaPipWithOptimizations(packageName) {\n        await this.pyodide.runPythonAsync(`\ntry:\n    # Import piplite first\n    import piplite\n    # Use optimized pip installation with caching\n    await piplite.install('${packageName}', keep_going=True, deps=True)\n    print(\"âœ… Successfully installed ${packageName} via optimized pip\")\nexcept Exception as e:\n    print(\"âš ï¸ Warning: Failed to install ${packageName}:\", str(e))\n    # Try alternative installation method\n    try:\n        import micropip\n        await micropip.install('${packageName}', keep_going=True)\n        print(\"âœ… Successfully installed ${packageName} via micropip fallback\")\n    except Exception as e2:\n        print(\"âŒ Both pip methods failed for ${packageName}:\", str(e2))\n        raise e2\n`);\n    }\n    /**\n     * Analyze installation results and provide performance insights\n     */\n    analyzeInstallationResults(results) {\n        const successful = results.filter(r => r.success);\n        const failed = results.filter(r => !r.success);\n        const pyodideInstalls = successful.filter(r => r.method === 'pyodide');\n        const pipInstalls = successful.filter(r => r.method === 'pip');\n        const fallbackInstalls = successful.filter(r => r.method === 'pip-fallback');\n        const totalDuration = Math.max(...results.map(r => r.duration));\n        const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;\n        const estimatedSequential = results.reduce((sum, r) => sum + r.duration, 0);\n        console.log(`ðŸŽ¯ INTELLIGENT INSTALLATION COMPLETE!`);\n        console.log(`ðŸ“Š Results: ${successful.length}/${results.length} successful`);\n        console.log(`âš¡ Pyodide CDN: ${pyodideInstalls.length} packages`);\n        console.log(`ðŸ“¦ Direct pip: ${pipInstalls.length} packages`);\n        console.log(`ðŸ”„ Pip fallback: ${fallbackInstalls.length} packages`);\n        console.log(`âŒ Failed: ${failed.length} packages`);\n        console.log(`â±ï¸  Total time: ${totalDuration}ms (vs ~${estimatedSequential}ms sequential)`);\n        console.log(`ðŸš€ Speed improvement: ~${Math.round(estimatedSequential / totalDuration)}x faster`);\n        console.log(`ðŸ“ˆ Average per package: ${Math.round(avgDuration)}ms`);\n        if (failed.length > 0) {\n            console.warn(`âš ï¸  Failed packages: ${failed.map(f => f.package).join(', ')}`);\n            // Log specific failure reasons for debugging\n            failed.forEach(f => {\n                console.warn(`   - ${f.package}: ${f.error?.message || 'Unknown error'}`);\n            });\n        }\n        // Performance insights\n        const fastestInstall = Math.min(...successful.map(r => r.duration));\n        const slowestInstall = Math.max(...successful.map(r => r.duration));\n        console.log(`ðŸ“Š Performance range: ${fastestInstall}ms (fastest) to ${slowestInstall}ms (slowest)`);\n    }\n    /**\n     * Initialize global objects from the pyodide_kernel package\n     * Based on the PyodideRemoteKernel implementation\n     */\n    async initGlobals() {\n        console.log(\"Initializing globals...\");\n        // Get the globals from the Python environment\n        const { globals } = this.pyodide;\n        // Get the kernel instance and related objects\n        this._kernel = globals.get('pyodide_kernel').kernel_instance.copy();\n        this._stdout_stream = globals.get('pyodide_kernel').stdout_stream.copy();\n        this._stderr_stream = globals.get('pyodide_kernel').stderr_stream.copy();\n        this._interpreter = this._kernel.interpreter.copy();\n        // Set up communication handlers\n        this._interpreter.send_comm = this.sendComm.bind(this);\n        // Set up callbacks\n        this.setupCallbacks();\n    }\n    /**\n     * Setup all necessary callbacks for the Python environment\n     */\n    setupCallbacks() {\n        // Execution result callback\n        const publishExecutionResult = (prompt_count, data, metadata) => {\n            const bundle = {\n                execution_count: prompt_count,\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'execute_result',\n            });\n        };\n        // Error callback\n        const publishExecutionError = (ename, evalue, traceback) => {\n            const bundle = {\n                ename: ename,\n                evalue: evalue,\n                traceback: traceback,\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'execute_error',\n            });\n        };\n        // Clear output callback\n        const clearOutputCallback = (wait) => {\n            const bundle = {\n                wait: this.formatResult(wait),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'clear_output',\n            });\n        };\n        // Display data callback\n        const displayDataCallback = (data, metadata, transient) => {\n            const bundle = {\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n                transient: this.formatResult(transient),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'display_data',\n            });\n        };\n        // Update display data callback\n        const updateDisplayDataCallback = (data, metadata, transient) => {\n            const bundle = {\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n                transient: this.formatResult(transient),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'update_display_data',\n            });\n        };\n        // Stream callback\n        const publishStreamCallback = (name, text) => {\n            const bundle = {\n                name: this.formatResult(name),\n                text: this.formatResult(text),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'stream',\n            });\n        };\n        // Assign callbacks to the Python objects\n        this._stdout_stream.publish_stream_callback = publishStreamCallback;\n        this._stderr_stream.publish_stream_callback = publishStreamCallback;\n        this._interpreter.display_pub.clear_output_callback = clearOutputCallback;\n        this._interpreter.display_pub.display_data_callback = displayDataCallback;\n        this._interpreter.display_pub.update_display_data_callback = updateDisplayDataCallback;\n        this._interpreter.displayhook.publish_execution_result = publishExecutionResult;\n        this._interpreter.input = this.input.bind(this);\n        this._interpreter.getpass = this.getpass.bind(this);\n    }\n    /**\n     * Process a message from Python environment\n     */\n    _sendMessage(msg) {\n        this._processMessage(msg);\n    }\n    /**\n     * Process a message by emitting the appropriate event\n     */\n    _processMessage(msg) {\n        if (!msg.type) {\n            return;\n        }\n        let eventData;\n        switch (msg.type) {\n            case 'stream': {\n                const bundle = msg.bundle ?? { name: 'stdout', text: '' };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.STREAM, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'input_request': {\n                const content = msg.content ?? { prompt: '', password: false };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.INPUT_REQUEST, content);\n                eventData = content;\n                break;\n            }\n            case 'display_data': {\n                const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.DISPLAY_DATA, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'update_display_data': {\n                const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.UPDATE_DISPLAY_DATA, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'clear_output': {\n                const bundle = msg.bundle ?? { wait: false };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.CLEAR_OUTPUT, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'execute_result': {\n                const bundle = msg.bundle ?? {\n                    execution_count: this.executionCount,\n                    data: {},\n                    metadata: {},\n                };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_RESULT, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'execute_error': {\n                const bundle = msg.bundle ?? { ename: '', evalue: '', traceback: [] };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'comm_open':\n            case 'comm_msg':\n            case 'comm_close': {\n                const content = msg.content ?? {};\n                super.emit(msg.type, content, msg.metadata, msg.buffers);\n                eventData = {\n                    content,\n                    metadata: msg.metadata,\n                    buffers: msg.buffers\n                };\n                break;\n            }\n        }\n        // Emit the ALL event with standardized format\n        if (eventData) {\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, {\n                type: msg.type,\n                data: eventData\n            });\n        }\n    }\n    /**\n     * Check if the kernel has been initialized\n     */\n    isInitialized() {\n        return this.initialized;\n    }\n    /**\n     * Makes sure pyodide is ready before continuing, and cache the parent message.\n     */\n    async setup(parent) {\n        await this.initialize();\n        this._parent_header = this.pyodide.toPy(parent || {});\n    }\n    /**\n     * Execute code in the kernel with proper message-based completion detection\n     *\n     * @param code The code to execute\n     * @param parent Parent message header\n     * @returns The result of the execution\n     */\n    async execute(code, parent = {}) {\n        // Simple implementation that collects all outputs from executeStream\n        const outputs = [];\n        try {\n            // Use executeStream to get all outputs\n            for await (const output of this.executeStream(code, parent)) {\n                outputs.push(output);\n            }\n            // Process collected outputs to create a comprehensive result\n            const result = {\n                outputs: [],\n                data: {},\n                metadata: {},\n                execution_count: this.executionCount\n            };\n            // Collect all output types\n            for (const output of outputs) {\n                if (output.type === 'stream') {\n                    // Collect stdout/stderr\n                    if (!result.stdout)\n                        result.stdout = '';\n                    if (!result.stderr)\n                        result.stderr = '';\n                    if (output.data.name === 'stdout') {\n                        result.stdout += output.data.text;\n                    }\n                    else if (output.data.name === 'stderr') {\n                        result.stderr += output.data.text;\n                    }\n                    result.outputs.push(output.data);\n                }\n                else if (output.type === 'display_data' || output.type === 'execute_result') {\n                    // Collect display data\n                    if (output.data.data) {\n                        Object.assign(result.data, output.data.data);\n                    }\n                    if (output.data.metadata) {\n                        Object.assign(result.metadata, output.data.metadata);\n                    }\n                    result.outputs.push(output.data);\n                }\n                else if (output.type === 'execute_error' || output.type === 'error') {\n                    // Handle errors\n                    const errorData = output.data;\n                    return {\n                        success: false,\n                        error: new Error(`${errorData.ename}: ${errorData.evalue}`),\n                        ename: errorData.ename,\n                        evalue: errorData.evalue,\n                        traceback: errorData.traceback,\n                        outputs: result.outputs\n                    };\n                }\n                else {\n                    // Store any other output type\n                    result.outputs.push(output);\n                }\n            }\n            // Return collected results\n            result.success = true;\n            // Auto-sync native filesystems if enabled\n            if (this.autoSyncFs) {\n                await this.syncAllNativeFs();\n            }\n            return result;\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Execute error:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    /**\n     * Format the result from the Pyodide evaluation\n     * Based on PyodideRemoteKernel implementation\n     */\n    formatResult(res) {\n        if (!(res instanceof this.pyodide.ffi.PyProxy)) {\n            return res;\n        }\n        try {\n            // Convert PyProxy to JS\n            const m = res.toJs();\n            const results = this.mapToObject(m);\n            return results;\n        }\n        catch (error) {\n            console.error(\"Error formatting result:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    }\n    /**\n     * Convert a Map to a JavaScript object recursively\n     * Based on PyodideRemoteKernel implementation\n     */\n    mapToObject(obj) {\n        const out = obj instanceof Array ? [] : {};\n        obj.forEach((value, key) => {\n            out[key] =\n                value instanceof Map || value instanceof Array\n                    ? this.mapToObject(value)\n                    : value;\n        });\n        return out;\n    }\n    /**\n     * Handle input reply from user\n     */\n    async inputReply(content) {\n        if (this._resolveInputReply) {\n            this._resolveInputReply(content);\n            this._resolveInputReply = null;\n        }\n    }\n    /**\n     * Send a input request to the front-end.\n     */\n    async sendInputRequest(prompt, password) {\n        const content = {\n            prompt,\n            password,\n        };\n        this._sendMessage({\n            type: 'input_request',\n            content,\n            parentHeader: this.formatResult(this._parent_header)['header']\n        });\n    }\n    /**\n     * Get password input (with hidden input)\n     */\n    async getpass(prompt) {\n        prompt = typeof prompt === 'undefined' ? '' : prompt;\n        await this.sendInputRequest(prompt, true);\n        const replyPromise = new Promise((resolve) => {\n            this._resolveInputReply = resolve;\n        });\n        const result = await replyPromise;\n        return result.value;\n    }\n    /**\n     * Get text input\n     */\n    async input(prompt) {\n        prompt = typeof prompt === 'undefined' ? '' : prompt;\n        await this.sendInputRequest(prompt, false);\n        const replyPromise = new Promise((resolve) => {\n            this._resolveInputReply = resolve;\n        });\n        const result = await replyPromise;\n        return result.value;\n    }\n    /**\n     * Send a comm message to the front-end.\n     */\n    async sendComm(type, content, metadata, ident, buffers) {\n        this._sendMessage({\n            type: type,\n            content: this.formatResult(content),\n            metadata: this.formatResult(metadata),\n            ident: this.formatResult(ident),\n            buffers: this.formatResult(buffers),\n            parentHeader: this.formatResult(this._parent_header)['header'],\n        });\n    }\n    /**\n     * Complete the code submitted by a user.\n     */\n    async complete(code, cursor_pos, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.complete(code, cursor_pos);\n        return this.formatResult(res);\n    }\n    /**\n     * Inspect the code submitted by a user.\n     */\n    async inspect(code, cursor_pos, detail_level, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.inspect(code, cursor_pos, detail_level);\n        return this.formatResult(res);\n    }\n    /**\n     * Check code for completeness.\n     */\n    async isComplete(code, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.is_complete(code);\n        return this.formatResult(res);\n    }\n    /**\n     * Get information about available comms.\n     */\n    async commInfo(target_name, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_info(target_name);\n        return {\n            comms: this.formatResult(res),\n            status: 'ok',\n        };\n    }\n    /**\n     * Open a COMM\n     */\n    async commOpen(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_open(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Send a message through a COMM\n     */\n    async commMsg(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_msg(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Close a COMM\n     */\n    async commClose(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_close(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Execute Python code with streaming output\n     * @param code The Python code to execute\n     * @param parent Parent message header\n     * @returns AsyncGenerator yielding intermediate outputs and finally the execution result\n     */\n    async *executeStream(code, parent = {}) {\n        if (!this.initialized) {\n            await this.initialize();\n        }\n        try {\n            this._status = \"busy\";\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_BUSY, {});\n            await this.setup(parent);\n            // Create event listeners for streaming\n            const eventQueue = [];\n            let executionComplete = false;\n            let executionResult = null;\n            let executionError = null;\n            const handleAllEvents = (eventData) => {\n                eventQueue.push(eventData);\n            };\n            // Listen for all events BEFORE executing code\n            super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, handleAllEvents);\n            try {\n                // Execute the code directly\n                this._kernel.run(code).then((result) => {\n                    console.log(\"[KERNEL] Python execution finished\");\n                    executionResult = this.formatResult(result);\n                    // Check if the result indicates an error and emit it as an event\n                    if (executionResult && executionResult.status === 'error') {\n                        console.log(\"[KERNEL] Execution completed with error status, emitting execute_error event\");\n                        // Emit the error event so the UI can display it\n                        this._sendMessage({\n                            parentHeader: this.formatResult(this._parent_header)['header'],\n                            bundle: {\n                                ename: executionResult.ename || 'Error',\n                                evalue: executionResult.evalue || 'Unknown error',\n                                traceback: executionResult.traceback || []\n                            },\n                            type: 'execute_error',\n                        });\n                    }\n                    // Wait a small amount of time for any remaining messages to be processed\n                    setTimeout(() => {\n                        executionComplete = true;\n                    }, 100); // 100ms should be enough for message processing\n                }).catch((error) => {\n                    console.error(\"[KERNEL] Python execution error:\", error);\n                    executionError = error instanceof Error ? error : new Error(String(error));\n                    // Still wait for messages to settle before completing\n                    setTimeout(() => {\n                        executionComplete = true;\n                    }, 100);\n                });\n                // Stream events as they arrive\n                while (!executionComplete || eventQueue.length > 0) {\n                    // Yield queued events\n                    if (eventQueue.length > 0) {\n                        const event = eventQueue.shift();\n                        yield event;\n                    }\n                    else if (!executionComplete) {\n                        // Wait a bit for more events\n                        await new Promise(resolve => setTimeout(resolve, 10));\n                    }\n                }\n                // Process final result\n                this._status = \"active\";\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_IDLE, {});\n                if (executionError) {\n                    return {\n                        success: false,\n                        error: executionError,\n                        result: executionResult\n                    };\n                }\n                // Check if result indicates an error\n                if (executionResult && executionResult.status === 'error') {\n                    const errorMsg = `${executionResult.ename || 'Error'}: ${executionResult.evalue || 'Unknown error'}`;\n                    return {\n                        success: false,\n                        error: new Error(errorMsg),\n                        result: executionResult\n                    };\n                }\n                // Auto-sync native filesystems if enabled\n                if (this.autoSyncFs) {\n                    await this.syncAllNativeFs();\n                }\n                return {\n                    success: true,\n                    result: executionResult\n                };\n            }\n            finally {\n                // Clean up listener\n                super.off(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, handleAllEvents);\n            }\n        }\n        catch (error) {\n            console.error(\"[KERNEL] ExecuteStream error:\", error);\n            this._status = \"active\";\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_IDLE, {});\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    // Interrupt functionality\n    async interrupt() {\n        if (!this.initialized || !this.pyodide) {\n            console.warn(\"[KERNEL] Cannot interrupt: kernel not initialized\");\n            return false;\n        }\n        console.log(\"[KERNEL] Attempting to interrupt execution...\");\n        try {\n            // First priority: Use interrupt buffer if available\n            if (this._interruptBuffer && this._interruptSupported) {\n                console.log(\"[KERNEL] Using interrupt buffer method\");\n                // Set interrupt signal (2 = SIGINT)\n                this._interruptBuffer[0] = 2;\n                // Give the interrupt a moment to be processed\n                await new Promise(resolve => setTimeout(resolve, 100));\n                // Check if the interrupt was processed (buffer should be reset to 0)\n                const wasProcessed = this._interruptBuffer[0] === 0;\n                if (wasProcessed) {\n                    console.log(\"[KERNEL] Interrupt processed successfully via buffer\");\n                    return true;\n                }\n            }\n            // Second priority: Try Python-level interrupt\n            try {\n                console.log(\"[KERNEL] Attempting Python-level interrupt\");\n                // Try to raise KeyboardInterrupt in Python\n                await this.pyodide.runPythonAsync(`\nimport sys\nimport _thread\n# Try to interrupt the main thread\n_thread.interrupt_main()\n`);\n                console.log(\"[KERNEL] Python interrupt signal sent\");\n                return true;\n            }\n            catch (pythonError) {\n                console.log(\"[KERNEL] Python interrupt attempt failed:\", pythonError);\n            }\n            // Third priority: Try interpreter interrupt if available\n            if (this._interpreter && typeof this._interpreter.interrupt === 'function') {\n                console.log(\"[KERNEL] Using interpreter interrupt method\");\n                this._interpreter.interrupt();\n                return true;\n            }\n            // Last resort: Send interrupt messages for UI feedback\n            console.log(\"[KERNEL] Sending interrupt messages for UI feedback\");\n            // Send stderr stream first (for Jupyter notebook UI compatibility)\n            this._sendMessage({\n                type: 'stream',\n                bundle: {\n                    name: 'stderr',\n                    text: 'KeyboardInterrupt: Execution interrupted by user\\n'\n                }\n            });\n            this._sendMessage({\n                type: 'execute_error',\n                bundle: {\n                    ename: 'KeyboardInterrupt',\n                    evalue: 'Execution interrupted by user',\n                    traceback: ['KeyboardInterrupt: Execution interrupted by user']\n                }\n            });\n            // Return false since we couldn't actually interrupt the execution\n            return false;\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Error during interrupt:\", error);\n            return false;\n        }\n    }\n    setInterruptBuffer(buffer) {\n        this._interruptBuffer = buffer;\n        try {\n            if (this.pyodide && typeof this.pyodide.setInterruptBuffer === 'function') {\n                this.pyodide.setInterruptBuffer(buffer);\n                this._interruptSupported = true;\n            }\n            else {\n                console.warn(\"[KERNEL] pyodide.setInterruptBuffer not available, interrupt support limited\");\n                this._interruptSupported = false;\n            }\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Error setting interrupt buffer:\", error);\n            this._interruptSupported = false;\n        }\n    }\n    /**\n     * Verify and request permission for a file system handle\n     * @private\n     */\n    async verifyPermission(fileHandle, permission) {\n        const opts = {};\n        if (permission === 'readwrite') {\n            opts.mode = 'readwrite';\n        }\n        console.log(`[KERNEL] Verifying ${permission} permission for file handle...`);\n        // Check if permission APIs are supported\n        if (typeof fileHandle.queryPermission !== 'function') {\n            console.warn('[KERNEL] queryPermission not supported, assuming permission granted');\n            return true;\n        }\n        try {\n            // Check if we already have permission, if so, return true.\n            const queryResult = await fileHandle.queryPermission(opts);\n            console.log('[KERNEL] Query result:', queryResult);\n            if (queryResult === 'granted') {\n                console.log(`[KERNEL] Permission already granted for ${permission} access`);\n                return true;\n            }\n            // Request permission to the file, if the user grants permission, return true.\n            if (typeof fileHandle.requestPermission === 'function') {\n                console.log(`[KERNEL] Requesting ${permission} permission from user...`);\n                try {\n                    const requestResult = await fileHandle.requestPermission(opts);\n                    console.log('[KERNEL] Request result:', requestResult);\n                    if (requestResult === 'granted') {\n                        console.log(`[KERNEL] Permission granted for ${permission} access`);\n                        return true;\n                    }\n                }\n                catch (requestError) {\n                    console.log('[KERNEL] Permission request failed or was dismissed:', requestError);\n                }\n            }\n            // The user did not grant permission, return false.\n            console.log(`[KERNEL] ${permission} permission not granted`);\n            return false;\n        }\n        catch (error) {\n            console.error('[KERNEL] Error checking permission:', error);\n            // If permission check fails, assume it's granted (more permissive approach)\n            console.warn('[KERNEL] Permission check failed, assuming granted as fallback');\n            return true;\n        }\n    }\n    /**\n     * Mount a native file system directory into the Pyodide filesystem\n     * @param mountPath The path where the directory should be mounted in the Python filesystem\n     * @param dirHandle Optional FileSystemDirectoryHandle. If null/undefined, shows directory picker\n     * @param permission Permission mode:\n     *   - 'read': Read-only access, no syncing capabilities, auto-sync will be skipped (default)\n     *   - 'readwrite': Full read/write access with syncing capabilities\n     * @returns Promise resolving to a handle with syncfs() method for syncing changes\n     * @note syncfs() will throw an error if called on a read-only mounted filesystem\n     * @note Many browsers only offer read permission initially. Explicitly request 'readwrite' if you need write access.\n     */\n    async mountFS(mountPath, dirHandle, permission = 'read') {\n        if (!this.initialized || !this.pyodide) {\n            throw new Error(\"Kernel must be initialized before mounting filesystem\");\n        }\n        // Check if mountNativeFS is available\n        if (typeof this.pyodide.mountNativeFS !== 'function') {\n            throw new Error(\"pyodide.mountNativeFS is not available. Make sure you're using Pyodide 0.23.0 or later.\");\n        }\n        let handle = dirHandle;\n        // If no dirHandle provided, show directory picker\n        if (!handle) {\n            // Check if we're in a worker context\n            if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n                throw new Error(\"Cannot show directory picker in worker context. Please provide a dirHandle parameter.\");\n            }\n            // Check if showDirectoryPicker is available\n            if (typeof window !== 'undefined' && 'showDirectoryPicker' in window) {\n                try {\n                    handle = await window.showDirectoryPicker({\n                        mode: 'readwrite',\n                    });\n                }\n                catch (error) {\n                    throw new Error(`Failed to show directory picker: ${error instanceof Error ? error.message : String(error)}`);\n                }\n            }\n            else {\n                throw new Error(\"showDirectoryPicker is not supported in this browser. Please provide a dirHandle parameter.\");\n            }\n        }\n        if (!handle) {\n            throw new Error(\"No directory handle available\");\n        }\n        // Verify and request permissions before mounting\n        console.log(`[KERNEL] Verifying ${permission} permissions before mounting...`);\n        const hasRequestedPermission = await this.verifyPermission(handle, permission);\n        if (!hasRequestedPermission) {\n            if (permission === 'readwrite') {\n                throw new Error(`Failed to obtain write permission for directory. ` +\n                    `The browser may only be offering read permission. ` +\n                    `Try mounting with permission: 'read' if you only need to read files, ` +\n                    `or ensure the browser supports write access to this directory.`);\n            }\n            else {\n                throw new Error(`Failed to obtain ${permission} permission for directory.`);\n            }\n        }\n        const actualPermission = permission;\n        // Mount the native filesystem\n        try {\n            console.log(`[KERNEL] Mounting native filesystem at ${mountPath} with ${actualPermission} permission`);\n            // Check if the mount point already exists and handle cleanup\n            try {\n                const pathInfo = this.pyodide.FS.analyzePath(mountPath);\n                if (pathInfo.exists) {\n                    console.log(`[KERNEL] Path ${mountPath} exists, checking if it's a mount point`);\n                    // Try to unmount if it's already mounted\n                    try {\n                        await this.pyodide.FS.unmount(mountPath);\n                        console.log(`[KERNEL] Successfully unmounted existing filesystem at ${mountPath}`);\n                    }\n                    catch (unmountError) {\n                        // If unmount fails, it might not be a mount point or might be busy\n                        console.log(`[KERNEL] Unmount failed (this is normal if not mounted): ${unmountError}`);\n                    }\n                    // Remove the directory if it exists but is empty\n                    try {\n                        this.pyodide.FS.rmdir(mountPath);\n                        console.log(`[KERNEL] Removed existing directory at ${mountPath}`);\n                    }\n                    catch (rmdirError) {\n                        // Directory might not be empty or might not exist, that's okay\n                        console.log(`[KERNEL] Could not remove directory (this is normal): ${rmdirError}`);\n                    }\n                }\n            }\n            catch (analyzeError) {\n                // analyzePath might fail, that's okay - the path probably doesn't exist\n                console.log(`[KERNEL] Path analysis failed (path probably doesn't exist): ${analyzeError}`);\n            }\n            // Ensure the parent directory exists\n            const parentPath = mountPath.substring(0, mountPath.lastIndexOf('/')) || '/';\n            try {\n                if (parentPath !== '/' && !this.pyodide.FS.analyzePath(parentPath).exists) {\n                    this.pyodide.FS.mkdir(parentPath);\n                    console.log(`[KERNEL] Created parent directory ${parentPath}`);\n                }\n            }\n            catch (parentError) {\n                console.log(`[KERNEL] Parent directory handling: ${parentError}`);\n            }\n            const nativefs = await this.pyodide.mountNativeFS(mountPath, handle);\n            console.log(`[KERNEL] Successfully mounted native filesystem at ${mountPath} with ${actualPermission} permission`);\n            // Create a handle with syncfs method and permission recovery\n            const fsHandle = {\n                syncfs: async () => {\n                    // Check if filesystem is read-only\n                    if (actualPermission === 'read') {\n                        throw new Error(`Cannot sync read-only filesystem at ${mountPath}. Use upgradeFilesystemPermission() to request write access.`);\n                    }\n                    try {\n                        await nativefs.syncfs();\n                        console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                    }\n                    catch (error) {\n                        throw new Error(`Failed to sync filesystem: ${error instanceof Error ? error.message : String(error)}`);\n                    }\n                },\n                dirHandle: handle,\n                permission: actualPermission,\n                nativefs: nativefs\n            };\n            // Store the handle for auto-sync\n            this.nativeFsHandles.set(mountPath, fsHandle);\n            return { syncfs: fsHandle.syncfs };\n        }\n        catch (error) {\n            throw new Error(`Failed to mount native filesystem: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    /**\n     * Sync all mounted native filesystems with permission recovery\n     * Only syncs filesystems mounted with 'readwrite' permission\n     * @private\n     */\n    async syncAllNativeFs() {\n        if (this.nativeFsHandles.size === 0) {\n            return;\n        }\n        const syncResults = [];\n        for (const [mountPath, fsHandle] of this.nativeFsHandles.entries()) {\n            // Skip read-only filesystems\n            if (fsHandle.permission === 'read') {\n                syncResults.push({ mountPath, success: true, skipped: true });\n                console.log(`[KERNEL] Skipping sync for read-only filesystem at ${mountPath}`);\n                continue;\n            }\n            try {\n                // First, try to sync directly\n                await fsHandle.syncfs();\n                syncResults.push({ mountPath, success: true });\n                console.log(`[KERNEL] Successfully synced filesystem at ${mountPath}`);\n            }\n            catch (error) {\n                // If sync fails, check if it's a permission error\n                const errorMessage = error instanceof Error ? error.message : String(error);\n                if (errorMessage.includes('not allowed by the user agent') ||\n                    errorMessage.includes('getFileHandle') ||\n                    errorMessage.includes('permission')) {\n                    console.warn(`[KERNEL] Permission error syncing ${mountPath}, attempting recovery...`);\n                    try {\n                        // Try to recover by re-verifying permissions\n                        const hasPermission = await this.verifyPermission(fsHandle.dirHandle, fsHandle.permission);\n                        if (hasPermission) {\n                            // Try to remount and sync\n                            console.log(`[KERNEL] Permission recovered for ${mountPath}, attempting remount...`);\n                            const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n                            // Update the stored handle with the new nativefs\n                            fsHandle.nativefs = newNativefs;\n                            fsHandle.syncfs = async () => {\n                                try {\n                                    await newNativefs.syncfs();\n                                    console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                                }\n                                catch (syncError) {\n                                    throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                                }\n                            };\n                            // Try sync again with the new handle\n                            await fsHandle.syncfs();\n                            syncResults.push({ mountPath, success: true });\n                            console.log(`[KERNEL] Successfully recovered and synced filesystem at ${mountPath}`);\n                        }\n                        else {\n                            syncResults.push({\n                                mountPath,\n                                success: false,\n                                error: 'Permission denied by user'\n                            });\n                            console.warn(`[KERNEL] User denied permission for ${mountPath}, skipping sync`);\n                        }\n                    }\n                    catch (recoveryError) {\n                        const recoveryMessage = recoveryError instanceof Error ? recoveryError.message : String(recoveryError);\n                        syncResults.push({\n                            mountPath,\n                            success: false,\n                            error: `Recovery failed: ${recoveryMessage}`\n                        });\n                        console.error(`[KERNEL] Failed to recover permissions for ${mountPath}:`, recoveryError);\n                    }\n                }\n                else {\n                    // Non-permission error\n                    syncResults.push({\n                        mountPath,\n                        success: false,\n                        error: errorMessage\n                    });\n                    console.error(`[KERNEL] Non-permission error syncing ${mountPath}:`, error);\n                }\n            }\n        }\n        // Log summary\n        const successful = syncResults.filter(r => r.success && !r.skipped).length;\n        const skipped = syncResults.filter(r => r.skipped).length;\n        const failed = syncResults.filter(r => !r.success);\n        if (successful > 0 || skipped > 0) {\n            const parts = [];\n            if (successful > 0)\n                parts.push(`${successful} synced`);\n            if (skipped > 0)\n                parts.push(`${skipped} read-only skipped`);\n            console.log(`[KERNEL] Auto-sync completed: ${parts.join(', ')} (${syncResults.length} total filesystems)`);\n        }\n        if (failed.length > 0) {\n            console.warn(`[KERNEL] Auto-sync issues:`, failed.map(f => `${f.mountPath}: ${f.error}`));\n        }\n        // Don't throw - we don't want to fail execution just because sync failed\n    }\n    /**\n     * Get information about mounted native filesystems and their permission status\n     * @returns Array of mounted filesystem information\n     */\n    getMountedFilesystems() {\n        const result = [];\n        for (const [mountPath, fsHandle] of this.nativeFsHandles.entries()) {\n            result.push({\n                mountPath,\n                permission: fsHandle.permission,\n                canSync: fsHandle.permission === 'readwrite'\n            });\n        }\n        return result;\n    }\n    /**\n     * Manually sync a specific mounted filesystem\n     * @param mountPath The path of the mounted filesystem to sync\n     * @returns Promise resolving to success status\n     */\n    async syncFilesystem(mountPath) {\n        const fsHandle = this.nativeFsHandles.get(mountPath);\n        if (!fsHandle) {\n            return {\n                success: false,\n                error: `No filesystem mounted at ${mountPath}`\n            };\n        }\n        // Check if filesystem is read-only\n        if (fsHandle.permission === 'read') {\n            return {\n                success: false,\n                error: `Cannot sync read-only filesystem at ${mountPath}. Mount with 'readwrite' permission to enable syncing.`\n            };\n        }\n        try {\n            await fsHandle.syncfs();\n            return { success: true };\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            // Try permission recovery if it's a permission error\n            if (errorMessage.includes('not allowed by the user agent') ||\n                errorMessage.includes('getFileHandle') ||\n                errorMessage.includes('permission')) {\n                console.log(`[KERNEL] Permission error syncing ${mountPath}, attempting recovery...`);\n                try {\n                    const hasPermission = await this.verifyPermission(fsHandle.dirHandle, fsHandle.permission);\n                    if (hasPermission) {\n                        // Remount and try again\n                        const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n                        fsHandle.nativefs = newNativefs;\n                        fsHandle.syncfs = async () => {\n                            try {\n                                await newNativefs.syncfs();\n                                console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                            }\n                            catch (syncError) {\n                                throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                            }\n                        };\n                        await fsHandle.syncfs();\n                        return { success: true };\n                    }\n                    else {\n                        return {\n                            success: false,\n                            error: 'Permission denied by user'\n                        };\n                    }\n                }\n                catch (recoveryError) {\n                    return {\n                        success: false,\n                        error: `Recovery failed: ${recoveryError instanceof Error ? recoveryError.message : String(recoveryError)}`\n                    };\n                }\n            }\n            return {\n                success: false,\n                error: errorMessage\n            };\n        }\n    }\n    /**\n     * Upgrade a mounted filesystem from read-only to read-write permission\n     * @param mountPath The path of the mounted filesystem to upgrade\n     * @returns Promise resolving to success status\n     */\n    async upgradeFilesystemPermission(mountPath) {\n        const fsHandle = this.nativeFsHandles.get(mountPath);\n        if (!fsHandle) {\n            return {\n                success: false,\n                error: `No filesystem mounted at ${mountPath}`\n            };\n        }\n        if (fsHandle.permission === 'readwrite') {\n            return {\n                success: true,\n                error: `Filesystem at ${mountPath} already has readwrite permission`\n            };\n        }\n        try {\n            console.log(`[KERNEL] Attempting to upgrade ${mountPath} to readwrite permission...`);\n            // Try to get readwrite permission\n            const hasWritePermission = await this.verifyPermission(fsHandle.dirHandle, 'readwrite');\n            if (!hasWritePermission) {\n                return {\n                    success: false,\n                    error: 'User denied write permission or browser does not support write access to this directory'\n                };\n            }\n            // Remount with write permission\n            const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n            // Update the stored handle\n            fsHandle.permission = 'readwrite';\n            fsHandle.nativefs = newNativefs;\n            fsHandle.syncfs = async () => {\n                try {\n                    await newNativefs.syncfs();\n                    console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                }\n                catch (syncError) {\n                    throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                }\n            };\n            console.log(`[KERNEL] Successfully upgraded ${mountPath} to readwrite permission`);\n            return { success: true };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Failed to upgrade permission: ${error instanceof Error ? error.message : String(error)}`\n            };\n        }\n    }\n    /**\n     * Set environment variables with performance optimization\n     * OPTIMIZED: Parallel variable setting and validation with proper escaping and edge case handling\n     */\n    async setEnvironmentVariables() {\n        if (Object.keys(this.environmentVariables).length === 0) {\n            return; // No variables to set\n        }\n        const startTime = Date.now();\n        console.log(`ðŸŒ Setting ${Object.keys(this.environmentVariables).length} environment variables...`);\n        try {\n            // Set each environment variable individually to avoid escaping issues\n            for (const [key, value] of Object.entries(this.environmentVariables)) {\n                // Handle edge cases: null, undefined, etc.\n                let processedValue;\n                if (value === null) {\n                    processedValue = ''; // Convert null to empty string\n                }\n                else if (value === undefined) {\n                    processedValue = ''; // Convert undefined to empty string\n                }\n                else {\n                    processedValue = String(value); // Convert everything else to string\n                }\n                await this.pyodide.runPythonAsync(`\nimport os\nos.environ[${JSON.stringify(key)}] = ${JSON.stringify(processedValue)}\n`);\n            }\n            const duration = Date.now() - startTime;\n            console.log(`âš¡ Environment variables set in ${duration}ms`);\n        }\n        catch (error) {\n            console.error(\"âŒ Failed to set environment variables:\", error);\n            throw error;\n        }\n    }\n}\n// Only Python kernel is supported\n// Export the manager for advanced usage\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxJQUFJLGNBQXNCLENBQUM7Z0JBQzNCLElBQUksS0FBSyxLQUFLLElBQUksRUFBRSxDQUFDO29CQUNuQixjQUFjLEdBQUcsRUFBRSxDQUFDLENBQUUsK0JBQStCO2dCQUN2RCxDQUFDO3FCQUFNLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRSxDQUFDO29CQUMvQixjQUFjLEdBQUcsRUFBRSxDQUFDLENBQUUsb0NBQW9DO2dCQUM1RCxDQUFDO3FCQUFNLENBQUM7b0JBQ04sY0FBYyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFFLG9DQUFvQztnQkFDdkUsQ0FBQztnQkFFRCxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDOzthQUU3QixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDO0NBQ3BFLENBQUMsQ0FBQztZQUNHLENBQUM7WUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsU0FBUyxDQUFDO1lBQ3hDLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0NBQWtDLFFBQVEsSUFBSSxDQUFDLENBQUM7UUFDOUQsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLHdDQUF3QyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQy9ELE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUM7Q0FDRjtBQUVELGtDQUFrQztBQUVsQyx3Q0FBd0M7QUFDRSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1weXRob24ta2VybmVsLy4vc3JjL2luZGV4LnRzP2ZmYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gS2VybmVsIGltcGxlbWVudGF0aW9uIGZvciBEZW5vIHVzaW5nIFB5b2RpZGUgZGlyZWN0bHlcbi8vIEJhc2VkIG9uIHRoZSBQeW9kaWRlUmVtb3RlS2VybmVsIGJ1dCBhZGFwdGVkIGZvciBkaXJlY3QgZXhlY3V0aW9uIGluIG1haW4gdGhyZWFkXG5cbi8vIEB0cy1pZ25vcmUgSW1wb3J0aW5nIGZyb20gbnBtXG4vLyBVc2UgYSBicm93c2VyLWNvbXBhdGlibGUgRXZlbnRFbWl0dGVyXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGV2ZW50czogeyBba2V5OiBzdHJpbmddOiBGdW5jdGlvbltdIH0gPSB7fTtcblxuICBvbihldmVudE5hbWU6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gW107XG4gICAgfVxuICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICBvZmYoZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikge1xuICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkgcmV0dXJuO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIGVtaXQoZXZlbnROYW1lOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSByZXR1cm47XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKC4uLmFyZ3MpKTtcbiAgfVxuXG4gIHNldE1heExpc3RlbmVycyhuOiBudW1iZXIpIHtcbiAgICAvLyBOby1vcCBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4gIH1cbn1cblxuLy8gQHRzLWlnbm9yZSBJbXBvcnRpbmcgZnJvbSBucG1cbmltcG9ydCB7IGxvYWRQeW9kaWRlIH0gZnJvbSBcIi4vcHlvZGlkZS1sb2FkZXJcIjtcblxuLy8gSW1wb3J0IHR5cGVzIGFuZCBlbnVtc1xuaW1wb3J0IHsgS2VybmVsRXZlbnRzLCBJRXZlbnREYXRhLCBJTWVzc2FnZSwgSUtlcm5lbCwgSUtlcm5lbE9wdGlvbnMsIElGaWxlc3lzdGVtTW91bnRPcHRpb25zLCBJS2VybmVsRXhlY3V0ZU9wdGlvbnMsIElFdmVudEVtaXR0ZXIgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG4vLyBJbXBvcnQgUHlQSSBVUkxzXG5pbXBvcnQge1xuICBwaXBsaXRlV2hlZWxVcmwsXG4gIHB5b2RpZGVfa2VybmVsV2hlZWxVcmwsXG4gIGlweWtlcm5lbFdoZWVsVXJsLFxuICBhbGxKU09OVXJsLFxuICB3aWRnZXRzbmJleHRlbnNpb25XaGVlbFVybCxcbiAgd2lkZ2V0c25iZXh0ZW5zaW9uV2hlZWxVcmwxXG59IGZyb20gJy4vX3B5cGknO1xuXG4vLyBFdmVudCB0eXBlcyBmcm9tIEp1cHl0ZXJMYWJcbi8vIFJlLWV4cG9ydCB0eXBlcyB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5leHBvcnQgeyBLZXJuZWxFdmVudHMgfSBmcm9tIFwiLi90eXBlc1wiO1xuZXhwb3J0IHR5cGUge1xuICBJS2VybmVsLFxuICBJS2VybmVsT3B0aW9ucyxcbiAgSUZpbGVzeXN0ZW1Nb3VudE9wdGlvbnMsXG4gIElLZXJuZWxFeGVjdXRlT3B0aW9ucyxcbiAgSU1lc3NhZ2UsXG4gIElFdmVudERhdGEsXG4gIElFdmVudEVtaXR0ZXIsXG4gIElOYXRpdmVGU0hhbmRsZVxufSBmcm9tIFwiLi90eXBlc1wiO1xuXG5leHBvcnQgeyBLZXJuZWxNb2RlLCBLZXJuZWxMYW5ndWFnZSB9IGZyb20gXCIuL21hbmFnZXJcIjtcblxuXG5cblxuZXhwb3J0IGNsYXNzIEtlcm5lbCBleHRlbmRzIEV2ZW50RW1pdHRlciBpbXBsZW1lbnRzIElLZXJuZWwge1xuICBwcml2YXRlIHB5b2RpZGU6IGFueTtcbiAgcHJpdmF0ZSBpbml0aWFsaXplZCA9IGZhbHNlO1xuICBwcml2YXRlIGluaXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gIFxuICAvLyBGaWxlc3lzdGVtIG9wdGlvbnNcbiAgcHJpdmF0ZSBmaWxlc3lzdGVtT3B0aW9uczogSUZpbGVzeXN0ZW1Nb3VudE9wdGlvbnMgPSB7XG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgcm9vdDogXCIuXCIsXG4gICAgbW91bnRQb2ludDogXCIvaG9tZS9weW9kaWRlXCJcbiAgfTtcbiAgXG4gIC8vIEtlcm5lbCBvcHRpb25zXG4gIHByaXZhdGUgbG9ja0ZpbGVVUkw/OiBzdHJpbmc7XG4gIFxuICAvLyBLZXJuZWwgY29tcG9uZW50c1xuICBwcml2YXRlIF9rZXJuZWw6IGFueTtcbiAgcHJpdmF0ZSBfaW50ZXJwcmV0ZXI6IGFueTtcbiAgcHJpdmF0ZSBfc3Rkb3V0X3N0cmVhbTogYW55O1xuICBwcml2YXRlIF9zdGRlcnJfc3RyZWFtOiBhbnk7XG4gIFxuICAvLyBJbnB1dCBoYW5kbGluZ1xuICBwcml2YXRlIF9yZXNvbHZlSW5wdXRSZXBseTogKCh2YWx1ZTogYW55KSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gRXhlY3V0aW9uIHN0YXRlXG4gIHByaXZhdGUgX3BhcmVudF9oZWFkZXI6IGFueSA9IHt9O1xuICBwcml2YXRlIGV4ZWN1dGlvbkNvdW50ID0gMDtcbiAgcHJpdmF0ZSBfc3RhdHVzOiBcImFjdGl2ZVwiIHwgXCJidXN5XCIgfCBcInVua25vd25cIiA9IFwidW5rbm93blwiO1xuICBcbiAgLy8gSW50ZXJydXB0IGhhbmRsaW5nXG4gIHByaXZhdGUgX2ludGVycnVwdEJ1ZmZlcjogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9pbnRlcnJ1cHRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgXG4gIC8vIEVudmlyb25tZW50IHZhcmlhYmxlc1xuICBwcml2YXRlIGVudmlyb25tZW50VmFyaWFibGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgLy8gTmF0aXZlIGZpbGVzeXN0ZW0gaGFuZGxlc1xuICBwcml2YXRlIG5hdGl2ZUZzSGFuZGxlczogTWFwPHN0cmluZywgeyBcbiAgICBzeW5jZnM6ICgpID0+IFByb21pc2U8dm9pZD47IFxuICAgIGRpckhhbmRsZTogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZTtcbiAgICBwZXJtaXNzaW9uOiAncmVhZCcgfCAncmVhZHdyaXRlJztcbiAgICBuYXRpdmVmczogYW55O1xuICB9PiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBhdXRvU3luY0ZzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLy8gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMga2VybmVsIGluc3RhbmNlXG4gIHByaXZhdGUgcmVhZG9ubHkga2VybmVsSWQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHN1cGVyLnNldE1heExpc3RlbmVycygyMCk7XG4gICAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgSUQgZm9yIHRoaXMga2VybmVsIGluc3RhbmNlXG4gICAgdGhpcy5rZXJuZWxJZCA9IGBrZXJuZWxfJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMil9XyR7RGF0ZS5ub3coKX1gO1xuICB9XG5cbiAgLy8gQXN5bmMgbWV0aG9kIGZvciBrZXJuZWwgc3RhdHVzXG4gIGFzeW5jIGdldFN0YXR1cygpOiBQcm9taXNlPFwiYWN0aXZlXCIgfCBcImJ1c3lcIiB8IFwidW5rbm93blwiPiB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBrZXJuZWwgd2l0aCBtYXhpbXVtIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnNcbiAgICogT1BUSU1JWkVEOiBGdWxsIHBhcmFsbGVsaXphdGlvbiB3aXRoIHNtYXJ0IGNhY2hpbmcgYW5kIHBlcmZvcm1hbmNlIG1vbml0b3JpbmdcbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbml0aWFsaXplKG9wdGlvbnM/OiBJS2VybmVsT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLmluaXRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgICB9XG5cbiAgICAvLyBTZXQgZmlsZXN5c3RlbSBvcHRpb25zIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnM/LmZpbGVzeXN0ZW0pIHtcbiAgICAgIHRoaXMuZmlsZXN5c3RlbU9wdGlvbnMgPSB7XG4gICAgICAgIC4uLnRoaXMuZmlsZXN5c3RlbU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMuZmlsZXN5c3RlbVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBTZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnM/LmVudikge1xuICAgICAgdGhpcy5lbnZpcm9ubWVudFZhcmlhYmxlcyA9IHsgLi4ub3B0aW9ucy5lbnYgfTtcbiAgICB9XG5cbiAgICAvLyBTZXQgbG9ja0ZpbGVVUkwgaWYgcHJvdmlkZWRcbiAgICBpZiAob3B0aW9ucz8ubG9ja0ZpbGVVUkwpIHtcbiAgICAgIHRoaXMubG9ja0ZpbGVVUkwgPSBvcHRpb25zLmxvY2tGaWxlVVJMO1xuICAgIH1cblxuICAgIC8vIFNldCBhdXRvU3luY0ZzIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnM/LmF1dG9TeW5jRnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hdXRvU3luY0ZzID0gb3B0aW9ucy5hdXRvU3luY0ZzO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdFByb21pc2UgPSB0aGlzLl9pbml0aWFsaXplSW50ZXJuYWwoKTtcbiAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGtlcm5lbCB3aXRoIG1heGltdW0gcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uc1xuICAgKiBPUFRJTUlaRUQ6IEZ1bGwgcGFyYWxsZWxpemF0aW9uIHdpdGggc21hcnQgY2FjaGluZyBhbmQgcGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfaW5pdGlhbGl6ZUludGVybmFsKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc29sZS5sb2coXCLwn5qAIFN0YXJ0aW5nIG9wdGltaXplZCBrZXJuZWwgaW5pdGlhbGl6YXRpb24uLi5cIik7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIExvYWQgUHlvZGlkZSBmcm9tIENETlxuICAgICAgY29uc3QgcHlvZGlkZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBcbiAgICAgIC8vIENvbmZpZ3VyZSBweW9kaWRlIG9wdGlvbnNcbiAgICAgIGNvbnN0IHB5b2RpZGVDb25maWc6IGFueSA9IHt9O1xuICAgICAgaWYgKHRoaXMubG9ja0ZpbGVVUkwpIHtcbiAgICAgICAgcHlvZGlkZUNvbmZpZy5sb2NrRmlsZVVSTCA9IHRoaXMubG9ja0ZpbGVVUkw7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SSIFVzaW5nIGxvY2tGaWxlVVJMOiAke3RoaXMubG9ja0ZpbGVVUkx9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVzZSBvdXIgQ0ROIGxvYWRlciAtIGl0IHdpbGwgYXV0b21hdGljYWxseSBoYW5kbGUgbWFpbiB0aHJlYWQgdnMgd29ya2VyXG4gICAgICB0aGlzLnB5b2RpZGUgPSBhd2FpdCBsb2FkUHlvZGlkZShweW9kaWRlQ29uZmlnKTtcbiAgICAgIGNvbnN0IHB5b2RpZGVUaW1lID0gRGF0ZS5ub3coKSAtIHB5b2RpZGVTdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFB5b2RpZGUgbG9hZGVkIGluICR7cHlvZGlkZVRpbWV9bXNgKTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSBjb3JlIGNvbXBvbmVudHMgaW4gcGFyYWxsZWxcbiAgICAgIGlmICh0aGlzLmxvY2tGaWxlVVJMKSB7XG4gICAgICAgIC8vIFdoZW4gdXNpbmcgbG9ja0ZpbGVVUkwsIHBhY2thZ2VzIGFyZSBwcmUtaW5zdGFsbGVkLCBza2lwIHBhY2thZ2UgaW5zdGFsbGF0aW9uXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+agCBVc2luZyBsb2NrIGZpbGUgLSBza2lwcGluZyBwYWNrYWdlIGluc3RhbGxhdGlvblwiKTtcbiAgICAgICAgY29uc3QgWyxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIC8vIDEuIEZpbGVzeXN0ZW0gbW91bnRpbmcgKGlmIGVuYWJsZWQpXG4gICAgICAgICAgdGhpcy5maWxlc3lzdGVtT3B0aW9ucy5lbmFibGVkID8gdGhpcy5tb3VudEZpbGVzeXN0ZW0oKSA6IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgICAgIC8vIDIuIEVudmlyb25tZW50IHZhcmlhYmxlcyBzZXR1cFxuICAgICAgICAgIHRoaXMuc2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKVxuICAgICAgICBdKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEluaXRpYWxpemUgZ2xvYmFscyBkaXJlY3RseSAocGFja2FnZXMgYXJlIGFscmVhZHkgYXZhaWxhYmxlKVxuICAgICAgICBhd2FpdCB0aGlzLmluaXRHbG9iYWxzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGFuZGFyZCBpbml0aWFsaXphdGlvbiB3aXRoIHBhY2thZ2UgaW5zdGFsbGF0aW9uXG4gICAgICAgIGNvbnN0IFssICxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIC8vIDEuIEZpbGVzeXN0ZW0gbW91bnRpbmcgKGlmIGVuYWJsZWQpXG4gICAgICAgICAgdGhpcy5maWxlc3lzdGVtT3B0aW9ucy5lbmFibGVkID8gdGhpcy5tb3VudEZpbGVzeXN0ZW0oKSA6IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgICAgIC8vIDIuIFBhY2thZ2UgbWFuYWdlciBpbml0aWFsaXphdGlvblxuICAgICAgICAgIHRoaXMuaW5pdFBhY2thZ2VNYW5hZ2VyKCksXG4gICAgICAgICAgLy8gMy4gRW52aXJvbm1lbnQgdmFyaWFibGVzIHNldHVwXG4gICAgICAgICAgdGhpcy5zZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpXG4gICAgICAgIF0pO1xuICAgICAgICBcbiAgICAgICAgLy8gSW5zdGFsbCBwYWNrYWdlcyBhbmQgaW5pdGlhbGl6ZSBnbG9iYWxzXG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdEtlcm5lbCgpO1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRHbG9iYWxzKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OryBLRVJORUwgSU5JVElBTElaQVRJT04gQ09NUExFVEUgaW4gJHt0b3RhbFRpbWV9bXNgKTtcbiAgICAgIGNvbnNvbGUubG9nKGDimqEgUGVyZm9ybWFuY2U6IFB5b2RpZGUoJHtweW9kaWRlVGltZX1tcykgKyBTZXR1cCgke3RvdGFsVGltZSAtIHB5b2RpZGVUaW1lfW1zKWApO1xuICAgICAgXG4gICAgICAvLyBNYXJrIGFzIGluaXRpYWxpemVkXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IFwiYWN0aXZlXCI7XG4gICAgICBjb25zb2xlLmxvZyhcIvCfn6IgS2VybmVsIGlzIG5vdyBBQ1RJVkUgYW5kIHJlYWR5IGZvciBleGVjdXRpb24hXCIpO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgS2VybmVsIGluaXRpYWxpemF0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gXCJ1bmtub3duXCI7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBNb3VudCB0aGUgbG9jYWwgZmlsZXN5c3RlbSB0byB0aGUgUHlvZGlkZSBlbnZpcm9ubWVudFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBtb3VudEZpbGVzeXN0ZW0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBNb3VudGluZyBmaWxlc3lzdGVtIGZyb20gJHt0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLnJvb3R9IHRvICR7dGhpcy5maWxlc3lzdGVtT3B0aW9ucy5tb3VudFBvaW50fWApO1xuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgYXBwcm9hY2ggYXMgaW4gZGVuby1kZW1vLWZzLWFzZ2kuanMgZm9yIG1heGltdW0gY29tcGF0aWJpbGl0eVxuICAgICAgLy8gU2ltcGxlIGFuZCBkaXJlY3QgbW91bnRpbmcgb2YgdGhlIGZpbGVzeXN0ZW1cbiAgICAgIGF3YWl0IHRoaXMucHlvZGlkZS5GUy5tb3VudChcbiAgICAgICAgdGhpcy5weW9kaWRlLkZTLmZpbGVzeXN0ZW1zLk5PREVGUyxcbiAgICAgICAgeyByb290OiB0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLnJvb3QgfHwgXCIuXCIgfSxcbiAgICAgICAgdGhpcy5maWxlc3lzdGVtT3B0aW9ucy5tb3VudFBvaW50IHx8IFwiL2hvbWUvcHlvZGlkZVwiXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIkZpbGVzeXN0ZW0gbW91bnRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0aGUgbW91bnQgYnkgbGlzdGluZyB0aGUgZGlyZWN0b3J5XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtb3VudGVkRmlsZXMgPSB0aGlzLnB5b2RpZGUuRlMucmVhZGRpcih0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLm1vdW50UG9pbnQgfHwgXCIvaG9tZS9weW9kaWRlXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRmlsZXMgaW4gJHt0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLm1vdW50UG9pbnR9IGRpcmVjdG9yeTogJHttb3VudGVkRmlsZXMuam9pbihcIiwgXCIpfWApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgbGlzdGluZyBtb3VudGVkIGRpcmVjdG9yeTogJHtlcnJvcn1gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG1vdW50aW5nIGZpbGVzeXN0ZW06XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBQeW9kaWRlIHBhY2thZ2UgbWFuYWdlciB3aXRoIG9wdGltaXplZCB3aGVlbCBsb2FkaW5nXG4gICAqIE9QVElNSVpFRDogU21hcnQgY2FjaGluZyBhbmQgcGFyYWxsZWwgd2hlZWwgaW5zdGFsbGF0aW9uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRQYWNrYWdlTWFuYWdlcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnNvbGUubG9nKFwi4pqhIEluaXRpYWxpemluZyBvcHRpbWl6ZWQgcGFja2FnZSBtYW5hZ2VyLi4uXCIpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBMb2FkIG1pY3JvcGlwIGFuZCBwYWNrYWdpbmcgaW4gcGFyYWxsZWxcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+TpiBMb2FkaW5nIG1pY3JvcGlwLCBwYWNrYWdpbmcuLi5cIik7XG4gICAgICBhd2FpdCB0aGlzLnB5b2RpZGUubG9hZFBhY2thZ2UoWydtaWNyb3BpcCcsICdwYWNrYWdpbmcnXSk7XG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBMb2FkZWQgbWljcm9waXAsIHBhY2thZ2luZ1wiKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBiYXNlIFVSTCAtIHVzZSB3aW5kb3cubG9jYXRpb24gZm9yIGJyb3dzZXIgb3IgZmFsbGJhY2sgZm9yIHdvcmtlclxuICAgICAgbGV0IGJhc2VVcmw6IHN0cmluZztcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgICAgLy8gSW4gbWFpbiB0aHJlYWQgLSB1c2Ugd2luZG93LmxvY2F0aW9uXG4gICAgICAgIGJhc2VVcmwgPSBuZXcgVVJMKFwiLlwiLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYubG9jYXRpb24pIHtcbiAgICAgICAgLy8gSW4gd2ViIHdvcmtlciAtIHVzZSBzZWxmLmxvY2F0aW9uXG4gICAgICAgIGJhc2VVcmwgPSBuZXcgVVJMKFwiLlwiLCBzZWxmLmxvY2F0aW9uLmhyZWYpLmhyZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayAtIGFzc3VtZSBjdXJyZW50IG9yaWdpblxuICAgICAgICBiYXNlVXJsID0gXCIvXCI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGFsbEpzb25QYXRoID0gbmV3IFVSTChhbGxKU09OVXJsLCBiYXNlVXJsKS5ocmVmO1xuICAgICAgXG4gICAgICAvLyBQcmVwYXJlIGFsbCB3aGVlbCBVUkxzIGZvciBwYXJhbGxlbCBsb2FkaW5nXG4gICAgICBjb25zdCB3aGVlbEZpbGVzID0gW1xuICAgICAgICBuZXcgVVJMKHBpcGxpdGVXaGVlbFVybCwgYmFzZVVybCkuaHJlZixcbiAgICAgICAgbmV3IFVSTChweW9kaWRlX2tlcm5lbFdoZWVsVXJsLCBiYXNlVXJsKS5ocmVmLFxuICAgICAgICBuZXcgVVJMKGlweWtlcm5lbFdoZWVsVXJsLCBiYXNlVXJsKS5ocmVmLFxuICAgICAgICBuZXcgVVJMKHdpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsLCBiYXNlVXJsKS5ocmVmLFxuICAgICAgICBuZXcgVVJMKHdpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsMSwgYmFzZVVybCkuaHJlZixcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5qAIEluc3RhbGxpbmcgJHt3aGVlbEZpbGVzLmxlbmd0aH0gd2hlZWwgcGFja2FnZXMgaW4gcGFyYWxsZWwuLi5gKTtcbiAgICAgIFxuICAgICAgLy8gSW5zdGFsbCBhbGwgd2hlZWwgcGFja2FnZXMgaW4gcGFyYWxsZWwgZm9yIG1heGltdW0gc3BlZWRcbiAgICAgIGNvbnN0IHdoZWVsUHJvbWlzZXMgPSB3aGVlbEZpbGVzLm1hcChhc3luYyAod2hlZWxVcmwsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHdoZWVsU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxuaW1wb3J0IG1pY3JvcGlwXG5hd2FpdCBtaWNyb3BpcC5pbnN0YWxsKCcke3doZWVsVXJsfScsIGtlZXBfZ29pbmc9VHJ1ZSlcbnByaW50KGZcIuKchSBXaGVlbCAke2luZGV4ICsgMX0vJHt3aGVlbEZpbGVzLmxlbmd0aH0gaW5zdGFsbGVkXCIpXG5gKTtcbiAgICAgICAgICBjb25zdCB3aGVlbFRpbWUgPSBEYXRlLm5vdygpIC0gd2hlZWxTdGFydFRpbWU7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKaoSBXaGVlbCAke2luZGV4ICsgMX0gaW5zdGFsbGVkIGluICR7d2hlZWxUaW1lfW1zYCk7XG4gICAgICAgICAgcmV0dXJuIHsgaW5kZXgsIHN1Y2Nlc3M6IHRydWUsIHRpbWU6IHdoZWVsVGltZSB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnN0IHdoZWVsVGltZSA9IERhdGUubm93KCkgLSB3aGVlbFN0YXJ0VGltZTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBXaGVlbCAke2luZGV4ICsgMX0gZmFpbGVkIGFmdGVyICR7d2hlZWxUaW1lfW1zOmAsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm4geyBpbmRleCwgc3VjY2VzczogZmFsc2UsIHRpbWU6IHdoZWVsVGltZSwgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIGFsbCB3aGVlbCBpbnN0YWxsYXRpb25zXG4gICAgICBjb25zdCB3aGVlbFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh3aGVlbFByb21pc2VzKTtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSB3aGVlbFJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdWNjZXNzKTtcbiAgICAgIGNvbnN0IGZhaWxlZCA9IHdoZWVsUmVzdWx0cy5maWx0ZXIociA9PiAhci5zdWNjZXNzKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYPCfk4ogV2hlZWxzOiAke3N1Y2Nlc3NmdWwubGVuZ3RofS8ke3doZWVsRmlsZXMubGVuZ3RofSBzdWNjZXNzZnVsYCk7XG4gICAgICBpZiAoZmFpbGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gRmFpbGVkIHdoZWVsczogJHtmYWlsZWQubWFwKGYgPT4gZi5pbmRleCArIDEpLmpvaW4oJywgJyl9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNldCB1cCBwaXBsaXRlIGNvbmZpZ3VyYXRpb24gd2l0aCBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zIChpZiBhdmFpbGFibGUpXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxudHJ5OlxuICAgIGltcG9ydCBwaXBsaXRlLnBpcGxpdGVcbiAgICBpbXBvcnQganNvblxuXG4gICAgIyBMb2FkIHBhY2thZ2UgaW5kZXggZm9yIGZhc3RlciBsb29rdXBzXG4gICAgdHJ5OlxuICAgICAgICBwaXBsaXRlLnBpcGxpdGUuUElQTElURV9VUkwgPSBcIiR7YWxsSnNvblBhdGh9XCJcbiAgICAgICAgIyBQcmUtbG9hZCBwYWNrYWdlIGluZGV4IGZvciBmYXN0ZXIgaW5zdGFsbGF0aW9uXG4gICAgICAgIHByaW50KFwi8J+TiyBQYWNrYWdlIGluZGV4IGNvbmZpZ3VyZWRcIilcbiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6XG4gICAgICAgIHByaW50KGZcIuKaoO+4jyBQYWNrYWdlIGluZGV4IHNldHVwIHdhcm5pbmc6IHtlfVwiKVxuXG4gICAgIyBDb25maWd1cmUgcGlwbGl0ZSBmb3Igb3B0aW1hbCBwZXJmb3JtYW5jZVxuICAgIHBpcGxpdGUucGlwbGl0ZS5SRVBPREFUQV9JTkZPID0ge31cbiAgICBwcmludChcIuKaoSBQaXBsaXRlIG9wdGltaXplZCBmb3IgcGVyZm9ybWFuY2VcIilcbmV4Y2VwdCBJbXBvcnRFcnJvcjpcbiAgICBwcmludChcIuKaoO+4jyBQaXBsaXRlIG5vdCBhdmFpbGFibGUsIGNvbnRpbnVpbmcgd2l0aG91dCBpdFwiKVxuZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOlxuICAgIHByaW50KGZcIuKaoO+4jyBQaXBsaXRlIHNldHVwIGZhaWxlZDoge2V9XCIpXG5gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBQaXBsaXRlIGNvbmZpZ3VyYXRpb24gZmFpbGVkLCBjb250aW51aW5nIHdpdGhvdXQgaXQ6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdG90YWxUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIFBhY2thZ2UgbWFuYWdlciBpbml0aWFsaXplZCBpbiAke3RvdGFsVGltZX1tc2ApO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgUGFja2FnZSBtYW5hZ2VyIGluaXRpYWxpemF0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGtlcm5lbCB3aXRoIHJlcXVpcmVkIFB5dGhvbiBwYWNrYWdlc1xuICAgKiBPUFRJTUlaRUQ6IE1heGltdW0gcGFyYWxsZWxpemF0aW9uIHdpdGggaW50ZWxsaWdlbnQgZGVwZW5kZW5jeSByZXNvbHV0aW9uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRLZXJuZWwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zb2xlLmxvZyhcIvCfmoAgSW5pdGlhbGl6aW5nIGtlcm5lbCBwYWNrYWdlcyB3aXRoIG1heGltdW0gb3B0aW1pemF0aW9uLi4uXCIpO1xuICAgIFxuICAgIC8vIEFsbCBwYWNrYWdlcyB0byBpbnN0YWxsIHdpdGggcHJpb3JpdHkgYW5kIGRlcGVuZGVuY3kgaW5mb3JtYXRpb25cbiAgICBjb25zdCBwYWNrYWdlQ29uZmlnID0gW1xuICAgICAgLy8gSGlnaCBwcmlvcml0eTogQ0ROIHBhY2thZ2VzIChmYXN0ZXN0KVxuICAgICAgeyBuYW1lOiAncHVyZS1ldmFsJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdzdGFjay1kYXRhJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdweWdtZW50cycsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnc3NsJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdzcWxpdGUzJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdwcm9tcHRfdG9vbGtpdCcsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnamVkaScsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnaXB5dGhvbicsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgXG4gICAgICAvLyBNZWRpdW0gcHJpb3JpdHk6IHBpcCBwYWNrYWdlc1xuICAgICAgeyBuYW1lOiAnY29tbScsIHByaW9yaXR5OiAyLCBzb3VyY2U6ICdwaXAnIH0sXG4gICAgICB7IG5hbWU6ICdoeXBoYS1ycGMnLCBwcmlvcml0eTogMiwgc291cmNlOiAncGlwJyB9LFxuICAgICAgeyBuYW1lOiAnbmJmb3JtYXQnLCBwcmlvcml0eTogMiwgc291cmNlOiAncGlwJyB9LFxuICAgICAgXG4gICAgICAvLyBMb3dlciBwcmlvcml0eTogY29tcGxleCBwYWNrYWdlc1xuICAgICAgeyBuYW1lOiAnaXB5a2VybmVsJywgcHJpb3JpdHk6IDMsIHNvdXJjZTogJ3BpcCcgfSxcbiAgICAgIHsgbmFtZTogJ3B5b2RpZGVfa2VybmVsJywgcHJpb3JpdHk6IDMsIHNvdXJjZTogJ3BpcCcgfVxuICAgIF07XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCfk6YgSW5zdGFsbGluZyAke3BhY2thZ2VDb25maWcubGVuZ3RofSBwYWNrYWdlcyB3aXRoIGludGVsbGlnZW50IG9wdGltaXphdGlvbi4uLmApO1xuICAgICAgXG4gICAgICAvLyBJbnN0YWxsIEFMTCBwYWNrYWdlcyBpbiBwYXJhbGxlbCB3aXRoIGFkdmFuY2VkIGVycm9yIGhhbmRsaW5nIGFuZCBjYWNoaW5nXG4gICAgICBhd2FpdCB0aGlzLmluc3RhbGxQYWNrYWdlc1dpdGhJbnRlbGxpZ2VudE9wdGltaXphdGlvbihwYWNrYWdlQ29uZmlnKTtcbiAgICAgIFxuICAgICAgLy8gSW1wb3J0IHRoZSBrZXJuZWwgKG11c3QgYmUgZG9uZSBhZnRlciBwYWNrYWdlcyBhcmUgaW5zdGFsbGVkKVxuICAgICAgY29uc29sZS5sb2coXCLwn5OlIEltcG9ydGluZyBweW9kaWRlX2tlcm5lbC4uLlwiKTtcbiAgICAgIGNvbnN0IGltcG9ydFN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoJ2ltcG9ydCBweW9kaWRlX2tlcm5lbCcpO1xuICAgICAgY29uc3QgaW1wb3J0VGltZSA9IERhdGUubm93KCkgLSBpbXBvcnRTdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg4pyFIHB5b2RpZGVfa2VybmVsIGltcG9ydGVkIGluICR7aW1wb3J0VGltZX1tc2ApO1xuICAgICAgXG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYPCfjq8gS2VybmVsIHBhY2thZ2VzIGluaXRpYWxpemVkIGluICR7dG90YWxUaW1lfW1zYCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBLZXJuZWwgcGFja2FnZSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEluc3RhbGwgcGFja2FnZXMgd2l0aCBpbnRlbGxpZ2VudCBvcHRpbWl6YXRpb24gYW5kIGFkdmFuY2VkIGNhY2hpbmdcbiAgICogT1BUSU1JWkVEOiBTbWFydCBzb3VyY2Ugc2VsZWN0aW9uLCBwYXJhbGxlbCBpbnN0YWxsYXRpb24sIGFuZCBwZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluc3RhbGxQYWNrYWdlc1dpdGhJbnRlbGxpZ2VudE9wdGltaXphdGlvbihwYWNrYWdlQ29uZmlnOiBBcnJheTx7bmFtZTogc3RyaW5nLCBwcmlvcml0eTogbnVtYmVyLCBzb3VyY2U6IHN0cmluZ30+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coYOKaoSBTdGFydGluZyBpbnRlbGxpZ2VudCBwYXJhbGxlbCBpbnN0YWxsYXRpb24gb2YgJHtwYWNrYWdlQ29uZmlnLmxlbmd0aH0gcGFja2FnZXMuLi5gKTtcbiAgICBcbiAgICBjb25zdCBpbnN0YWxsUHJvbWlzZXMgPSBwYWNrYWdlQ29uZmlnLm1hcChhc3luYyAocGtnKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgSW5zdGFsbGluZyAke3BrZy5uYW1lfSAocHJpb3JpdHk6ICR7cGtnLnByaW9yaXR5fSwgcHJlZmVycmVkOiAke3BrZy5zb3VyY2V9KS4uLmApO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHByZWZlcnJlZCBzb3VyY2UgZmlyc3QsIHdpdGggaW50ZWxsaWdlbnQgZmFsbGJhY2tcbiAgICAgICAgaWYgKHBrZy5zb3VyY2UgPT09ICdweW9kaWRlJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUubG9hZFBhY2thZ2UoW3BrZy5uYW1lXSk7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7cGtnLm5hbWV9IGxvYWRlZCBmcm9tIFB5b2RpZGUgQ0ROICgke2R1cmF0aW9ufW1zKWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFja2FnZTogcGtnLm5hbWUsIG1ldGhvZDogJ3B5b2RpZGUnLCBkdXJhdGlvbiwgc3VjY2VzczogdHJ1ZSwgcHJpb3JpdHk6IHBrZy5wcmlvcml0eSB9O1xuICAgICAgICAgIH0gY2F0Y2ggKHB5b2RpZGVFcnJvcikge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcGlwIHdpdGggZW5oYW5jZWQgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OmICR7cGtnLm5hbWV9IG5vdCBhdmFpbGFibGUgb24gQ0ROLCB0cnlpbmcgcGlwLi4uYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluc3RhbGxWaWFQaXBXaXRoT3B0aW1pemF0aW9ucyhwa2cubmFtZSk7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7cGtnLm5hbWV9IGluc3RhbGxlZCB2aWEgcGlwIGZhbGxiYWNrICgke2R1cmF0aW9ufW1zKWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFja2FnZTogcGtnLm5hbWUsIG1ldGhvZDogJ3BpcC1mYWxsYmFjaycsIGR1cmF0aW9uLCBzdWNjZXNzOiB0cnVlLCBwcmlvcml0eTogcGtnLnByaW9yaXR5IH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERpcmVjdCBwaXAgaW5zdGFsbGF0aW9uIHdpdGggb3B0aW1pemF0aW9uc1xuICAgICAgICAgIGF3YWl0IHRoaXMuaW5zdGFsbFZpYVBpcFdpdGhPcHRpbWl6YXRpb25zKHBrZy5uYW1lKTtcbiAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSAke3BrZy5uYW1lfSBpbnN0YWxsZWQgdmlhIHBpcCAoJHtkdXJhdGlvbn1tcylgKTtcbiAgICAgICAgICByZXR1cm4geyBwYWNrYWdlOiBwa2cubmFtZSwgbWV0aG9kOiAncGlwJywgZHVyYXRpb24sIHN1Y2Nlc3M6IHRydWUsIHByaW9yaXR5OiBwa2cucHJpb3JpdHkgfTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICBjb25zb2xlLndhcm4oYOKdjCBGYWlsZWQgdG8gaW5zdGFsbCAke3BrZy5uYW1lfSBhZnRlciAke2R1cmF0aW9ufW1zOmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgcGFja2FnZTogcGtnLm5hbWUsIG1ldGhvZDogJ2ZhaWxlZCcsIGR1cmF0aW9uLCBzdWNjZXNzOiBmYWxzZSwgcHJpb3JpdHk6IHBrZy5wcmlvcml0eSwgZXJyb3IgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBXYWl0IGZvciBhbGwgaW5zdGFsbGF0aW9ucyB3aXRoIGRldGFpbGVkIGFuYWx5c2lzXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGluc3RhbGxQcm9taXNlcyk7XG4gICAgXG4gICAgLy8gQ29tcHJlaGVuc2l2ZSBwZXJmb3JtYW5jZSBhbmFseXNpc1xuICAgIHRoaXMuYW5hbHl6ZUluc3RhbGxhdGlvblJlc3VsdHMocmVzdWx0cyk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbnN0YWxsIHBhY2thZ2UgdmlhIHBpcCB3aXRoIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnNcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5zdGFsbFZpYVBpcFdpdGhPcHRpbWl6YXRpb25zKHBhY2thZ2VOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxudHJ5OlxuICAgICMgSW1wb3J0IHBpcGxpdGUgZmlyc3RcbiAgICBpbXBvcnQgcGlwbGl0ZVxuICAgICMgVXNlIG9wdGltaXplZCBwaXAgaW5zdGFsbGF0aW9uIHdpdGggY2FjaGluZ1xuICAgIGF3YWl0IHBpcGxpdGUuaW5zdGFsbCgnJHtwYWNrYWdlTmFtZX0nLCBrZWVwX2dvaW5nPVRydWUsIGRlcHM9VHJ1ZSlcbiAgICBwcmludChcIuKchSBTdWNjZXNzZnVsbHkgaW5zdGFsbGVkICR7cGFja2FnZU5hbWV9IHZpYSBvcHRpbWl6ZWQgcGlwXCIpXG5leGNlcHQgRXhjZXB0aW9uIGFzIGU6XG4gICAgcHJpbnQoXCLimqDvuI8gV2FybmluZzogRmFpbGVkIHRvIGluc3RhbGwgJHtwYWNrYWdlTmFtZX06XCIsIHN0cihlKSlcbiAgICAjIFRyeSBhbHRlcm5hdGl2ZSBpbnN0YWxsYXRpb24gbWV0aG9kXG4gICAgdHJ5OlxuICAgICAgICBpbXBvcnQgbWljcm9waXBcbiAgICAgICAgYXdhaXQgbWljcm9waXAuaW5zdGFsbCgnJHtwYWNrYWdlTmFtZX0nLCBrZWVwX2dvaW5nPVRydWUpXG4gICAgICAgIHByaW50KFwi4pyFIFN1Y2Nlc3NmdWxseSBpbnN0YWxsZWQgJHtwYWNrYWdlTmFtZX0gdmlhIG1pY3JvcGlwIGZhbGxiYWNrXCIpXG4gICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlMjpcbiAgICAgICAgcHJpbnQoXCLinYwgQm90aCBwaXAgbWV0aG9kcyBmYWlsZWQgZm9yICR7cGFja2FnZU5hbWV9OlwiLCBzdHIoZTIpKVxuICAgICAgICByYWlzZSBlMlxuYCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBBbmFseXplIGluc3RhbGxhdGlvbiByZXN1bHRzIGFuZCBwcm92aWRlIHBlcmZvcm1hbmNlIGluc2lnaHRzXG4gICAqL1xuICBwcml2YXRlIGFuYWx5emVJbnN0YWxsYXRpb25SZXN1bHRzKHJlc3VsdHM6IEFycmF5PGFueT4pOiB2b2lkIHtcbiAgICBjb25zdCBzdWNjZXNzZnVsID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN1Y2Nlc3MpO1xuICAgIGNvbnN0IGZhaWxlZCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gIXIuc3VjY2Vzcyk7XG4gICAgY29uc3QgcHlvZGlkZUluc3RhbGxzID0gc3VjY2Vzc2Z1bC5maWx0ZXIociA9PiByLm1ldGhvZCA9PT0gJ3B5b2RpZGUnKTtcbiAgICBjb25zdCBwaXBJbnN0YWxscyA9IHN1Y2Nlc3NmdWwuZmlsdGVyKHIgPT4gci5tZXRob2QgPT09ICdwaXAnKTtcbiAgICBjb25zdCBmYWxsYmFja0luc3RhbGxzID0gc3VjY2Vzc2Z1bC5maWx0ZXIociA9PiByLm1ldGhvZCA9PT0gJ3BpcC1mYWxsYmFjaycpO1xuICAgIFxuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBNYXRoLm1heCguLi5yZXN1bHRzLm1hcChyID0+IHIuZHVyYXRpb24pKTtcbiAgICBjb25zdCBhdmdEdXJhdGlvbiA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuZHVyYXRpb24sIDApIC8gcmVzdWx0cy5sZW5ndGg7XG4gICAgY29uc3QgZXN0aW1hdGVkU2VxdWVudGlhbCA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuZHVyYXRpb24sIDApO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn46vIElOVEVMTElHRU5UIElOU1RBTExBVElPTiBDT01QTEVURSFgKTtcbiAgICBjb25zb2xlLmxvZyhg8J+TiiBSZXN1bHRzOiAke3N1Y2Nlc3NmdWwubGVuZ3RofS8ke3Jlc3VsdHMubGVuZ3RofSBzdWNjZXNzZnVsYCk7XG4gICAgY29uc29sZS5sb2coYOKaoSBQeW9kaWRlIENETjogJHtweW9kaWRlSW5zdGFsbHMubGVuZ3RofSBwYWNrYWdlc2ApO1xuICAgIGNvbnNvbGUubG9nKGDwn5OmIERpcmVjdCBwaXA6ICR7cGlwSW5zdGFsbHMubGVuZ3RofSBwYWNrYWdlc2ApO1xuICAgIGNvbnNvbGUubG9nKGDwn5SEIFBpcCBmYWxsYmFjazogJHtmYWxsYmFja0luc3RhbGxzLmxlbmd0aH0gcGFja2FnZXNgKTtcbiAgICBjb25zb2xlLmxvZyhg4p2MIEZhaWxlZDogJHtmYWlsZWQubGVuZ3RofSBwYWNrYWdlc2ApO1xuICAgIGNvbnNvbGUubG9nKGDij7HvuI8gIFRvdGFsIHRpbWU6ICR7dG90YWxEdXJhdGlvbn1tcyAodnMgfiR7ZXN0aW1hdGVkU2VxdWVudGlhbH1tcyBzZXF1ZW50aWFsKWApO1xuICAgIGNvbnNvbGUubG9nKGDwn5qAIFNwZWVkIGltcHJvdmVtZW50OiB+JHtNYXRoLnJvdW5kKGVzdGltYXRlZFNlcXVlbnRpYWwgLyB0b3RhbER1cmF0aW9uKX14IGZhc3RlcmApO1xuICAgIGNvbnNvbGUubG9nKGDwn5OIIEF2ZXJhZ2UgcGVyIHBhY2thZ2U6ICR7TWF0aC5yb3VuZChhdmdEdXJhdGlvbil9bXNgKTtcbiAgICBcbiAgICBpZiAoZmFpbGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPICBGYWlsZWQgcGFja2FnZXM6ICR7ZmFpbGVkLm1hcChmID0+IGYucGFja2FnZSkuam9pbignLCAnKX1gKTtcbiAgICAgIC8vIExvZyBzcGVjaWZpYyBmYWlsdXJlIHJlYXNvbnMgZm9yIGRlYnVnZ2luZ1xuICAgICAgZmFpbGVkLmZvckVhY2goZiA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihgICAgLSAke2YucGFja2FnZX06ICR7Zi5lcnJvcj8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gUGVyZm9ybWFuY2UgaW5zaWdodHNcbiAgICBjb25zdCBmYXN0ZXN0SW5zdGFsbCA9IE1hdGgubWluKC4uLnN1Y2Nlc3NmdWwubWFwKHIgPT4gci5kdXJhdGlvbikpO1xuICAgIGNvbnN0IHNsb3dlc3RJbnN0YWxsID0gTWF0aC5tYXgoLi4uc3VjY2Vzc2Z1bC5tYXAociA9PiByLmR1cmF0aW9uKSk7XG4gICAgY29uc29sZS5sb2coYPCfk4ogUGVyZm9ybWFuY2UgcmFuZ2U6ICR7ZmFzdGVzdEluc3RhbGx9bXMgKGZhc3Rlc3QpIHRvICR7c2xvd2VzdEluc3RhbGx9bXMgKHNsb3dlc3QpYCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGdsb2JhbCBvYmplY3RzIGZyb20gdGhlIHB5b2RpZGVfa2VybmVsIHBhY2thZ2VcbiAgICogQmFzZWQgb24gdGhlIFB5b2RpZGVSZW1vdGVLZXJuZWwgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5pdEdsb2JhbHMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coXCJJbml0aWFsaXppbmcgZ2xvYmFscy4uLlwiKTtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGdsb2JhbHMgZnJvbSB0aGUgUHl0aG9uIGVudmlyb25tZW50XG4gICAgY29uc3QgeyBnbG9iYWxzIH0gPSB0aGlzLnB5b2RpZGU7XG4gICAgXG4gICAgLy8gR2V0IHRoZSBrZXJuZWwgaW5zdGFuY2UgYW5kIHJlbGF0ZWQgb2JqZWN0c1xuICAgIHRoaXMuX2tlcm5lbCA9IGdsb2JhbHMuZ2V0KCdweW9kaWRlX2tlcm5lbCcpLmtlcm5lbF9pbnN0YW5jZS5jb3B5KCk7XG4gICAgdGhpcy5fc3Rkb3V0X3N0cmVhbSA9IGdsb2JhbHMuZ2V0KCdweW9kaWRlX2tlcm5lbCcpLnN0ZG91dF9zdHJlYW0uY29weSgpO1xuICAgIHRoaXMuX3N0ZGVycl9zdHJlYW0gPSBnbG9iYWxzLmdldCgncHlvZGlkZV9rZXJuZWwnKS5zdGRlcnJfc3RyZWFtLmNvcHkoKTtcbiAgICB0aGlzLl9pbnRlcnByZXRlciA9IHRoaXMuX2tlcm5lbC5pbnRlcnByZXRlci5jb3B5KCk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGNvbW11bmljYXRpb24gaGFuZGxlcnNcbiAgICB0aGlzLl9pbnRlcnByZXRlci5zZW5kX2NvbW0gPSB0aGlzLnNlbmRDb21tLmJpbmQodGhpcyk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGNhbGxiYWNrc1xuICAgIHRoaXMuc2V0dXBDYWxsYmFja3MoKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNldHVwIGFsbCBuZWNlc3NhcnkgY2FsbGJhY2tzIGZvciB0aGUgUHl0aG9uIGVudmlyb25tZW50XG4gICAqL1xuICBwcml2YXRlIHNldHVwQ2FsbGJhY2tzKCk6IHZvaWQge1xuICAgIC8vIEV4ZWN1dGlvbiByZXN1bHQgY2FsbGJhY2tcbiAgICBjb25zdCBwdWJsaXNoRXhlY3V0aW9uUmVzdWx0ID0gKFxuICAgICAgcHJvbXB0X2NvdW50OiBhbnksXG4gICAgICBkYXRhOiBhbnksXG4gICAgICBtZXRhZGF0YTogYW55LFxuICAgICk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgYnVuZGxlID0ge1xuICAgICAgICBleGVjdXRpb25fY291bnQ6IHByb21wdF9jb3VudCxcbiAgICAgICAgZGF0YTogdGhpcy5mb3JtYXRSZXN1bHQoZGF0YSksXG4gICAgICAgIG1ldGFkYXRhOiB0aGlzLmZvcm1hdFJlc3VsdChtZXRhZGF0YSksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgICAgICBidW5kbGUsXG4gICAgICAgIHR5cGU6ICdleGVjdXRlX3Jlc3VsdCcsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRXJyb3IgY2FsbGJhY2tcbiAgICBjb25zdCBwdWJsaXNoRXhlY3V0aW9uRXJyb3IgPSAoZW5hbWU6IGFueSwgZXZhbHVlOiBhbnksIHRyYWNlYmFjazogYW55KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSB7XG4gICAgICAgIGVuYW1lOiBlbmFtZSxcbiAgICAgICAgZXZhbHVlOiBldmFsdWUsXG4gICAgICAgIHRyYWNlYmFjazogdHJhY2ViYWNrLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgYnVuZGxlLFxuICAgICAgICAgIHR5cGU6ICdleGVjdXRlX2Vycm9yJyxcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBDbGVhciBvdXRwdXQgY2FsbGJhY2tcbiAgICBjb25zdCBjbGVhck91dHB1dENhbGxiYWNrID0gKHdhaXQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICAgICAgd2FpdDogdGhpcy5mb3JtYXRSZXN1bHQod2FpdCksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgICAgICBidW5kbGUsXG4gICAgICAgICAgdHlwZTogJ2NsZWFyX291dHB1dCcsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRGlzcGxheSBkYXRhIGNhbGxiYWNrXG4gICAgY29uc3QgZGlzcGxheURhdGFDYWxsYmFjayA9IChkYXRhOiBhbnksIG1ldGFkYXRhOiBhbnksIHRyYW5zaWVudDogYW55KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSB7XG4gICAgICAgIGRhdGE6IHRoaXMuZm9ybWF0UmVzdWx0KGRhdGEpLFxuICAgICAgICBtZXRhZGF0YTogdGhpcy5mb3JtYXRSZXN1bHQobWV0YWRhdGEpLFxuICAgICAgICB0cmFuc2llbnQ6IHRoaXMuZm9ybWF0UmVzdWx0KHRyYW5zaWVudCksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgICAgICBidW5kbGUsXG4gICAgICAgIHR5cGU6ICdkaXNwbGF5X2RhdGEnLFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSBkaXNwbGF5IGRhdGEgY2FsbGJhY2tcbiAgICBjb25zdCB1cGRhdGVEaXNwbGF5RGF0YUNhbGxiYWNrID0gKFxuICAgICAgZGF0YTogYW55LFxuICAgICAgbWV0YWRhdGE6IGFueSxcbiAgICAgIHRyYW5zaWVudDogYW55LFxuICAgICk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgYnVuZGxlID0ge1xuICAgICAgICBkYXRhOiB0aGlzLmZvcm1hdFJlc3VsdChkYXRhKSxcbiAgICAgICAgbWV0YWRhdGE6IHRoaXMuZm9ybWF0UmVzdWx0KG1ldGFkYXRhKSxcbiAgICAgICAgdHJhbnNpZW50OiB0aGlzLmZvcm1hdFJlc3VsdCh0cmFuc2llbnQpLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgYnVuZGxlLFxuICAgICAgICB0eXBlOiAndXBkYXRlX2Rpc3BsYXlfZGF0YScsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gU3RyZWFtIGNhbGxiYWNrXG4gICAgY29uc3QgcHVibGlzaFN0cmVhbUNhbGxiYWNrID0gKG5hbWU6IGFueSwgdGV4dDogYW55KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMuZm9ybWF0UmVzdWx0KG5hbWUpLFxuICAgICAgICB0ZXh0OiB0aGlzLmZvcm1hdFJlc3VsdCh0ZXh0KSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgcGFyZW50SGVhZGVyOiB0aGlzLmZvcm1hdFJlc3VsdCh0aGlzLl9wYXJlbnRfaGVhZGVyKVsnaGVhZGVyJ10sXG4gICAgICAgIGJ1bmRsZSxcbiAgICAgICAgdHlwZTogJ3N0cmVhbScsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQXNzaWduIGNhbGxiYWNrcyB0byB0aGUgUHl0aG9uIG9iamVjdHNcbiAgICB0aGlzLl9zdGRvdXRfc3RyZWFtLnB1Ymxpc2hfc3RyZWFtX2NhbGxiYWNrID0gcHVibGlzaFN0cmVhbUNhbGxiYWNrO1xuICAgIHRoaXMuX3N0ZGVycl9zdHJlYW0ucHVibGlzaF9zdHJlYW1fY2FsbGJhY2sgPSBwdWJsaXNoU3RyZWFtQ2FsbGJhY2s7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuZGlzcGxheV9wdWIuY2xlYXJfb3V0cHV0X2NhbGxiYWNrID0gY2xlYXJPdXRwdXRDYWxsYmFjaztcbiAgICB0aGlzLl9pbnRlcnByZXRlci5kaXNwbGF5X3B1Yi5kaXNwbGF5X2RhdGFfY2FsbGJhY2sgPSBkaXNwbGF5RGF0YUNhbGxiYWNrO1xuICAgIHRoaXMuX2ludGVycHJldGVyLmRpc3BsYXlfcHViLnVwZGF0ZV9kaXNwbGF5X2RhdGFfY2FsbGJhY2sgPSB1cGRhdGVEaXNwbGF5RGF0YUNhbGxiYWNrO1xuICAgIHRoaXMuX2ludGVycHJldGVyLmRpc3BsYXlob29rLnB1Ymxpc2hfZXhlY3V0aW9uX3Jlc3VsdCA9IHB1Ymxpc2hFeGVjdXRpb25SZXN1bHQ7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuaW5wdXQgPSB0aGlzLmlucHV0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuZ2V0cGFzcyA9IHRoaXMuZ2V0cGFzcy5iaW5kKHRoaXMpO1xuICB9XG4gIFxuICAvKipcbiAgICogUHJvY2VzcyBhIG1lc3NhZ2UgZnJvbSBQeXRob24gZW52aXJvbm1lbnRcbiAgICovXG4gIHByaXZhdGUgX3NlbmRNZXNzYWdlKG1zZzogSU1lc3NhZ2UpOiB2b2lkIHtcbiAgICB0aGlzLl9wcm9jZXNzTWVzc2FnZShtc2cpO1xuICB9XG4gIFxuICAvKipcbiAgICogUHJvY2VzcyBhIG1lc3NhZ2UgYnkgZW1pdHRpbmcgdGhlIGFwcHJvcHJpYXRlIGV2ZW50XG4gICAqL1xuICBwcml2YXRlIF9wcm9jZXNzTWVzc2FnZShtc2c6IElNZXNzYWdlKTogdm9pZCB7XG4gICAgaWYgKCFtc2cudHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBldmVudERhdGE6IGFueTtcblxuICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmVhbSc6IHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbXNnLmJ1bmRsZSA/PyB7IG5hbWU6ICdzdGRvdXQnLCB0ZXh0OiAnJyB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5TVFJFQU0sIGJ1bmRsZSk7XG4gICAgICAgIGV2ZW50RGF0YSA9IGJ1bmRsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdpbnB1dF9yZXF1ZXN0Jzoge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gbXNnLmNvbnRlbnQgPz8geyBwcm9tcHQ6ICcnLCBwYXNzd29yZDogZmFsc2UgfTtcbiAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuSU5QVVRfUkVRVUVTVCwgY29udGVudCk7XG4gICAgICAgIGV2ZW50RGF0YSA9IGNvbnRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZGlzcGxheV9kYXRhJzoge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBtc2cuYnVuZGxlID8/IHsgZGF0YToge30sIG1ldGFkYXRhOiB7fSwgdHJhbnNpZW50OiB7fSB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5ESVNQTEFZX0RBVEEsIGJ1bmRsZSk7XG4gICAgICAgIGV2ZW50RGF0YSA9IGJ1bmRsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICd1cGRhdGVfZGlzcGxheV9kYXRhJzoge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBtc2cuYnVuZGxlID8/IHsgZGF0YToge30sIG1ldGFkYXRhOiB7fSwgdHJhbnNpZW50OiB7fSB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5VUERBVEVfRElTUExBWV9EQVRBLCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnY2xlYXJfb3V0cHV0Jzoge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBtc2cuYnVuZGxlID8/IHsgd2FpdDogZmFsc2UgfTtcbiAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuQ0xFQVJfT1VUUFVULCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZXhlY3V0ZV9yZXN1bHQnOiB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IG1zZy5idW5kbGUgPz8ge1xuICAgICAgICAgIGV4ZWN1dGlvbl9jb3VudDogdGhpcy5leGVjdXRpb25Db3VudCxcbiAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfUkVTVUxULCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZXhlY3V0ZV9lcnJvcic6IHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbXNnLmJ1bmRsZSA/PyB7IGVuYW1lOiAnJywgZXZhbHVlOiAnJywgdHJhY2ViYWNrOiBbXSB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnY29tbV9vcGVuJzpcbiAgICAgIGNhc2UgJ2NvbW1fbXNnJzpcbiAgICAgIGNhc2UgJ2NvbW1fY2xvc2UnOiB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBtc2cuY29udGVudCA/PyB7fTtcbiAgICAgICAgc3VwZXIuZW1pdChtc2cudHlwZSwgY29udGVudCwgbXNnLm1ldGFkYXRhLCBtc2cuYnVmZmVycyk7XG4gICAgICAgIGV2ZW50RGF0YSA9IHtcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIG1ldGFkYXRhOiBtc2cubWV0YWRhdGEsXG4gICAgICAgICAgYnVmZmVyczogbXNnLmJ1ZmZlcnNcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW1pdCB0aGUgQUxMIGV2ZW50IHdpdGggc3RhbmRhcmRpemVkIGZvcm1hdFxuICAgIGlmIChldmVudERhdGEpIHtcbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkFMTCwge1xuICAgICAgICB0eXBlOiBtc2cudHlwZSxcbiAgICAgICAgZGF0YTogZXZlbnREYXRhXG4gICAgICB9IGFzIElFdmVudERhdGEpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBrZXJuZWwgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbiAgICovXG4gIHB1YmxpYyBpc0luaXRpYWxpemVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVkO1xuICB9XG4gIFxuICAvKipcbiAgICogTWFrZXMgc3VyZSBweW9kaWRlIGlzIHJlYWR5IGJlZm9yZSBjb250aW51aW5nLCBhbmQgY2FjaGUgdGhlIHBhcmVudCBtZXNzYWdlLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZXR1cChwYXJlbnQ6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIHRoaXMuX3BhcmVudF9oZWFkZXIgPSB0aGlzLnB5b2RpZGUudG9QeShwYXJlbnQgfHwge30pO1xuICB9XG4gIFxuICAvKipcbiAgICogRXhlY3V0ZSBjb2RlIGluIHRoZSBrZXJuZWwgd2l0aCBwcm9wZXIgbWVzc2FnZS1iYXNlZCBjb21wbGV0aW9uIGRldGVjdGlvblxuICAgKiBcbiAgICogQHBhcmFtIGNvZGUgVGhlIGNvZGUgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0gcGFyZW50IFBhcmVudCBtZXNzYWdlIGhlYWRlclxuICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBleGVjdXRpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBleGVjdXRlKGNvZGU6IHN0cmluZywgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuLCBvdXRwdXRzPzogYW55LCBlcnJvcj86IEVycm9yLCBlbmFtZT86IHN0cmluZywgZXZhbHVlPzogc3RyaW5nLCB0cmFjZWJhY2s/OiBhbnkgfT4ge1xuICAgIC8vIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiB0aGF0IGNvbGxlY3RzIGFsbCBvdXRwdXRzIGZyb20gZXhlY3V0ZVN0cmVhbVxuICAgIGNvbnN0IG91dHB1dHM6IGFueVtdID0gW107XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBleGVjdXRlU3RyZWFtIHRvIGdldCBhbGwgb3V0cHV0c1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBvdXRwdXQgb2YgdGhpcy5leGVjdXRlU3RyZWFtKGNvZGUsIHBhcmVudCkpIHtcbiAgICAgICAgb3V0cHV0cy5wdXNoKG91dHB1dCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgY29sbGVjdGVkIG91dHB1dHMgdG8gY3JlYXRlIGEgY29tcHJlaGVuc2l2ZSByZXN1bHRcbiAgICAgIGNvbnN0IHJlc3VsdDogYW55ID0ge1xuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgZGF0YToge30sXG4gICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgZXhlY3V0aW9uX2NvdW50OiB0aGlzLmV4ZWN1dGlvbkNvdW50XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBDb2xsZWN0IGFsbCBvdXRwdXQgdHlwZXNcbiAgICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgICAgaWYgKG91dHB1dC50eXBlID09PSAnc3RyZWFtJykge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc3Rkb3V0L3N0ZGVyclxuICAgICAgICAgIGlmICghcmVzdWx0LnN0ZG91dCkgcmVzdWx0LnN0ZG91dCA9ICcnO1xuICAgICAgICAgIGlmICghcmVzdWx0LnN0ZGVycikgcmVzdWx0LnN0ZGVyciA9ICcnO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChvdXRwdXQuZGF0YS5uYW1lID09PSAnc3Rkb3V0Jykge1xuICAgICAgICAgICAgcmVzdWx0LnN0ZG91dCArPSBvdXRwdXQuZGF0YS50ZXh0O1xuICAgICAgICAgIH0gZWxzZSBpZiAob3V0cHV0LmRhdGEubmFtZSA9PT0gJ3N0ZGVycicpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGRlcnIgKz0gb3V0cHV0LmRhdGEudGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0Lm91dHB1dHMucHVzaChvdXRwdXQuZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3V0cHV0LnR5cGUgPT09ICdkaXNwbGF5X2RhdGEnIHx8IG91dHB1dC50eXBlID09PSAnZXhlY3V0ZV9yZXN1bHQnKSB7XG4gICAgICAgICAgLy8gQ29sbGVjdCBkaXNwbGF5IGRhdGFcbiAgICAgICAgICBpZiAob3V0cHV0LmRhdGEuZGF0YSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQuZGF0YSwgb3V0cHV0LmRhdGEuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdXRwdXQuZGF0YS5tZXRhZGF0YSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQubWV0YWRhdGEsIG91dHB1dC5kYXRhLm1ldGFkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0Lm91dHB1dHMucHVzaChvdXRwdXQuZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3V0cHV0LnR5cGUgPT09ICdleGVjdXRlX2Vycm9yJyB8fCBvdXRwdXQudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgIC8vIEhhbmRsZSBlcnJvcnNcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBvdXRwdXQuZGF0YTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGAke2Vycm9yRGF0YS5lbmFtZX06ICR7ZXJyb3JEYXRhLmV2YWx1ZX1gKSxcbiAgICAgICAgICAgIGVuYW1lOiBlcnJvckRhdGEuZW5hbWUsXG4gICAgICAgICAgICBldmFsdWU6IGVycm9yRGF0YS5ldmFsdWUsXG4gICAgICAgICAgICB0cmFjZWJhY2s6IGVycm9yRGF0YS50cmFjZWJhY2ssXG4gICAgICAgICAgICBvdXRwdXRzOiByZXN1bHQub3V0cHV0c1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU3RvcmUgYW55IG90aGVyIG91dHB1dCB0eXBlXG4gICAgICAgICAgcmVzdWx0Lm91dHB1dHMucHVzaChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZXR1cm4gY29sbGVjdGVkIHJlc3VsdHNcbiAgICAgIHJlc3VsdC5zdWNjZXNzID0gdHJ1ZTtcblxuICAgICAgLy8gQXV0by1zeW5jIG5hdGl2ZSBmaWxlc3lzdGVtcyBpZiBlbmFibGVkXG4gICAgICBpZiAodGhpcy5hdXRvU3luY0ZzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3luY0FsbE5hdGl2ZUZzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltLRVJORUxdIEV4ZWN1dGUgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEZvcm1hdCB0aGUgcmVzdWx0IGZyb20gdGhlIFB5b2RpZGUgZXZhbHVhdGlvblxuICAgKiBCYXNlZCBvbiBQeW9kaWRlUmVtb3RlS2VybmVsIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBwcml2YXRlIGZvcm1hdFJlc3VsdChyZXM6IGFueSk6IGFueSB7XG4gICAgaWYgKCEocmVzIGluc3RhbmNlb2YgdGhpcy5weW9kaWRlLmZmaS5QeVByb3h5KSkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnZlcnQgUHlQcm94eSB0byBKU1xuICAgICAgY29uc3QgbSA9IHJlcy50b0pzKCk7XG4gICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5tYXBUb09iamVjdChtKTtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZm9ybWF0dGluZyByZXN1bHQ6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgTWFwIHRvIGEgSmF2YVNjcmlwdCBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICogQmFzZWQgb24gUHlvZGlkZVJlbW90ZUtlcm5lbCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBtYXBUb09iamVjdChvYmo6IGFueSkge1xuICAgIGNvbnN0IG91dDogYW55ID0gb2JqIGluc3RhbmNlb2YgQXJyYXkgPyBbXSA6IHt9O1xuICAgIFxuICAgIG9iai5mb3JFYWNoKCh2YWx1ZTogYW55LCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgb3V0W2tleV0gPSBcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgID8gdGhpcy5tYXBUb09iamVjdCh2YWx1ZSlcbiAgICAgICAgICA6IHZhbHVlO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBIYW5kbGUgaW5wdXQgcmVwbHkgZnJvbSB1c2VyXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW5wdXRSZXBseShjb250ZW50OiB7IHZhbHVlOiBzdHJpbmcgfSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLl9yZXNvbHZlSW5wdXRSZXBseSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZUlucHV0UmVwbHkoY29udGVudCk7XG4gICAgICB0aGlzLl9yZXNvbHZlSW5wdXRSZXBseSA9IG51bGw7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogU2VuZCBhIGlucHV0IHJlcXVlc3QgdG8gdGhlIGZyb250LWVuZC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc2VuZElucHV0UmVxdWVzdChwcm9tcHQ6IHN0cmluZywgcGFzc3dvcmQ6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjb250ZW50ID0ge1xuICAgICAgcHJvbXB0LFxuICAgICAgcGFzc3dvcmQsXG4gICAgfTtcblxuICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgIHR5cGU6ICdpbnB1dF9yZXF1ZXN0JyxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwYXNzd29yZCBpbnB1dCAod2l0aCBoaWRkZW4gaW5wdXQpXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldHBhc3MocHJvbXB0OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHByb21wdCA9IHR5cGVvZiBwcm9tcHQgPT09ICd1bmRlZmluZWQnID8gJycgOiBwcm9tcHQ7XG4gICAgYXdhaXQgdGhpcy5zZW5kSW5wdXRSZXF1ZXN0KHByb21wdCwgdHJ1ZSk7XG4gICAgY29uc3QgcmVwbHlQcm9taXNlID0gbmV3IFByb21pc2U8eyB2YWx1ZTogc3RyaW5nIH0+KChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9yZXNvbHZlSW5wdXRSZXBseSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbHlQcm9taXNlO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRleHQgaW5wdXRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5wdXQocHJvbXB0OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHByb21wdCA9IHR5cGVvZiBwcm9tcHQgPT09ICd1bmRlZmluZWQnID8gJycgOiBwcm9tcHQ7XG4gICAgYXdhaXQgdGhpcy5zZW5kSW5wdXRSZXF1ZXN0KHByb21wdCwgZmFsc2UpO1xuICAgIGNvbnN0IHJlcGx5UHJvbWlzZSA9IG5ldyBQcm9taXNlPHsgdmFsdWU6IHN0cmluZyB9PigocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZUlucHV0UmVwbHkgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGx5UHJvbWlzZTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICB9XG4gIFxuICAvKipcbiAgICogU2VuZCBhIGNvbW0gbWVzc2FnZSB0byB0aGUgZnJvbnQtZW5kLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZW5kQ29tbSh0eXBlOiBzdHJpbmcsIGNvbnRlbnQ6IGFueSwgbWV0YWRhdGE6IGFueSwgaWRlbnQ6IGFueSwgYnVmZmVyczogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuZm9ybWF0UmVzdWx0KGNvbnRlbnQpLFxuICAgICAgbWV0YWRhdGE6IHRoaXMuZm9ybWF0UmVzdWx0KG1ldGFkYXRhKSxcbiAgICAgIGlkZW50OiB0aGlzLmZvcm1hdFJlc3VsdChpZGVudCksXG4gICAgICBidWZmZXJzOiB0aGlzLmZvcm1hdFJlc3VsdChidWZmZXJzKSxcbiAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogQ29tcGxldGUgdGhlIGNvZGUgc3VibWl0dGVkIGJ5IGEgdXNlci5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBjb21wbGV0ZShjb2RlOiBzdHJpbmcsIGN1cnNvcl9wb3M6IG51bWJlciwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgIFxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2tlcm5lbC5jb21wbGV0ZShjb2RlLCBjdXJzb3JfcG9zKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHQocmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNwZWN0IHRoZSBjb2RlIHN1Ym1pdHRlZCBieSBhIHVzZXIuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW5zcGVjdChjb2RlOiBzdHJpbmcsIGN1cnNvcl9wb3M6IG51bWJlciwgZGV0YWlsX2xldmVsOiAwIHwgMSwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgIFxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2tlcm5lbC5pbnNwZWN0KGNvZGUsIGN1cnNvcl9wb3MsIGRldGFpbF9sZXZlbCk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0KHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgY29kZSBmb3IgY29tcGxldGVuZXNzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGlzQ29tcGxldGUoY29kZTogc3RyaW5nLCBwYXJlbnQ6IGFueSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBhd2FpdCB0aGlzLnNldHVwKHBhcmVudCk7XG4gICAgXG4gICAgY29uc3QgcmVzID0gdGhpcy5fa2VybmVsLmlzX2NvbXBsZXRlKGNvZGUpO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdChyZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhdmFpbGFibGUgY29tbXMuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY29tbUluZm8odGFyZ2V0X25hbWU6IHN0cmluZyB8IG51bGwsIHBhcmVudDogYW55ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICBcbiAgICBjb25zdCByZXMgPSB0aGlzLl9rZXJuZWwuY29tbV9pbmZvKHRhcmdldF9uYW1lKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29tbXM6IHRoaXMuZm9ybWF0UmVzdWx0KHJlcyksXG4gICAgICBzdGF0dXM6ICdvaycsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIGEgQ09NTVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNvbW1PcGVuKGNvbnRlbnQ6IGFueSwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICBcbiAgICBjb25zdCByZXMgPSB0aGlzLl9rZXJuZWwuY29tbV9tYW5hZ2VyLmNvbW1fb3BlbihcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KG51bGwpLFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkobnVsbCksXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShjb250ZW50KVxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0KHJlcyk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZW5kIGEgbWVzc2FnZSB0aHJvdWdoIGEgQ09NTVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNvbW1Nc2coY29udGVudDogYW55LCBwYXJlbnQ6IGFueSA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgIFxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2tlcm5lbC5jb21tX21hbmFnZXIuY29tbV9tc2coXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShudWxsKSxcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KG51bGwpLFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkoY29udGVudClcbiAgICApO1xuICAgIFxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdChyZXMpO1xuICB9XG4gIFxuICAvKipcbiAgICogQ2xvc2UgYSBDT01NXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY29tbUNsb3NlKGNvbnRlbnQ6IGFueSwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICBcbiAgICBjb25zdCByZXMgPSB0aGlzLl9rZXJuZWwuY29tbV9tYW5hZ2VyLmNvbW1fY2xvc2UoXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShudWxsKSxcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KG51bGwpLFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkoY29udGVudClcbiAgICApO1xuICAgIFxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdChyZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgUHl0aG9uIGNvZGUgd2l0aCBzdHJlYW1pbmcgb3V0cHV0XG4gICAqIEBwYXJhbSBjb2RlIFRoZSBQeXRob24gY29kZSB0byBleGVjdXRlXG4gICAqIEBwYXJhbSBwYXJlbnQgUGFyZW50IG1lc3NhZ2UgaGVhZGVyXG4gICAqIEByZXR1cm5zIEFzeW5jR2VuZXJhdG9yIHlpZWxkaW5nIGludGVybWVkaWF0ZSBvdXRwdXRzIGFuZCBmaW5hbGx5IHRoZSBleGVjdXRpb24gcmVzdWx0XG4gICAqL1xuICBwdWJsaWMgYXN5bmMqIGV4ZWN1dGVTdHJlYW0oY29kZTogc3RyaW5nLCBwYXJlbnQ6IGFueSA9IHt9KTogQXN5bmNHZW5lcmF0b3I8YW55LCB7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9LCB2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fc3RhdHVzID0gXCJidXN5XCI7XG4gICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5LRVJORUxfQlVTWSwge30pO1xuICAgICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgICAgLy8gQ3JlYXRlIGV2ZW50IGxpc3RlbmVycyBmb3Igc3RyZWFtaW5nXG4gICAgICBjb25zdCBldmVudFF1ZXVlOiBJRXZlbnREYXRhW10gPSBbXTtcbiAgICAgIGxldCBleGVjdXRpb25Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgbGV0IGV4ZWN1dGlvblJlc3VsdDogYW55ID0gbnVsbDtcbiAgICAgIGxldCBleGVjdXRpb25FcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbDtcbiAgICAgIFxuICAgICAgY29uc3QgaGFuZGxlQWxsRXZlbnRzID0gKGV2ZW50RGF0YTogSUV2ZW50RGF0YSkgPT4ge1xuICAgICAgICBldmVudFF1ZXVlLnB1c2goZXZlbnREYXRhKTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIExpc3RlbiBmb3IgYWxsIGV2ZW50cyBCRUZPUkUgZXhlY3V0aW5nIGNvZGVcbiAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5BTEwsIGhhbmRsZUFsbEV2ZW50cyk7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNvZGUgZGlyZWN0bHlcbiAgICAgICAgdGhpcy5fa2VybmVsLnJ1bihjb2RlKS50aGVuKChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0tFUk5FTF0gUHl0aG9uIGV4ZWN1dGlvbiBmaW5pc2hlZFwiKTtcbiAgICAgICAgICBleGVjdXRpb25SZXN1bHQgPSB0aGlzLmZvcm1hdFJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSByZXN1bHQgaW5kaWNhdGVzIGFuIGVycm9yIGFuZCBlbWl0IGl0IGFzIGFuIGV2ZW50XG4gICAgICAgICAgaWYgKGV4ZWN1dGlvblJlc3VsdCAmJiBleGVjdXRpb25SZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIEV4ZWN1dGlvbiBjb21wbGV0ZWQgd2l0aCBlcnJvciBzdGF0dXMsIGVtaXR0aW5nIGV4ZWN1dGVfZXJyb3IgZXZlbnRcIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEVtaXQgdGhlIGVycm9yIGV2ZW50IHNvIHRoZSBVSSBjYW4gZGlzcGxheSBpdFxuICAgICAgICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgICAgICAgYnVuZGxlOiB7XG4gICAgICAgICAgICAgICAgZW5hbWU6IGV4ZWN1dGlvblJlc3VsdC5lbmFtZSB8fCAnRXJyb3InLFxuICAgICAgICAgICAgICAgIGV2YWx1ZTogZXhlY3V0aW9uUmVzdWx0LmV2YWx1ZSB8fCAnVW5rbm93biBlcnJvcicsXG4gICAgICAgICAgICAgICAgdHJhY2ViYWNrOiBleGVjdXRpb25SZXN1bHQudHJhY2ViYWNrIHx8IFtdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHR5cGU6ICdleGVjdXRlX2Vycm9yJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXYWl0IGEgc21hbGwgYW1vdW50IG9mIHRpbWUgZm9yIGFueSByZW1haW5pbmcgbWVzc2FnZXMgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgfSwgMTAwKTsgLy8gMTAwbXMgc2hvdWxkIGJlIGVub3VnaCBmb3IgbWVzc2FnZSBwcm9jZXNzaW5nXG4gICAgICAgICAgXG4gICAgICAgIH0pLmNhdGNoKChlcnJvcjogYW55KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIltLRVJORUxdIFB5dGhvbiBleGVjdXRpb24gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICBleGVjdXRpb25FcnJvciA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdGlsbCB3YWl0IGZvciBtZXNzYWdlcyB0byBzZXR0bGUgYmVmb3JlIGNvbXBsZXRpbmdcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0cmVhbSBldmVudHMgYXMgdGhleSBhcnJpdmVcbiAgICAgICAgd2hpbGUgKCFleGVjdXRpb25Db21wbGV0ZSB8fCBldmVudFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBZaWVsZCBxdWV1ZWQgZXZlbnRzXG4gICAgICAgICAgaWYgKGV2ZW50UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudFF1ZXVlLnNoaWZ0KCkhO1xuICAgICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgYSBiaXQgZm9yIG1vcmUgZXZlbnRzXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFByb2Nlc3MgZmluYWwgcmVzdWx0XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IFwiYWN0aXZlXCI7XG4gICAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLktFUk5FTF9JRExFLCB7fSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXhlY3V0aW9uRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXhlY3V0aW9uRXJyb3IsXG4gICAgICAgICAgICByZXN1bHQ6IGV4ZWN1dGlvblJlc3VsdFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHJlc3VsdCBpbmRpY2F0ZXMgYW4gZXJyb3JcbiAgICAgICAgaWYgKGV4ZWN1dGlvblJlc3VsdCAmJiBleGVjdXRpb25SZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JNc2cgPSBgJHtleGVjdXRpb25SZXN1bHQuZW5hbWUgfHwgJ0Vycm9yJ306ICR7ZXhlY3V0aW9uUmVzdWx0LmV2YWx1ZSB8fCAnVW5rbm93biBlcnJvcid9YDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGVycm9yTXNnKSxcbiAgICAgICAgICAgIHJlc3VsdDogZXhlY3V0aW9uUmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF1dG8tc3luYyBuYXRpdmUgZmlsZXN5c3RlbXMgaWYgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5hdXRvU3luY0ZzKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zeW5jQWxsTmF0aXZlRnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICByZXN1bHQ6IGV4ZWN1dGlvblJlc3VsdFxuICAgICAgICB9O1xuXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBDbGVhbiB1cCBsaXN0ZW5lclxuICAgICAgICBzdXBlci5vZmYoS2VybmVsRXZlbnRzLkFMTCwgaGFuZGxlQWxsRXZlbnRzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW0tFUk5FTF0gRXhlY3V0ZVN0cmVhbSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gXCJhY3RpdmVcIjtcbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLktFUk5FTF9JRExFLCB7fSk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIEludGVycnVwdCBmdW5jdGlvbmFsaXR5XG4gIHB1YmxpYyBhc3luYyBpbnRlcnJ1cHQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkIHx8ICF0aGlzLnB5b2RpZGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltLRVJORUxdIENhbm5vdCBpbnRlcnJ1cHQ6IGtlcm5lbCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiW0tFUk5FTF0gQXR0ZW1wdGluZyB0byBpbnRlcnJ1cHQgZXhlY3V0aW9uLi4uXCIpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCBwcmlvcml0eTogVXNlIGludGVycnVwdCBidWZmZXIgaWYgYXZhaWxhYmxlXG4gICAgICBpZiAodGhpcy5faW50ZXJydXB0QnVmZmVyICYmIHRoaXMuX2ludGVycnVwdFN1cHBvcnRlZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIFVzaW5nIGludGVycnVwdCBidWZmZXIgbWV0aG9kXCIpO1xuICAgICAgICAvLyBTZXQgaW50ZXJydXB0IHNpZ25hbCAoMiA9IFNJR0lOVClcbiAgICAgICAgdGhpcy5faW50ZXJydXB0QnVmZmVyWzBdID0gMjtcbiAgICAgICAgXG4gICAgICAgIC8vIEdpdmUgdGhlIGludGVycnVwdCBhIG1vbWVudCB0byBiZSBwcm9jZXNzZWRcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGludGVycnVwdCB3YXMgcHJvY2Vzc2VkIChidWZmZXIgc2hvdWxkIGJlIHJlc2V0IHRvIDApXG4gICAgICAgIGNvbnN0IHdhc1Byb2Nlc3NlZCA9IHRoaXMuX2ludGVycnVwdEJ1ZmZlclswXSA9PT0gMDtcbiAgICAgICAgaWYgKHdhc1Byb2Nlc3NlZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0tFUk5FTF0gSW50ZXJydXB0IHByb2Nlc3NlZCBzdWNjZXNzZnVsbHkgdmlhIGJ1ZmZlclwiKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZWNvbmQgcHJpb3JpdHk6IFRyeSBQeXRob24tbGV2ZWwgaW50ZXJydXB0XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIEF0dGVtcHRpbmcgUHl0aG9uLWxldmVsIGludGVycnVwdFwiKTtcbiAgICAgICAgLy8gVHJ5IHRvIHJhaXNlIEtleWJvYXJkSW50ZXJydXB0IGluIFB5dGhvblxuICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxuaW1wb3J0IHN5c1xuaW1wb3J0IF90aHJlYWRcbiMgVHJ5IHRvIGludGVycnVwdCB0aGUgbWFpbiB0aHJlYWRcbl90aHJlYWQuaW50ZXJydXB0X21haW4oKVxuYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0tFUk5FTF0gUHl0aG9uIGludGVycnVwdCBzaWduYWwgc2VudFwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChweXRob25FcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIFB5dGhvbiBpbnRlcnJ1cHQgYXR0ZW1wdCBmYWlsZWQ6XCIsIHB5dGhvbkVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVGhpcmQgcHJpb3JpdHk6IFRyeSBpbnRlcnByZXRlciBpbnRlcnJ1cHQgaWYgYXZhaWxhYmxlXG4gICAgICBpZiAodGhpcy5faW50ZXJwcmV0ZXIgJiYgdHlwZW9mIHRoaXMuX2ludGVycHJldGVyLmludGVycnVwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIFVzaW5nIGludGVycHJldGVyIGludGVycnVwdCBtZXRob2RcIik7XG4gICAgICAgIHRoaXMuX2ludGVycHJldGVyLmludGVycnVwdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTGFzdCByZXNvcnQ6IFNlbmQgaW50ZXJydXB0IG1lc3NhZ2VzIGZvciBVSSBmZWVkYmFja1xuICAgICAgY29uc29sZS5sb2coXCJbS0VSTkVMXSBTZW5kaW5nIGludGVycnVwdCBtZXNzYWdlcyBmb3IgVUkgZmVlZGJhY2tcIik7XG4gICAgICBcbiAgICAgIC8vIFNlbmQgc3RkZXJyIHN0cmVhbSBmaXJzdCAoZm9yIEp1cHl0ZXIgbm90ZWJvb2sgVUkgY29tcGF0aWJpbGl0eSlcbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ3N0cmVhbScsXG4gICAgICAgIGJ1bmRsZToge1xuICAgICAgICAgIG5hbWU6ICdzdGRlcnInLFxuICAgICAgICAgIHRleHQ6ICdLZXlib2FyZEludGVycnVwdDogRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXJcXG4nXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdleGVjdXRlX2Vycm9yJyxcbiAgICAgICAgYnVuZGxlOiB7XG4gICAgICAgICAgZW5hbWU6ICdLZXlib2FyZEludGVycnVwdCcsXG4gICAgICAgICAgZXZhbHVlOiAnRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXInLFxuICAgICAgICAgIHRyYWNlYmFjazogWydLZXlib2FyZEludGVycnVwdDogRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXInXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gUmV0dXJuIGZhbHNlIHNpbmNlIHdlIGNvdWxkbid0IGFjdHVhbGx5IGludGVycnVwdCB0aGUgZXhlY3V0aW9uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbS0VSTkVMXSBFcnJvciBkdXJpbmcgaW50ZXJydXB0OlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldEludGVycnVwdEJ1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICB0aGlzLl9pbnRlcnJ1cHRCdWZmZXIgPSBidWZmZXI7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMucHlvZGlkZSAmJiB0eXBlb2YgdGhpcy5weW9kaWRlLnNldEludGVycnVwdEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnB5b2RpZGUuc2V0SW50ZXJydXB0QnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2ludGVycnVwdFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbS0VSTkVMXSBweW9kaWRlLnNldEludGVycnVwdEJ1ZmZlciBub3QgYXZhaWxhYmxlLCBpbnRlcnJ1cHQgc3VwcG9ydCBsaW1pdGVkXCIpO1xuICAgICAgICB0aGlzLl9pbnRlcnJ1cHRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltLRVJORUxdIEVycm9yIHNldHRpbmcgaW50ZXJydXB0IGJ1ZmZlcjpcIiwgZXJyb3IpO1xuICAgICAgdGhpcy5faW50ZXJydXB0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBhbmQgcmVxdWVzdCBwZXJtaXNzaW9uIGZvciBhIGZpbGUgc3lzdGVtIGhhbmRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB2ZXJpZnlQZXJtaXNzaW9uKFxuICAgIGZpbGVIYW5kbGU6IEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUsXG4gICAgcGVybWlzc2lvbjogJ3JlYWQnIHwgJ3JlYWR3cml0ZSdcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3Qgb3B0czogYW55ID0ge307XG4gICAgaWYgKHBlcm1pc3Npb24gPT09ICdyZWFkd3JpdGUnKSB7XG4gICAgICBvcHRzLm1vZGUgPSAncmVhZHdyaXRlJztcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gVmVyaWZ5aW5nICR7cGVybWlzc2lvbn0gcGVybWlzc2lvbiBmb3IgZmlsZSBoYW5kbGUuLi5gKTtcblxuICAgIC8vIENoZWNrIGlmIHBlcm1pc3Npb24gQVBJcyBhcmUgc3VwcG9ydGVkXG4gICAgaWYgKHR5cGVvZiAoZmlsZUhhbmRsZSBhcyBhbnkpLnF1ZXJ5UGVybWlzc2lvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS53YXJuKCdbS0VSTkVMXSBxdWVyeVBlcm1pc3Npb24gbm90IHN1cHBvcnRlZCwgYXNzdW1pbmcgcGVybWlzc2lvbiBncmFudGVkJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIHBlcm1pc3Npb24sIGlmIHNvLCByZXR1cm4gdHJ1ZS5cbiAgICAgIGNvbnN0IHF1ZXJ5UmVzdWx0ID0gYXdhaXQgKGZpbGVIYW5kbGUgYXMgYW55KS5xdWVyeVBlcm1pc3Npb24ob3B0cyk7XG4gICAgICBjb25zb2xlLmxvZygnW0tFUk5FTF0gUXVlcnkgcmVzdWx0OicsIHF1ZXJ5UmVzdWx0KTtcbiAgICAgIFxuICAgICAgaWYgKHF1ZXJ5UmVzdWx0ID09PSAnZ3JhbnRlZCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBlcm1pc3Npb24gYWxyZWFkeSBncmFudGVkIGZvciAke3Blcm1pc3Npb259IGFjY2Vzc2ApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVxdWVzdCBwZXJtaXNzaW9uIHRvIHRoZSBmaWxlLCBpZiB0aGUgdXNlciBncmFudHMgcGVybWlzc2lvbiwgcmV0dXJuIHRydWUuXG4gICAgICBpZiAodHlwZW9mIChmaWxlSGFuZGxlIGFzIGFueSkucmVxdWVzdFBlcm1pc3Npb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFJlcXVlc3RpbmcgJHtwZXJtaXNzaW9ufSBwZXJtaXNzaW9uIGZyb20gdXNlci4uLmApO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0UmVzdWx0ID0gYXdhaXQgKGZpbGVIYW5kbGUgYXMgYW55KS5yZXF1ZXN0UGVybWlzc2lvbihvcHRzKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW0tFUk5FTF0gUmVxdWVzdCByZXN1bHQ6JywgcmVxdWVzdFJlc3VsdCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHJlcXVlc3RSZXN1bHQgPT09ICdncmFudGVkJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBlcm1pc3Npb24gZ3JhbnRlZCBmb3IgJHtwZXJtaXNzaW9ufSBhY2Nlc3NgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAocmVxdWVzdEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tLRVJORUxdIFBlcm1pc3Npb24gcmVxdWVzdCBmYWlsZWQgb3Igd2FzIGRpc21pc3NlZDonLCByZXF1ZXN0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSB1c2VyIGRpZCBub3QgZ3JhbnQgcGVybWlzc2lvbiwgcmV0dXJuIGZhbHNlLlxuICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdICR7cGVybWlzc2lvbn0gcGVybWlzc2lvbiBub3QgZ3JhbnRlZGApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tLRVJORUxdIEVycm9yIGNoZWNraW5nIHBlcm1pc3Npb246JywgZXJyb3IpO1xuICAgICAgLy8gSWYgcGVybWlzc2lvbiBjaGVjayBmYWlscywgYXNzdW1lIGl0J3MgZ3JhbnRlZCAobW9yZSBwZXJtaXNzaXZlIGFwcHJvYWNoKVxuICAgICAgY29uc29sZS53YXJuKCdbS0VSTkVMXSBQZXJtaXNzaW9uIGNoZWNrIGZhaWxlZCwgYXNzdW1pbmcgZ3JhbnRlZCBhcyBmYWxsYmFjaycpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdW50IGEgbmF0aXZlIGZpbGUgc3lzdGVtIGRpcmVjdG9yeSBpbnRvIHRoZSBQeW9kaWRlIGZpbGVzeXN0ZW1cbiAgICogQHBhcmFtIG1vdW50UGF0aCBUaGUgcGF0aCB3aGVyZSB0aGUgZGlyZWN0b3J5IHNob3VsZCBiZSBtb3VudGVkIGluIHRoZSBQeXRob24gZmlsZXN5c3RlbVxuICAgKiBAcGFyYW0gZGlySGFuZGxlIE9wdGlvbmFsIEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUuIElmIG51bGwvdW5kZWZpbmVkLCBzaG93cyBkaXJlY3RvcnkgcGlja2VyXG4gICAqIEBwYXJhbSBwZXJtaXNzaW9uIFBlcm1pc3Npb24gbW9kZTpcbiAgICogICAtICdyZWFkJzogUmVhZC1vbmx5IGFjY2Vzcywgbm8gc3luY2luZyBjYXBhYmlsaXRpZXMsIGF1dG8tc3luYyB3aWxsIGJlIHNraXBwZWQgKGRlZmF1bHQpXG4gICAqICAgLSAncmVhZHdyaXRlJzogRnVsbCByZWFkL3dyaXRlIGFjY2VzcyB3aXRoIHN5bmNpbmcgY2FwYWJpbGl0aWVzXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgaGFuZGxlIHdpdGggc3luY2ZzKCkgbWV0aG9kIGZvciBzeW5jaW5nIGNoYW5nZXNcbiAgICogQG5vdGUgc3luY2ZzKCkgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBjYWxsZWQgb24gYSByZWFkLW9ubHkgbW91bnRlZCBmaWxlc3lzdGVtXG4gICAqIEBub3RlIE1hbnkgYnJvd3NlcnMgb25seSBvZmZlciByZWFkIHBlcm1pc3Npb24gaW5pdGlhbGx5LiBFeHBsaWNpdGx5IHJlcXVlc3QgJ3JlYWR3cml0ZScgaWYgeW91IG5lZWQgd3JpdGUgYWNjZXNzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIG1vdW50RlMoXG4gICAgbW91bnRQYXRoOiBzdHJpbmcsXG4gICAgZGlySGFuZGxlPzogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSB8IG51bGwsXG4gICAgcGVybWlzc2lvbjogJ3JlYWQnIHwgJ3JlYWR3cml0ZScgPSAncmVhZCdcbiAgKTogUHJvbWlzZTx7IHN5bmNmczogKCkgPT4gUHJvbWlzZTx2b2lkPiB9PiB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkIHx8ICF0aGlzLnB5b2RpZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktlcm5lbCBtdXN0IGJlIGluaXRpYWxpemVkIGJlZm9yZSBtb3VudGluZyBmaWxlc3lzdGVtXCIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIG1vdW50TmF0aXZlRlMgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB0aGlzLnB5b2RpZGUubW91bnROYXRpdmVGUyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHlvZGlkZS5tb3VudE5hdGl2ZUZTIGlzIG5vdCBhdmFpbGFibGUuIE1ha2Ugc3VyZSB5b3UncmUgdXNpbmcgUHlvZGlkZSAwLjIzLjAgb3IgbGF0ZXIuXCIpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGUgPSBkaXJIYW5kbGU7XG5cbiAgICAvLyBJZiBubyBkaXJIYW5kbGUgcHJvdmlkZWQsIHNob3cgZGlyZWN0b3J5IHBpY2tlclxuICAgIGlmICghaGFuZGxlKSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBpbiBhIHdvcmtlciBjb250ZXh0XG4gICAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNob3cgZGlyZWN0b3J5IHBpY2tlciBpbiB3b3JrZXIgY29udGV4dC4gUGxlYXNlIHByb3ZpZGUgYSBkaXJIYW5kbGUgcGFyYW1ldGVyLlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgc2hvd0RpcmVjdG9yeVBpY2tlciBpcyBhdmFpbGFibGVcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnc2hvd0RpcmVjdG9yeVBpY2tlcicgaW4gd2luZG93KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGFuZGxlID0gYXdhaXQgKHdpbmRvdyBhcyBhbnkpLnNob3dEaXJlY3RvcnlQaWNrZXIoe1xuICAgICAgICAgICAgbW9kZTogJ3JlYWR3cml0ZScsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2hvdyBkaXJlY3RvcnkgcGlja2VyOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hvd0RpcmVjdG9yeVBpY2tlciBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gUGxlYXNlIHByb3ZpZGUgYSBkaXJIYW5kbGUgcGFyYW1ldGVyLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZGlyZWN0b3J5IGhhbmRsZSBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IGFuZCByZXF1ZXN0IHBlcm1pc3Npb25zIGJlZm9yZSBtb3VudGluZ1xuICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBWZXJpZnlpbmcgJHtwZXJtaXNzaW9ufSBwZXJtaXNzaW9ucyBiZWZvcmUgbW91bnRpbmcuLi5gKTtcbiAgICBjb25zdCBoYXNSZXF1ZXN0ZWRQZXJtaXNzaW9uID0gYXdhaXQgdGhpcy52ZXJpZnlQZXJtaXNzaW9uKGhhbmRsZSwgcGVybWlzc2lvbik7XG4gICAgXG4gICAgaWYgKCFoYXNSZXF1ZXN0ZWRQZXJtaXNzaW9uKSB7XG4gICAgICBpZiAocGVybWlzc2lvbiA9PT0gJ3JlYWR3cml0ZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gb2J0YWluIHdyaXRlIHBlcm1pc3Npb24gZm9yIGRpcmVjdG9yeS4gYCArXG4gICAgICAgICAgYFRoZSBicm93c2VyIG1heSBvbmx5IGJlIG9mZmVyaW5nIHJlYWQgcGVybWlzc2lvbi4gYCArXG4gICAgICAgICAgYFRyeSBtb3VudGluZyB3aXRoIHBlcm1pc3Npb246ICdyZWFkJyBpZiB5b3Ugb25seSBuZWVkIHRvIHJlYWQgZmlsZXMsIGAgK1xuICAgICAgICAgIGBvciBlbnN1cmUgdGhlIGJyb3dzZXIgc3VwcG9ydHMgd3JpdGUgYWNjZXNzIHRvIHRoaXMgZGlyZWN0b3J5LmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIG9idGFpbiAke3Blcm1pc3Npb259IHBlcm1pc3Npb24gZm9yIGRpcmVjdG9yeS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgYWN0dWFsUGVybWlzc2lvbiA9IHBlcm1pc3Npb247XG5cbiAgICAvLyBNb3VudCB0aGUgbmF0aXZlIGZpbGVzeXN0ZW1cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIE1vdW50aW5nIG5hdGl2ZSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofSB3aXRoICR7YWN0dWFsUGVybWlzc2lvbn0gcGVybWlzc2lvbmApO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGUgbW91bnQgcG9pbnQgYWxyZWFkeSBleGlzdHMgYW5kIGhhbmRsZSBjbGVhbnVwXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXRoSW5mbyA9IHRoaXMucHlvZGlkZS5GUy5hbmFseXplUGF0aChtb3VudFBhdGgpO1xuICAgICAgICBpZiAocGF0aEluZm8uZXhpc3RzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBhdGggJHttb3VudFBhdGh9IGV4aXN0cywgY2hlY2tpbmcgaWYgaXQncyBhIG1vdW50IHBvaW50YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIHVubW91bnQgaWYgaXQncyBhbHJlYWR5IG1vdW50ZWRcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5weW9kaWRlLkZTLnVubW91bnQobW91bnRQYXRoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTdWNjZXNzZnVsbHkgdW5tb3VudGVkIGV4aXN0aW5nIGZpbGVzeXN0ZW0gYXQgJHttb3VudFBhdGh9YCk7XG4gICAgICAgICAgfSBjYXRjaCAodW5tb3VudEVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiB1bm1vdW50IGZhaWxzLCBpdCBtaWdodCBub3QgYmUgYSBtb3VudCBwb2ludCBvciBtaWdodCBiZSBidXN5XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gVW5tb3VudCBmYWlsZWQgKHRoaXMgaXMgbm9ybWFsIGlmIG5vdCBtb3VudGVkKTogJHt1bm1vdW50RXJyb3J9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZGlyZWN0b3J5IGlmIGl0IGV4aXN0cyBidXQgaXMgZW1wdHlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5weW9kaWRlLkZTLnJtZGlyKG1vdW50UGF0aCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gUmVtb3ZlZCBleGlzdGluZyBkaXJlY3RvcnkgYXQgJHttb3VudFBhdGh9YCk7XG4gICAgICAgICAgfSBjYXRjaCAocm1kaXJFcnJvcikge1xuICAgICAgICAgICAgLy8gRGlyZWN0b3J5IG1pZ2h0IG5vdCBiZSBlbXB0eSBvciBtaWdodCBub3QgZXhpc3QsIHRoYXQncyBva2F5XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gQ291bGQgbm90IHJlbW92ZSBkaXJlY3RvcnkgKHRoaXMgaXMgbm9ybWFsKTogJHtybWRpckVycm9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoYW5hbHl6ZUVycm9yKSB7XG4gICAgICAgIC8vIGFuYWx5emVQYXRoIG1pZ2h0IGZhaWwsIHRoYXQncyBva2F5IC0gdGhlIHBhdGggcHJvYmFibHkgZG9lc24ndCBleGlzdFxuICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gUGF0aCBhbmFseXNpcyBmYWlsZWQgKHBhdGggcHJvYmFibHkgZG9lc24ndCBleGlzdCk6ICR7YW5hbHl6ZUVycm9yfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFbnN1cmUgdGhlIHBhcmVudCBkaXJlY3RvcnkgZXhpc3RzXG4gICAgICBjb25zdCBwYXJlbnRQYXRoID0gbW91bnRQYXRoLnN1YnN0cmluZygwLCBtb3VudFBhdGgubGFzdEluZGV4T2YoJy8nKSkgfHwgJy8nO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHBhcmVudFBhdGggIT09ICcvJyAmJiAhdGhpcy5weW9kaWRlLkZTLmFuYWx5emVQYXRoKHBhcmVudFBhdGgpLmV4aXN0cykge1xuICAgICAgICAgIHRoaXMucHlvZGlkZS5GUy5ta2RpcihwYXJlbnRQYXRoKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gQ3JlYXRlZCBwYXJlbnQgZGlyZWN0b3J5ICR7cGFyZW50UGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAocGFyZW50RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBhcmVudCBkaXJlY3RvcnkgaGFuZGxpbmc6ICR7cGFyZW50RXJyb3J9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IG5hdGl2ZWZzID0gYXdhaXQgdGhpcy5weW9kaWRlLm1vdW50TmF0aXZlRlMobW91bnRQYXRoLCBoYW5kbGUpO1xuXG4gICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gU3VjY2Vzc2Z1bGx5IG1vdW50ZWQgbmF0aXZlIGZpbGVzeXN0ZW0gYXQgJHttb3VudFBhdGh9IHdpdGggJHthY3R1YWxQZXJtaXNzaW9ufSBwZXJtaXNzaW9uYCk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIGhhbmRsZSB3aXRoIHN5bmNmcyBtZXRob2QgYW5kIHBlcm1pc3Npb24gcmVjb3ZlcnlcbiAgICAgIGNvbnN0IGZzSGFuZGxlID0ge1xuICAgICAgICBzeW5jZnM6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBmaWxlc3lzdGVtIGlzIHJlYWQtb25seVxuICAgICAgICAgIGlmIChhY3R1YWxQZXJtaXNzaW9uID09PSAncmVhZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHN5bmMgcmVhZC1vbmx5IGZpbGVzeXN0ZW0gYXQgJHttb3VudFBhdGh9LiBVc2UgdXBncmFkZUZpbGVzeXN0ZW1QZXJtaXNzaW9uKCkgdG8gcmVxdWVzdCB3cml0ZSBhY2Nlc3MuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBuYXRpdmVmcy5zeW5jZnMoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTeW5jZWQgY2hhbmdlcyB0byBuYXRpdmUgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH1gKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3luYyBmaWxlc3lzdGVtOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpckhhbmRsZTogaGFuZGxlLFxuICAgICAgICBwZXJtaXNzaW9uOiBhY3R1YWxQZXJtaXNzaW9uLFxuICAgICAgICBuYXRpdmVmczogbmF0aXZlZnNcbiAgICAgIH07XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBoYW5kbGUgZm9yIGF1dG8tc3luY1xuICAgICAgdGhpcy5uYXRpdmVGc0hhbmRsZXMuc2V0KG1vdW50UGF0aCwgZnNIYW5kbGUpO1xuXG4gICAgICByZXR1cm4geyBzeW5jZnM6IGZzSGFuZGxlLnN5bmNmcyB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBtb3VudCBuYXRpdmUgZmlsZXN5c3RlbTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmMgYWxsIG1vdW50ZWQgbmF0aXZlIGZpbGVzeXN0ZW1zIHdpdGggcGVybWlzc2lvbiByZWNvdmVyeVxuICAgKiBPbmx5IHN5bmNzIGZpbGVzeXN0ZW1zIG1vdW50ZWQgd2l0aCAncmVhZHdyaXRlJyBwZXJtaXNzaW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHN5bmNBbGxOYXRpdmVGcygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5uYXRpdmVGc0hhbmRsZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN5bmNSZXN1bHRzOiBBcnJheTx7IG1vdW50UGF0aDogc3RyaW5nOyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZzsgc2tpcHBlZD86IGJvb2xlYW4gfT4gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW21vdW50UGF0aCwgZnNIYW5kbGVdIG9mIHRoaXMubmF0aXZlRnNIYW5kbGVzLmVudHJpZXMoKSkge1xuICAgICAgLy8gU2tpcCByZWFkLW9ubHkgZmlsZXN5c3RlbXNcbiAgICAgIGlmIChmc0hhbmRsZS5wZXJtaXNzaW9uID09PSAncmVhZCcpIHtcbiAgICAgICAgc3luY1Jlc3VsdHMucHVzaCh7IG1vdW50UGF0aCwgc3VjY2VzczogdHJ1ZSwgc2tpcHBlZDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFNraXBwaW5nIHN5bmMgZm9yIHJlYWQtb25seSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyc3QsIHRyeSB0byBzeW5jIGRpcmVjdGx5XG4gICAgICAgIGF3YWl0IGZzSGFuZGxlLnN5bmNmcygpO1xuICAgICAgICBzeW5jUmVzdWx0cy5wdXNoKHsgbW91bnRQYXRoLCBzdWNjZXNzOiB0cnVlIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gU3VjY2Vzc2Z1bGx5IHN5bmNlZCBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgc3luYyBmYWlscywgY2hlY2sgaWYgaXQncyBhIHBlcm1pc3Npb24gZXJyb3JcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnbm90IGFsbG93ZWQgYnkgdGhlIHVzZXIgYWdlbnQnKSB8fCBcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcygnZ2V0RmlsZUhhbmRsZScpIHx8XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ3Blcm1pc3Npb24nKSkge1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUud2FybihgW0tFUk5FTF0gUGVybWlzc2lvbiBlcnJvciBzeW5jaW5nICR7bW91bnRQYXRofSwgYXR0ZW1wdGluZyByZWNvdmVyeS4uLmApO1xuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gcmVjb3ZlciBieSByZS12ZXJpZnlpbmcgcGVybWlzc2lvbnNcbiAgICAgICAgICAgIGNvbnN0IGhhc1Blcm1pc3Npb24gPSBhd2FpdCB0aGlzLnZlcmlmeVBlcm1pc3Npb24oZnNIYW5kbGUuZGlySGFuZGxlLCBmc0hhbmRsZS5wZXJtaXNzaW9uKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGhhc1Blcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJlbW91bnQgYW5kIHN5bmNcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBlcm1pc3Npb24gcmVjb3ZlcmVkIGZvciAke21vdW50UGF0aH0sIGF0dGVtcHRpbmcgcmVtb3VudC4uLmApO1xuICAgICAgICAgICAgICBjb25zdCBuZXdOYXRpdmVmcyA9IGF3YWl0IHRoaXMucHlvZGlkZS5tb3VudE5hdGl2ZUZTKG1vdW50UGF0aCwgZnNIYW5kbGUuZGlySGFuZGxlKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RvcmVkIGhhbmRsZSB3aXRoIHRoZSBuZXcgbmF0aXZlZnNcbiAgICAgICAgICAgICAgZnNIYW5kbGUubmF0aXZlZnMgPSBuZXdOYXRpdmVmcztcbiAgICAgICAgICAgICAgZnNIYW5kbGUuc3luY2ZzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCBuZXdOYXRpdmVmcy5zeW5jZnMoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTeW5jZWQgY2hhbmdlcyB0byBuYXRpdmUgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH1gKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChzeW5jRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHN5bmMgZmlsZXN5c3RlbTogJHtzeW5jRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHN5bmNFcnJvci5tZXNzYWdlIDogU3RyaW5nKHN5bmNFcnJvcil9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gVHJ5IHN5bmMgYWdhaW4gd2l0aCB0aGUgbmV3IGhhbmRsZVxuICAgICAgICAgICAgICBhd2FpdCBmc0hhbmRsZS5zeW5jZnMoKTtcbiAgICAgICAgICAgICAgc3luY1Jlc3VsdHMucHVzaCh7IG1vdW50UGF0aCwgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFN1Y2Nlc3NmdWxseSByZWNvdmVyZWQgYW5kIHN5bmNlZCBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3luY1Jlc3VsdHMucHVzaCh7IFxuICAgICAgICAgICAgICAgIG1vdW50UGF0aCwgXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgICAgICAgIGVycm9yOiAnUGVybWlzc2lvbiBkZW5pZWQgYnkgdXNlcicgXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtLRVJORUxdIFVzZXIgZGVuaWVkIHBlcm1pc3Npb24gZm9yICR7bW91bnRQYXRofSwgc2tpcHBpbmcgc3luY2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHJlY292ZXJ5RXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY292ZXJ5TWVzc2FnZSA9IHJlY292ZXJ5RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHJlY292ZXJ5RXJyb3IubWVzc2FnZSA6IFN0cmluZyhyZWNvdmVyeUVycm9yKTtcbiAgICAgICAgICAgIHN5bmNSZXN1bHRzLnB1c2goeyBcbiAgICAgICAgICAgICAgbW91bnRQYXRoLCBcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgICAgICBlcnJvcjogYFJlY292ZXJ5IGZhaWxlZDogJHtyZWNvdmVyeU1lc3NhZ2V9YCBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW0tFUk5FTF0gRmFpbGVkIHRvIHJlY292ZXIgcGVybWlzc2lvbnMgZm9yICR7bW91bnRQYXRofTpgLCByZWNvdmVyeUVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9uLXBlcm1pc3Npb24gZXJyb3JcbiAgICAgICAgICBzeW5jUmVzdWx0cy5wdXNoKHsgXG4gICAgICAgICAgICBtb3VudFBhdGgsIFxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbS0VSTkVMXSBOb24tcGVybWlzc2lvbiBlcnJvciBzeW5jaW5nICR7bW91bnRQYXRofTpgLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMb2cgc3VtbWFyeVxuICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSBzeW5jUmVzdWx0cy5maWx0ZXIociA9PiByLnN1Y2Nlc3MgJiYgIXIuc2tpcHBlZCkubGVuZ3RoO1xuICAgIGNvbnN0IHNraXBwZWQgPSBzeW5jUmVzdWx0cy5maWx0ZXIociA9PiByLnNraXBwZWQpLmxlbmd0aDtcbiAgICBjb25zdCBmYWlsZWQgPSBzeW5jUmVzdWx0cy5maWx0ZXIociA9PiAhci5zdWNjZXNzKTtcbiAgICBcbiAgICBpZiAoc3VjY2Vzc2Z1bCA+IDAgfHwgc2tpcHBlZCA+IDApIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICBpZiAoc3VjY2Vzc2Z1bCA+IDApIHBhcnRzLnB1c2goYCR7c3VjY2Vzc2Z1bH0gc3luY2VkYCk7XG4gICAgICBpZiAoc2tpcHBlZCA+IDApIHBhcnRzLnB1c2goYCR7c2tpcHBlZH0gcmVhZC1vbmx5IHNraXBwZWRgKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBBdXRvLXN5bmMgY29tcGxldGVkOiAke3BhcnRzLmpvaW4oJywgJyl9ICgke3N5bmNSZXN1bHRzLmxlbmd0aH0gdG90YWwgZmlsZXN5c3RlbXMpYCk7XG4gICAgfVxuICAgIFxuICAgIGlmIChmYWlsZWQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS53YXJuKGBbS0VSTkVMXSBBdXRvLXN5bmMgaXNzdWVzOmAsIGZhaWxlZC5tYXAoZiA9PiBgJHtmLm1vdW50UGF0aH06ICR7Zi5lcnJvcn1gKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIERvbid0IHRocm93IC0gd2UgZG9uJ3Qgd2FudCB0byBmYWlsIGV4ZWN1dGlvbiBqdXN0IGJlY2F1c2Ugc3luYyBmYWlsZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgbW91bnRlZCBuYXRpdmUgZmlsZXN5c3RlbXMgYW5kIHRoZWlyIHBlcm1pc3Npb24gc3RhdHVzXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIG1vdW50ZWQgZmlsZXN5c3RlbSBpbmZvcm1hdGlvblxuICAgKi9cbiAgcHVibGljIGdldE1vdW50ZWRGaWxlc3lzdGVtcygpOiBBcnJheTx7XG4gICAgbW91bnRQYXRoOiBzdHJpbmc7XG4gICAgcGVybWlzc2lvbjogJ3JlYWQnIHwgJ3JlYWR3cml0ZSc7XG4gICAgY2FuU3luYzogYm9vbGVhbjtcbiAgfT4ge1xuICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8e1xuICAgICAgbW91bnRQYXRoOiBzdHJpbmc7XG4gICAgICBwZXJtaXNzaW9uOiAncmVhZCcgfCAncmVhZHdyaXRlJztcbiAgICAgIGNhblN5bmM6IGJvb2xlYW47XG4gICAgfT4gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW21vdW50UGF0aCwgZnNIYW5kbGVdIG9mIHRoaXMubmF0aXZlRnNIYW5kbGVzLmVudHJpZXMoKSkge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBtb3VudFBhdGgsXG4gICAgICAgIHBlcm1pc3Npb246IGZzSGFuZGxlLnBlcm1pc3Npb24sXG4gICAgICAgIGNhblN5bmM6IGZzSGFuZGxlLnBlcm1pc3Npb24gPT09ICdyZWFkd3JpdGUnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1hbnVhbGx5IHN5bmMgYSBzcGVjaWZpYyBtb3VudGVkIGZpbGVzeXN0ZW1cbiAgICogQHBhcmFtIG1vdW50UGF0aCBUaGUgcGF0aCBvZiB0aGUgbW91bnRlZCBmaWxlc3lzdGVtIHRvIHN5bmNcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gc3VjY2VzcyBzdGF0dXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBzeW5jRmlsZXN5c3RlbShtb3VudFBhdGg6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgY29uc3QgZnNIYW5kbGUgPSB0aGlzLm5hdGl2ZUZzSGFuZGxlcy5nZXQobW91bnRQYXRoKTtcbiAgICBcbiAgICBpZiAoIWZzSGFuZGxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBObyBmaWxlc3lzdGVtIG1vdW50ZWQgYXQgJHttb3VudFBhdGh9YFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBmaWxlc3lzdGVtIGlzIHJlYWQtb25seVxuICAgIGlmIChmc0hhbmRsZS5wZXJtaXNzaW9uID09PSAncmVhZCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogYENhbm5vdCBzeW5jIHJlYWQtb25seSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofS4gTW91bnQgd2l0aCAncmVhZHdyaXRlJyBwZXJtaXNzaW9uIHRvIGVuYWJsZSBzeW5jaW5nLmBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzSGFuZGxlLnN5bmNmcygpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICBcbiAgICAgIC8vIFRyeSBwZXJtaXNzaW9uIHJlY292ZXJ5IGlmIGl0J3MgYSBwZXJtaXNzaW9uIGVycm9yXG4gICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdub3QgYWxsb3dlZCBieSB0aGUgdXNlciBhZ2VudCcpIHx8IFxuICAgICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcygnZ2V0RmlsZUhhbmRsZScpIHx8XG4gICAgICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdwZXJtaXNzaW9uJykpIHtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBQZXJtaXNzaW9uIGVycm9yIHN5bmNpbmcgJHttb3VudFBhdGh9LCBhdHRlbXB0aW5nIHJlY292ZXJ5Li4uYCk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGhhc1Blcm1pc3Npb24gPSBhd2FpdCB0aGlzLnZlcmlmeVBlcm1pc3Npb24oZnNIYW5kbGUuZGlySGFuZGxlLCBmc0hhbmRsZS5wZXJtaXNzaW9uKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaGFzUGVybWlzc2lvbikge1xuICAgICAgICAgICAgLy8gUmVtb3VudCBhbmQgdHJ5IGFnYWluXG4gICAgICAgICAgICBjb25zdCBuZXdOYXRpdmVmcyA9IGF3YWl0IHRoaXMucHlvZGlkZS5tb3VudE5hdGl2ZUZTKG1vdW50UGF0aCwgZnNIYW5kbGUuZGlySGFuZGxlKTtcbiAgICAgICAgICAgIGZzSGFuZGxlLm5hdGl2ZWZzID0gbmV3TmF0aXZlZnM7XG4gICAgICAgICAgICBmc0hhbmRsZS5zeW5jZnMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3TmF0aXZlZnMuc3luY2ZzKCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFN5bmNlZCBjaGFuZ2VzIHRvIG5hdGl2ZSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChzeW5jRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzeW5jIGZpbGVzeXN0ZW06ICR7c3luY0Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBzeW5jRXJyb3IubWVzc2FnZSA6IFN0cmluZyhzeW5jRXJyb3IpfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhd2FpdCBmc0hhbmRsZS5zeW5jZnMoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiAnUGVybWlzc2lvbiBkZW5pZWQgYnkgdXNlcidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChyZWNvdmVyeUVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGBSZWNvdmVyeSBmYWlsZWQ6ICR7cmVjb3ZlcnlFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gcmVjb3ZlcnlFcnJvci5tZXNzYWdlIDogU3RyaW5nKHJlY292ZXJ5RXJyb3IpfWBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIGEgbW91bnRlZCBmaWxlc3lzdGVtIGZyb20gcmVhZC1vbmx5IHRvIHJlYWQtd3JpdGUgcGVybWlzc2lvblxuICAgKiBAcGFyYW0gbW91bnRQYXRoIFRoZSBwYXRoIG9mIHRoZSBtb3VudGVkIGZpbGVzeXN0ZW0gdG8gdXBncmFkZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBzdWNjZXNzIHN0YXR1c1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHVwZ3JhZGVGaWxlc3lzdGVtUGVybWlzc2lvbihtb3VudFBhdGg6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgY29uc3QgZnNIYW5kbGUgPSB0aGlzLm5hdGl2ZUZzSGFuZGxlcy5nZXQobW91bnRQYXRoKTtcbiAgICBcbiAgICBpZiAoIWZzSGFuZGxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBObyBmaWxlc3lzdGVtIG1vdW50ZWQgYXQgJHttb3VudFBhdGh9YFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoZnNIYW5kbGUucGVybWlzc2lvbiA9PT0gJ3JlYWR3cml0ZScpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGVycm9yOiBgRmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH0gYWxyZWFkeSBoYXMgcmVhZHdyaXRlIHBlcm1pc3Npb25gXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gQXR0ZW1wdGluZyB0byB1cGdyYWRlICR7bW91bnRQYXRofSB0byByZWFkd3JpdGUgcGVybWlzc2lvbi4uLmApO1xuICAgICAgXG4gICAgICAvLyBUcnkgdG8gZ2V0IHJlYWR3cml0ZSBwZXJtaXNzaW9uXG4gICAgICBjb25zdCBoYXNXcml0ZVBlcm1pc3Npb24gPSBhd2FpdCB0aGlzLnZlcmlmeVBlcm1pc3Npb24oZnNIYW5kbGUuZGlySGFuZGxlLCAncmVhZHdyaXRlJyk7XG4gICAgICBcbiAgICAgIGlmICghaGFzV3JpdGVQZXJtaXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6ICdVc2VyIGRlbmllZCB3cml0ZSBwZXJtaXNzaW9uIG9yIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB3cml0ZSBhY2Nlc3MgdG8gdGhpcyBkaXJlY3RvcnknXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW91bnQgd2l0aCB3cml0ZSBwZXJtaXNzaW9uXG4gICAgICBjb25zdCBuZXdOYXRpdmVmcyA9IGF3YWl0IHRoaXMucHlvZGlkZS5tb3VudE5hdGl2ZUZTKG1vdW50UGF0aCwgZnNIYW5kbGUuZGlySGFuZGxlKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHRoZSBzdG9yZWQgaGFuZGxlXG4gICAgICBmc0hhbmRsZS5wZXJtaXNzaW9uID0gJ3JlYWR3cml0ZSc7XG4gICAgICBmc0hhbmRsZS5uYXRpdmVmcyA9IG5ld05hdGl2ZWZzO1xuICAgICAgZnNIYW5kbGUuc3luY2ZzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG5ld05hdGl2ZWZzLnN5bmNmcygpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTeW5jZWQgY2hhbmdlcyB0byBuYXRpdmUgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH1gKTtcbiAgICAgICAgfSBjYXRjaCAoc3luY0Vycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3luYyBmaWxlc3lzdGVtOiAke3N5bmNFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gc3luY0Vycm9yLm1lc3NhZ2UgOiBTdHJpbmcoc3luY0Vycm9yKX1gKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFN1Y2Nlc3NmdWxseSB1cGdyYWRlZCAke21vdW50UGF0aH0gdG8gcmVhZHdyaXRlIHBlcm1pc3Npb25gKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gdXBncmFkZSBwZXJtaXNzaW9uOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpdGggcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uXG4gICAqIE9QVElNSVpFRDogUGFyYWxsZWwgdmFyaWFibGUgc2V0dGluZyBhbmQgdmFsaWRhdGlvbiB3aXRoIHByb3BlciBlc2NhcGluZyBhbmQgZWRnZSBjYXNlIGhhbmRsaW5nXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNldEVudmlyb25tZW50VmFyaWFibGVzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmVudmlyb25tZW50VmFyaWFibGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gTm8gdmFyaWFibGVzIHRvIHNldFxuICAgIH1cbiAgICBcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnNvbGUubG9nKGDwn4yNIFNldHRpbmcgJHtPYmplY3Qua2V5cyh0aGlzLmVudmlyb25tZW50VmFyaWFibGVzKS5sZW5ndGh9IGVudmlyb25tZW50IHZhcmlhYmxlcy4uLmApO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBTZXQgZWFjaCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpbmRpdmlkdWFsbHkgdG8gYXZvaWQgZXNjYXBpbmcgaXNzdWVzXG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmVudmlyb25tZW50VmFyaWFibGVzKSkge1xuICAgICAgICAvLyBIYW5kbGUgZWRnZSBjYXNlczogbnVsbCwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGxldCBwcm9jZXNzZWRWYWx1ZTogc3RyaW5nO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBwcm9jZXNzZWRWYWx1ZSA9ICcnOyAgLy8gQ29udmVydCBudWxsIHRvIGVtcHR5IHN0cmluZ1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9jZXNzZWRWYWx1ZSA9ICcnOyAgLy8gQ29udmVydCB1bmRlZmluZWQgdG8gZW1wdHkgc3RyaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzc2VkVmFsdWUgPSBTdHJpbmcodmFsdWUpOyAgLy8gQ29udmVydCBldmVyeXRoaW5nIGVsc2UgdG8gc3RyaW5nXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGF3YWl0IHRoaXMucHlvZGlkZS5ydW5QeXRob25Bc3luYyhgXG5pbXBvcnQgb3Ncbm9zLmVudmlyb25bJHtKU09OLnN0cmluZ2lmeShrZXkpfV0gPSAke0pTT04uc3RyaW5naWZ5KHByb2Nlc3NlZFZhbHVlKX1cbmApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg4pqhIEVudmlyb25tZW50IHZhcmlhYmxlcyBzZXQgaW4gJHtkdXJhdGlvbn1tc2ApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEZhaWxlZCB0byBzZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLy8gT25seSBQeXRob24ga2VybmVsIGlzIHN1cHBvcnRlZFxuXG4vLyBFeHBvcnQgdGhlIG1hbmFnZXIgZm9yIGFkdmFuY2VkIHVzYWdlXG5leHBvcnQgeyBLZXJuZWxNYW5hZ2VyIH0gZnJvbSBcIi4vbWFuYWdlclwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.ts\n\n}");

/***/ }),

/***/ "./src/kernel.worker.ts":
/*!******************************!*\
  !*** ./src/kernel.worker.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

eval("{/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! comlink */ \"./node_modules/comlink/dist/esm/comlink.mjs\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ \"./src/index.ts\");\n// Web Worker file for running the Kernel in a separate thread\n// Import necessary modules\n\n\n\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    }\n    off(eventName, listener) {\n        if (!this.events[eventName])\n            return;\n        const index = this.events[eventName].indexOf(listener);\n        if (index > -1) {\n            this.events[eventName].splice(index, 1);\n        }\n    }\n    emit(eventName, ...args) {\n        if (!this.events[eventName])\n            return;\n        this.events[eventName].forEach(listener => listener(...args));\n    }\n}\n// Create a new kernel instance\nconst kernel = new _index__WEBPACK_IMPORTED_MODULE_2__.Kernel();\n// Variable to store the event port\nlet eventPort = null;\n// Store kernel initialization options\nlet kernelOptions = {};\n// Track current event listeners for cleanup\nlet currentEventListeners = new Map();\n// Interrupt handling for worker\nlet interruptBuffer = null;\n// Helper function to check if an error is a KeyboardInterrupt\nfunction isKeyboardInterrupt(error) {\n    return error &&\n        typeof error === 'object' &&\n        (error.type === \"KeyboardInterrupt\" ||\n            (error.message && error.message.includes(\"KeyboardInterrupt\")));\n}\n// Helper function to create KeyboardInterrupt error result\nfunction createKeyboardInterruptResult() {\n    return {\n        success: false,\n        error: new Error(\"KeyboardInterrupt: Execution interrupted by user\"),\n        result: {\n            payload: [],\n            status: \"error\",\n            ename: \"KeyboardInterrupt\",\n            evalue: \"Execution interrupted by user\",\n            traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n        }\n    };\n}\n// Global error handlers to prevent worker crashes\nself.addEventListener(\"error\", (event) => {\n    console.error(\"[WORKER] Global error caught:\", event.error);\n    event.preventDefault();\n});\nself.addEventListener(\"unhandledrejection\", (event) => {\n    if (isKeyboardInterrupt(event.reason)) {\n        console.log(\"[WORKER] KeyboardInterrupt caught in unhandled rejection handler - this is expected during interrupts\");\n        // Send interrupt acknowledgment if we have an event port\n        if (eventPort) {\n            eventPort.postMessage({\n                type: _types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR,\n                data: {\n                    ename: \"KeyboardInterrupt\",\n                    evalue: \"Execution interrupted by user\",\n                    traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n                }\n            });\n        }\n    }\n    else {\n        console.error(\"[WORKER] Unhandled promise rejection:\", event.reason);\n    }\n    event.preventDefault();\n});\n// Listen for messages to set up the event port and initialize kernel\nself.addEventListener(\"message\", (event) => {\n    if (event.data?.type === \"SET_EVENT_PORT\" && event.data?.port) {\n        // Clean up old event listeners and port before setting up new ones\n        cleanupEventForwarding();\n        // Set the new port\n        eventPort = event.data.port;\n        // If the kernel is already initialized, set up event forwarding immediately\n        if (kernel.isInitialized()) {\n            setupEventForwarding();\n        }\n    }\n    else if (event.data?.type === \"INITIALIZE_KERNEL\") {\n        // Save the options for kernel initialization\n        kernelOptions = event.data.options || {};\n        // Initialize the kernel with the provided options\n        initializeKernel(kernelOptions).catch(error => {\n            console.error(\"[WORKER] Error initializing kernel in worker:\", error);\n            if (eventPort) {\n                eventPort.postMessage({\n                    type: _types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR,\n                    data: {\n                        ename: \"WorkerInitError\",\n                        evalue: `Failed to initialize kernel: ${error.message}`,\n                        traceback: [error.stack || \"\"]\n                    }\n                });\n            }\n        });\n    }\n    else if (event.data?.type === \"SET_INTERRUPT_BUFFER\") {\n        // Handle interrupt buffer setup\n        interruptBuffer = event.data.buffer;\n        // Set the interrupt buffer in the kernel if it's initialized\n        if (kernel.isInitialized() && interruptBuffer && typeof kernel.setInterruptBuffer === 'function') {\n            kernel.setInterruptBuffer(interruptBuffer);\n            console.log(\"[WORKER] Interrupt buffer set in pyodide kernel\");\n        }\n        else if (interruptBuffer) {\n            console.log(\"[WORKER] Interrupt buffer stored, will be set when kernel initializes\");\n        }\n        const responseMessage = {\n            type: \"INTERRUPT_BUFFER_SET\",\n            data: { success: true }\n        };\n        // Send response on both channels to ensure it's received\n        if (eventPort) {\n            eventPort.postMessage(responseMessage);\n        }\n        // Also send on main worker channel in case eventPort isn't set up yet\n        self.postMessage(responseMessage);\n    }\n    else if (event.data?.type === \"INTERRUPT_KERNEL\") {\n        // Handle interrupt request\n        if (interruptBuffer) {\n            // Set interrupt signal (2 = SIGINT)\n            interruptBuffer[0] = 2;\n            const responseMessage = {\n                type: \"INTERRUPT_TRIGGERED\",\n                data: { success: true, method: \"buffer\" }\n            };\n            // Send response on both channels\n            if (eventPort) {\n                eventPort.postMessage(responseMessage);\n            }\n            self.postMessage(responseMessage);\n        }\n        else {\n            console.log(\"[WORKER] No interrupt buffer available, trying kernel.interrupt()\");\n            // Fallback to kernel interrupt method\n            if (typeof kernel.interrupt === 'function') {\n                kernel.interrupt().then(success => {\n                    const responseMessage = {\n                        type: \"INTERRUPT_TRIGGERED\",\n                        data: { success, method: \"kernel\" }\n                    };\n                    if (eventPort) {\n                        eventPort.postMessage(responseMessage);\n                    }\n                    self.postMessage(responseMessage);\n                }).catch(error => {\n                    console.error(\"[WORKER] Error during kernel interrupt:\", error);\n                    const responseMessage = {\n                        type: \"INTERRUPT_TRIGGERED\",\n                        data: { success: false, error: error.message, method: \"kernel\" }\n                    };\n                    if (eventPort) {\n                        eventPort.postMessage(responseMessage);\n                    }\n                    self.postMessage(responseMessage);\n                });\n            }\n            else {\n                console.warn(\"[WORKER] No interrupt method available\");\n                const responseMessage = {\n                    type: \"INTERRUPT_TRIGGERED\",\n                    data: { success: false, error: \"No interrupt method available\", method: \"none\" }\n                };\n                if (eventPort) {\n                    eventPort.postMessage(responseMessage);\n                }\n                self.postMessage(responseMessage);\n            }\n        }\n    }\n});\n// Initialize the kernel with provided options\nasync function initializeKernel(options) {\n    try {\n        await kernel.initialize(options);\n        // Set up the interrupt buffer if it's available and the kernel supports it\n        if (interruptBuffer && typeof kernel.setInterruptBuffer === 'function') {\n            kernel.setInterruptBuffer(interruptBuffer);\n        }\n        // Set up event forwarding AFTER kernel is initialized\n        setupEventForwarding();\n        if (eventPort) {\n            eventPort.postMessage({\n                type: \"KERNEL_INITIALIZED\",\n                data: { success: true }\n            });\n        }\n    }\n    catch (error) {\n        console.error(\"Kernel initialization failed:\", error);\n        throw error;\n    }\n}\n// Clean up old event listeners and port\nfunction cleanupEventForwarding() {\n    if (currentEventListeners.size > 0) {\n        // Remove all current event listeners\n        for (const [eventType, listener] of currentEventListeners.entries()) {\n            kernel.off(eventType, listener);\n        }\n        // Clear the listeners map\n        currentEventListeners.clear();\n    }\n    // Close the old port if it exists\n    if (eventPort) {\n        eventPort.close();\n        eventPort = null;\n    }\n}\n// Set up event forwarding from kernel to main thread\nfunction setupEventForwarding() {\n    if (!eventPort) {\n        console.error(\"[WORKER] Cannot set up event forwarding: no event port available\");\n        return;\n    }\n    // Forward all kernel events to the main thread\n    Object.values(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents).forEach((eventType) => {\n        // Create a listener function for this event type\n        const listener = (data) => {\n            if (eventPort) {\n                // Send just the event type and raw data\n                // This matches the structure used in main thread mode\n                eventPort.postMessage({\n                    type: eventType,\n                    data: data\n                });\n            }\n        };\n        // Store the listener for later cleanup\n        currentEventListeners.set(eventType, listener);\n        // Add the listener to the kernel\n        kernel.on(eventType, listener);\n    });\n}\n// Handle cleanup when worker is terminated\nself.addEventListener(\"beforeunload\", async () => {\n    // Close any resources or connections\n    try {\n        // Send a final message before termination if needed\n        if (eventPort) {\n            eventPort.postMessage({\n                type: \"WORKER_TERMINATING\",\n                data: { message: \"Worker is shutting down\" }\n            });\n        }\n    }\n    catch (error) {\n        console.error(\"Error during worker cleanup:\", error);\n    }\n});\n// Log available methods for debugging\n// Create a simplified proxy that only exposes the methods we need\n// We're not trying to implement the full EventEmitter interface\nconst simpleProxy = {\n    // Required methods from IKernel interface\n    initialize: async (options) => {\n        try {\n            await kernel.initialize(options);\n            return undefined;\n        }\n        catch (error) {\n            console.error(\"[WORKER] Initialize error:\", error);\n            throw error;\n        }\n    },\n    execute: async (code, parent) => {\n        try {\n            const result = await kernel.execute(code, parent);\n            return result;\n        }\n        catch (error) {\n            console.error(\"[WORKER] Execute error:\", error);\n            // Check if this is a KeyboardInterrupt and handle it specially\n            if (isKeyboardInterrupt(error)) {\n                console.log(\"[WORKER] KeyboardInterrupt caught in execute method\");\n                return createKeyboardInterruptResult();\n            }\n            // Handle other errors normally\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error)),\n                result: {\n                    payload: [],\n                    status: \"error\",\n                    ename: error instanceof Error ? error.constructor.name : \"Error\",\n                    evalue: error instanceof Error ? error.message : String(error),\n                    traceback: error instanceof Error && error.stack ? error.stack.split('\\n') : [String(error)]\n                }\n            };\n        }\n    },\n    isInitialized: () => {\n        try {\n            const result = kernel.isInitialized();\n            return result;\n        }\n        catch (error) {\n            console.error(\"[WORKER] IsInitialized error:\", error);\n            return false;\n        }\n    },\n    inputReply: async (content) => {\n        try {\n            await kernel.inputReply(content);\n        }\n        catch (error) {\n            console.error(\"[WORKER] InputReply error:\", error);\n            throw error;\n        }\n    },\n    // Async method for status\n    getStatus: async () => {\n        try {\n            const status = await kernel.getStatus();\n            return status;\n        }\n        catch (error) {\n            console.error(\"[WORKER] getStatus error:\", error);\n            return \"unknown\";\n        }\n    },\n    // Interrupt functionality\n    interrupt: async () => {\n        try {\n            if (typeof kernel.interrupt === 'function') {\n                const result = await kernel.interrupt();\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support interrupt method\");\n                return false;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] Interrupt error:\", error);\n            // Don't let interrupt errors crash the worker\n            return false;\n        }\n    },\n    setInterruptBuffer: (buffer) => {\n        try {\n            if (typeof kernel.setInterruptBuffer === 'function') {\n                kernel.setInterruptBuffer(buffer);\n                return true;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support setInterruptBuffer method\");\n                return false;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] setInterruptBuffer error:\", error);\n            return false;\n        }\n    },\n    // Completion methods\n    complete: async (code, cursor_pos, parent) => {\n        try {\n            if (typeof kernel.complete === 'function') {\n                const result = await kernel.complete(code, cursor_pos, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support complete method\");\n                return { status: 'error', error: 'Completion not supported' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] Complete error:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    },\n    inspect: async (code, cursor_pos, detail_level, parent) => {\n        try {\n            if (typeof kernel.inspect === 'function') {\n                const result = await kernel.inspect(code, cursor_pos, detail_level, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support inspect method\");\n                return { status: 'error', error: 'Inspection not supported' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] Inspect error:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    },\n    isComplete: async (code, parent) => {\n        try {\n            if (typeof kernel.isComplete === 'function') {\n                const result = await kernel.isComplete(code, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support isComplete method\");\n                return { status: 'unknown' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] IsComplete error:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    },\n    // Native filesystem mounting\n    mountFS: async (mountPath, dirHandle, permission) => {\n        try {\n            if (typeof kernel.mountFS === 'function') {\n                // In worker context, dirHandle must be provided - we cannot show directory picker\n                if (!dirHandle) {\n                    throw new Error(\"Cannot show directory picker in worker context. Please provide a dirHandle parameter when calling mountFS on a worker kernel.\");\n                }\n                const result = await kernel.mountFS(mountPath, dirHandle, permission);\n                // Wrap the result with Comlink.proxy so the syncfs function can be called across worker boundary\n                return comlink__WEBPACK_IMPORTED_MODULE_0__.proxy(result);\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support mountFS method\");\n                throw new Error(\"mountFS is not supported by this kernel\");\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] MountFS error:\", error);\n            throw error;\n        }\n    },\n    // Comm methods\n    commInfo: async (target_name, parent) => {\n        try {\n            if (typeof kernel.commInfo === 'function') {\n                const result = await kernel.commInfo(target_name, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support commInfo method\");\n                return { comms: {}, status: 'ok' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] CommInfo error:\", error);\n            return { comms: {}, status: 'error', error: String(error) };\n        }\n    },\n    commOpen: async (content, parent) => {\n        try {\n            if (typeof kernel.commOpen === 'function') {\n                const result = await kernel.commOpen(content, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support commOpen method\");\n                return undefined;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] CommOpen error:\", error);\n            return undefined;\n        }\n    },\n    commMsg: async (content, parent) => {\n        try {\n            if (typeof kernel.commMsg === 'function') {\n                const result = await kernel.commMsg(content, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support commMsg method\");\n                return undefined;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] CommMsg error:\", error);\n            return undefined;\n        }\n    },\n    commClose: async (content, parent) => {\n        try {\n            if (typeof kernel.commClose === 'function') {\n                const result = await kernel.commClose(content, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support commClose method\");\n                return undefined;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] CommClose error:\", error);\n            return undefined;\n        }\n    }\n};\n// Expose the proxy through Comlink\ntry {\n    comlink__WEBPACK_IMPORTED_MODULE_0__.expose(simpleProxy);\n}\ncatch (error) {\n    console.error(\"Error exposing proxy:\", error);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztJQUNILDJDQUFjLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDOUIsQ0FBQztBQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7SUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLHVCQUF1QixFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ2hELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItcHl0aG9uLWtlcm5lbC8uL3NyYy9rZXJuZWwud29ya2VyLnRzPzRlNzEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV2ViIFdvcmtlciBmaWxlIGZvciBydW5uaW5nIHRoZSBLZXJuZWwgaW4gYSBzZXBhcmF0ZSB0aHJlYWRcbi8vIEltcG9ydCBuZWNlc3NhcnkgbW9kdWxlc1xuaW1wb3J0ICogYXMgQ29tbGluayBmcm9tIFwiY29tbGlua1wiO1xuaW1wb3J0IHsgS2VybmVsRXZlbnRzLCBJS2VybmVsT3B0aW9ucyB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBLZXJuZWwgfSBmcm9tIFwiLi9pbmRleFwiO1xuXG4vLyBVc2UgYSBicm93c2VyLWNvbXBhdGlibGUgRXZlbnRFbWl0dGVyXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBwdWJsaWMgZXZlbnRzOiB7IFtrZXk6IHN0cmluZ106IEZ1bmN0aW9uW10gfSA9IHt9O1xuXG4gIG9uKGV2ZW50TmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogRnVuY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIG9mZihldmVudE5hbWU6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSByZXR1cm47XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgZW1pdChldmVudE5hbWU6IHN0cmluZywgLi4uYXJnczogYW55W10pIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHJldHVybjtcbiAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoLi4uYXJncykpO1xuICB9XG59XG5cblxuLy8gQ3JlYXRlIGEgbmV3IGtlcm5lbCBpbnN0YW5jZVxuY29uc3Qga2VybmVsID0gbmV3IEtlcm5lbCgpO1xuXG4vLyBWYXJpYWJsZSB0byBzdG9yZSB0aGUgZXZlbnQgcG9ydFxubGV0IGV2ZW50UG9ydDogTWVzc2FnZVBvcnQgfCBudWxsID0gbnVsbDtcblxuLy8gU3RvcmUga2VybmVsIGluaXRpYWxpemF0aW9uIG9wdGlvbnNcbmxldCBrZXJuZWxPcHRpb25zOiBJS2VybmVsT3B0aW9ucyA9IHt9O1xuXG4vLyBUcmFjayBjdXJyZW50IGV2ZW50IGxpc3RlbmVycyBmb3IgY2xlYW51cFxubGV0IGN1cnJlbnRFdmVudExpc3RlbmVyczogTWFwPHN0cmluZywgKGRhdGE6IGFueSkgPT4gdm9pZD4gPSBuZXcgTWFwKCk7XG5cbi8vIEludGVycnVwdCBoYW5kbGluZyBmb3Igd29ya2VyXG5sZXQgaW50ZXJydXB0QnVmZmVyOiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBhbiBlcnJvciBpcyBhIEtleWJvYXJkSW50ZXJydXB0XG5mdW5jdGlvbiBpc0tleWJvYXJkSW50ZXJydXB0KGVycm9yOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIGVycm9yICYmIFxuICAgICAgICAgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBcbiAgICAgICAgIChlcnJvci50eXBlID09PSBcIktleWJvYXJkSW50ZXJydXB0XCIgfHwgXG4gICAgICAgICAgKGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIktleWJvYXJkSW50ZXJydXB0XCIpKSk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgS2V5Ym9hcmRJbnRlcnJ1cHQgZXJyb3IgcmVzdWx0XG5mdW5jdGlvbiBjcmVhdGVLZXlib2FyZEludGVycnVwdFJlc3VsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICBlcnJvcjogbmV3IEVycm9yKFwiS2V5Ym9hcmRJbnRlcnJ1cHQ6IEV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCIpLFxuICAgIHJlc3VsdDoge1xuICAgICAgcGF5bG9hZDogW10sXG4gICAgICBzdGF0dXM6IFwiZXJyb3JcIixcbiAgICAgIGVuYW1lOiBcIktleWJvYXJkSW50ZXJydXB0XCIsXG4gICAgICBldmFsdWU6IFwiRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXJcIixcbiAgICAgIHRyYWNlYmFjazogW1wiS2V5Ym9hcmRJbnRlcnJ1cHQ6IEV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCJdXG4gICAgfVxuICB9O1xufVxuXG4vLyBHbG9iYWwgZXJyb3IgaGFuZGxlcnMgdG8gcHJldmVudCB3b3JrZXIgY3Jhc2hlc1xuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGV2ZW50KSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBHbG9iYWwgZXJyb3IgY2F1Z2h0OlwiLCBldmVudC5lcnJvcik7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59KTtcblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsIChldmVudCkgPT4ge1xuICBpZiAoaXNLZXlib2FyZEludGVycnVwdChldmVudC5yZWFzb24pKSB7XG4gICAgY29uc29sZS5sb2coXCJbV09SS0VSXSBLZXlib2FyZEludGVycnVwdCBjYXVnaHQgaW4gdW5oYW5kbGVkIHJlamVjdGlvbiBoYW5kbGVyIC0gdGhpcyBpcyBleHBlY3RlZCBkdXJpbmcgaW50ZXJydXB0c1wiKTtcbiAgICBcbiAgICAvLyBTZW5kIGludGVycnVwdCBhY2tub3dsZWRnbWVudCBpZiB3ZSBoYXZlIGFuIGV2ZW50IHBvcnRcbiAgICBpZiAoZXZlbnRQb3J0KSB7XG4gICAgICBldmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGVuYW1lOiBcIktleWJvYXJkSW50ZXJydXB0XCIsXG4gICAgICAgICAgZXZhbHVlOiBcIkV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCIsXG4gICAgICAgICAgdHJhY2ViYWNrOiBbXCJLZXlib2FyZEludGVycnVwdDogRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXJcIl1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb246XCIsIGV2ZW50LnJlYXNvbik7XG4gIH1cbiAgXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59KTtcblxuLy8gTGlzdGVuIGZvciBtZXNzYWdlcyB0byBzZXQgdXAgdGhlIGV2ZW50IHBvcnQgYW5kIGluaXRpYWxpemUga2VybmVsXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJTRVRfRVZFTlRfUE9SVFwiICYmIGV2ZW50LmRhdGE/LnBvcnQpIHtcbiAgICAvLyBDbGVhbiB1cCBvbGQgZXZlbnQgbGlzdGVuZXJzIGFuZCBwb3J0IGJlZm9yZSBzZXR0aW5nIHVwIG5ldyBvbmVzXG4gICAgY2xlYW51cEV2ZW50Rm9yd2FyZGluZygpO1xuICAgIFxuICAgIC8vIFNldCB0aGUgbmV3IHBvcnRcbiAgICBldmVudFBvcnQgPSBldmVudC5kYXRhLnBvcnQ7XG4gICAgXG4gICAgLy8gSWYgdGhlIGtlcm5lbCBpcyBhbHJlYWR5IGluaXRpYWxpemVkLCBzZXQgdXAgZXZlbnQgZm9yd2FyZGluZyBpbW1lZGlhdGVseVxuICAgIGlmIChrZXJuZWwuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICBzZXR1cEV2ZW50Rm9yd2FyZGluZygpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIklOSVRJQUxJWkVfS0VSTkVMXCIpIHtcbiAgICAvLyBTYXZlIHRoZSBvcHRpb25zIGZvciBrZXJuZWwgaW5pdGlhbGl6YXRpb25cbiAgICBrZXJuZWxPcHRpb25zID0gZXZlbnQuZGF0YS5vcHRpb25zIHx8IHt9O1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgdGhlIGtlcm5lbCB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zXG4gICAgaW5pdGlhbGl6ZUtlcm5lbChrZXJuZWxPcHRpb25zKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gRXJyb3IgaW5pdGlhbGl6aW5nIGtlcm5lbCBpbiB3b3JrZXI6XCIsIGVycm9yKTtcbiAgICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgICAgZXZlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICB0eXBlOiBLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUixcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBlbmFtZTogXCJXb3JrZXJJbml0RXJyb3JcIixcbiAgICAgICAgICAgIGV2YWx1ZTogYEZhaWxlZCB0byBpbml0aWFsaXplIGtlcm5lbDogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICAgICB0cmFjZWJhY2s6IFtlcnJvci5zdGFjayB8fCBcIlwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJTRVRfSU5URVJSVVBUX0JVRkZFUlwiKSB7XG4gICAgLy8gSGFuZGxlIGludGVycnVwdCBidWZmZXIgc2V0dXBcbiAgICBpbnRlcnJ1cHRCdWZmZXIgPSBldmVudC5kYXRhLmJ1ZmZlcjtcbiAgICBcbiAgICAvLyBTZXQgdGhlIGludGVycnVwdCBidWZmZXIgaW4gdGhlIGtlcm5lbCBpZiBpdCdzIGluaXRpYWxpemVkXG4gICAgaWYgKGtlcm5lbC5pc0luaXRpYWxpemVkKCkgJiYgaW50ZXJydXB0QnVmZmVyICYmIHR5cGVvZiBrZXJuZWwuc2V0SW50ZXJydXB0QnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBrZXJuZWwuc2V0SW50ZXJydXB0QnVmZmVyKGludGVycnVwdEJ1ZmZlcik7XG4gICAgICBjb25zb2xlLmxvZyhcIltXT1JLRVJdIEludGVycnVwdCBidWZmZXIgc2V0IGluIHB5b2RpZGUga2VybmVsXCIpO1xuICAgIH0gZWxzZSBpZiAoaW50ZXJydXB0QnVmZmVyKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltXT1JLRVJdIEludGVycnVwdCBidWZmZXIgc3RvcmVkLCB3aWxsIGJlIHNldCB3aGVuIGtlcm5lbCBpbml0aWFsaXplc1wiKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgdHlwZTogXCJJTlRFUlJVUFRfQlVGRkVSX1NFVFwiLFxuICAgICAgZGF0YTogeyBzdWNjZXNzOiB0cnVlIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIFNlbmQgcmVzcG9uc2Ugb24gYm90aCBjaGFubmVscyB0byBlbnN1cmUgaXQncyByZWNlaXZlZFxuICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZShyZXNwb25zZU1lc3NhZ2UpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBbHNvIHNlbmQgb24gbWFpbiB3b3JrZXIgY2hhbm5lbCBpbiBjYXNlIGV2ZW50UG9ydCBpc24ndCBzZXQgdXAgeWV0XG4gICAgc2VsZi5wb3N0TWVzc2FnZShyZXNwb25zZU1lc3NhZ2UpO1xuICAgIFxuICB9IGVsc2UgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IFwiSU5URVJSVVBUX0tFUk5FTFwiKSB7XG4gICAgLy8gSGFuZGxlIGludGVycnVwdCByZXF1ZXN0XG4gICAgXG4gICAgaWYgKGludGVycnVwdEJ1ZmZlcikge1xuICAgICAgLy8gU2V0IGludGVycnVwdCBzaWduYWwgKDIgPSBTSUdJTlQpXG4gICAgICBpbnRlcnJ1cHRCdWZmZXJbMF0gPSAyO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSB7XG4gICAgICAgIHR5cGU6IFwiSU5URVJSVVBUX1RSSUdHRVJFRFwiLFxuICAgICAgICBkYXRhOiB7IHN1Y2Nlc3M6IHRydWUsIG1ldGhvZDogXCJidWZmZXJcIiB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBTZW5kIHJlc3BvbnNlIG9uIGJvdGggY2hhbm5lbHNcbiAgICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgICAgZXZlbnRQb3J0LnBvc3RNZXNzYWdlKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJbV09SS0VSXSBObyBpbnRlcnJ1cHQgYnVmZmVyIGF2YWlsYWJsZSwgdHJ5aW5nIGtlcm5lbC5pbnRlcnJ1cHQoKVwiKTtcbiAgICAgIFxuICAgICAgLy8gRmFsbGJhY2sgdG8ga2VybmVsIGludGVycnVwdCBtZXRob2RcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmludGVycnVwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBrZXJuZWwuaW50ZXJydXB0KCkudGhlbihzdWNjZXNzID0+IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIklOVEVSUlVQVF9UUklHR0VSRURcIixcbiAgICAgICAgICAgIGRhdGE6IHsgc3VjY2VzcywgbWV0aG9kOiBcImtlcm5lbFwiIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgICAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZShyZXNwb25zZU1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gRXJyb3IgZHVyaW5nIGtlcm5lbCBpbnRlcnJ1cHQ6XCIsIGVycm9yKTtcbiAgICAgICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIklOVEVSUlVQVF9UUklHR0VSRURcIixcbiAgICAgICAgICAgIGRhdGE6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlLCBtZXRob2Q6IFwia2VybmVsXCIgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGV2ZW50UG9ydCkge1xuICAgICAgICAgICAgZXZlbnRQb3J0LnBvc3RNZXNzYWdlKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV09SS0VSXSBObyBpbnRlcnJ1cHQgbWV0aG9kIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgICAgIHR5cGU6IFwiSU5URVJSVVBUX1RSSUdHRVJFRFwiLFxuICAgICAgICAgIGRhdGE6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIk5vIGludGVycnVwdCBtZXRob2QgYXZhaWxhYmxlXCIsIG1ldGhvZDogXCJub25lXCIgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgaWYgKGV2ZW50UG9ydCkge1xuICAgICAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZShyZXNwb25zZU1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBJbml0aWFsaXplIHRoZSBrZXJuZWwgd2l0aCBwcm92aWRlZCBvcHRpb25zXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplS2VybmVsKG9wdGlvbnM6IElLZXJuZWxPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgYXdhaXQga2VybmVsLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgXG4gICAgLy8gU2V0IHVwIHRoZSBpbnRlcnJ1cHQgYnVmZmVyIGlmIGl0J3MgYXZhaWxhYmxlIGFuZCB0aGUga2VybmVsIHN1cHBvcnRzIGl0XG4gICAgaWYgKGludGVycnVwdEJ1ZmZlciAmJiB0eXBlb2Yga2VybmVsLnNldEludGVycnVwdEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAga2VybmVsLnNldEludGVycnVwdEJ1ZmZlcihpbnRlcnJ1cHRCdWZmZXIpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTZXQgdXAgZXZlbnQgZm9yd2FyZGluZyBBRlRFUiBrZXJuZWwgaXMgaW5pdGlhbGl6ZWRcbiAgICBzZXR1cEV2ZW50Rm9yd2FyZGluZygpO1xuICAgIFxuICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiS0VSTkVMX0lOSVRJQUxJWkVEXCIsXG4gICAgICAgIGRhdGE6IHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIktlcm5lbCBpbml0aWFsaXphdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vLyBDbGVhbiB1cCBvbGQgZXZlbnQgbGlzdGVuZXJzIGFuZCBwb3J0XG5mdW5jdGlvbiBjbGVhbnVwRXZlbnRGb3J3YXJkaW5nKCkge1xuICBpZiAoY3VycmVudEV2ZW50TGlzdGVuZXJzLnNpemUgPiAwKSB7XG4gICAgLy8gUmVtb3ZlIGFsbCBjdXJyZW50IGV2ZW50IGxpc3RlbmVyc1xuICAgIGZvciAoY29uc3QgW2V2ZW50VHlwZSwgbGlzdGVuZXJdIG9mIGN1cnJlbnRFdmVudExpc3RlbmVycy5lbnRyaWVzKCkpIHtcbiAgICAgIChrZXJuZWwgYXMgdW5rbm93biBhcyBFdmVudEVtaXR0ZXIpLm9mZihldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYXIgdGhlIGxpc3RlbmVycyBtYXBcbiAgICBjdXJyZW50RXZlbnRMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxuICBcbiAgLy8gQ2xvc2UgdGhlIG9sZCBwb3J0IGlmIGl0IGV4aXN0c1xuICBpZiAoZXZlbnRQb3J0KSB7XG4gICAgZXZlbnRQb3J0LmNsb3NlKCk7XG4gICAgZXZlbnRQb3J0ID0gbnVsbDtcbiAgfVxufVxuXG4vLyBTZXQgdXAgZXZlbnQgZm9yd2FyZGluZyBmcm9tIGtlcm5lbCB0byBtYWluIHRocmVhZFxuZnVuY3Rpb24gc2V0dXBFdmVudEZvcndhcmRpbmcoKSB7XG4gIGlmICghZXZlbnRQb3J0KSB7XG4gICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIENhbm5vdCBzZXQgdXAgZXZlbnQgZm9yd2FyZGluZzogbm8gZXZlbnQgcG9ydCBhdmFpbGFibGVcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yd2FyZCBhbGwga2VybmVsIGV2ZW50cyB0byB0aGUgbWFpbiB0aHJlYWRcbiAgT2JqZWN0LnZhbHVlcyhLZXJuZWxFdmVudHMpLmZvckVhY2goKGV2ZW50VHlwZSkgPT4ge1xuICAgIC8vIENyZWF0ZSBhIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciB0aGlzIGV2ZW50IHR5cGVcbiAgICBjb25zdCBsaXN0ZW5lciA9IChkYXRhOiBhbnkpID0+IHtcbiAgICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgICAgLy8gU2VuZCBqdXN0IHRoZSBldmVudCB0eXBlIGFuZCByYXcgZGF0YVxuICAgICAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHN0cnVjdHVyZSB1c2VkIGluIG1haW4gdGhyZWFkIG1vZGVcbiAgICAgICAgZXZlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICB0eXBlOiBldmVudFR5cGUsXG4gICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIFN0b3JlIHRoZSBsaXN0ZW5lciBmb3IgbGF0ZXIgY2xlYW51cFxuICAgIGN1cnJlbnRFdmVudExpc3RlbmVycy5zZXQoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgXG4gICAgLy8gQWRkIHRoZSBsaXN0ZW5lciB0byB0aGUga2VybmVsXG4gICAgKGtlcm5lbCBhcyB1bmtub3duIGFzIEV2ZW50RW1pdHRlcikub24oZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gIH0pO1xufVxuXG4vLyBIYW5kbGUgY2xlYW51cCB3aGVuIHdvcmtlciBpcyB0ZXJtaW5hdGVkXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgYXN5bmMgKCkgPT4ge1xuICAvLyBDbG9zZSBhbnkgcmVzb3VyY2VzIG9yIGNvbm5lY3Rpb25zXG4gIHRyeSB7XG4gICAgLy8gU2VuZCBhIGZpbmFsIG1lc3NhZ2UgYmVmb3JlIHRlcm1pbmF0aW9uIGlmIG5lZWRlZFxuICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiV09SS0VSX1RFUk1JTkFUSU5HXCIsXG4gICAgICAgIGRhdGE6IHsgbWVzc2FnZTogXCJXb3JrZXIgaXMgc2h1dHRpbmcgZG93blwiIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIHdvcmtlciBjbGVhbnVwOlwiLCBlcnJvcik7XG4gIH1cbn0pO1xuXG4vLyBMb2cgYXZhaWxhYmxlIG1ldGhvZHMgZm9yIGRlYnVnZ2luZ1xuXG4vLyBDcmVhdGUgYSBzaW1wbGlmaWVkIHByb3h5IHRoYXQgb25seSBleHBvc2VzIHRoZSBtZXRob2RzIHdlIG5lZWRcbi8vIFdlJ3JlIG5vdCB0cnlpbmcgdG8gaW1wbGVtZW50IHRoZSBmdWxsIEV2ZW50RW1pdHRlciBpbnRlcmZhY2VcbmNvbnN0IHNpbXBsZVByb3h5ID0ge1xuICAvLyBSZXF1aXJlZCBtZXRob2RzIGZyb20gSUtlcm5lbCBpbnRlcmZhY2VcbiAgaW5pdGlhbGl6ZTogYXN5bmMgKG9wdGlvbnM/OiBJS2VybmVsT3B0aW9ucykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBrZXJuZWwuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBJbml0aWFsaXplIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG4gIFxuICBleGVjdXRlOiBhc3luYyAoY29kZTogc3RyaW5nLCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga2VybmVsLmV4ZWN1dGUoY29kZSwgcGFyZW50KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBFeGVjdXRlIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBLZXlib2FyZEludGVycnVwdCBhbmQgaGFuZGxlIGl0IHNwZWNpYWxseVxuICAgICAgaWYgKGlzS2V5Ym9hcmRJbnRlcnJ1cHQoZXJyb3IpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW1dPUktFUl0gS2V5Ym9hcmRJbnRlcnJ1cHQgY2F1Z2h0IGluIGV4ZWN1dGUgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4gY3JlYXRlS2V5Ym9hcmRJbnRlcnJ1cHRSZXN1bHQoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIG90aGVyIGVycm9ycyBub3JtYWxseVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSksXG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIHBheWxvYWQ6IFtdLFxuICAgICAgICAgIHN0YXR1czogXCJlcnJvclwiLFxuICAgICAgICAgIGVuYW1lOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IuY29uc3RydWN0b3IubmFtZSA6IFwiRXJyb3JcIixcbiAgICAgICAgICBldmFsdWU6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICB0cmFjZWJhY2s6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3Iuc3RhY2sgPyBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykgOiBbU3RyaW5nKGVycm9yKV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIFxuICBpc0luaXRpYWxpemVkOiAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbC5pc0luaXRpYWxpemVkKCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gSXNJbml0aWFsaXplZCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgXG4gIGlucHV0UmVwbHk6IGFzeW5jIChjb250ZW50OiB7IHZhbHVlOiBzdHJpbmcgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBrZXJuZWwuaW5wdXRSZXBseShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIElucHV0UmVwbHkgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8vIEFzeW5jIG1ldGhvZCBmb3Igc3RhdHVzXG4gIGdldFN0YXR1czogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBrZXJuZWwuZ2V0U3RhdHVzKCk7XG4gICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gZ2V0U3RhdHVzIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gICAgfVxuICB9LFxuICBcbiAgLy8gSW50ZXJydXB0IGZ1bmN0aW9uYWxpdHlcbiAgaW50ZXJydXB0OiBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmludGVycnVwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBrZXJuZWwuaW50ZXJydXB0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV09SS0VSXSBLZXJuZWwgZG9lcyBub3Qgc3VwcG9ydCBpbnRlcnJ1cHQgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBJbnRlcnJ1cHQgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIC8vIERvbid0IGxldCBpbnRlcnJ1cHQgZXJyb3JzIGNyYXNoIHRoZSB3b3JrZXJcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIFxuICBzZXRJbnRlcnJ1cHRCdWZmZXI6IChidWZmZXI6IFVpbnQ4QXJyYXkpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBrZXJuZWwuc2V0SW50ZXJydXB0QnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGtlcm5lbC5zZXRJbnRlcnJ1cHRCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV09SS0VSXSBLZXJuZWwgZG9lcyBub3Qgc3VwcG9ydCBzZXRJbnRlcnJ1cHRCdWZmZXIgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBzZXRJbnRlcnJ1cHRCdWZmZXIgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIFxuICAvLyBDb21wbGV0aW9uIG1ldGhvZHNcbiAgY29tcGxldGU6IGFzeW5jIChjb2RlOiBzdHJpbmcsIGN1cnNvcl9wb3M6IG51bWJlciwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGtlcm5lbC5jb21wbGV0ZShjb2RlLCBjdXJzb3JfcG9zLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gS2VybmVsIGRvZXMgbm90IHN1cHBvcnQgY29tcGxldGUgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiAnQ29tcGxldGlvbiBub3Qgc3VwcG9ydGVkJyB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gQ29tcGxldGUgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICB9XG4gIH0sXG4gIFxuICBpbnNwZWN0OiBhc3luYyAoY29kZTogc3RyaW5nLCBjdXJzb3JfcG9zOiBudW1iZXIsIGRldGFpbF9sZXZlbDogMCB8IDEsIHBhcmVudD86IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGtlcm5lbC5pbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGtlcm5lbC5pbnNwZWN0KGNvZGUsIGN1cnNvcl9wb3MsIGRldGFpbF9sZXZlbCwgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltXT1JLRVJdIEtlcm5lbCBkb2VzIG5vdCBzdXBwb3J0IGluc3BlY3QgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiAnSW5zcGVjdGlvbiBub3Qgc3VwcG9ydGVkJyB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gSW5zcGVjdCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogU3RyaW5nKGVycm9yKSB9O1xuICAgIH1cbiAgfSxcbiAgXG4gIGlzQ29tcGxldGU6IGFzeW5jIChjb2RlOiBzdHJpbmcsIHBhcmVudD86IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGtlcm5lbC5pc0NvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGtlcm5lbC5pc0NvbXBsZXRlKGNvZGUsIHBhcmVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV09SS0VSXSBLZXJuZWwgZG9lcyBub3Qgc3VwcG9ydCBpc0NvbXBsZXRlIG1ldGhvZFwiKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAndW5rbm93bicgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIElzQ29tcGxldGUgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gTmF0aXZlIGZpbGVzeXN0ZW0gbW91bnRpbmdcbiAgbW91bnRGUzogYXN5bmMgKG1vdW50UGF0aDogc3RyaW5nLCBkaXJIYW5kbGU/OiBGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHwgbnVsbCwgcGVybWlzc2lvbj86ICdyZWFkJyB8ICdyZWFkd3JpdGUnKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLm1vdW50RlMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSW4gd29ya2VyIGNvbnRleHQsIGRpckhhbmRsZSBtdXN0IGJlIHByb3ZpZGVkIC0gd2UgY2Fubm90IHNob3cgZGlyZWN0b3J5IHBpY2tlclxuICAgICAgICBpZiAoIWRpckhhbmRsZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzaG93IGRpcmVjdG9yeSBwaWNrZXIgaW4gd29ya2VyIGNvbnRleHQuIFBsZWFzZSBwcm92aWRlIGEgZGlySGFuZGxlIHBhcmFtZXRlciB3aGVuIGNhbGxpbmcgbW91bnRGUyBvbiBhIHdvcmtlciBrZXJuZWwuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGtlcm5lbC5tb3VudEZTKG1vdW50UGF0aCwgZGlySGFuZGxlLCBwZXJtaXNzaW9uKTtcbiAgICAgICAgLy8gV3JhcCB0aGUgcmVzdWx0IHdpdGggQ29tbGluay5wcm94eSBzbyB0aGUgc3luY2ZzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgYWNyb3NzIHdvcmtlciBib3VuZGFyeVxuICAgICAgICByZXR1cm4gQ29tbGluay5wcm94eShyZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gS2VybmVsIGRvZXMgbm90IHN1cHBvcnQgbW91bnRGUyBtZXRob2RcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vdW50RlMgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGtlcm5lbFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIE1vdW50RlMgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICAvLyBDb21tIG1ldGhvZHNcbiAgY29tbUluZm86IGFzeW5jICh0YXJnZXRfbmFtZTogc3RyaW5nIHwgbnVsbCwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmNvbW1JbmZvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGtlcm5lbC5jb21tSW5mbyh0YXJnZXRfbmFtZSwgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltXT1JLRVJdIEtlcm5lbCBkb2VzIG5vdCBzdXBwb3J0IGNvbW1JbmZvIG1ldGhvZFwiKTtcbiAgICAgICAgcmV0dXJuIHsgY29tbXM6IHt9LCBzdGF0dXM6ICdvaycgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIENvbW1JbmZvIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4geyBjb21tczoge30sIHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICB9XG4gIH0sXG4gIFxuICBjb21tT3BlbjogYXN5bmMgKGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmNvbW1PcGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGtlcm5lbC5jb21tT3Blbihjb250ZW50LCBwYXJlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gS2VybmVsIGRvZXMgbm90IHN1cHBvcnQgY29tbU9wZW4gbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gQ29tbU9wZW4gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICBcbiAgY29tbU1zZzogYXN5bmMgKGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmNvbW1Nc2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga2VybmVsLmNvbW1Nc2coY29udGVudCwgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltXT1JLRVJdIEtlcm5lbCBkb2VzIG5vdCBzdXBwb3J0IGNvbW1Nc2cgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gQ29tbU1zZyBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIFxuICBjb21tQ2xvc2U6IGFzeW5jIChjb250ZW50OiBhbnksIHBhcmVudD86IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGtlcm5lbC5jb21tQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga2VybmVsLmNvbW1DbG9zZShjb250ZW50LCBwYXJlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gS2VybmVsIGRvZXMgbm90IHN1cHBvcnQgY29tbUNsb3NlIG1ldGhvZFwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIENvbW1DbG9zZSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEV4cG9zZSB0aGUgcHJveHkgdGhyb3VnaCBDb21saW5rXG50cnkge1xuICBDb21saW5rLmV4cG9zZShzaW1wbGVQcm94eSk7XG59IGNhdGNoIChlcnJvcikge1xuICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZXhwb3NpbmcgcHJveHk6XCIsIGVycm9yKTtcbn0gIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/kernel.worker.ts\n\n}");

/***/ }),

/***/ "./src/manager.ts":
/*!************************!*\
  !*** ./src/manager.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* unused harmony exports KernelMode, KernelLanguage, KernelManager */\n/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! comlink */ \"./node_modules/comlink/dist/esm/comlink.mjs\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ \"./src/index.ts\");\n// Kernel Manager for Deno App Engine\n// This file manages kernel instances in either main thread or worker mode\n\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    }\n    off(eventName, listener) {\n        if (!this.events[eventName])\n            return;\n        const index = this.events[eventName].indexOf(listener);\n        if (index > -1) {\n            this.events[eventName].splice(index, 1);\n        }\n    }\n    removeListener(eventName, listener) {\n        this.off(eventName, listener);\n    }\n    emit(eventName, ...args) {\n        if (!this.events[eventName])\n            return;\n        this.events[eventName].forEach(listener => listener(...args));\n    }\n    setMaxListeners(n) {\n        // No-op for browser compatibility\n    }\n}\n\n\n// Re-export KernelEvents for test usage\n\n// Execution mode enum\nvar KernelMode;\n(function (KernelMode) {\n    KernelMode[\"MAIN_THREAD\"] = \"main_thread\";\n    KernelMode[\"WORKER\"] = \"worker\";\n})(KernelMode || (KernelMode = {}));\n// Kernel language enum\nvar KernelLanguage;\n(function (KernelLanguage) {\n    KernelLanguage[\"PYTHON\"] = \"python\";\n})(KernelLanguage || (KernelLanguage = {}));\n/**\n * KernelManager class manages multiple kernel instances\n * in either main thread or worker mode\n */\nclass KernelManager extends EventEmitter {\n    /**\n     * Resolve the worker URL based on the current environment\n     * @private\n     * @returns The resolved worker URL\n     */\n    resolveWorkerUrl() {\n        // If a custom worker URL is provided, use it\n        if (this.workerUrl) {\n            return this.workerUrl;\n        }\n        // Try to detect the current script location and derive the worker URL\n        if (typeof window !== 'undefined' && window.location) {\n            // Browser environment\n            const currentScript = document.currentScript ||\n                Array.from(document.getElementsByTagName('script')).pop();\n            if (currentScript && currentScript.src) {\n                // Get the base URL from the current script\n                const scriptUrl = new URL(currentScript.src);\n                const baseUrl = scriptUrl.href.substring(0, scriptUrl.href.lastIndexOf('/'));\n                // Check if we're loading from a CDN (jsdelivr, unpkg, etc.)\n                if (scriptUrl.hostname.includes('jsdelivr.net') ||\n                    scriptUrl.hostname.includes('unpkg.com') ||\n                    scriptUrl.hostname.includes('cdnjs.cloudflare.com')) {\n                    // For CDN, the worker should be at the same path\n                    return `${baseUrl}/kernel.worker.js`;\n                }\n                // For local development or custom deployments\n                return `${baseUrl}/kernel.worker.js`;\n            }\n            // Fallback to relative path from current location\n            const baseUrl = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));\n            return `${baseUrl}/dist/kernel.worker.js`;\n        }\n        // Node.js or unknown environment - use relative path\n        // This may not work in Node.js but is provided as a fallback\n        return './kernel.worker.js';\n    }\n    /**\n     * Helper function to check if an error is a KeyboardInterrupt\n     * @private\n     */\n    isKeyboardInterrupt(error) {\n        return error &&\n            typeof error === 'object' &&\n            (('type' in error && error.type === \"KeyboardInterrupt\") ||\n                ('message' in error && typeof error.message === 'string' && error.message.includes(\"KeyboardInterrupt\")));\n    }\n    /**\n     * Helper function to create a standardized KeyboardInterrupt error result\n     * @private\n     */\n    createKeyboardInterruptResult() {\n        return {\n            success: false,\n            error: new Error(\"KeyboardInterrupt: Execution interrupted by user\"),\n            result: {\n                status: \"error\",\n                ename: \"KeyboardInterrupt\",\n                evalue: \"Execution interrupted by user\",\n                traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n            }\n        };\n    }\n    /**\n     * Store an AbortController for a specific kernel execution\n     * @private\n     */\n    storeAbortController(kernelId, executionId, controller) {\n        if (!this.abortControllers.has(kernelId)) {\n            this.abortControllers.set(kernelId, new Map());\n        }\n        this.abortControllers.get(kernelId).set(executionId, controller);\n    }\n    /**\n     * Remove and return an AbortController for a specific kernel execution\n     * @private\n     */\n    removeAbortController(kernelId, executionId) {\n        const kernelControllers = this.abortControllers.get(kernelId);\n        if (!kernelControllers)\n            return undefined;\n        const controller = kernelControllers.get(executionId);\n        if (controller) {\n            kernelControllers.delete(executionId);\n            if (kernelControllers.size === 0) {\n                this.abortControllers.delete(kernelId);\n            }\n        }\n        return controller;\n    }\n    /**\n     * Abort all ongoing operations for a specific kernel\n     * @private\n     */\n    abortAllKernelOperations(kernelId) {\n        const kernelControllers = this.abortControllers.get(kernelId);\n        if (!kernelControllers)\n            return;\n        for (const [executionId, controller] of kernelControllers) {\n            try {\n                controller.abort();\n                console.log(`ðŸš« Aborted execution ${executionId} for kernel ${kernelId}`);\n            }\n            catch (error) {\n                console.warn(`âš ï¸ Error aborting execution ${executionId}:`, error);\n            }\n        }\n        // Clear all controllers for this kernel\n        this.abortControllers.delete(kernelId);\n    }\n    constructor(options = {}) {\n        super();\n        this.kernels = new Map();\n        // Track listeners for each kernel to enable individual removal\n        this.listenerWrappers = new Map();\n        // Track last activity time for each kernel\n        this.lastActivityTime = new Map();\n        // Store inactivity timers for each kernel\n        this.inactivityTimers = new Map();\n        // Track ongoing executions for each kernel\n        this.ongoingExecutions = new Map();\n        // Track execution timeouts for detecting stuck/dead kernels\n        this.executionTimeouts = new Map();\n        // Track execution start times for accurate duration calculation\n        this.executionStartTimes = new Map();\n        // Track execution metadata for better monitoring\n        this.executionMetadata = new Map();\n        // Track AbortControllers for each kernel's ongoing operations\n        this.abortControllers = new Map();\n        // Pool management - now using promises for immediate response\n        this.pool = new Map();\n        this.isPreloading = false;\n        // Track which pool keys are currently being prefilled to prevent duplicates\n        this.prefillingInProgress = new Map();\n        // Interrupt buffers for worker kernels (using SharedArrayBuffer)\n        this.interruptBuffers = new Map();\n        super.setMaxListeners(100); // Allow many listeners for kernel events\n        // Set interruption mode (default to 'auto')\n        this.interruptionMode = options.interruptionMode || 'auto';\n        // Set worker URL if provided\n        this.workerUrl = options.workerUrl;\n        // Set default allowed kernel types (worker mode only for security)\n        this.allowedKernelTypes = options.allowedKernelTypes || [\n            { mode: KernelMode.WORKER, language: KernelLanguage.PYTHON }\n        ];\n        // Initialize pool configuration with defaults based on allowed types\n        const defaultPreloadConfigs = this.allowedKernelTypes.filter(type => type.language === KernelLanguage.PYTHON // Only preload Python kernels by default\n        );\n        this.poolConfig = {\n            enabled: false,\n            poolSize: 2,\n            autoRefill: true,\n            preloadConfigs: defaultPreloadConfigs,\n            ...options.pool\n        };\n        // Validate that pool preload configs are within allowed types\n        if (this.poolConfig.preloadConfigs) {\n            this.poolConfig.preloadConfigs = this.poolConfig.preloadConfigs.filter(config => {\n                const isAllowed = this.isKernelTypeAllowed(config.mode, config.language);\n                if (!isAllowed) {\n                    console.warn(`Pool preload config ${config.mode}-${config.language} is not in allowedKernelTypes, skipping`);\n                }\n                return isAllowed;\n            });\n        }\n        // Start preloading if pool is enabled\n        if (this.poolConfig.enabled) {\n            this.preloadPool().catch(error => {\n                console.error(\"Error preloading kernel pool:\", error);\n            });\n        }\n    }\n    /**\n     * Generate a pool key for a given mode and language combination\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Pool key string\n     * @private\n     */\n    getPoolKey(mode, language) {\n        return `${mode}-${language}`;\n    }\n    /**\n     * Get a kernel promise from the pool if available\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Kernel promise or null if none available\n     * @private\n     */\n    getFromPool(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return null;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        const poolPromises = this.pool.get(poolKey);\n        if (!poolPromises || poolPromises.length === 0) {\n            return null;\n        }\n        // Remove and return the first promise from the pool (FIFO)\n        const kernelPromise = poolPromises.shift();\n        // Immediately trigger background refill to add one promise back\n        if (this.poolConfig.autoRefill) {\n            setTimeout(() => {\n                this.refillPoolSingle(mode, language).catch(error => {\n                    console.error(`Error refilling single kernel for ${poolKey}:`, error);\n                });\n            }, 0);\n        }\n        return kernelPromise;\n    }\n    /**\n     * Add a kernel promise to the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @param kernelPromise Kernel promise\n     * @private\n     */\n    addToPool(mode, language, kernelPromise) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        if (!this.pool.has(poolKey)) {\n            this.pool.set(poolKey, []);\n        }\n        const poolPromises = this.pool.get(poolKey);\n        // Only add if we haven't reached the pool size limit\n        if (poolPromises.length < this.poolConfig.poolSize) {\n            poolPromises.push(kernelPromise);\n            // Handle promise rejection to prevent unhandled rejections\n            kernelPromise.catch(error => {\n                console.error(`Pool kernel promise rejected for ${poolKey}:`, error);\n                // Remove the failed promise from the pool\n                const index = poolPromises.indexOf(kernelPromise);\n                if (index !== -1) {\n                    poolPromises.splice(index, 1);\n                }\n            });\n        }\n        else {\n            // Pool is full, let the excess promise resolve and then destroy the kernel\n            kernelPromise.then(kernel => {\n                kernel.destroy().catch(error => {\n                    console.error(\"Error destroying excess pool kernel:\", error);\n                });\n            }).catch(error => {\n                console.error(\"Excess pool kernel promise rejected:\", error);\n            });\n        }\n    }\n    /**\n     * Refill the pool with a single kernel promise\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @private\n     */\n    async refillPoolSingle(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        const poolPromises = this.pool.get(poolKey) || [];\n        // Only add one if we're below the pool size\n        if (poolPromises.length < this.poolConfig.poolSize) {\n            const kernelPromise = this.createPoolKernelPromise(mode, language);\n            this.addToPool(mode, language, kernelPromise);\n        }\n    }\n    /**\n     * Refill the pool for a specific configuration with parallel creation\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @private\n     */\n    async refillPool(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        // Check if already prefilling this pool key to prevent duplicates\n        if (this.prefillingInProgress.get(poolKey)) {\n            return;\n        }\n        // Set prefilling flag\n        this.prefillingInProgress.set(poolKey, true);\n        try {\n            const poolPromises = this.pool.get(poolKey) || [];\n            const needed = this.poolConfig.poolSize - poolPromises.length;\n            if (needed <= 0) {\n                return;\n            }\n            // Create all needed kernel promises in parallel\n            const newPromises = Array.from({ length: needed }, () => this.createPoolKernelPromise(mode, language));\n            // Add all promises to the pool\n            for (const kernelPromise of newPromises) {\n                this.addToPool(mode, language, kernelPromise);\n            }\n        }\n        catch (error) {\n            console.error(`Error refilling pool for ${poolKey}:`, error);\n        }\n        finally {\n            // Always clear the prefilling flag\n            this.prefillingInProgress.set(poolKey, false);\n        }\n    }\n    /**\n     * Create a kernel promise for the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Promise that resolves to a kernel instance\n     * @private\n     */\n    createPoolKernelPromise(mode, language) {\n        return new Promise(async (resolve, reject) => {\n            try {\n                const kernel = await this.createPoolKernel(mode, language);\n                // Mark as taken from pool\n                kernel.isFromPool = true;\n                resolve(kernel);\n            }\n            catch (error) {\n                console.error(`Error creating pool kernel for ${mode}-${language}:`, error);\n                reject(error);\n            }\n        });\n    }\n    /**\n     * Create a kernel specifically for the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Kernel instance\n     * @private\n     */\n    async createPoolKernel(mode, language) {\n        // Generate a temporary ID for the pool kernel\n        const tempId = `pool-${crypto.randomUUID()}`;\n        // Create kernel with minimal configuration\n        const options = {\n            mode,\n            lang: language\n        };\n        // Store options temporarily - but don't store incomplete instance in kernels map\n        // Instead, we'll pass the options directly to the creation methods\n        let instance;\n        try {\n            if (mode === KernelMode.MAIN_THREAD) {\n                // For main thread, we need to temporarily store the instance for createMainThreadKernel\n                const tempInstance = {\n                    id: tempId,\n                    options,\n                    mode,\n                    language\n                };\n                this.kernels.set(tempId, tempInstance);\n                try {\n                    instance = await this.createMainThreadKernel(tempId);\n                }\n                finally {\n                    // Always clean up the temporary instance\n                    this.kernels.delete(tempId);\n                }\n            }\n            else {\n                // For worker mode, we need to temporarily store the instance for createWorkerKernel\n                const tempInstance = {\n                    id: tempId,\n                    options,\n                    mode,\n                    language\n                };\n                this.kernels.set(tempId, tempInstance);\n                try {\n                    instance = await this.createWorkerKernel(tempId);\n                }\n                finally {\n                    // Always clean up the temporary instance\n                    this.kernels.delete(tempId);\n                }\n            }\n        }\n        catch (error) {\n            // Ensure cleanup on any error\n            this.kernels.delete(tempId);\n            throw error;\n        }\n        return instance;\n    }\n    /**\n     * Preload the kernel pool with configured kernel types\n     * @private\n     */\n    async preloadPool() {\n        if (!this.poolConfig.enabled || this.isPreloading) {\n            return;\n        }\n        this.isPreloading = true;\n        try {\n            // Preload kernels for each configured type\n            for (const config of this.poolConfig.preloadConfigs) {\n                try {\n                    await this.refillPool(config.mode, config.language);\n                }\n                catch (error) {\n                    console.error(`Error preloading ${config.mode}-${config.language}:`, error);\n                    // Continue with other configurations\n                }\n            }\n        }\n        catch (error) {\n            console.error(\"Error during kernel pool preloading:\", error);\n        }\n        finally {\n            this.isPreloading = false;\n        }\n    }\n    /**\n     * Check if a kernel request can use the pool\n     * @param options Kernel creation options\n     * @returns True if the request can use pool\n     * @private\n     */\n    canUsePool(options) {\n        // Don't use pool if it's disabled\n        if (!this.poolConfig.enabled) {\n            return false;\n        }\n        // Don't use pool if custom filesystem or permissions are specified\n        if (options.filesystem || options.deno?.permissions) {\n            return false;\n        }\n        // Don't use pool if custom timeouts are specified\n        if (options.inactivityTimeout !== undefined || options.maxExecutionTime !== undefined) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Reassign a pool kernel with new ID and options\n     * @param poolKernel Kernel from pool\n     * @param newId New kernel ID\n     * @param options Kernel options\n     * @returns Updated kernel instance\n     * @private\n     */\n    reassignPoolKernel(poolKernel, newId, options) {\n        // Create a new instance object explicitly to avoid spread operator issues\n        const updatedInstance = {\n            id: newId,\n            kernel: poolKernel.kernel,\n            mode: poolKernel.mode,\n            language: poolKernel.language,\n            worker: poolKernel.worker,\n            created: new Date().toISOString(), // Update creation time\n            options: { ...poolKernel.options, ...options },\n            isFromPool: true,\n            destroy: poolKernel.destroy // Preserve the original destroy function\n        };\n        // Verify the destroy function is properly set\n        if (typeof updatedInstance.destroy !== 'function') {\n            console.error('Failed to preserve destroy function during pool kernel reassignment');\n            console.error('poolKernel.destroy type:', typeof poolKernel.destroy);\n            console.error('updatedInstance.destroy type:', typeof updatedInstance.destroy);\n            throw new Error(`Failed to preserve destroy function during pool kernel reassignment`);\n        }\n        return updatedInstance;\n    }\n    /**\n     * Get pool statistics for debugging/monitoring\n     * @returns Pool statistics\n     */\n    getPoolStats() {\n        const stats = {};\n        for (const [poolKey, promises] of this.pool.entries()) {\n            stats[poolKey] = {\n                available: promises.length,\n                total: this.poolConfig.poolSize\n            };\n        }\n        return stats;\n    }\n    /**\n     * Get pool configuration information\n     * @returns Pool configuration details\n     */\n    getPoolConfig() {\n        return {\n            enabled: this.poolConfig.enabled,\n            poolSize: this.poolConfig.poolSize,\n            autoRefill: this.poolConfig.autoRefill,\n            preloadConfigs: [...this.poolConfig.preloadConfigs], // Return a copy to prevent modification\n            isPreloading: this.isPreloading\n        };\n    }\n    /**\n     * Get the current worker URL configuration\n     * @returns The worker URL or undefined if using auto-detection\n     */\n    getWorkerUrl() {\n        return this.workerUrl;\n    }\n    /**\n     * Set a custom worker URL for kernel workers\n     * @param url The URL to the kernel.worker.js file\n     * @example\n     * // For CDN usage:\n     * manager.setWorkerUrl('https://cdn.jsdelivr.net/npm/web-python-kernel@latest/dist/kernel.worker.js');\n     * // For local development:\n     * manager.setWorkerUrl('/dist/kernel.worker.js');\n     */\n    setWorkerUrl(url) {\n        this.workerUrl = url;\n    }\n    /**\n     * Create a new kernel instance\n     * @param options Options for creating the kernel\n     * @param options.id Optional custom ID for the kernel\n     * @param options.mode Optional kernel mode (main_thread or worker)\n     * @param options.lang Optional kernel language (python or typescript)\n     * @param options.namespace Optional namespace prefix for the kernel ID\n     * @param options.deno.permissions Optional Deno permissions for worker mode\n     * @param options.filesystem Optional filesystem mounting options\n     * @param options.inactivityTimeout Optional timeout in ms after which an inactive kernel will be shut down\n     * @param options.maxExecutionTime Optional maximum time in ms an execution can run before considered stuck\n     * @returns Promise resolving to the kernel instance ID\n     */\n    async createKernel(options = {}) {\n        // make sure the options.id does not contain colons because it will be used as a namespace prefix\n        if (options.id && options.id.includes(':')) {\n            throw new Error('Kernel ID cannot contain colons');\n        }\n        const baseId = options.id || crypto.randomUUID();\n        const mode = options.mode || KernelMode.WORKER;\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Check if the requested kernel type is allowed\n        if (!this.isKernelTypeAllowed(mode, language)) {\n            throw new Error(`Kernel type ${mode}-${language} is not allowed. Allowed types: ${this.allowedKernelTypes.map(t => `${t.mode}-${t.language}`).join(', ')}`);\n        }\n        // Apply namespace prefix if provided\n        const id = options.namespace ? `${options.namespace}:${baseId}` : baseId;\n        // Check if kernel with this ID already exists\n        if (this.kernels.has(id)) {\n            throw new Error(`Kernel with ID ${id} already exists`);\n        }\n        // Try to get from pool if possible\n        if (this.canUsePool(options)) {\n            const poolKey = this.getPoolKey(mode, language);\n            // Check if this kernel type is configured for pooling\n            const isPooledType = this.poolConfig.preloadConfigs.some(config => config.mode === mode && config.language === language);\n            if (isPooledType) {\n                // First try to get from existing pool\n                let poolKernelPromise = this.getFromPool(mode, language);\n                if (poolKernelPromise) {\n                    return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n                }\n                // Pool is empty, but this type should be pooled\n                // Create a new promise immediately and trigger background refill\n                try {\n                    // Create a new kernel promise specifically for this request\n                    const newKernelPromise = this.createPoolKernelPromise(mode, language);\n                    // Trigger background refill to replenish the pool for future requests\n                    if (this.poolConfig.autoRefill) {\n                        setTimeout(() => {\n                            this.refillPool(mode, language).catch(error => {\n                                console.error(`Error refilling exhausted pool for ${poolKey}:`, error);\n                            });\n                        }, 0);\n                    }\n                    return await this.setupPoolKernelFromPromise(newKernelPromise, id, options);\n                }\n                catch (error) {\n                    console.error(`Failed to create kernel promise for exhausted pool: ${error}`);\n                    // Fall through to on-demand creation as last resort\n                }\n            }\n            else {\n                // This kernel type is not configured for pooling, try to get from pool anyway\n                // in case there are kernels available from previous configurations\n                const poolKernelPromise = this.getFromPool(mode, language);\n                if (poolKernelPromise) {\n                    return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n                }\n            }\n        }\n        // Fall back to creating a new kernel on-demand\n        return this.createOnDemandKernel(id, mode, language, options);\n    }\n    /**\n     * Setup a pool kernel from a promise with new ID and options\n     * @param poolKernelPromise Kernel promise from pool\n     * @param id New kernel ID\n     * @param options Kernel options\n     * @returns Kernel ID (returned after kernel is ready)\n     * @private\n     */\n    async setupPoolKernelFromPromise(poolKernelPromise, id, options) {\n        try {\n            // Wait for the pool kernel to be ready\n            const poolKernel = await poolKernelPromise;\n            // Reassign the pool kernel with the new ID and options\n            const instance = this.reassignPoolKernel(poolKernel, id, options);\n            // For worker kernels, we need to recreate the event handler with the new ID\n            if (instance.mode === KernelMode.WORKER && instance.worker) {\n                // Get the worker and create new message channel\n                const worker = instance.worker;\n                // Create a new message channel for the reassigned kernel\n                const { port1, port2 } = new MessageChannel();\n                // Send the new event port to the worker\n                worker.postMessage({\n                    type: \"SET_EVENT_PORT\",\n                    port: port2\n                }, [port2]);\n                // Create a new event handler with the correct kernel ID\n                const eventHandler = (event) => {\n                    if (event.data && event.data.type) {\n                        // Emit the event from the manager with kernel ID\n                        // This structure matches the setupEventForwarding method for main thread kernels\n                        super.emit(event.data.type, {\n                            kernelId: id,\n                            data: event.data.data\n                        });\n                    }\n                };\n                // Listen for events from the worker with the new handler\n                port1.addEventListener('message', eventHandler);\n                port1.start();\n                // Update the destroy function to clean up the new event handler\n                const originalDestroy = instance.destroy;\n                instance.destroy = async () => {\n                    port1.removeEventListener('message', eventHandler);\n                    port1.close();\n                    return originalDestroy();\n                };\n            }\n            // Store the kernel instance\n            this.kernels.set(id, instance);\n            // Forward kernel events to manager (for main thread kernels)\n            this.setupEventForwarding(instance);\n            // Initialize activity tracking\n            this.updateKernelActivity(id);\n            // Set up inactivity timeout if specified and greater than 0\n            if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n                this.setupInactivityTimeout(id, options.inactivityTimeout);\n            }\n            // Setup handlers for stalled executions if maxExecutionTime is specified\n            if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n                this.setupStalledExecutionHandler(id);\n            }\n            return id;\n        }\n        catch (error) {\n            console.error(`Error setting up pool kernel ${id}:`, error);\n            // Emit an error event for this kernel\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: id,\n                data: {\n                    ename: \"KernelSetupError\",\n                    evalue: `Failed to setup kernel: ${error instanceof Error ? error.message : String(error)}`,\n                    traceback: [error instanceof Error ? (error.stack || error.message) : String(error)]\n                }\n            });\n            throw error; // Re-throw to let the caller handle it\n        }\n    }\n    /**\n     * Setup a pool kernel with new ID and options (for already resolved kernels)\n     * @param poolKernel Kernel from pool\n     * @param id New kernel ID\n     * @param options Kernel options\n     * @returns Kernel ID\n     * @private\n     */\n    setupPoolKernel(poolKernel, id, options) {\n        // Reassign the pool kernel with the new ID and options\n        const instance = this.reassignPoolKernel(poolKernel, id, options);\n        // For worker kernels, we need to recreate the event handler with the new ID\n        if (instance.mode === KernelMode.WORKER && instance.worker) {\n            // Get the worker and create new message channel\n            const worker = instance.worker;\n            // Create a new message channel for the reassigned kernel\n            const { port1, port2 } = new MessageChannel();\n            // Send the new event port to the worker\n            worker.postMessage({\n                type: \"SET_EVENT_PORT\",\n                port: port2\n            }, [port2]);\n            // Create a new event handler with the correct kernel ID\n            const eventHandler = (event) => {\n                if (event.data && event.data.type) {\n                    // Emit the event from the manager with kernel ID\n                    // This structure matches the setupEventForwarding method for main thread kernels\n                    super.emit(event.data.type, {\n                        kernelId: id,\n                        data: event.data.data\n                    });\n                }\n            };\n            // Listen for events from the worker with the new handler\n            port1.addEventListener('message', eventHandler);\n            port1.start();\n            // Update the destroy function to clean up the new event handler\n            const originalDestroy = instance.destroy;\n            instance.destroy = async () => {\n                port1.removeEventListener('message', eventHandler);\n                port1.close();\n                return originalDestroy();\n            };\n        }\n        // Store the kernel instance\n        this.kernels.set(id, instance);\n        // Forward kernel events to manager (for main thread kernels)\n        this.setupEventForwarding(instance);\n        // Initialize activity tracking\n        this.updateKernelActivity(id);\n        // Set up inactivity timeout if specified and greater than 0\n        if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n            this.setupInactivityTimeout(id, options.inactivityTimeout);\n        }\n        // Setup handlers for stalled executions if maxExecutionTime is specified\n        if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n            this.setupStalledExecutionHandler(id);\n        }\n        return id;\n    }\n    /**\n     * Create a kernel on-demand (not from pool)\n     * @param id Kernel ID\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @param options Kernel options\n     * @returns Kernel ID\n     * @private\n     */\n    async createOnDemandKernel(id, mode, language, options) {\n        // Store options temporarily to be used in createWorkerKernel\n        const tempInstance = {\n            id,\n            options: { ...options, lang: language },\n            mode,\n            language\n        };\n        this.kernels.set(id, tempInstance);\n        // Create the appropriate kernel instance\n        let instance;\n        if (mode === KernelMode.MAIN_THREAD) {\n            instance = await this.createMainThreadKernel(id);\n        }\n        else {\n            instance = await this.createWorkerKernel(id);\n        }\n        // Store the kernel instance\n        this.kernels.set(id, instance);\n        // Forward kernel events to manager\n        this.setupEventForwarding(instance);\n        // Initialize activity tracking\n        this.updateKernelActivity(id);\n        // Set up inactivity timeout if specified and greater than 0\n        if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n            this.setupInactivityTimeout(id, options.inactivityTimeout);\n        }\n        // Setup handlers for stalled executions if maxExecutionTime is specified\n        if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n            this.setupStalledExecutionHandler(id);\n        }\n        return id;\n    }\n    /**\n     * Create a kernel instance running in the main thread\n     * @param id Kernel ID\n     * @returns Kernel instance\n     */\n    async createMainThreadKernel(id) {\n        // Get options from the temporary instance\n        const options = this.kernels.get(id)?.options || {};\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Create the Python kernel\n        const kernel = new _index__WEBPACK_IMPORTED_MODULE_2__.Kernel();\n        // Create the kernel instance\n        const instance = {\n            id,\n            kernel,\n            mode: KernelMode.MAIN_THREAD,\n            language,\n            created: new Date().toISOString(),\n            options,\n            destroy: async () => {\n                // Nothing special to do for main thread kernel\n                return Promise.resolve();\n            }\n        };\n        // Initialize the kernel with filesystem options\n        const kernelOptions = {};\n        // Add filesystem options if provided\n        if (options.filesystem) {\n            kernelOptions.filesystem = options.filesystem;\n        }\n        // Add environment variables if provided\n        if (options.env) {\n            kernelOptions.env = options.env;\n        }\n        // Add lockFileURL if provided\n        if (options.lockFileURL) {\n            kernelOptions.lockFileURL = options.lockFileURL;\n        }\n        // Add autoSyncFs if provided\n        if (options.autoSyncFs !== undefined) {\n            kernelOptions.autoSyncFs = options.autoSyncFs;\n        }\n        // Initialize the kernel\n        await kernel.initialize(kernelOptions);\n        return instance;\n    }\n    /**\n     * Create a kernel instance running in a worker\n     * @param id Kernel ID\n     * @returns Kernel instance\n     */\n    async createWorkerKernel(id) {\n        // Get permissions from options when creating the kernel\n        const options = this.kernels.get(id)?.options || {};\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Create a new worker with optional permissions\n        const workerOptions = {\n            type: \"module\",\n        };\n        // If Deno permissions are provided, use them.\n        // Otherwise don't specify Deno permissions at all to inherit from host script\n        if (options.deno?.permissions) {\n            workerOptions.deno = {\n                permissions: options.deno.permissions\n            };\n        }\n        // Determine the worker URL based on the environment\n        const workerUrl = this.resolveWorkerUrl();\n        const worker = new Worker(workerUrl, { type: 'classic' });\n        // Create a message channel for events\n        const { port1, port2 } = new MessageChannel();\n        // Create a promise that will resolve when the kernel is initialized\n        const initPromise = new Promise((resolve, reject) => {\n            const initHandler = (event) => {\n                if (event.data?.type === \"KERNEL_INITIALIZED\") {\n                    if (event.data.data.success) {\n                        port1.removeEventListener('message', initHandler);\n                        resolve();\n                    }\n                    else {\n                        port1.removeEventListener('message', initHandler);\n                        reject(new Error(\"Kernel initialization failed\"));\n                    }\n                }\n            };\n            port1.addEventListener('message', initHandler);\n        });\n        // Send the port to the worker\n        worker.postMessage({ type: \"SET_EVENT_PORT\", port: port2 }, [port2]);\n        // Create a proxy to the worker using Comlink\n        const kernelProxy = comlink__WEBPACK_IMPORTED_MODULE_0__.wrap(worker);\n        // Add a local event handler to bridge the worker events\n        // This works around the limitation that Comlink doesn't proxy event emitters\n        const eventHandler = (event) => {\n            if (event.data && event.data.type) {\n                // Emit the event from the manager with kernel ID\n                // This structure matches the setupEventForwarding method for main thread kernels\n                super.emit(event.data.type, {\n                    kernelId: id,\n                    data: event.data.data\n                });\n            }\n        };\n        // Listen for events from the worker\n        port1.addEventListener('message', eventHandler);\n        port1.start();\n        // Initialize the kernel with filesystem options\n        // We need to pass these options to the worker\n        worker.postMessage({\n            type: \"INITIALIZE_KERNEL\",\n            options: {\n                filesystem: options.filesystem,\n                env: options.env,\n                lockFileURL: options.lockFileURL,\n                autoSyncFs: options.autoSyncFs,\n                lang: language\n            }\n        });\n        // Wait for kernel initialization\n        await initPromise;\n        // Set up interrupt buffer automatically for worker kernels\n        await this.setupWorkerInterruptBuffer(id, worker);\n        // Create the kernel instance\n        const instance = {\n            id,\n            kernel: {\n                // Map methods from the Comlink proxy to the IKernel interface\n                initialize: async (options) => {\n                    return kernelProxy.initialize(options);\n                },\n                execute: async (code, parent) => {\n                    const result = await kernelProxy.execute(code, parent);\n                    // Handle Python worker results (no special display reconstruction needed)\n                    return result;\n                },\n                isInitialized: () => {\n                    return kernelProxy.isInitialized();\n                },\n                inputReply: async (content) => {\n                    return kernelProxy.inputReply(content);\n                },\n                // Map async getStatus method\n                getStatus: async () => {\n                    try {\n                        if (typeof kernelProxy.getStatus === 'function') {\n                            return await kernelProxy.getStatus();\n                        }\n                        else {\n                            return \"unknown\";\n                        }\n                    }\n                    catch (error) {\n                        return \"unknown\";\n                    }\n                },\n                // Map completion methods\n                complete: async (code, cursor_pos, parent) => {\n                    try {\n                        if (typeof kernelProxy.complete === 'function') {\n                            return await kernelProxy.complete(code, cursor_pos, parent);\n                        }\n                        else {\n                            return { status: 'error', error: 'Completion not supported' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                inspect: async (code, cursor_pos, detail_level, parent) => {\n                    try {\n                        if (typeof kernelProxy.inspect === 'function') {\n                            return await kernelProxy.inspect(code, cursor_pos, detail_level, parent);\n                        }\n                        else {\n                            return { status: 'error', error: 'Inspection not supported' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                isComplete: async (code, parent) => {\n                    try {\n                        if (typeof kernelProxy.isComplete === 'function') {\n                            return await kernelProxy.isComplete(code, parent);\n                        }\n                        else {\n                            return { status: 'unknown' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                // Map interrupt methods\n                interrupt: async () => {\n                    try {\n                        if (typeof kernelProxy.interrupt === 'function') {\n                            return await kernelProxy.interrupt();\n                        }\n                        else {\n                            return false;\n                        }\n                    }\n                    catch (error) {\n                        return false;\n                    }\n                },\n                setInterruptBuffer: (buffer) => {\n                    try {\n                        if (typeof kernelProxy.setInterruptBuffer === 'function') {\n                            kernelProxy.setInterruptBuffer(buffer);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to set interrupt buffer:', error);\n                    }\n                },\n                // Map mountFS method\n                mountFS: async (mountPath, dirHandle, permission) => {\n                    try {\n                        if (typeof kernelProxy.mountFS === 'function') {\n                            return await kernelProxy.mountFS(mountPath, dirHandle, permission);\n                        }\n                        else {\n                            throw new Error('mountFS is not supported by this kernel');\n                        }\n                    }\n                    catch (error) {\n                        throw error;\n                    }\n                },\n                // Map comm methods\n                commInfo: async (target_name, parent) => {\n                    try {\n                        if (typeof kernelProxy.commInfo === 'function') {\n                            return await kernelProxy.commInfo(target_name, parent);\n                        }\n                        else {\n                            return { comms: {}, status: 'ok' };\n                        }\n                    }\n                    catch (error) {\n                        return { comms: {}, status: 'error', error: String(error) };\n                    }\n                },\n                commOpen: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commOpen === 'function') {\n                            return await kernelProxy.commOpen(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to open comm:', error);\n                    }\n                },\n                commMsg: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commMsg === 'function') {\n                            return await kernelProxy.commMsg(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to send comm message:', error);\n                    }\n                },\n                commClose: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commClose === 'function') {\n                            return await kernelProxy.commClose(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to close comm:', error);\n                    }\n                }\n            },\n            mode: KernelMode.WORKER,\n            language,\n            worker,\n            created: new Date().toISOString(),\n            options, // Store the options for reference\n            destroy: async () => {\n                // Clean up the worker and event listeners\n                port1.removeEventListener('message', eventHandler);\n                port1.close();\n                worker.terminate();\n                return Promise.resolve();\n            }\n        };\n        return instance;\n    }\n    /**\n     * Setup event forwarding from kernel to manager\n     * @param instance Kernel instance\n     */\n    setupEventForwarding(instance) {\n        // Only needed for main thread kernels as worker events are handled directly\n        if (instance.mode === KernelMode.MAIN_THREAD) {\n            // Forward all kernel events to the manager with kernel ID\n            Object.values(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents).forEach((eventType) => {\n                // Access the kernel as a Kernel instance which extends EventEmitter\n                const kernelEmitter = instance.kernel;\n                // Add event listener to forward events\n                kernelEmitter.on(eventType, (data) => {\n                    super.emit(eventType, {\n                        kernelId: instance.id,\n                        data\n                    });\n                });\n            });\n        }\n    }\n    /**\n     * Get a kernel instance by ID\n     * @param id Kernel ID\n     * @returns Kernel instance or undefined if not found\n     */\n    getKernel(id) {\n        return this.kernels.get(id);\n    }\n    /**\n     * Get a list of all kernel IDs\n     * @returns Array of kernel IDs\n     */\n    getKernelIds() {\n        return Array.from(this.kernels.keys());\n    }\n    /**\n     * Get a list of all kernels with their details\n     * @param namespace Optional namespace to filter kernels by\n     * @returns Array of kernel information objects\n     */\n    async listKernels(namespace) {\n        const filteredKernels = Array.from(this.kernels.entries())\n            .filter(([id]) => {\n            // Filter out pool kernels (temporary kernels with IDs starting with \"pool-\")\n            if (id.startsWith(\"pool-\"))\n                return false;\n            if (!namespace)\n                return true;\n            return id.startsWith(`${namespace}:`);\n        });\n        // Use Promise.all to get all statuses concurrently\n        const kernelInfos = await Promise.all(filteredKernels.map(async ([id, instance]) => {\n            // Extract namespace from id if present\n            const namespaceMatch = id.match(/^([^:]+):/);\n            const extractedNamespace = namespaceMatch ? namespaceMatch[1] : undefined;\n            // Get status using async getStatus method\n            let status = \"unknown\";\n            try {\n                if (instance && instance.kernel && typeof instance.kernel.getStatus === 'function') {\n                    status = await instance.kernel.getStatus();\n                }\n            }\n            catch (error) {\n                console.warn(`Error getting status for kernel ${id}:`, error);\n                status = \"unknown\";\n            }\n            return {\n                id,\n                mode: instance.mode,\n                language: instance.language,\n                status,\n                created: instance.created || new Date().toISOString(),\n                namespace: extractedNamespace,\n                deno: instance.options?.deno\n            };\n        }));\n        return kernelInfos;\n    }\n    /**\n     * Destroy a kernel instance\n     * @param id Kernel ID\n     * @returns Promise resolving when kernel is destroyed\n     */\n    async destroyKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            // Handle gracefully - kernel may already be destroyed\n            return;\n        }\n        // Verify the destroy function exists\n        if (typeof instance.destroy !== 'function') {\n            throw new Error(`Kernel ${id} is missing destroy function (type: ${typeof instance.destroy})`);\n        }\n        // Abort all ongoing operations for this kernel first\n        this.abortAllKernelOperations(id);\n        // Clear any inactivity timer\n        this.clearInactivityTimeout(id);\n        // Clean up execution timeouts\n        if (this.executionTimeouts.has(id)) {\n            const timeouts = this.executionTimeouts.get(id);\n            for (const timeoutId of timeouts.values()) {\n                clearTimeout(timeoutId);\n            }\n            this.executionTimeouts.delete(id);\n        }\n        // Clean up execution start times\n        if (this.executionStartTimes.has(id)) {\n            this.executionStartTimes.delete(id);\n        }\n        // Clean up execution metadata\n        if (this.executionMetadata.has(id)) {\n            this.executionMetadata.delete(id);\n        }\n        // Clean up interrupt buffers\n        if (this.interruptBuffers.has(id)) {\n            this.interruptBuffers.delete(id);\n        }\n        // Clean up ongoing executions tracking\n        this.ongoingExecutions.delete(id);\n        // Clean up activity tracking\n        this.lastActivityTime.delete(id);\n        // Remove all event listeners for this kernel\n        this.removeAllKernelListeners(id);\n        // Destroy the kernel instance\n        await instance.destroy();\n        // Remove the kernel from the map\n        this.kernels.delete(id);\n    }\n    /**\n     * Destroy all kernel instances\n     * @param namespace Optional namespace to filter kernels to destroy\n     * @returns Promise resolving when all kernels are destroyed\n     */\n    async destroyAll(namespace) {\n        const ids = Array.from(this.kernels.keys())\n            .filter(id => {\n            if (!namespace)\n                return true;\n            return id.startsWith(`${namespace}:`);\n        });\n        // Destroy all kernels, but skip incomplete instances\n        const destroyPromises = ids.map(async (id) => {\n            const instance = this.kernels.get(id);\n            if (!instance || typeof instance.destroy !== 'function') {\n                console.warn(`Skipping incomplete kernel instance ${id} during destroyAll`);\n                // Just remove it from the map\n                this.kernels.delete(id);\n                return;\n            }\n            return this.destroyKernel(id);\n        });\n        await Promise.all(destroyPromises);\n        // If no namespace specified, also clean up the pool\n        if (!namespace) {\n            await this.destroyPool();\n        }\n    }\n    /**\n     * Destroy all kernels in the pool\n     * @private\n     */\n    async destroyPool() {\n        const destroyPromises = [];\n        for (const [poolKey, promises] of this.pool.entries()) {\n            for (const kernelPromise of promises) {\n                // Handle each promise - if it resolves, destroy the kernel\n                const destroyPromise = kernelPromise.then(kernel => {\n                    return kernel.destroy();\n                }).catch(error => {\n                    console.error(`Error destroying pool kernel from promise:`, error);\n                    // Don't re-throw to avoid unhandled rejections\n                });\n                destroyPromises.push(destroyPromise);\n            }\n        }\n        // Wait for all pool kernels to be destroyed\n        await Promise.all(destroyPromises);\n        // Clear the pool and prefilling flags\n        this.pool.clear();\n        this.prefillingInProgress.clear();\n    }\n    /**\n     * Register an event listener for a specific kernel's events\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @param listener Event listener\n     */\n    onKernelEvent(kernelId, eventType, listener) {\n        // Check if kernel exists\n        if (!this.kernels.has(kernelId)) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        // Create wrapper that filters events for this specific kernel\n        const wrapper = {\n            original: listener,\n            wrapped: (event) => {\n                if (event.kernelId === kernelId) {\n                    // Pass just the data to the listener\n                    // The data structure is consistent across main thread and worker modes\n                    listener(event.data);\n                }\n            }\n        };\n        // Store the wrapper for later removal\n        this.storeListener(kernelId, eventType, listener, wrapper);\n        // Add the wrapped listener to the manager\n        super.on(eventType, wrapper.wrapped);\n    }\n    /**\n     * Remove an event listener for a specific kernel\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @param listener Event listener\n     */\n    offKernelEvent(kernelId, eventType, listener) {\n        const wrapper = this.getListener(kernelId, eventType, listener);\n        if (wrapper) {\n            // Remove the wrapped listener from the manager\n            super.removeListener(eventType, wrapper.wrapped);\n            // Remove the wrapper from our tracking map\n            this.removeStoredListener(kernelId, eventType, listener);\n        }\n    }\n    /**\n     * Store a listener wrapper for later removal\n     */\n    storeListener(kernelId, eventType, original, wrapper) {\n        // Get or create kernel map\n        if (!this.listenerWrappers.has(kernelId)) {\n            this.listenerWrappers.set(kernelId, new Map());\n        }\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        // Get or create event type map\n        if (!kernelMap.has(eventType)) {\n            kernelMap.set(eventType, new Map());\n        }\n        const eventMap = kernelMap.get(eventType);\n        // Store the wrapper\n        eventMap.set(original, wrapper);\n    }\n    /**\n     * Get a stored listener wrapper\n     */\n    getListener(kernelId, eventType, original) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return undefined;\n        const eventMap = kernelMap.get(eventType);\n        if (!eventMap)\n            return undefined;\n        return eventMap.get(original);\n    }\n    /**\n     * Remove a stored listener wrapper\n     */\n    removeStoredListener(kernelId, eventType, original) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return;\n        const eventMap = kernelMap.get(eventType);\n        if (!eventMap)\n            return;\n        // Remove the listener\n        eventMap.delete(original);\n        // Clean up empty maps\n        if (eventMap.size === 0) {\n            kernelMap.delete(eventType);\n        }\n        if (kernelMap.size === 0) {\n            this.listenerWrappers.delete(kernelId);\n        }\n    }\n    /**\n     * Remove all listeners for a specific kernel\n     */\n    removeAllKernelListeners(kernelId) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return;\n        // For each event type\n        for (const [eventType, eventMap] of kernelMap.entries()) {\n            // For each original listener\n            for (const wrapper of eventMap.values()) {\n                // Remove the wrapped listener from the manager\n                super.removeListener(eventType, wrapper.wrapped);\n            }\n        }\n        // Clear the kernel's listener map\n        this.listenerWrappers.delete(kernelId);\n    }\n    /**\n     * Get all listeners for a specific kernel and event type\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @returns Array of listeners\n     */\n    getListeners(kernelId, eventType) {\n        const kernelListeners = this.listenerWrappers.get(kernelId);\n        if (!kernelListeners) {\n            return [];\n        }\n        const eventListeners = kernelListeners.get(eventType);\n        if (!eventListeners) {\n            return [];\n        }\n        return Array.from(eventListeners.keys());\n    }\n    /**\n     * Execute Python code with streaming output\n     * This method works in both main thread and worker modes\n     * @param kernelId ID of the kernel to use\n     * @param code The Python code to execute\n     * @param parent Optional parent message header\n     * @returns AsyncGenerator yielding intermediate outputs\n     */\n    async *executeStream(kernelId, code, parent = {}) {\n        const instance = this.getKernel(kernelId);\n        if (!instance) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        // Update kernel activity\n        this.updateKernelActivity(kernelId);\n        // Track this execution with the code for better monitoring\n        const executionId = this.trackExecution(kernelId, code);\n        // Create AbortController for this execution to enable cancellation\n        const abortController = new AbortController();\n        this.storeAbortController(kernelId, executionId, abortController);\n        try {\n            // For main thread kernels, we can use the executeStream method directly\n            if (instance.mode === KernelMode.MAIN_THREAD) {\n                const kernel = instance.kernel;\n                // Forward to the kernel's executeStream method\n                if (typeof kernel.executeStream === 'function') {\n                    try {\n                        yield* kernel.executeStream(code, parent);\n                        // Update activity after execution completes\n                        this.updateKernelActivity(kernelId);\n                        // Complete execution tracking\n                        this.completeExecution(kernelId, executionId);\n                        return { success: true };\n                    }\n                    catch (error) {\n                        console.error(`Error in main thread executeStream:`, error);\n                        // Update activity even if there's an error\n                        this.updateKernelActivity(kernelId);\n                        // Complete execution tracking even on error\n                        this.completeExecution(kernelId, executionId);\n                        return {\n                            success: false,\n                            error: error instanceof Error ? error : new Error(String(error))\n                        };\n                    }\n                }\n            }\n            // For worker mode, we need to implement streaming via events with proper isolation\n            try {\n                // Event-based approach for worker kernels or main thread kernels without executeStream\n                const streamQueue = [];\n                let executionComplete = false;\n                let executionResult = { success: true };\n                // Store handler references for guaranteed cleanup\n                const eventHandlers = new Map();\n                // Helper function to clean up all event handlers\n                const cleanupHandlers = () => {\n                    for (const [eventType, handler] of eventHandlers.entries()) {\n                        super.off(eventType, handler);\n                    }\n                    eventHandlers.clear();\n                };\n                // Create execution-specific event handlers that include executionId check\n                const createHandler = (eventType) => {\n                    const handler = (event) => {\n                        // Only process events for this specific kernel and while this execution is active\n                        if (event.kernelId === kernelId && !executionComplete) {\n                            streamQueue.push({\n                                type: eventType,\n                                data: event.data,\n                                executionId // Include execution ID for debugging\n                            });\n                            // Events also count as activity\n                            this.updateKernelActivity(kernelId);\n                        }\n                    };\n                    eventHandlers.set(eventType, handler);\n                    return handler;\n                };\n                // Create and register all event handlers\n                const handleStreamEvent = createHandler('stream');\n                const handleDisplayEvent = createHandler('display_data');\n                const handleUpdateDisplayEvent = createHandler('update_display_data');\n                const handleResultEvent = createHandler('execute_result');\n                const handleErrorEvent = createHandler('execute_error');\n                // Register handlers\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.STREAM, handleStreamEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.DISPLAY_DATA, handleDisplayEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.UPDATE_DISPLAY_DATA, handleUpdateDisplayEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_RESULT, handleResultEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, handleErrorEvent);\n                // Create a promise that will resolve when execution is complete\n                const executionPromise = new Promise((resolve, reject) => {\n                    // Set up a handler for execution errors specifically\n                    const handleExecutionError = (event) => {\n                        if (event.kernelId === kernelId && !executionComplete) {\n                            // Mark execution as complete to stop processing more events\n                            executionComplete = true;\n                            // Store the error for the final result\n                            executionResult = {\n                                success: false,\n                                error: new Error(`${event.data.ename}: ${event.data.evalue}`),\n                                result: event.data\n                            };\n                            // Update activity\n                            this.updateKernelActivity(kernelId);\n                            resolve(executionResult);\n                        }\n                    };\n                    // Add error handler to our cleanup list\n                    eventHandlers.set('execute_error_completion', handleExecutionError);\n                    super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, handleExecutionError);\n                    // Check if already aborted\n                    if (abortController.signal.aborted) {\n                        executionComplete = true;\n                        resolve({\n                            success: false,\n                            error: new Error('Execution was aborted')\n                        });\n                        return;\n                    }\n                    // Set up abort handler\n                    const abortHandler = () => {\n                        if (!executionComplete) {\n                            console.log(`ðŸš« Execution ${executionId} aborted`);\n                            executionComplete = true;\n                            resolve({\n                                success: false,\n                                error: new Error('Execution was aborted')\n                            });\n                        }\n                    };\n                    abortController.signal.addEventListener('abort', abortHandler);\n                    // Execute the code\n                    // We know the execute method is available directly on the kernel object\n                    try {\n                        const executePromise = instance.kernel.execute(code, parent);\n                        executePromise.then((result) => {\n                            // Only process if execution hasn't been marked complete already\n                            if (!executionComplete) {\n                                // Check if the execution result indicates an error (for Python kernels)\n                                if (result.success && result.result && result.result.status === \"error\") {\n                                    // Handle as error\n                                    const errorData = {\n                                        status: result.result.status,\n                                        ename: result.result.ename,\n                                        evalue: result.result.evalue,\n                                        traceback: result.result.traceback\n                                    };\n                                    // Push error to stream queue directly \n                                    streamQueue.push({\n                                        type: 'error',\n                                        data: errorData,\n                                        executionId\n                                    });\n                                    // Update execution result to reflect the error\n                                    executionResult = {\n                                        success: false,\n                                        error: new Error(`${result.result.ename}: ${result.result.evalue}`),\n                                        result: result.result\n                                    };\n                                }\n                                else {\n                                    executionResult = result;\n                                }\n                                executionComplete = true;\n                                // Update activity when execution completes\n                                this.updateKernelActivity(kernelId);\n                                resolve(executionResult);\n                            }\n                        }).catch((error) => {\n                            // Only process if execution hasn't been marked complete already\n                            if (!executionComplete) {\n                                console.error(`Error in execute for kernel ${kernelId}:`, error);\n                                // Check if this is a KeyboardInterrupt and handle it specially\n                                let errorResult;\n                                if (this.isKeyboardInterrupt(error)) {\n                                    console.log(`KeyboardInterrupt caught in executeStream for kernel ${kernelId}`);\n                                    errorResult = this.createKeyboardInterruptResult();\n                                    // Also push to stream queue for immediate feedback\n                                    streamQueue.push({\n                                        type: 'error',\n                                        data: errorResult.result,\n                                        executionId\n                                    });\n                                }\n                                else {\n                                    // Handle other errors normally\n                                    errorResult = {\n                                        success: false,\n                                        error: error instanceof Error ? error : new Error(String(error))\n                                    };\n                                }\n                                executionComplete = true;\n                                executionResult = errorResult;\n                                // Update activity even on error\n                                this.updateKernelActivity(kernelId);\n                                resolve(errorResult);\n                            }\n                        });\n                    }\n                    catch (error) {\n                        // Only process if execution hasn't been marked complete already\n                        if (!executionComplete) {\n                            console.error(`Error calling execute for kernel ${kernelId}:`, error);\n                            // Simple error handling\n                            const errorResult = {\n                                success: false,\n                                error: error instanceof Error ? error : new Error(String(error))\n                            };\n                            executionComplete = true;\n                            executionResult = errorResult;\n                            // Update activity even on direct error\n                            this.updateKernelActivity(kernelId);\n                            resolve(errorResult);\n                        }\n                    }\n                });\n                // Use try/finally to guarantee cleanup\n                try {\n                    // Monitor the stream queue and yield results\n                    // Continue until execution is complete AND all queued events have been yielded\n                    while ((!executionComplete || streamQueue.length > 0) && !abortController.signal.aborted) {\n                        // If there are items in the queue, yield them\n                        if (streamQueue.length > 0) {\n                            const event = streamQueue.shift();\n                            yield event;\n                            continue;\n                        }\n                        // If no more events but execution is not complete, wait a little\n                        if (!executionComplete) {\n                            // Use abort signal to cancel the wait\n                            try {\n                                await new Promise((resolve, reject) => {\n                                    const timeoutId = setTimeout(resolve, 10);\n                                    abortController.signal.addEventListener('abort', () => {\n                                        clearTimeout(timeoutId);\n                                        reject(new Error('Aborted'));\n                                    });\n                                });\n                            }\n                            catch (error) {\n                                // If aborted, break out of loop\n                                if (abortController.signal.aborted) {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    // Check if execution was aborted during stream monitoring\n                    if (abortController.signal.aborted && !executionComplete) {\n                        throw new Error('Execution was aborted during stream monitoring');\n                    }\n                    // Wait for the final result\n                    const result = await executionPromise;\n                    return result;\n                }\n                finally {\n                    // ALWAYS clean up event handlers regardless of how execution ends\n                    cleanupHandlers();\n                    // Remove AbortController to prevent memory leaks\n                    this.removeAbortController(kernelId, executionId);\n                    // Complete execution tracking\n                    this.completeExecution(kernelId, executionId);\n                }\n            }\n            catch (error) {\n                // Complete execution tracking on any outer error\n                this.completeExecution(kernelId, executionId);\n                console.error(`Unexpected error in executeStream:`, error);\n                return {\n                    success: false,\n                    error: error instanceof Error ? error : new Error(String(error))\n                };\n            }\n        }\n        catch (error) {\n            // Complete execution tracking on any outer error\n            this.completeExecution(kernelId, executionId);\n            console.error(`Unexpected error in executeStream:`, error);\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    /**\n     * Track a new execution task for a kernel\n     * @param kernelId Kernel ID\n     * @param code Optional code being executed for metadata\n     * @returns Unique execution ID\n     * @private\n     */\n    trackExecution(kernelId, code) {\n        // Create a unique execution ID\n        const executionId = `exec-${crypto.randomUUID()}`;\n        const startTime = Date.now();\n        // Reset interrupt buffer for worker kernels before each new execution\n        // This ensures the kernel can be interrupted multiple times\n        const instance = this.kernels.get(kernelId);\n        if (instance && instance.mode === KernelMode.WORKER && this.interruptBuffers.has(kernelId)) {\n            const interruptBuffer = this.interruptBuffers.get(kernelId);\n            // Reset buffer to 0 (no interrupt signal) to ensure clean state\n            interruptBuffer[0] = 0;\n        }\n        // Get or create the set of ongoing executions for this kernel\n        if (!this.ongoingExecutions.has(kernelId)) {\n            this.ongoingExecutions.set(kernelId, new Set());\n        }\n        // Add this execution to the set\n        this.ongoingExecutions.get(kernelId).add(executionId);\n        // Track execution start time\n        if (!this.executionStartTimes.has(kernelId)) {\n            this.executionStartTimes.set(kernelId, new Map());\n        }\n        this.executionStartTimes.get(kernelId).set(executionId, startTime);\n        // Track execution metadata\n        if (!this.executionMetadata.has(kernelId)) {\n            this.executionMetadata.set(kernelId, new Map());\n        }\n        // Update activity timestamp\n        this.updateKernelActivity(kernelId);\n        // If maxExecutionTime is set, create a timeout to detect stuck/dead kernels\n        if (instance && instance.options.maxExecutionTime && instance.options.maxExecutionTime > 0) {\n            // Get or create the map of execution timeouts for this kernel\n            if (!this.executionTimeouts.has(kernelId)) {\n                this.executionTimeouts.set(kernelId, new Map());\n            }\n            // Set a timeout for this execution with enhanced handling\n            const timeoutId = setTimeout(() => {\n                console.warn(`Execution ${executionId} on kernel ${kernelId} has been running for ${instance.options.maxExecutionTime}ms and may be stuck/dead.`);\n                // Get execution metadata for better error reporting\n                const metadata = this.executionMetadata.get(kernelId)?.get(executionId);\n                const actualRuntime = Date.now() - (metadata?.startTime || startTime);\n                // Emit a stalled execution event with enhanced information\n                super.emit('execution_stalled', {\n                    kernelId,\n                    executionId,\n                    maxExecutionTime: instance.options.maxExecutionTime,\n                    actualRuntime,\n                    code: metadata?.code || code,\n                    startTime: metadata?.startTime || startTime\n                });\n                // Auto-handle stuck execution if configured\n                this.handleStuckExecution(kernelId, executionId, actualRuntime, metadata?.code || code);\n            }, instance.options.maxExecutionTime);\n            // Store the timeout ID\n            this.executionTimeouts.get(kernelId).set(executionId, timeoutId);\n            // Store metadata including timeout ID\n            this.executionMetadata.get(kernelId).set(executionId, {\n                startTime,\n                code,\n                timeoutId\n            });\n        }\n        else {\n            // Store metadata without timeout ID\n            this.executionMetadata.get(kernelId).set(executionId, {\n                startTime,\n                code\n            });\n        }\n        return executionId;\n    }\n    /**\n     * Complete tracking for an execution\n     * @param kernelId Kernel ID\n     * @param executionId Execution ID\n     * @private\n     */\n    completeExecution(kernelId, executionId) {\n        // Clear any execution timeout\n        if (this.executionTimeouts.has(kernelId)) {\n            const timeouts = this.executionTimeouts.get(kernelId);\n            if (timeouts.has(executionId)) {\n                clearTimeout(timeouts.get(executionId));\n                timeouts.delete(executionId);\n            }\n            // Clean up empty maps\n            if (timeouts.size === 0) {\n                this.executionTimeouts.delete(kernelId);\n            }\n        }\n        // Clean up execution start times\n        if (this.executionStartTimes.has(kernelId)) {\n            const startTimes = this.executionStartTimes.get(kernelId);\n            startTimes.delete(executionId);\n            // Clean up empty maps\n            if (startTimes.size === 0) {\n                this.executionStartTimes.delete(kernelId);\n            }\n        }\n        // Clean up execution metadata\n        if (this.executionMetadata.has(kernelId)) {\n            const metadata = this.executionMetadata.get(kernelId);\n            metadata.delete(executionId);\n            // Clean up empty maps\n            if (metadata.size === 0) {\n                this.executionMetadata.delete(kernelId);\n            }\n        }\n        // Remove from ongoing executions\n        if (this.ongoingExecutions.has(kernelId)) {\n            const executions = this.ongoingExecutions.get(kernelId);\n            executions.delete(executionId);\n            // Clean up empty sets\n            if (executions.size === 0) {\n                this.ongoingExecutions.delete(kernelId);\n                // Update activity timestamp for completed execution\n                this.updateKernelActivity(kernelId);\n            }\n        }\n    }\n    /**\n     * Check if a kernel has any ongoing executions\n     * @param kernelId Kernel ID\n     * @returns True if the kernel has ongoing executions\n     * @private\n     */\n    hasOngoingExecutions(kernelId) {\n        return this.ongoingExecutions.has(kernelId) &&\n            this.ongoingExecutions.get(kernelId).size > 0;\n    }\n    /**\n     * Get the count of ongoing executions for a kernel\n     * @param id Kernel ID\n     * @returns Number of ongoing executions\n     */\n    getOngoingExecutionCount(id) {\n        if (!this.ongoingExecutions.has(id)) {\n            return 0;\n        }\n        return this.ongoingExecutions.get(id).size;\n    }\n    /**\n     * Set up an inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @param timeout Timeout in milliseconds\n     * @private\n     */\n    setupInactivityTimeout(id, timeout) {\n        // Don't set up a timer if timeout is 0 or negative\n        if (timeout <= 0) {\n            return;\n        }\n        // Always clear any existing timer first\n        this.clearInactivityTimeout(id);\n        // Calculate remaining time based on last activity\n        const lastActivity = this.lastActivityTime.get(id) || Date.now();\n        const elapsed = Date.now() - lastActivity;\n        const remainingTime = Math.max(0, timeout - elapsed);\n        // If no time remaining, destroy immediately\n        if (remainingTime === 0) {\n            // Check if the kernel has ongoing executions before shutting down\n            if (this.hasOngoingExecutions(id)) {\n                // Reset the timer to check again later\n                this.setupInactivityTimeout(id, timeout);\n                return;\n            }\n            // Destroy immediately\n            this.destroyKernel(id).catch(error => {\n                console.error(`Error destroying inactive kernel ${id}:`, error);\n            });\n            return;\n        }\n        // Create a timer to destroy the kernel after the remaining timeout\n        const timer = setTimeout(() => {\n            // Check if the kernel has ongoing executions before shutting down\n            if (this.hasOngoingExecutions(id)) {\n                // Reset the timer to check again later\n                this.setupInactivityTimeout(id, timeout);\n                return;\n            }\n            this.destroyKernel(id).catch(error => {\n                console.error(`Error destroying inactive kernel ${id}:`, error);\n            });\n        }, remainingTime);\n        // Store the timer ID\n        this.inactivityTimers.set(id, timer);\n    }\n    /**\n     * Clear any existing inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @private\n     */\n    clearInactivityTimeout(id) {\n        if (this.inactivityTimers.has(id)) {\n            const timerId = this.inactivityTimers.get(id);\n            clearTimeout(timerId);\n            this.inactivityTimers.delete(id);\n        }\n    }\n    /**\n     * Update activity timestamp for a kernel and reset inactivity timer if present\n     * @param id Kernel ID\n     * @private\n     */\n    updateKernelActivity(id) {\n        // Update the last activity time\n        this.lastActivityTime.set(id, Date.now());\n        // Get the kernel options\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return;\n        const timeout = instance.options.inactivityTimeout;\n        // Reset the inactivity timer if timeout is enabled (greater than 0)\n        if (timeout && timeout > 0) {\n            this.setupInactivityTimeout(id, timeout);\n        }\n    }\n    /**\n     * Get the last activity time for a kernel\n     * @param id Kernel ID\n     * @returns Last activity time in milliseconds since epoch, or undefined if not found\n     */\n    getLastActivityTime(id) {\n        return this.lastActivityTime.get(id);\n    }\n    /**\n     * Get the inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @returns Inactivity timeout in milliseconds, or undefined if not set\n     */\n    getInactivityTimeout(id) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return undefined;\n        return instance.options.inactivityTimeout;\n    }\n    /**\n     * Set or update the inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @param timeout Timeout in milliseconds, or 0 to disable\n     * @returns True if the timeout was set, false if the kernel was not found\n     */\n    setInactivityTimeout(id, timeout) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return false;\n        // Update the timeout in the options\n        instance.options.inactivityTimeout = timeout;\n        // Clear any existing timer\n        this.clearInactivityTimeout(id);\n        // If timeout is greater than 0, set up a new timer\n        if (timeout > 0) {\n            this.setupInactivityTimeout(id, timeout);\n        }\n        return true;\n    }\n    /**\n     * Get time until auto-shutdown for a kernel\n     * @param id Kernel ID\n     * @returns Time in milliseconds until auto-shutdown, or undefined if no timeout is set\n     */\n    getTimeUntilShutdown(id) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return undefined;\n        const timeout = instance.options.inactivityTimeout;\n        if (!timeout || timeout <= 0)\n            return undefined;\n        const lastActivity = this.lastActivityTime.get(id);\n        if (!lastActivity)\n            return undefined;\n        const elapsedTime = Date.now() - lastActivity;\n        const remainingTime = timeout - elapsedTime;\n        return Math.max(0, remainingTime);\n    }\n    /**\n     * Get the map of inactivity timers (for debugging/testing only)\n     * @returns Object with kernel IDs as keys and timer IDs as values\n     */\n    getInactivityTimers() {\n        // Convert Map to Object for easier inspection\n        const timers = {};\n        this.inactivityTimers.forEach((value, key) => {\n            timers[key] = value;\n        });\n        return timers;\n    }\n    /**\n     * Set up a handler for stalled executions\n     * @param id Kernel ID\n     * @private\n     */\n    setupStalledExecutionHandler(id) {\n        // Listen for stalled execution events\n        super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTION_STALLED, (event) => {\n            if (event.kernelId === id) {\n                console.warn(`Handling stalled execution ${event.executionId} on kernel ${id} (running longer than ${event.maxExecutionTime}ms)`);\n                // Emit an event for clients to handle\n                const instance = this.kernels.get(id);\n                if (instance) {\n                    super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                        kernelId: id,\n                        data: {\n                            ename: \"ExecutionStalledError\",\n                            evalue: `Execution stalled or potentially deadlocked (running > ${event.maxExecutionTime}ms)`,\n                            traceback: [\"Execution may be stuck in an infinite loop or deadlocked.\"]\n                        }\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * Force terminate a potentially stuck kernel\n     * @param id Kernel ID\n     * @param reason Optional reason for termination\n     * @returns Promise resolving to true if the kernel was terminated\n     */\n    async forceTerminateKernel(id, reason = \"Force terminated due to stalled execution\") {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return false;\n        }\n        try {\n            // Log the forced termination\n            console.warn(`Force terminating kernel ${id}: ${reason}`);\n            // Emit an error event to notify clients\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: id,\n                data: {\n                    ename: \"KernelForcedTermination\",\n                    evalue: reason,\n                    traceback: [\"Kernel was forcefully terminated by the system.\"]\n                }\n            });\n            // Destroy the kernel\n            await this.destroyKernel(id);\n            return true;\n        }\n        catch (error) {\n            console.error(`Error during forced termination of kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Get information about ongoing executions for a kernel\n     * @param id Kernel ID\n     * @returns Information about ongoing executions with accurate timing\n     */\n    getExecutionInfo(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return { count: 0, isStuck: false, executionIds: [], executions: [] };\n        }\n        // Handle partially initialized kernels where options may not be fully set\n        if (!instance.options) {\n            return { count: 0, isStuck: false, executionIds: [], executions: [] };\n        }\n        const executionIds = this.ongoingExecutions.get(id)\n            ? Array.from(this.ongoingExecutions.get(id))\n            : [];\n        const count = executionIds.length;\n        const currentTime = Date.now();\n        const maxExecutionTime = instance.options.maxExecutionTime;\n        // Build detailed execution information\n        const executions = [];\n        let longestRunningTime = undefined;\n        let anyStuck = false;\n        // Get execution start times and metadata\n        const startTimes = this.executionStartTimes.get(id);\n        const metadata = this.executionMetadata.get(id);\n        for (const executionId of executionIds) {\n            const startTime = startTimes?.get(executionId);\n            const execMetadata = metadata?.get(executionId);\n            if (startTime !== undefined) {\n                const runtime = currentTime - startTime;\n                const isStuck = maxExecutionTime !== undefined && runtime > maxExecutionTime;\n                executions.push({\n                    id: executionId,\n                    startTime,\n                    runtime,\n                    code: execMetadata?.code,\n                    isStuck\n                });\n                // Track longest running time\n                if (longestRunningTime === undefined || runtime > longestRunningTime) {\n                    longestRunningTime = runtime;\n                }\n                // Track if any execution is stuck\n                if (isStuck) {\n                    anyStuck = true;\n                }\n            }\n            else {\n                // Fallback for executions without start time tracking\n                console.warn(`No start time found for execution ${executionId} on kernel ${id}`);\n                executions.push({\n                    id: executionId,\n                    startTime: 0,\n                    runtime: 0,\n                    code: execMetadata?.code,\n                    isStuck: false\n                });\n            }\n        }\n        // Sort executions by start time (oldest first)\n        executions.sort((a, b) => a.startTime - b.startTime);\n        return {\n            count,\n            isStuck: anyStuck,\n            executionIds,\n            longestRunningTime,\n            executions\n        };\n    }\n    /**\n     * Execute Python code in a kernel\n     * Uses executeStream to collect all outputs and return them\n     * @param kernelId ID of the kernel to use\n     * @param code Python code to execute\n     * @param parent Optional parent message header\n     * @returns Promise resolving to execution result with collected outputs\n     */\n    async execute(kernelId, code, parent = {}) {\n        const instance = this.getKernel(kernelId);\n        if (!instance) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        return await instance.kernel.execute(code, parent);\n    }\n    /**\n     * Check if a kernel type is allowed\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns True if the kernel type is allowed\n     * @private\n     */\n    isKernelTypeAllowed(mode, language) {\n        return this.allowedKernelTypes.some(type => type.mode === mode && type.language === language);\n    }\n    /**\n     * Get the list of allowed kernel types\n     * @returns Array of allowed kernel type configurations\n     */\n    getAllowedKernelTypes() {\n        return [...this.allowedKernelTypes]; // Return a copy to prevent modification\n    }\n    /**\n     * Ping a kernel to reset its activity timer and extend the deadline\n     * @param id Kernel ID\n     * @returns True if the kernel was pinged successfully, false if not found\n     */\n    pingKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return false;\n        }\n        // Update kernel activity (this will reset the inactivity timer)\n        this.updateKernelActivity(id);\n        return true;\n    }\n    /**\n     * Restart a kernel by destroying it and creating a new one with the same ID and configuration\n     * @param id Kernel ID\n     * @returns Promise resolving to true if the kernel was restarted successfully, false if not found\n     */\n    async restartKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            console.warn(`Cannot restart kernel ${id}: kernel not found`);\n            return false;\n        }\n        try {\n            // Store the current configuration\n            const currentConfig = {\n                mode: instance.mode,\n                language: instance.language,\n                options: { ...instance.options }\n            };\n            // Extract namespace from ID if present\n            let namespace;\n            let baseId;\n            if (id.includes(':')) {\n                const parts = id.split(':');\n                namespace = parts[0];\n                baseId = parts[1];\n            }\n            else {\n                baseId = id;\n            }\n            // Destroy the existing kernel\n            await this.destroyKernel(id);\n            // Create a new kernel with the same configuration\n            const restartOptions = {\n                id: baseId,\n                mode: currentConfig.mode,\n                lang: currentConfig.language,\n                namespace,\n                deno: currentConfig.options.deno,\n                filesystem: currentConfig.options.filesystem,\n                inactivityTimeout: currentConfig.options.inactivityTimeout,\n                maxExecutionTime: currentConfig.options.maxExecutionTime\n            };\n            // Create the new kernel\n            const newKernelId = await this.createKernel(restartOptions);\n            // Verify the new kernel has the same ID\n            if (newKernelId !== id) {\n                console.error(`Kernel restart failed: expected ID ${id}, got ${newKernelId}`);\n                return false;\n            }\n            return true;\n        }\n        catch (error) {\n            console.error(`Error restarting kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Interrupt a running kernel execution\n     * @param id Kernel ID\n     * @returns Promise resolving to true if the interrupt was successful, false if not found or failed\n     */\n    async interruptKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            console.warn(`Cannot interrupt kernel ${id}: kernel not found`);\n            return false;\n        }\n        try {\n            if (instance.mode === KernelMode.WORKER && instance.worker) {\n                // For worker kernels, use SharedArrayBuffer interrupt method\n                return await this.interruptWorkerKernel(id, instance);\n            }\n            else {\n                // For main thread kernels, try to interrupt (will throw error if not supported)\n                return await this.interruptMainThreadKernel(id, instance);\n            }\n        }\n        catch (error) {\n            console.error(`Error interrupting kernel ${id}:`, error instanceof Error ? error.message : String(error));\n            return false;\n        }\n    }\n    /**\n     * Interrupt a main thread kernel\n     * @param id Kernel ID\n     * @param instance Kernel instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptMainThreadKernel(id, instance) {\n        // Main thread kernels don't support proper interruption like worker kernels do\n        // Even if they have an interrupt method, it's limited and unreliable\n        throw new Error(`Main thread kernel ${id} does not support reliable interruption. Use worker kernels for interruptible execution.`);\n    }\n    /**\n     * Interrupt a worker kernel using SharedArrayBuffer according to Pyodide documentation\n     * @param id Kernel ID\n     * @param instance Kernel instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptWorkerKernel(id, instance) {\n        try {\n            const worker = instance.worker;\n            if (!worker) {\n                console.error(`Worker not found for kernel ${id}`);\n                return false;\n            }\n            // If interruption mode is 'kernel-interrupt', use fallback directly\n            if (this.interruptionMode === 'kernel-interrupt') {\n                return await this.interruptWorkerKernelFallback(id, worker);\n            }\n            // Check if we already have an interrupt buffer for this kernel\n            let interruptBuffer = this.interruptBuffers.get(id);\n            if (!interruptBuffer) {\n                // Create a new SharedArrayBuffer for interrupt control\n                try {\n                    // Try to create SharedArrayBuffer (requires specific security headers)\n                    const sharedBuffer = new SharedArrayBuffer(1);\n                    interruptBuffer = new Uint8Array(sharedBuffer);\n                    // Initialize buffer to 0 (no interrupt signal)\n                    interruptBuffer[0] = 0;\n                    // Store the buffer for future use\n                    this.interruptBuffers.set(id, interruptBuffer);\n                    // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n                    worker.postMessage({\n                        type: \"SET_INTERRUPT_BUFFER\",\n                        buffer: interruptBuffer\n                    });\n                    // Wait for the worker to confirm buffer setup\n                    await new Promise((resolve, reject) => {\n                        const timeout = setTimeout(() => {\n                            reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n                        }, 2000);\n                        const handler = (event) => {\n                            if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n                                worker.removeEventListener(\"message\", handler);\n                                clearTimeout(timeout);\n                                resolve();\n                            }\n                        };\n                        worker.addEventListener(\"message\", handler);\n                    });\n                    console.log(`Interrupt buffer set up for kernel ${id}`);\n                }\n                catch (error) {\n                    // Handle based on interruption mode\n                    if (this.interruptionMode === 'shared-array-buffer') {\n                        // If explicitly set to shared-array-buffer, this is an error\n                        console.error(`âŒ Cannot create SharedArrayBuffer for interrupt handling in kernel ${id}`);\n                        throw new Error(`SharedArrayBuffer is required for interruption mode 'shared-array-buffer' but is not available.\n\nTo fix this issue, either:\n1. Configure your web server with these headers:\n   - Cross-Origin-Opener-Policy: same-origin\n   - Cross-Origin-Embedder-Policy: require-corp\n\n2. Or change the interruption mode when creating KernelManager:\n   new KernelManager({ interruptionMode: 'auto' })`);\n                    }\n                    else {\n                        // Auto mode: fall back to kernel.interrupt()\n                        console.info(`â„¹ï¸ Using message-based interrupt for kernel ${id} (SharedArrayBuffer not available)`);\n                        // Fallback: use message-based interrupt\n                        return await this.interruptWorkerKernelFallback(id, worker);\n                    }\n                }\n            }\n            // According to Pyodide docs: Set interrupt signal (2 = SIGINT)\n            console.log(`Setting interrupt signal for kernel ${id}...`);\n            interruptBuffer[0] = 2;\n            // Wait for Pyodide to process the interrupt\n            // Pyodide will reset the buffer to 0 when it processes the interrupt\n            let attempts = 0;\n            const maxAttempts = 50; // Check for up to 5 seconds (50 * 100ms)\n            while (attempts < maxAttempts && interruptBuffer[0] !== 0) {\n                await new Promise(resolve => setTimeout(resolve, 100));\n                attempts++;\n            }\n            if (interruptBuffer[0] === 0) {\n                console.log(`Interrupt processed successfully for kernel ${id} after ${attempts * 100}ms`);\n                return true;\n            }\n            else {\n                console.warn(`Interrupt signal not processed for kernel ${id} after ${maxAttempts * 100}ms`);\n                // Still return true as we set the signal - the interrupt may be processed later\n                return true;\n            }\n        }\n        catch (error) {\n            console.error(`Error interrupting worker kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Fallback interrupt method for worker kernels when SharedArrayBuffer is not available\n     * @param id Kernel ID\n     * @param worker Worker instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptWorkerKernelFallback(id, worker) {\n        return new Promise((resolve) => {\n            // Set up a listener for the interrupt response\n            const responseHandler = (event) => {\n                if (event.data?.type === \"INTERRUPT_TRIGGERED\") {\n                    worker.removeEventListener(\"message\", responseHandler);\n                    const success = event.data.data?.success || false;\n                    resolve(success);\n                }\n            };\n            // Listen for the response\n            worker.addEventListener(\"message\", responseHandler);\n            // Send the interrupt message\n            worker.postMessage({\n                type: \"INTERRUPT_KERNEL\"\n            });\n            // Set a timeout in case we don't get a response\n            setTimeout(() => {\n                worker.removeEventListener(\"message\", responseHandler);\n                console.warn(`â±ï¸ Interrupt request timed out for kernel ${id} after 5 seconds.\nThis may happen if:\n- The kernel is running code that cannot be interrupted\n- The kernel is in an unresponsive state\nYou may need to restart the kernel if it remains unresponsive.`);\n                resolve(false);\n            }, 5000); // 5 second timeout\n        });\n    }\n    /**\n     * Handle a stuck execution with configurable strategies\n     * @param kernelId Kernel ID\n     * @param executionId Execution ID that's stuck\n     * @param actualRuntime How long the execution has been running\n     * @param code The code that was being executed\n     * @private\n     */\n    async handleStuckExecution(kernelId, executionId, actualRuntime, code) {\n        const instance = this.kernels.get(kernelId);\n        if (!instance) {\n            return;\n        }\n        console.warn(`Handling stuck execution ${executionId} on kernel ${kernelId} (runtime: ${actualRuntime}ms)`);\n        // Strategy 1: Try to interrupt the kernel first\n        const interruptSuccess = await this.interruptKernel(kernelId);\n        if (interruptSuccess) {\n            console.log(`Successfully interrupted kernel ${kernelId}`);\n            // Emit an execution error to notify clients\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: kernelId,\n                data: {\n                    ename: \"ExecutionInterrupted\",\n                    evalue: `Execution automatically interrupted after ${actualRuntime}ms (exceeded maxExecutionTime)`,\n                    traceback: [\n                        `Execution was automatically interrupted due to timeout.`,\n                        `Runtime: ${actualRuntime}ms`,\n                        `Max allowed: ${instance.options.maxExecutionTime}ms`,\n                        code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n                    ]\n                }\n            });\n            return;\n        }\n        // Strategy 2: If interrupt failed, try restarting the kernel\n        console.warn(`Interrupt failed for kernel ${kernelId}, attempting restart...`);\n        const restartSuccess = await this.restartKernel(kernelId);\n        if (restartSuccess) {\n            console.log(`Successfully restarted kernel ${kernelId}`);\n            // Emit a restart notification\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: kernelId,\n                data: {\n                    ename: \"KernelRestarted\",\n                    evalue: `Kernel automatically restarted due to stuck execution (runtime: ${actualRuntime}ms)`,\n                    traceback: [\n                        `Kernel was automatically restarted due to stuck execution.`,\n                        `Runtime: ${actualRuntime}ms`,\n                        `Max allowed: ${instance.options.maxExecutionTime}ms`,\n                        `Interrupt attempt failed, kernel was restarted instead.`,\n                        code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n                    ]\n                }\n            });\n            return;\n        }\n        // Strategy 3: If restart failed, force terminate the kernel\n        console.error(`Restart failed for kernel ${kernelId}, force terminating...`);\n        const terminateSuccess = await this.forceTerminateKernel(kernelId, `Stuck execution could not be interrupted or restarted (runtime: ${actualRuntime}ms)`);\n        if (terminateSuccess) {\n            console.log(`Successfully terminated kernel ${kernelId}`);\n        }\n        else {\n            console.error(`Failed to terminate kernel ${kernelId} - manual intervention may be required`);\n            // Emit a critical error\n            super.emit('kernel_unrecoverable', {\n                kernelId: kernelId,\n                executionId: executionId,\n                actualRuntime: actualRuntime,\n                code: code,\n                message: 'Kernel is stuck and could not be recovered through interrupt, restart, or termination'\n            });\n        }\n    }\n    /**\n     * Get detailed information about stuck executions across all kernels\n     * @returns Array of stuck execution details\n     */\n    getStuckExecutions() {\n        const stuckExecutions = [];\n        const currentTime = Date.now();\n        for (const [kernelId, instance] of this.kernels.entries()) {\n            // Skip pool kernels\n            if (kernelId.startsWith(\"pool-\"))\n                continue;\n            // Skip kernels without maxExecutionTime configured\n            if (!instance.options?.maxExecutionTime || instance.options.maxExecutionTime <= 0) {\n                continue;\n            }\n            const maxExecutionTime = instance.options.maxExecutionTime;\n            const startTimes = this.executionStartTimes.get(kernelId);\n            const metadata = this.executionMetadata.get(kernelId);\n            const ongoingExecs = this.ongoingExecutions.get(kernelId);\n            if (!ongoingExecs || ongoingExecs.size === 0) {\n                continue;\n            }\n            for (const executionId of ongoingExecs) {\n                const startTime = startTimes?.get(executionId);\n                if (startTime === undefined)\n                    continue;\n                const runtime = currentTime - startTime;\n                // Check if this execution is stuck\n                if (runtime > maxExecutionTime) {\n                    const execMetadata = metadata?.get(executionId);\n                    stuckExecutions.push({\n                        kernelId,\n                        executionId,\n                        startTime,\n                        runtime,\n                        maxAllowed: maxExecutionTime,\n                        code: execMetadata?.code,\n                        kernelMode: instance.mode,\n                        kernelLanguage: instance.language\n                    });\n                }\n            }\n        }\n        // Sort by runtime (longest running first)\n        stuckExecutions.sort((a, b) => b.runtime - a.runtime);\n        return stuckExecutions;\n    }\n    /**\n     * Force interrupt all stuck executions across all kernels\n     * @returns Promise resolving to array of intervention results\n     */\n    async handleAllStuckExecutions() {\n        const stuckExecutions = this.getStuckExecutions();\n        const results = [];\n        console.log(`Found ${stuckExecutions.length} stuck executions to handle`);\n        // Group by kernel to avoid multiple interventions on the same kernel\n        const kernelGroups = new Map();\n        for (const exec of stuckExecutions) {\n            if (!kernelGroups.has(exec.kernelId)) {\n                kernelGroups.set(exec.kernelId, []);\n            }\n            kernelGroups.get(exec.kernelId).push(exec);\n        }\n        // Handle each kernel's stuck executions\n        for (const [kernelId, executions] of kernelGroups) {\n            try {\n                // Pick the longest running execution as the primary one\n                const primaryExec = executions[0]; // Already sorted by runtime desc\n                console.log(`Handling stuck kernel ${kernelId} with ${executions.length} stuck executions (primary: ${primaryExec.runtime}ms)`);\n                // Use the automated handling system\n                await this.handleStuckExecution(kernelId, primaryExec.executionId, primaryExec.runtime, primaryExec.code);\n                // Mark all executions for this kernel as handled\n                for (const exec of executions) {\n                    results.push({\n                        kernelId: exec.kernelId,\n                        executionId: exec.executionId,\n                        action: 'interrupted', // We don't know the exact action, but it was handled\n                        success: true\n                    });\n                }\n            }\n            catch (error) {\n                console.error(`Error handling stuck executions for kernel ${kernelId}:`, error);\n                // Mark all executions for this kernel as failed\n                for (const exec of executions) {\n                    results.push({\n                        kernelId: exec.kernelId,\n                        executionId: exec.executionId,\n                        action: 'failed',\n                        success: false,\n                        error: error instanceof Error ? error.message : String(error)\n                    });\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * Set up interrupt buffer for a worker kernel during creation\n     * @param id Kernel ID\n     * @param worker Worker instance\n     * @private\n     */\n    async setupWorkerInterruptBuffer(id, worker) {\n        // Skip SharedArrayBuffer setup if mode is 'kernel-interrupt'\n        if (this.interruptionMode === 'kernel-interrupt') {\n            console.log(`Skipping SharedArrayBuffer setup for kernel ${id} - using kernel.interrupt() mode`);\n            return;\n        }\n        try {\n            // Python kernels support interrupt buffers\n            // For Python kernels, create actual SharedArrayBuffer\n            const sharedBuffer = new SharedArrayBuffer(1);\n            const interruptBuffer = new Uint8Array(sharedBuffer);\n            // Initialize buffer to 0 (no interrupt signal)\n            interruptBuffer[0] = 0;\n            // Store the buffer for future use\n            this.interruptBuffers.set(id, interruptBuffer);\n            // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n            worker.postMessage({\n                type: \"SET_INTERRUPT_BUFFER\",\n                buffer: interruptBuffer\n            });\n            // Wait for the worker to confirm buffer setup\n            await new Promise((resolve, reject) => {\n                const timeout = setTimeout(() => {\n                    reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n                }, 5000);\n                const handler = (event) => {\n                    if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n                        worker.removeEventListener(\"message\", handler);\n                        clearTimeout(timeout);\n                        resolve();\n                    }\n                };\n                worker.addEventListener(\"message\", handler);\n            });\n        }\n        catch (error) {\n            // Handle based on interruption mode\n            if (this.interruptionMode === 'shared-array-buffer') {\n                // If explicitly set to shared-array-buffer, this is an error\n                console.error(`âŒ SharedArrayBuffer required but not available for kernel ${id}`);\n                throw new Error(`SharedArrayBuffer is required but not available. To enable SharedArrayBuffer, your server must set these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nAlternatively, use interruptionMode: 'kernel-interrupt' or 'auto' in KernelManager options.`);\n            }\n            else {\n                // Auto mode: fall back to kernel.interrupt()\n                console.info(`â„¹ï¸ SharedArrayBuffer not available for kernel ${id}. Using alternative interrupt method.\n\nTo enable faster interrupts, configure your server with these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nNote: Some development servers (e.g., Vite, webpack-dev-server) can be configured to add these headers.\nThe alternative interrupt method will still work but may be less responsive for long-running code.`);\n                // Don't throw - kernel can still work without interrupt buffer\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSSxLQUFLLENBQUM7Ozs7NEZBSW9FLENBQUMsQ0FBQztZQUN4RixDQUFDO2lCQUFNLENBQUM7Z0JBQ04sNkNBQTZDO2dCQUM3QyxPQUFPLENBQUMsSUFBSSxDQUFDLGlEQUFpRCxFQUFFOzs7Ozs7O21HQU8yQixDQUFDLENBQUM7Z0JBQzdGLCtEQUErRDtZQUNqRSxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7Q0FDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1weXRob24ta2VybmVsLy4vc3JjL21hbmFnZXIudHM/OTM2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBLZXJuZWwgTWFuYWdlciBmb3IgRGVubyBBcHAgRW5naW5lXG4vLyBUaGlzIGZpbGUgbWFuYWdlcyBrZXJuZWwgaW5zdGFuY2VzIGluIGVpdGhlciBtYWluIHRocmVhZCBvciB3b3JrZXIgbW9kZVxuXG5pbXBvcnQgKiBhcyBDb21saW5rIGZyb20gXCJjb21saW5rXCI7XG4vLyBAdHMtaWdub3JlIEltcG9ydGluZyBmcm9tIG5wbVxuLy8gVXNlIGEgYnJvd3Nlci1jb21wYXRpYmxlIEV2ZW50RW1pdHRlclxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSBldmVudHM6IHsgW2tleTogc3RyaW5nXTogRnVuY3Rpb25bXSB9ID0ge307XG5cbiAgb24oZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikge1xuICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgb2ZmKGV2ZW50TmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogRnVuY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHJldHVybjtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWU6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cblxuICBlbWl0KGV2ZW50TmFtZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkgcmV0dXJuO1xuICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lciguLi5hcmdzKSk7XG4gIH1cblxuICBzZXRNYXhMaXN0ZW5lcnMobjogbnVtYmVyKSB7XG4gICAgLy8gTm8tb3AgZm9yIGJyb3dzZXIgY29tcGF0aWJpbGl0eVxuICB9XG59XG5pbXBvcnQgeyBLZXJuZWxFdmVudHMsIElLZXJuZWwsIElLZXJuZWxPcHRpb25zLCBJRmlsZXN5c3RlbU1vdW50T3B0aW9ucyB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBLZXJuZWwgfSBmcm9tIFwiLi9pbmRleFwiO1xuXG4vLyBSZS1leHBvcnQgS2VybmVsRXZlbnRzIGZvciB0ZXN0IHVzYWdlXG5leHBvcnQgeyBLZXJuZWxFdmVudHMgfTtcblxuLy8gRXhlY3V0aW9uIG1vZGUgZW51bVxuZXhwb3J0IGVudW0gS2VybmVsTW9kZSB7XG4gIE1BSU5fVEhSRUFEID0gXCJtYWluX3RocmVhZFwiLFxuICBXT1JLRVIgPSBcIndvcmtlclwiXG59XG5cbi8vIEtlcm5lbCBsYW5ndWFnZSBlbnVtXG5leHBvcnQgZW51bSBLZXJuZWxMYW5ndWFnZSB7XG4gIFBZVEhPTiA9IFwicHl0aG9uXCJcbn1cblxuLy8gRXh0ZW5kZWQgV29ya2VyT3B0aW9ucyBpbnRlcmZhY2UgdG8gaW5jbHVkZSBEZW5vIHBlcm1pc3Npb25zXG5pbnRlcmZhY2UgV29ya2VyT3B0aW9ucyB7XG4gIHR5cGU/OiBcImNsYXNzaWNcIiB8IFwibW9kdWxlXCI7XG4gIG5hbWU/OiBzdHJpbmc7XG4gIGRlbm8/OiB7XG4gICAgcGVybWlzc2lvbnM/OiBJRGVub1Blcm1pc3Npb25zO1xuICB9O1xufVxuXG4vLyBJbnRlcmZhY2UgZm9yIGtlcm5lbCBwb29sIGNvbmZpZ3VyYXRpb25cbmV4cG9ydCBpbnRlcmZhY2UgSUtlcm5lbFBvb2xDb25maWcge1xuICBlbmFibGVkOiBib29sZWFuO1xuICBwb29sU2l6ZTogbnVtYmVyOyAvLyBOdW1iZXIgb2Yga2VybmVscyB0byBrZWVwIHJlYWR5IHBlciBjb25maWd1cmF0aW9uXG4gIGF1dG9SZWZpbGw6IGJvb2xlYW47IC8vIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSByZWZpbGwgdGhlIHBvb2wgd2hlbiBrZXJuZWxzIGFyZSB0YWtlblxuICBwcmVsb2FkQ29uZmlnczogQXJyYXk8e1xuICAgIG1vZGU6IEtlcm5lbE1vZGU7XG4gICAgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlO1xuICB9PjsgLy8gQ29uZmlndXJhdGlvbnMgdG8gcHJlbG9hZCBpbiB0aGUgcG9vbFxufVxuXG4vLyBJbnRlcmZhY2UgZm9yIGtlcm5lbCBtYW5hZ2VyIG9wdGlvbnNcbmV4cG9ydCBpbnRlcmZhY2UgSUtlcm5lbE1hbmFnZXJPcHRpb25zIHtcbiAgcG9vbD86IElLZXJuZWxQb29sQ29uZmlnO1xuICBhbGxvd2VkS2VybmVsVHlwZXM/OiBBcnJheTx7XG4gICAgbW9kZTogS2VybmVsTW9kZTtcbiAgICBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gIH0+OyAvLyBSZXN0cmljdCB3aGljaCBrZXJuZWwgdHlwZXMgY2FuIGJlIGNyZWF0ZWRcbiAgaW50ZXJydXB0aW9uTW9kZT86ICdzaGFyZWQtYXJyYXktYnVmZmVyJyB8ICdrZXJuZWwtaW50ZXJydXB0JyB8ICdhdXRvJzsgLy8gRGVmYXVsdDogJ2F1dG8nXG4gIHdvcmtlclVybD86IHN0cmluZzsgLy8gT3B0aW9uYWwgY3VzdG9tIFVSTCBmb3IgdGhlIHdvcmtlciBzY3JpcHRcbn1cblxuLy8gSW50ZXJmYWNlIGZvciBrZXJuZWwgaW5zdGFuY2VcbmV4cG9ydCBpbnRlcmZhY2UgSUtlcm5lbEluc3RhbmNlIHtcbiAgaWQ6IHN0cmluZztcbiAga2VybmVsOiBJS2VybmVsO1xuICBtb2RlOiBLZXJuZWxNb2RlO1xuICBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gIHdvcmtlcj86IFdvcmtlcjtcbiAgY3JlYXRlZDogc3RyaW5nO1xuICBvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnM7XG4gIGlzRnJvbVBvb2w/OiBib29sZWFuOyAvLyBUcmFjayBpZiB0aGlzIGtlcm5lbCBjYW1lIGZyb20gdGhlIHBvb2xcbiAgZGVzdHJveSgpOiBQcm9taXNlPHZvaWQ+O1xufVxuXG4vLyBJbnRlcmZhY2UgZm9yIERlbm8gd29ya2VyIHBlcm1pc3Npb25zXG5leHBvcnQgaW50ZXJmYWNlIElEZW5vUGVybWlzc2lvbnMge1xuICByZWFkPzogKHN0cmluZyB8IFVSTClbXTtcbiAgd3JpdGU/OiAoc3RyaW5nIHwgVVJMKVtdO1xuICBuZXQ/OiBzdHJpbmdbXTtcbiAgZW52Pzogc3RyaW5nW107XG4gIHJ1bj86IHN0cmluZ1tdO1xuICBmZmk/OiBzdHJpbmdbXTtcbiAgaHJ0aW1lPzogYm9vbGVhbjtcbn1cblxuLy8gSW50ZXJmYWNlIGZvciBrZXJuZWwgY3JlYXRpb24gb3B0aW9uc1xuZXhwb3J0IGludGVyZmFjZSBJTWFuYWdlcktlcm5lbE9wdGlvbnMge1xuICBpZD86IHN0cmluZztcbiAgbW9kZT86IEtlcm5lbE1vZGU7XG4gIGxhbmc/OiBLZXJuZWxMYW5ndWFnZTtcbiAgbmFtZXNwYWNlPzogc3RyaW5nO1xuICBkZW5vPzoge1xuICAgIHBlcm1pc3Npb25zPzogSURlbm9QZXJtaXNzaW9ucztcbiAgfTtcbiAgZmlsZXN5c3RlbT86IElGaWxlc3lzdGVtTW91bnRPcHRpb25zO1xuICBlbnY/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+OyAvLyBFbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gc2V0IGluIHRoZSBrZXJuZWxcbiAgbG9ja0ZpbGVVUkw/OiBzdHJpbmc7IC8vIFVSTCB0byBweW9kaWRlLWxvY2suanNvbiBmaWxlIGZvciBmYXN0ZXIgbG9hZGluZ1xuICBhdXRvU3luY0ZzPzogYm9vbGVhbjsgLy8gQXV0b21hdGljYWxseSBzeW5jIG5hdGl2ZSBmaWxlc3lzdGVtIGFmdGVyIGNvZGUgZXhlY3V0aW9uIChkZWZhdWx0OiBmYWxzZSlcbiAgaW5hY3Rpdml0eVRpbWVvdXQ/OiBudW1iZXI7IC8vIFRpbWUgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIGFuIGluYWN0aXZlIGtlcm5lbCB3aWxsIGJlIHNodXQgZG93blxuICBtYXhFeGVjdXRpb25UaW1lPzogbnVtYmVyOyAvLyBNYXhpbXVtIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGEgc2luZ2xlIGV4ZWN1dGlvbiBjYW4gcnVuIGJlZm9yZSBjb25zaWRlcmVkIHN0dWNrL2RlYWRcbn1cblxuLy8gSGVscGVyIHR5cGUgZm9yIGxpc3RlbmVyIG1hbmFnZW1lbnRcbnR5cGUgTGlzdGVuZXJXcmFwcGVyID0ge1xuICBvcmlnaW5hbDogKGRhdGE6IGFueSkgPT4gdm9pZDtcbiAgd3JhcHBlZDogKGV2ZW50OiB7IGtlcm5lbElkOiBzdHJpbmcsIGRhdGE6IGFueSB9KSA9PiB2b2lkO1xufTtcblxuLyoqXG4gKiBLZXJuZWxNYW5hZ2VyIGNsYXNzIG1hbmFnZXMgbXVsdGlwbGUga2VybmVsIGluc3RhbmNlcyBcbiAqIGluIGVpdGhlciBtYWluIHRocmVhZCBvciB3b3JrZXIgbW9kZVxuICovXG5leHBvcnQgY2xhc3MgS2VybmVsTWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUga2VybmVsczogTWFwPHN0cmluZywgSUtlcm5lbEluc3RhbmNlPiA9IG5ldyBNYXAoKTtcbiAgLy8gVHJhY2sgbGlzdGVuZXJzIGZvciBlYWNoIGtlcm5lbCB0byBlbmFibGUgaW5kaXZpZHVhbCByZW1vdmFsXG4gIHByaXZhdGUgbGlzdGVuZXJXcmFwcGVyczogTWFwPHN0cmluZywgTWFwPHN0cmluZywgTWFwPEZ1bmN0aW9uLCBMaXN0ZW5lcldyYXBwZXI+Pj4gPSBuZXcgTWFwKCk7XG4gIC8vIFRyYWNrIGxhc3QgYWN0aXZpdHkgdGltZSBmb3IgZWFjaCBrZXJuZWxcbiAgcHJpdmF0ZSBsYXN0QWN0aXZpdHlUaW1lOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICAvLyBTdG9yZSBpbmFjdGl2aXR5IHRpbWVycyBmb3IgZWFjaCBrZXJuZWxcbiAgcHJpdmF0ZSBpbmFjdGl2aXR5VGltZXJzOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcCgpO1xuICAvLyBUcmFjayBvbmdvaW5nIGV4ZWN1dGlvbnMgZm9yIGVhY2gga2VybmVsXG4gIHByaXZhdGUgb25nb2luZ0V4ZWN1dGlvbnM6IE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PiA9IG5ldyBNYXAoKTtcbiAgLy8gVHJhY2sgZXhlY3V0aW9uIHRpbWVvdXRzIGZvciBkZXRlY3Rpbmcgc3R1Y2svZGVhZCBrZXJuZWxzXG4gIHByaXZhdGUgZXhlY3V0aW9uVGltZW91dHM6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIGFueT4+ID0gbmV3IE1hcCgpO1xuICAvLyBUcmFjayBleGVjdXRpb24gc3RhcnQgdGltZXMgZm9yIGFjY3VyYXRlIGR1cmF0aW9uIGNhbGN1bGF0aW9uXG4gIHByaXZhdGUgZXhlY3V0aW9uU3RhcnRUaW1lczogTWFwPHN0cmluZywgTWFwPHN0cmluZywgbnVtYmVyPj4gPSBuZXcgTWFwKCk7XG4gIC8vIFRyYWNrIGV4ZWN1dGlvbiBtZXRhZGF0YSBmb3IgYmV0dGVyIG1vbml0b3JpbmdcbiAgcHJpdmF0ZSBleGVjdXRpb25NZXRhZGF0YTogTWFwPHN0cmluZywgTWFwPHN0cmluZywgeyBzdGFydFRpbWU6IG51bWJlcjsgY29kZT86IHN0cmluZzsgdGltZW91dElkPzogYW55IH0+PiA9IG5ldyBNYXAoKTtcbiAgXG4gIC8vIFRyYWNrIEFib3J0Q29udHJvbGxlcnMgZm9yIGVhY2gga2VybmVsJ3Mgb25nb2luZyBvcGVyYXRpb25zXG4gIHByaXZhdGUgYWJvcnRDb250cm9sbGVyczogTWFwPHN0cmluZywgTWFwPHN0cmluZywgQWJvcnRDb250cm9sbGVyPj4gPSBuZXcgTWFwKCk7XG4gIFxuICAvLyBQb29sIG1hbmFnZW1lbnQgLSBub3cgdXNpbmcgcHJvbWlzZXMgZm9yIGltbWVkaWF0ZSByZXNwb25zZVxuICBwcml2YXRlIHBvb2w6IE1hcDxzdHJpbmcsIFByb21pc2U8SUtlcm5lbEluc3RhbmNlPltdPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBwb29sQ29uZmlnOiBJS2VybmVsUG9vbENvbmZpZztcbiAgcHJpdmF0ZSBpc1ByZWxvYWRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgLy8gVHJhY2sgd2hpY2ggcG9vbCBrZXlzIGFyZSBjdXJyZW50bHkgYmVpbmcgcHJlZmlsbGVkIHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICBwcml2YXRlIHByZWZpbGxpbmdJblByb2dyZXNzOiBNYXA8c3RyaW5nLCBib29sZWFuPiA9IG5ldyBNYXAoKTtcbiAgXG4gIC8vIEFsbG93ZWQga2VybmVsIHR5cGVzIGNvbmZpZ3VyYXRpb25cbiAgcHJpdmF0ZSBhbGxvd2VkS2VybmVsVHlwZXM6IEFycmF5PHtcbiAgICBtb2RlOiBLZXJuZWxNb2RlO1xuICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgfT47XG4gIFxuICAvLyBJbnRlcnJ1cHQgYnVmZmVycyBmb3Igd29ya2VyIGtlcm5lbHMgKHVzaW5nIFNoYXJlZEFycmF5QnVmZmVyKVxuICBwcml2YXRlIGludGVycnVwdEJ1ZmZlcnM6IE1hcDxzdHJpbmcsIFVpbnQ4QXJyYXk+ID0gbmV3IE1hcCgpO1xuICBcbiAgLy8gSW50ZXJydXB0aW9uIG1vZGUgY29uZmlndXJhdGlvblxuICBwcml2YXRlIGludGVycnVwdGlvbk1vZGU6ICdzaGFyZWQtYXJyYXktYnVmZmVyJyB8ICdrZXJuZWwtaW50ZXJydXB0JyB8ICdhdXRvJztcbiAgXG4gIC8vIFdvcmtlciBVUkwgY29uZmlndXJhdGlvblxuICBwcml2YXRlIHdvcmtlclVybDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBcbiAgLyoqXG4gICAqIFJlc29sdmUgdGhlIHdvcmtlciBVUkwgYmFzZWQgb24gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMgVGhlIHJlc29sdmVkIHdvcmtlciBVUkxcbiAgICovXG4gIHByaXZhdGUgcmVzb2x2ZVdvcmtlclVybCgpOiBzdHJpbmcge1xuICAgIC8vIElmIGEgY3VzdG9tIHdvcmtlciBVUkwgaXMgcHJvdmlkZWQsIHVzZSBpdFxuICAgIGlmICh0aGlzLndvcmtlclVybCkge1xuICAgICAgcmV0dXJuIHRoaXMud29ya2VyVXJsO1xuICAgIH1cbiAgICBcbiAgICAvLyBUcnkgdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNjcmlwdCBsb2NhdGlvbiBhbmQgZGVyaXZlIHRoZSB3b3JrZXIgVVJMXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhdGlvbikge1xuICAgICAgLy8gQnJvd3NlciBlbnZpcm9ubWVudFxuICAgICAgY29uc3QgY3VycmVudFNjcmlwdCA9IChkb2N1bWVudC5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmZyb20oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpKS5wb3AoKTtcbiAgICAgIFxuICAgICAgaWYgKGN1cnJlbnRTY3JpcHQgJiYgY3VycmVudFNjcmlwdC5zcmMpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBiYXNlIFVSTCBmcm9tIHRoZSBjdXJyZW50IHNjcmlwdFxuICAgICAgICBjb25zdCBzY3JpcHRVcmwgPSBuZXcgVVJMKGN1cnJlbnRTY3JpcHQuc3JjKTtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IHNjcmlwdFVybC5ocmVmLnN1YnN0cmluZygwLCBzY3JpcHRVcmwuaHJlZi5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGxvYWRpbmcgZnJvbSBhIENETiAoanNkZWxpdnIsIHVucGtnLCBldGMuKVxuICAgICAgICBpZiAoc2NyaXB0VXJsLmhvc3RuYW1lLmluY2x1ZGVzKCdqc2RlbGl2ci5uZXQnKSB8fCBcbiAgICAgICAgICAgIHNjcmlwdFVybC5ob3N0bmFtZS5pbmNsdWRlcygndW5wa2cuY29tJykgfHxcbiAgICAgICAgICAgIHNjcmlwdFVybC5ob3N0bmFtZS5pbmNsdWRlcygnY2RuanMuY2xvdWRmbGFyZS5jb20nKSkge1xuICAgICAgICAgIC8vIEZvciBDRE4sIHRoZSB3b3JrZXIgc2hvdWxkIGJlIGF0IHRoZSBzYW1lIHBhdGhcbiAgICAgICAgICByZXR1cm4gYCR7YmFzZVVybH0va2VybmVsLndvcmtlci5qc2A7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEZvciBsb2NhbCBkZXZlbG9wbWVudCBvciBjdXN0b20gZGVwbG95bWVudHNcbiAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2tlcm5lbC53b3JrZXIuanNgO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGYWxsYmFjayB0byByZWxhdGl2ZSBwYXRoIGZyb20gY3VycmVudCBsb2NhdGlvblxuICAgICAgY29uc3QgYmFzZVVybCA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyaW5nKDAsIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9kaXN0L2tlcm5lbC53b3JrZXIuanNgO1xuICAgIH1cbiAgICBcbiAgICAvLyBOb2RlLmpzIG9yIHVua25vd24gZW52aXJvbm1lbnQgLSB1c2UgcmVsYXRpdmUgcGF0aFxuICAgIC8vIFRoaXMgbWF5IG5vdCB3b3JrIGluIE5vZGUuanMgYnV0IGlzIHByb3ZpZGVkIGFzIGEgZmFsbGJhY2tcbiAgICByZXR1cm4gJy4va2VybmVsLndvcmtlci5qcyc7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYW4gZXJyb3IgaXMgYSBLZXlib2FyZEludGVycnVwdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBpc0tleWJvYXJkSW50ZXJydXB0KGVycm9yOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZXJyb3IgJiYgXG4gICAgICAgICAgIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgXG4gICAgICAgICAgICgoJ3R5cGUnIGluIGVycm9yICYmIGVycm9yLnR5cGUgPT09IFwiS2V5Ym9hcmRJbnRlcnJ1cHRcIikgfHxcbiAgICAgICAgICAgICgnbWVzc2FnZScgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJLZXlib2FyZEludGVycnVwdFwiKSkpO1xuICB9XG4gIFxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHN0YW5kYXJkaXplZCBLZXlib2FyZEludGVycnVwdCBlcnJvciByZXN1bHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlS2V5Ym9hcmRJbnRlcnJ1cHRSZXN1bHQoKTogeyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcjogRXJyb3I7IHJlc3VsdDogYW55IH0ge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBuZXcgRXJyb3IoXCJLZXlib2FyZEludGVycnVwdDogRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXJcIiksXG4gICAgICByZXN1bHQ6IHtcbiAgICAgICAgc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICAgIGVuYW1lOiBcIktleWJvYXJkSW50ZXJydXB0XCIsXG4gICAgICAgIGV2YWx1ZTogXCJFeGVjdXRpb24gaW50ZXJydXB0ZWQgYnkgdXNlclwiLFxuICAgICAgICB0cmFjZWJhY2s6IFtcIktleWJvYXJkSW50ZXJydXB0OiBFeGVjdXRpb24gaW50ZXJydXB0ZWQgYnkgdXNlclwiXVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTdG9yZSBhbiBBYm9ydENvbnRyb2xsZXIgZm9yIGEgc3BlY2lmaWMga2VybmVsIGV4ZWN1dGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzdG9yZUFib3J0Q29udHJvbGxlcihrZXJuZWxJZDogc3RyaW5nLCBleGVjdXRpb25JZDogc3RyaW5nLCBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuYWJvcnRDb250cm9sbGVycy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICB0aGlzLmFib3J0Q29udHJvbGxlcnMuc2V0KGtlcm5lbElkLCBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICB0aGlzLmFib3J0Q29udHJvbGxlcnMuZ2V0KGtlcm5lbElkKSEuc2V0KGV4ZWN1dGlvbklkLCBjb250cm9sbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW5kIHJldHVybiBhbiBBYm9ydENvbnRyb2xsZXIgZm9yIGEgc3BlY2lmaWMga2VybmVsIGV4ZWN1dGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVBYm9ydENvbnRyb2xsZXIoa2VybmVsSWQ6IHN0cmluZywgZXhlY3V0aW9uSWQ6IHN0cmluZyk6IEFib3J0Q29udHJvbGxlciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qga2VybmVsQ29udHJvbGxlcnMgPSB0aGlzLmFib3J0Q29udHJvbGxlcnMuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAoIWtlcm5lbENvbnRyb2xsZXJzKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBrZXJuZWxDb250cm9sbGVycy5nZXQoZXhlY3V0aW9uSWQpO1xuICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICBrZXJuZWxDb250cm9sbGVycy5kZWxldGUoZXhlY3V0aW9uSWQpO1xuICAgICAgaWYgKGtlcm5lbENvbnRyb2xsZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXJzLmRlbGV0ZShrZXJuZWxJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sbGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEFib3J0IGFsbCBvbmdvaW5nIG9wZXJhdGlvbnMgZm9yIGEgc3BlY2lmaWMga2VybmVsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFib3J0QWxsS2VybmVsT3BlcmF0aW9ucyhrZXJuZWxJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3Qga2VybmVsQ29udHJvbGxlcnMgPSB0aGlzLmFib3J0Q29udHJvbGxlcnMuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAoIWtlcm5lbENvbnRyb2xsZXJzKSByZXR1cm47XG5cbiAgICBmb3IgKGNvbnN0IFtleGVjdXRpb25JZCwgY29udHJvbGxlcl0gb2Yga2VybmVsQ29udHJvbGxlcnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgY29uc29sZS5sb2coYPCfmqsgQWJvcnRlZCBleGVjdXRpb24gJHtleGVjdXRpb25JZH0gZm9yIGtlcm5lbCAke2tlcm5lbElkfWApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gRXJyb3IgYWJvcnRpbmcgZXhlY3V0aW9uICR7ZXhlY3V0aW9uSWR9OmAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYXIgYWxsIGNvbnRyb2xsZXJzIGZvciB0aGlzIGtlcm5lbFxuICAgIHRoaXMuYWJvcnRDb250cm9sbGVycy5kZWxldGUoa2VybmVsSWQpO1xuICB9XG4gIFxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBJS2VybmVsTWFuYWdlck9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgc3VwZXIuc2V0TWF4TGlzdGVuZXJzKDEwMCk7IC8vIEFsbG93IG1hbnkgbGlzdGVuZXJzIGZvciBrZXJuZWwgZXZlbnRzXG4gICAgXG4gICAgLy8gU2V0IGludGVycnVwdGlvbiBtb2RlIChkZWZhdWx0IHRvICdhdXRvJylcbiAgICB0aGlzLmludGVycnVwdGlvbk1vZGUgPSBvcHRpb25zLmludGVycnVwdGlvbk1vZGUgfHwgJ2F1dG8nO1xuICAgIFxuICAgIC8vIFNldCB3b3JrZXIgVVJMIGlmIHByb3ZpZGVkXG4gICAgdGhpcy53b3JrZXJVcmwgPSBvcHRpb25zLndvcmtlclVybDtcbiAgICBcbiAgICAvLyBTZXQgZGVmYXVsdCBhbGxvd2VkIGtlcm5lbCB0eXBlcyAod29ya2VyIG1vZGUgb25seSBmb3Igc2VjdXJpdHkpXG4gICAgdGhpcy5hbGxvd2VkS2VybmVsVHlwZXMgPSBvcHRpb25zLmFsbG93ZWRLZXJuZWxUeXBlcyB8fCBbXG4gICAgICB7IG1vZGU6IEtlcm5lbE1vZGUuV09SS0VSLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UuUFlUSE9OIH1cbiAgICBdO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgcG9vbCBjb25maWd1cmF0aW9uIHdpdGggZGVmYXVsdHMgYmFzZWQgb24gYWxsb3dlZCB0eXBlc1xuICAgIGNvbnN0IGRlZmF1bHRQcmVsb2FkQ29uZmlncyA9IHRoaXMuYWxsb3dlZEtlcm5lbFR5cGVzLmZpbHRlcih0eXBlID0+IFxuICAgICAgdHlwZS5sYW5ndWFnZSA9PT0gS2VybmVsTGFuZ3VhZ2UuUFlUSE9OIC8vIE9ubHkgcHJlbG9hZCBQeXRob24ga2VybmVscyBieSBkZWZhdWx0XG4gICAgKTtcbiAgICBcbiAgICB0aGlzLnBvb2xDb25maWcgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIHBvb2xTaXplOiAyLFxuICAgICAgYXV0b1JlZmlsbDogdHJ1ZSxcbiAgICAgIHByZWxvYWRDb25maWdzOiBkZWZhdWx0UHJlbG9hZENvbmZpZ3MsXG4gICAgICAuLi5vcHRpb25zLnBvb2xcbiAgICB9O1xuICAgIFxuICAgIC8vIFZhbGlkYXRlIHRoYXQgcG9vbCBwcmVsb2FkIGNvbmZpZ3MgYXJlIHdpdGhpbiBhbGxvd2VkIHR5cGVzXG4gICAgaWYgKHRoaXMucG9vbENvbmZpZy5wcmVsb2FkQ29uZmlncykge1xuICAgICAgdGhpcy5wb29sQ29uZmlnLnByZWxvYWRDb25maWdzID0gdGhpcy5wb29sQ29uZmlnLnByZWxvYWRDb25maWdzLmZpbHRlcihjb25maWcgPT4ge1xuICAgICAgICBjb25zdCBpc0FsbG93ZWQgPSB0aGlzLmlzS2VybmVsVHlwZUFsbG93ZWQoY29uZmlnLm1vZGUsIGNvbmZpZy5sYW5ndWFnZSk7XG4gICAgICAgIGlmICghaXNBbGxvd2VkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBQb29sIHByZWxvYWQgY29uZmlnICR7Y29uZmlnLm1vZGV9LSR7Y29uZmlnLmxhbmd1YWdlfSBpcyBub3QgaW4gYWxsb3dlZEtlcm5lbFR5cGVzLCBza2lwcGluZ2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FsbG93ZWQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RhcnQgcHJlbG9hZGluZyBpZiBwb29sIGlzIGVuYWJsZWRcbiAgICBpZiAodGhpcy5wb29sQ29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMucHJlbG9hZFBvb2woKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwcmVsb2FkaW5nIGtlcm5lbCBwb29sOlwiLCBlcnJvcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIFxuICAvKipcbiAgICogR2VuZXJhdGUgYSBwb29sIGtleSBmb3IgYSBnaXZlbiBtb2RlIGFuZCBsYW5ndWFnZSBjb21iaW5hdGlvblxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIFBvb2wga2V5IHN0cmluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRQb29sS2V5KG1vZGU6IEtlcm5lbE1vZGUsIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke21vZGV9LSR7bGFuZ3VhZ2V9YDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhIGtlcm5lbCBwcm9taXNlIGZyb20gdGhlIHBvb2wgaWYgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHJldHVybnMgS2VybmVsIHByb21pc2Ugb3IgbnVsbCBpZiBub25lIGF2YWlsYWJsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRGcm9tUG9vbChtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UpOiBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT4gfCBudWxsIHtcbiAgICBpZiAoIXRoaXMucG9vbENvbmZpZy5lbmFibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcG9vbEtleSA9IHRoaXMuZ2V0UG9vbEtleShtb2RlLCBsYW5ndWFnZSk7XG4gICAgY29uc3QgcG9vbFByb21pc2VzID0gdGhpcy5wb29sLmdldChwb29sS2V5KTtcbiAgICBcbiAgICBpZiAoIXBvb2xQcm9taXNlcyB8fCBwb29sUHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVtb3ZlIGFuZCByZXR1cm4gdGhlIGZpcnN0IHByb21pc2UgZnJvbSB0aGUgcG9vbCAoRklGTylcbiAgICBjb25zdCBrZXJuZWxQcm9taXNlID0gcG9vbFByb21pc2VzLnNoaWZ0KCkhO1xuICAgIFxuICAgIC8vIEltbWVkaWF0ZWx5IHRyaWdnZXIgYmFja2dyb3VuZCByZWZpbGwgdG8gYWRkIG9uZSBwcm9taXNlIGJhY2tcbiAgICBpZiAodGhpcy5wb29sQ29uZmlnLmF1dG9SZWZpbGwpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnJlZmlsbFBvb2xTaW5nbGUobW9kZSwgbGFuZ3VhZ2UpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZWZpbGxpbmcgc2luZ2xlIGtlcm5lbCBmb3IgJHtwb29sS2V5fTpgLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBrZXJuZWxQcm9taXNlO1xuICB9XG4gIFxuICAvKipcbiAgICogQWRkIGEga2VybmVsIHByb21pc2UgdG8gdGhlIHBvb2xcbiAgICogQHBhcmFtIG1vZGUgS2VybmVsIG1vZGVcbiAgICogQHBhcmFtIGxhbmd1YWdlIEtlcm5lbCBsYW5ndWFnZVxuICAgKiBAcGFyYW0ga2VybmVsUHJvbWlzZSBLZXJuZWwgcHJvbWlzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhZGRUb1Bvb2wobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlLCBrZXJuZWxQcm9taXNlOiBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT4pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucG9vbENvbmZpZy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHBvb2xLZXkgPSB0aGlzLmdldFBvb2xLZXkobW9kZSwgbGFuZ3VhZ2UpO1xuICAgIFxuICAgIGlmICghdGhpcy5wb29sLmhhcyhwb29sS2V5KSkge1xuICAgICAgdGhpcy5wb29sLnNldChwb29sS2V5LCBbXSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHBvb2xQcm9taXNlcyA9IHRoaXMucG9vbC5nZXQocG9vbEtleSkhO1xuICAgIFxuICAgIC8vIE9ubHkgYWRkIGlmIHdlIGhhdmVuJ3QgcmVhY2hlZCB0aGUgcG9vbCBzaXplIGxpbWl0XG4gICAgaWYgKHBvb2xQcm9taXNlcy5sZW5ndGggPCB0aGlzLnBvb2xDb25maWcucG9vbFNpemUpIHtcbiAgICAgIHBvb2xQcm9taXNlcy5wdXNoKGtlcm5lbFByb21pc2UpO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgcHJvbWlzZSByZWplY3Rpb24gdG8gcHJldmVudCB1bmhhbmRsZWQgcmVqZWN0aW9uc1xuICAgICAga2VybmVsUHJvbWlzZS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFBvb2wga2VybmVsIHByb21pc2UgcmVqZWN0ZWQgZm9yICR7cG9vbEtleX06YCwgZXJyb3IpO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGZhaWxlZCBwcm9taXNlIGZyb20gdGhlIHBvb2xcbiAgICAgICAgY29uc3QgaW5kZXggPSBwb29sUHJvbWlzZXMuaW5kZXhPZihrZXJuZWxQcm9taXNlKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHBvb2xQcm9taXNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUG9vbCBpcyBmdWxsLCBsZXQgdGhlIGV4Y2VzcyBwcm9taXNlIHJlc29sdmUgYW5kIHRoZW4gZGVzdHJveSB0aGUga2VybmVsXG4gICAgICBrZXJuZWxQcm9taXNlLnRoZW4oa2VybmVsID0+IHtcbiAgICAgICAga2VybmVsLmRlc3Ryb3koKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlc3Ryb3lpbmcgZXhjZXNzIHBvb2wga2VybmVsOlwiLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXhjZXNzIHBvb2wga2VybmVsIHByb21pc2UgcmVqZWN0ZWQ6XCIsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlZmlsbCB0aGUgcG9vbCB3aXRoIGEgc2luZ2xlIGtlcm5lbCBwcm9taXNlXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcmVmaWxsUG9vbFNpbmdsZShtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMucG9vbENvbmZpZy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHBvb2xLZXkgPSB0aGlzLmdldFBvb2xLZXkobW9kZSwgbGFuZ3VhZ2UpO1xuICAgIGNvbnN0IHBvb2xQcm9taXNlcyA9IHRoaXMucG9vbC5nZXQocG9vbEtleSkgfHwgW107XG4gICAgXG4gICAgLy8gT25seSBhZGQgb25lIGlmIHdlJ3JlIGJlbG93IHRoZSBwb29sIHNpemVcbiAgICBpZiAocG9vbFByb21pc2VzLmxlbmd0aCA8IHRoaXMucG9vbENvbmZpZy5wb29sU2l6ZSkge1xuICAgICAgY29uc3Qga2VybmVsUHJvbWlzZSA9IHRoaXMuY3JlYXRlUG9vbEtlcm5lbFByb21pc2UobW9kZSwgbGFuZ3VhZ2UpO1xuICAgICAgdGhpcy5hZGRUb1Bvb2wobW9kZSwgbGFuZ3VhZ2UsIGtlcm5lbFByb21pc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZpbGwgdGhlIHBvb2wgZm9yIGEgc3BlY2lmaWMgY29uZmlndXJhdGlvbiB3aXRoIHBhcmFsbGVsIGNyZWF0aW9uXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcmVmaWxsUG9vbChtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMucG9vbENvbmZpZy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHBvb2xLZXkgPSB0aGlzLmdldFBvb2xLZXkobW9kZSwgbGFuZ3VhZ2UpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJlZmlsbGluZyB0aGlzIHBvb2wga2V5IHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICAgIGlmICh0aGlzLnByZWZpbGxpbmdJblByb2dyZXNzLmdldChwb29sS2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBTZXQgcHJlZmlsbGluZyBmbGFnXG4gICAgdGhpcy5wcmVmaWxsaW5nSW5Qcm9ncmVzcy5zZXQocG9vbEtleSwgdHJ1ZSk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBvb2xQcm9taXNlcyA9IHRoaXMucG9vbC5nZXQocG9vbEtleSkgfHwgW107XG4gICAgICBjb25zdCBuZWVkZWQgPSB0aGlzLnBvb2xDb25maWcucG9vbFNpemUgLSBwb29sUHJvbWlzZXMubGVuZ3RoO1xuICAgICAgXG4gICAgICBpZiAobmVlZGVkIDw9IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYWxsIG5lZWRlZCBrZXJuZWwgcHJvbWlzZXMgaW4gcGFyYWxsZWxcbiAgICAgIGNvbnN0IG5ld1Byb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbmVlZGVkIH0sICgpID0+IFxuICAgICAgICB0aGlzLmNyZWF0ZVBvb2xLZXJuZWxQcm9taXNlKG1vZGUsIGxhbmd1YWdlKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIGFsbCBwcm9taXNlcyB0byB0aGUgcG9vbFxuICAgICAgZm9yIChjb25zdCBrZXJuZWxQcm9taXNlIG9mIG5ld1Byb21pc2VzKSB7XG4gICAgICAgIHRoaXMuYWRkVG9Qb29sKG1vZGUsIGxhbmd1YWdlLCBrZXJuZWxQcm9taXNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZWZpbGxpbmcgcG9vbCBmb3IgJHtwb29sS2V5fTpgLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIEFsd2F5cyBjbGVhciB0aGUgcHJlZmlsbGluZyBmbGFnXG4gICAgICB0aGlzLnByZWZpbGxpbmdJblByb2dyZXNzLnNldChwb29sS2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogQ3JlYXRlIGEga2VybmVsIHByb21pc2UgZm9yIHRoZSBwb29sXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEga2VybmVsIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVBvb2xLZXJuZWxQcm9taXNlKG1vZGU6IEtlcm5lbE1vZGUsIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSk6IFByb21pc2U8SUtlcm5lbEluc3RhbmNlPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGtlcm5lbCA9IGF3YWl0IHRoaXMuY3JlYXRlUG9vbEtlcm5lbChtb2RlLCBsYW5ndWFnZSk7XG4gICAgICAgIC8vIE1hcmsgYXMgdGFrZW4gZnJvbSBwb29sXG4gICAgICAgIGtlcm5lbC5pc0Zyb21Qb29sID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZShrZXJuZWwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY3JlYXRpbmcgcG9vbCBrZXJuZWwgZm9yICR7bW9kZX0tJHtsYW5ndWFnZX06YCwgZXJyb3IpO1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGtlcm5lbCBzcGVjaWZpY2FsbHkgZm9yIHRoZSBwb29sXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHJldHVybnMgS2VybmVsIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVBvb2xLZXJuZWwobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlKTogUHJvbWlzZTxJS2VybmVsSW5zdGFuY2U+IHtcbiAgICAvLyBHZW5lcmF0ZSBhIHRlbXBvcmFyeSBJRCBmb3IgdGhlIHBvb2wga2VybmVsXG4gICAgY29uc3QgdGVtcElkID0gYHBvb2wtJHtjcnlwdG8ucmFuZG9tVVVJRCgpfWA7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGtlcm5lbCB3aXRoIG1pbmltYWwgY29uZmlndXJhdGlvblxuICAgIGNvbnN0IG9wdGlvbnM6IElNYW5hZ2VyS2VybmVsT3B0aW9ucyA9IHtcbiAgICAgIG1vZGUsXG4gICAgICBsYW5nOiBsYW5ndWFnZVxuICAgIH07XG4gICAgXG4gICAgLy8gU3RvcmUgb3B0aW9ucyB0ZW1wb3JhcmlseSAtIGJ1dCBkb24ndCBzdG9yZSBpbmNvbXBsZXRlIGluc3RhbmNlIGluIGtlcm5lbHMgbWFwXG4gICAgLy8gSW5zdGVhZCwgd2UnbGwgcGFzcyB0aGUgb3B0aW9ucyBkaXJlY3RseSB0byB0aGUgY3JlYXRpb24gbWV0aG9kc1xuICAgIGxldCBpbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBpZiAobW9kZSA9PT0gS2VybmVsTW9kZS5NQUlOX1RIUkVBRCkge1xuICAgICAgICAvLyBGb3IgbWFpbiB0aHJlYWQsIHdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgc3RvcmUgdGhlIGluc3RhbmNlIGZvciBjcmVhdGVNYWluVGhyZWFkS2VybmVsXG4gICAgICAgIGNvbnN0IHRlbXBJbnN0YW5jZSA9IHtcbiAgICAgICAgICBpZDogdGVtcElkLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICBsYW5ndWFnZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmtlcm5lbHMuc2V0KHRlbXBJZCwgdGVtcEluc3RhbmNlIGFzIHVua25vd24gYXMgSUtlcm5lbEluc3RhbmNlKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2UgPSBhd2FpdCB0aGlzLmNyZWF0ZU1haW5UaHJlYWRLZXJuZWwodGVtcElkKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBBbHdheXMgY2xlYW4gdXAgdGhlIHRlbXBvcmFyeSBpbnN0YW5jZVxuICAgICAgICAgIHRoaXMua2VybmVscy5kZWxldGUodGVtcElkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIHdvcmtlciBtb2RlLCB3ZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHN0b3JlIHRoZSBpbnN0YW5jZSBmb3IgY3JlYXRlV29ya2VyS2VybmVsXG4gICAgICAgIGNvbnN0IHRlbXBJbnN0YW5jZSA9IHtcbiAgICAgICAgICBpZDogdGVtcElkLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICBsYW5ndWFnZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmtlcm5lbHMuc2V0KHRlbXBJZCwgdGVtcEluc3RhbmNlIGFzIHVua25vd24gYXMgSUtlcm5lbEluc3RhbmNlKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2UgPSBhd2FpdCB0aGlzLmNyZWF0ZVdvcmtlcktlcm5lbCh0ZW1wSWQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIC8vIEFsd2F5cyBjbGVhbiB1cCB0aGUgdGVtcG9yYXJ5IGluc3RhbmNlXG4gICAgICAgICAgdGhpcy5rZXJuZWxzLmRlbGV0ZSh0ZW1wSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEVuc3VyZSBjbGVhbnVwIG9uIGFueSBlcnJvclxuICAgICAgdGhpcy5rZXJuZWxzLmRlbGV0ZSh0ZW1wSWQpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFByZWxvYWQgdGhlIGtlcm5lbCBwb29sIHdpdGggY29uZmlndXJlZCBrZXJuZWwgdHlwZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcHJlbG9hZFBvb2woKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLnBvb2xDb25maWcuZW5hYmxlZCB8fCB0aGlzLmlzUHJlbG9hZGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmlzUHJlbG9hZGluZyA9IHRydWU7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFByZWxvYWQga2VybmVscyBmb3IgZWFjaCBjb25maWd1cmVkIHR5cGVcbiAgICAgIGZvciAoY29uc3QgY29uZmlnIG9mIHRoaXMucG9vbENvbmZpZy5wcmVsb2FkQ29uZmlncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucmVmaWxsUG9vbChjb25maWcubW9kZSwgY29uZmlnLmxhbmd1YWdlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcmVsb2FkaW5nICR7Y29uZmlnLm1vZGV9LSR7Y29uZmlnLmxhbmd1YWdlfTpgLCBlcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgd2l0aCBvdGhlciBjb25maWd1cmF0aW9uc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcga2VybmVsIHBvb2wgcHJlbG9hZGluZzpcIiwgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzUHJlbG9hZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIENoZWNrIGlmIGEga2VybmVsIHJlcXVlc3QgY2FuIHVzZSB0aGUgcG9vbFxuICAgKiBAcGFyYW0gb3B0aW9ucyBLZXJuZWwgY3JlYXRpb24gb3B0aW9uc1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSByZXF1ZXN0IGNhbiB1c2UgcG9vbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBjYW5Vc2VQb29sKG9wdGlvbnM6IElNYW5hZ2VyS2VybmVsT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIC8vIERvbid0IHVzZSBwb29sIGlmIGl0J3MgZGlzYWJsZWRcbiAgICBpZiAoIXRoaXMucG9vbENvbmZpZy5lbmFibGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIERvbid0IHVzZSBwb29sIGlmIGN1c3RvbSBmaWxlc3lzdGVtIG9yIHBlcm1pc3Npb25zIGFyZSBzcGVjaWZpZWRcbiAgICBpZiAob3B0aW9ucy5maWxlc3lzdGVtIHx8IG9wdGlvbnMuZGVubz8ucGVybWlzc2lvbnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gRG9uJ3QgdXNlIHBvb2wgaWYgY3VzdG9tIHRpbWVvdXRzIGFyZSBzcGVjaWZpZWRcbiAgICBpZiAob3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIFxuICAvKipcbiAgICogUmVhc3NpZ24gYSBwb29sIGtlcm5lbCB3aXRoIG5ldyBJRCBhbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0gcG9vbEtlcm5lbCBLZXJuZWwgZnJvbSBwb29sXG4gICAqIEBwYXJhbSBuZXdJZCBOZXcga2VybmVsIElEXG4gICAqIEBwYXJhbSBvcHRpb25zIEtlcm5lbCBvcHRpb25zXG4gICAqIEByZXR1cm5zIFVwZGF0ZWQga2VybmVsIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHJlYXNzaWduUG9vbEtlcm5lbChcbiAgICBwb29sS2VybmVsOiBJS2VybmVsSW5zdGFuY2UsIFxuICAgIG5ld0lkOiBzdHJpbmcsIFxuICAgIG9wdGlvbnM6IElNYW5hZ2VyS2VybmVsT3B0aW9uc1xuICApOiBJS2VybmVsSW5zdGFuY2Uge1xuICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvYmplY3QgZXhwbGljaXRseSB0byBhdm9pZCBzcHJlYWQgb3BlcmF0b3IgaXNzdWVzXG4gICAgY29uc3QgdXBkYXRlZEluc3RhbmNlOiBJS2VybmVsSW5zdGFuY2UgPSB7XG4gICAgICBpZDogbmV3SWQsXG4gICAgICBrZXJuZWw6IHBvb2xLZXJuZWwua2VybmVsLFxuICAgICAgbW9kZTogcG9vbEtlcm5lbC5tb2RlLFxuICAgICAgbGFuZ3VhZ2U6IHBvb2xLZXJuZWwubGFuZ3VhZ2UsXG4gICAgICB3b3JrZXI6IHBvb2xLZXJuZWwud29ya2VyLFxuICAgICAgY3JlYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLCAvLyBVcGRhdGUgY3JlYXRpb24gdGltZVxuICAgICAgb3B0aW9uczogeyAuLi5wb29sS2VybmVsLm9wdGlvbnMsIC4uLm9wdGlvbnMgfSxcbiAgICAgIGlzRnJvbVBvb2w6IHRydWUsXG4gICAgICBkZXN0cm95OiBwb29sS2VybmVsLmRlc3Ryb3kgLy8gUHJlc2VydmUgdGhlIG9yaWdpbmFsIGRlc3Ryb3kgZnVuY3Rpb25cbiAgICB9O1xuICAgIFxuICAgIC8vIFZlcmlmeSB0aGUgZGVzdHJveSBmdW5jdGlvbiBpcyBwcm9wZXJseSBzZXRcbiAgICBpZiAodHlwZW9mIHVwZGF0ZWRJbnN0YW5jZS5kZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcHJlc2VydmUgZGVzdHJveSBmdW5jdGlvbiBkdXJpbmcgcG9vbCBrZXJuZWwgcmVhc3NpZ25tZW50Jyk7XG4gICAgICBjb25zb2xlLmVycm9yKCdwb29sS2VybmVsLmRlc3Ryb3kgdHlwZTonLCB0eXBlb2YgcG9vbEtlcm5lbC5kZXN0cm95KTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3VwZGF0ZWRJbnN0YW5jZS5kZXN0cm95IHR5cGU6JywgdHlwZW9mIHVwZGF0ZWRJbnN0YW5jZS5kZXN0cm95KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHByZXNlcnZlIGRlc3Ryb3kgZnVuY3Rpb24gZHVyaW5nIHBvb2wga2VybmVsIHJlYXNzaWdubWVudGApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdXBkYXRlZEluc3RhbmNlO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IHBvb2wgc3RhdGlzdGljcyBmb3IgZGVidWdnaW5nL21vbml0b3JpbmdcbiAgICogQHJldHVybnMgUG9vbCBzdGF0aXN0aWNzXG4gICAqL1xuICBwdWJsaWMgZ2V0UG9vbFN0YXRzKCk6IFJlY29yZDxzdHJpbmcsIHsgYXZhaWxhYmxlOiBudW1iZXI7IHRvdGFsOiBudW1iZXIgfT4ge1xuICAgIGNvbnN0IHN0YXRzOiBSZWNvcmQ8c3RyaW5nLCB7IGF2YWlsYWJsZTogbnVtYmVyOyB0b3RhbDogbnVtYmVyIH0+ID0ge307XG4gICAgXG4gICAgZm9yIChjb25zdCBbcG9vbEtleSwgcHJvbWlzZXNdIG9mIHRoaXMucG9vbC5lbnRyaWVzKCkpIHtcbiAgICAgIHN0YXRzW3Bvb2xLZXldID0ge1xuICAgICAgICBhdmFpbGFibGU6IHByb21pc2VzLmxlbmd0aCxcbiAgICAgICAgdG90YWw6IHRoaXMucG9vbENvbmZpZy5wb29sU2l6ZVxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IHBvb2wgY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJucyBQb29sIGNvbmZpZ3VyYXRpb24gZGV0YWlsc1xuICAgKi9cbiAgcHVibGljIGdldFBvb2xDb25maWcoKToge1xuICAgIGVuYWJsZWQ6IGJvb2xlYW47XG4gICAgcG9vbFNpemU6IG51bWJlcjtcbiAgICBhdXRvUmVmaWxsOiBib29sZWFuO1xuICAgIHByZWxvYWRDb25maWdzOiBBcnJheTx7XG4gICAgICBtb2RlOiBLZXJuZWxNb2RlO1xuICAgICAgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlO1xuICAgIH0+O1xuICAgIGlzUHJlbG9hZGluZzogYm9vbGVhbjtcbiAgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuYWJsZWQ6IHRoaXMucG9vbENvbmZpZy5lbmFibGVkLFxuICAgICAgcG9vbFNpemU6IHRoaXMucG9vbENvbmZpZy5wb29sU2l6ZSxcbiAgICAgIGF1dG9SZWZpbGw6IHRoaXMucG9vbENvbmZpZy5hdXRvUmVmaWxsLFxuICAgICAgcHJlbG9hZENvbmZpZ3M6IFsuLi50aGlzLnBvb2xDb25maWcucHJlbG9hZENvbmZpZ3NdLCAvLyBSZXR1cm4gYSBjb3B5IHRvIHByZXZlbnQgbW9kaWZpY2F0aW9uXG4gICAgICBpc1ByZWxvYWRpbmc6IHRoaXMuaXNQcmVsb2FkaW5nXG4gICAgfTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB3b3JrZXIgVVJMIGNvbmZpZ3VyYXRpb25cbiAgICogQHJldHVybnMgVGhlIHdvcmtlciBVUkwgb3IgdW5kZWZpbmVkIGlmIHVzaW5nIGF1dG8tZGV0ZWN0aW9uXG4gICAqL1xuICBwdWJsaWMgZ2V0V29ya2VyVXJsKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMud29ya2VyVXJsO1xuICB9XG4gIFxuICAvKipcbiAgICogU2V0IGEgY3VzdG9tIHdvcmtlciBVUkwgZm9yIGtlcm5lbCB3b3JrZXJzXG4gICAqIEBwYXJhbSB1cmwgVGhlIFVSTCB0byB0aGUga2VybmVsLndvcmtlci5qcyBmaWxlXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEZvciBDRE4gdXNhZ2U6XG4gICAqIG1hbmFnZXIuc2V0V29ya2VyVXJsKCdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL3dlYi1weXRob24ta2VybmVsQGxhdGVzdC9kaXN0L2tlcm5lbC53b3JrZXIuanMnKTtcbiAgICogLy8gRm9yIGxvY2FsIGRldmVsb3BtZW50OlxuICAgKiBtYW5hZ2VyLnNldFdvcmtlclVybCgnL2Rpc3Qva2VybmVsLndvcmtlci5qcycpO1xuICAgKi9cbiAgcHVibGljIHNldFdvcmtlclVybCh1cmw6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgIHRoaXMud29ya2VyVXJsID0gdXJsO1xuICB9XG4gIFxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGtlcm5lbCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBjcmVhdGluZyB0aGUga2VybmVsXG4gICAqIEBwYXJhbSBvcHRpb25zLmlkIE9wdGlvbmFsIGN1c3RvbSBJRCBmb3IgdGhlIGtlcm5lbFxuICAgKiBAcGFyYW0gb3B0aW9ucy5tb2RlIE9wdGlvbmFsIGtlcm5lbCBtb2RlIChtYWluX3RocmVhZCBvciB3b3JrZXIpXG4gICAqIEBwYXJhbSBvcHRpb25zLmxhbmcgT3B0aW9uYWwga2VybmVsIGxhbmd1YWdlIChweXRob24gb3IgdHlwZXNjcmlwdClcbiAgICogQHBhcmFtIG9wdGlvbnMubmFtZXNwYWNlIE9wdGlvbmFsIG5hbWVzcGFjZSBwcmVmaXggZm9yIHRoZSBrZXJuZWwgSURcbiAgICogQHBhcmFtIG9wdGlvbnMuZGVuby5wZXJtaXNzaW9ucyBPcHRpb25hbCBEZW5vIHBlcm1pc3Npb25zIGZvciB3b3JrZXIgbW9kZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5maWxlc3lzdGVtIE9wdGlvbmFsIGZpbGVzeXN0ZW0gbW91bnRpbmcgb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCBPcHRpb25hbCB0aW1lb3V0IGluIG1zIGFmdGVyIHdoaWNoIGFuIGluYWN0aXZlIGtlcm5lbCB3aWxsIGJlIHNodXQgZG93blxuICAgKiBAcGFyYW0gb3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lIE9wdGlvbmFsIG1heGltdW0gdGltZSBpbiBtcyBhbiBleGVjdXRpb24gY2FuIHJ1biBiZWZvcmUgY29uc2lkZXJlZCBzdHVja1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUga2VybmVsIGluc3RhbmNlIElEXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY3JlYXRlS2VybmVsKG9wdGlvbnM6IElNYW5hZ2VyS2VybmVsT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAvLyBtYWtlIHN1cmUgdGhlIG9wdGlvbnMuaWQgZG9lcyBub3QgY29udGFpbiBjb2xvbnMgYmVjYXVzZSBpdCB3aWxsIGJlIHVzZWQgYXMgYSBuYW1lc3BhY2UgcHJlZml4XG4gICAgaWYgKG9wdGlvbnMuaWQgJiYgb3B0aW9ucy5pZC5pbmNsdWRlcygnOicpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tlcm5lbCBJRCBjYW5ub3QgY29udGFpbiBjb2xvbnMnKTtcbiAgICB9XG4gICAgY29uc3QgYmFzZUlkID0gb3B0aW9ucy5pZCB8fCBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgfHwgS2VybmVsTW9kZS5XT1JLRVI7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBvcHRpb25zLmxhbmcgfHwgS2VybmVsTGFuZ3VhZ2UuUFlUSE9OO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZSByZXF1ZXN0ZWQga2VybmVsIHR5cGUgaXMgYWxsb3dlZFxuICAgIGlmICghdGhpcy5pc0tlcm5lbFR5cGVBbGxvd2VkKG1vZGUsIGxhbmd1YWdlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgdHlwZSAke21vZGV9LSR7bGFuZ3VhZ2V9IGlzIG5vdCBhbGxvd2VkLiBBbGxvd2VkIHR5cGVzOiAke1xuICAgICAgICB0aGlzLmFsbG93ZWRLZXJuZWxUeXBlcy5tYXAodCA9PiBgJHt0Lm1vZGV9LSR7dC5sYW5ndWFnZX1gKS5qb2luKCcsICcpXG4gICAgICB9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFwcGx5IG5hbWVzcGFjZSBwcmVmaXggaWYgcHJvdmlkZWRcbiAgICBjb25zdCBpZCA9IG9wdGlvbnMubmFtZXNwYWNlID8gYCR7b3B0aW9ucy5uYW1lc3BhY2V9OiR7YmFzZUlkfWAgOiBiYXNlSWQ7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYga2VybmVsIHdpdGggdGhpcyBJRCBhbHJlYWR5IGV4aXN0c1xuICAgIGlmICh0aGlzLmtlcm5lbHMuaGFzKGlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgd2l0aCBJRCAke2lkfSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgIH1cbiAgICBcbiAgICAvLyBUcnkgdG8gZ2V0IGZyb20gcG9vbCBpZiBwb3NzaWJsZVxuICAgIGlmICh0aGlzLmNhblVzZVBvb2wob3B0aW9ucykpIHtcbiAgICAgIGNvbnN0IHBvb2xLZXkgPSB0aGlzLmdldFBvb2xLZXkobW9kZSwgbGFuZ3VhZ2UpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGtlcm5lbCB0eXBlIGlzIGNvbmZpZ3VyZWQgZm9yIHBvb2xpbmdcbiAgICAgIGNvbnN0IGlzUG9vbGVkVHlwZSA9IHRoaXMucG9vbENvbmZpZy5wcmVsb2FkQ29uZmlncy5zb21lKGNvbmZpZyA9PiBcbiAgICAgICAgY29uZmlnLm1vZGUgPT09IG1vZGUgJiYgY29uZmlnLmxhbmd1YWdlID09PSBsYW5ndWFnZVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKGlzUG9vbGVkVHlwZSkge1xuICAgICAgICAvLyBGaXJzdCB0cnkgdG8gZ2V0IGZyb20gZXhpc3RpbmcgcG9vbFxuICAgICAgICBsZXQgcG9vbEtlcm5lbFByb21pc2UgPSB0aGlzLmdldEZyb21Qb29sKG1vZGUsIGxhbmd1YWdlKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChwb29sS2VybmVsUHJvbWlzZSkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNldHVwUG9vbEtlcm5lbEZyb21Qcm9taXNlKHBvb2xLZXJuZWxQcm9taXNlLCBpZCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFBvb2wgaXMgZW1wdHksIGJ1dCB0aGlzIHR5cGUgc2hvdWxkIGJlIHBvb2xlZFxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcHJvbWlzZSBpbW1lZGlhdGVseSBhbmQgdHJpZ2dlciBiYWNrZ3JvdW5kIHJlZmlsbFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBrZXJuZWwgcHJvbWlzZSBzcGVjaWZpY2FsbHkgZm9yIHRoaXMgcmVxdWVzdFxuICAgICAgICAgIGNvbnN0IG5ld0tlcm5lbFByb21pc2UgPSB0aGlzLmNyZWF0ZVBvb2xLZXJuZWxQcm9taXNlKG1vZGUsIGxhbmd1YWdlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcmlnZ2VyIGJhY2tncm91bmQgcmVmaWxsIHRvIHJlcGxlbmlzaCB0aGUgcG9vbCBmb3IgZnV0dXJlIHJlcXVlc3RzXG4gICAgICAgICAgaWYgKHRoaXMucG9vbENvbmZpZy5hdXRvUmVmaWxsKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5yZWZpbGxQb29sKG1vZGUsIGxhbmd1YWdlKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVmaWxsaW5nIGV4aGF1c3RlZCBwb29sIGZvciAke3Bvb2xLZXl9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0dXBQb29sS2VybmVsRnJvbVByb21pc2UobmV3S2VybmVsUHJvbWlzZSwgaWQsIG9wdGlvbnMpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUga2VybmVsIHByb21pc2UgZm9yIGV4aGF1c3RlZCBwb29sOiAke2Vycm9yfWApO1xuICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBvbi1kZW1hbmQgY3JlYXRpb24gYXMgbGFzdCByZXNvcnRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBrZXJuZWwgdHlwZSBpcyBub3QgY29uZmlndXJlZCBmb3IgcG9vbGluZywgdHJ5IHRvIGdldCBmcm9tIHBvb2wgYW55d2F5XG4gICAgICAgIC8vIGluIGNhc2UgdGhlcmUgYXJlIGtlcm5lbHMgYXZhaWxhYmxlIGZyb20gcHJldmlvdXMgY29uZmlndXJhdGlvbnNcbiAgICAgICAgY29uc3QgcG9vbEtlcm5lbFByb21pc2UgPSB0aGlzLmdldEZyb21Qb29sKG1vZGUsIGxhbmd1YWdlKTtcbiAgICAgICAgaWYgKHBvb2xLZXJuZWxQcm9taXNlKSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0dXBQb29sS2VybmVsRnJvbVByb21pc2UocG9vbEtlcm5lbFByb21pc2UsIGlkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsIGJhY2sgdG8gY3JlYXRpbmcgYSBuZXcga2VybmVsIG9uLWRlbWFuZFxuICAgIHJldHVybiB0aGlzLmNyZWF0ZU9uRGVtYW5kS2VybmVsKGlkLCBtb2RlLCBsYW5ndWFnZSwgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZXR1cCBhIHBvb2wga2VybmVsIGZyb20gYSBwcm9taXNlIHdpdGggbmV3IElEIGFuZCBvcHRpb25zXG4gICAqIEBwYXJhbSBwb29sS2VybmVsUHJvbWlzZSBLZXJuZWwgcHJvbWlzZSBmcm9tIHBvb2xcbiAgICogQHBhcmFtIGlkIE5ldyBrZXJuZWwgSURcbiAgICogQHBhcmFtIG9wdGlvbnMgS2VybmVsIG9wdGlvbnNcbiAgICogQHJldHVybnMgS2VybmVsIElEIChyZXR1cm5lZCBhZnRlciBrZXJuZWwgaXMgcmVhZHkpXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNldHVwUG9vbEtlcm5lbEZyb21Qcm9taXNlKFxuICAgIHBvb2xLZXJuZWxQcm9taXNlOiBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT4sIFxuICAgIGlkOiBzdHJpbmcsIFxuICAgIG9wdGlvbnM6IElNYW5hZ2VyS2VybmVsT3B0aW9uc1xuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBXYWl0IGZvciB0aGUgcG9vbCBrZXJuZWwgdG8gYmUgcmVhZHlcbiAgICAgIGNvbnN0IHBvb2xLZXJuZWwgPSBhd2FpdCBwb29sS2VybmVsUHJvbWlzZTtcbiAgICAgIFxuICAgICAgLy8gUmVhc3NpZ24gdGhlIHBvb2wga2VybmVsIHdpdGggdGhlIG5ldyBJRCBhbmQgb3B0aW9uc1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLnJlYXNzaWduUG9vbEtlcm5lbChwb29sS2VybmVsLCBpZCwgb3B0aW9ucyk7XG4gICAgICBcbiAgICAgIC8vIEZvciB3b3JrZXIga2VybmVscywgd2UgbmVlZCB0byByZWNyZWF0ZSB0aGUgZXZlbnQgaGFuZGxlciB3aXRoIHRoZSBuZXcgSURcbiAgICAgIGlmIChpbnN0YW5jZS5tb2RlID09PSBLZXJuZWxNb2RlLldPUktFUiAmJiBpbnN0YW5jZS53b3JrZXIpIHtcbiAgICAgICAgLy8gR2V0IHRoZSB3b3JrZXIgYW5kIGNyZWF0ZSBuZXcgbWVzc2FnZSBjaGFubmVsXG4gICAgICAgIGNvbnN0IHdvcmtlciA9IGluc3RhbmNlLndvcmtlcjtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBtZXNzYWdlIGNoYW5uZWwgZm9yIHRoZSByZWFzc2lnbmVkIGtlcm5lbFxuICAgICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZW5kIHRoZSBuZXcgZXZlbnQgcG9ydCB0byB0aGUgd29ya2VyXG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgdHlwZTogXCJTRVRfRVZFTlRfUE9SVFwiLFxuICAgICAgICAgIHBvcnQ6IHBvcnQyXG4gICAgICAgIH0sIFtwb3J0Ml0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGV2ZW50IGhhbmRsZXIgd2l0aCB0aGUgY29ycmVjdCBrZXJuZWwgSURcbiAgICAgICAgY29uc3QgZXZlbnRIYW5kbGVyID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnR5cGUpIHtcbiAgICAgICAgICAgIC8vIEVtaXQgdGhlIGV2ZW50IGZyb20gdGhlIG1hbmFnZXIgd2l0aCBrZXJuZWwgSURcbiAgICAgICAgICAgIC8vIFRoaXMgc3RydWN0dXJlIG1hdGNoZXMgdGhlIHNldHVwRXZlbnRGb3J3YXJkaW5nIG1ldGhvZCBmb3IgbWFpbiB0aHJlYWQga2VybmVsc1xuICAgICAgICAgICAgc3VwZXIuZW1pdChldmVudC5kYXRhLnR5cGUsIHtcbiAgICAgICAgICAgICAga2VybmVsSWQ6IGlkLFxuICAgICAgICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIExpc3RlbiBmb3IgZXZlbnRzIGZyb20gdGhlIHdvcmtlciB3aXRoIHRoZSBuZXcgaGFuZGxlclxuICAgICAgICBwb3J0MS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgcG9ydDEuc3RhcnQoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZGVzdHJveSBmdW5jdGlvbiB0byBjbGVhbiB1cCB0aGUgbmV3IGV2ZW50IGhhbmRsZXJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxEZXN0cm95ID0gaW5zdGFuY2UuZGVzdHJveTtcbiAgICAgICAgaW5zdGFuY2UuZGVzdHJveSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBwb3J0MS5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgICBwb3J0MS5jbG9zZSgpO1xuICAgICAgICAgIHJldHVybiBvcmlnaW5hbERlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU3RvcmUgdGhlIGtlcm5lbCBpbnN0YW5jZVxuICAgICAgdGhpcy5rZXJuZWxzLnNldChpZCwgaW5zdGFuY2UpO1xuICAgICAgXG4gICAgICAvLyBGb3J3YXJkIGtlcm5lbCBldmVudHMgdG8gbWFuYWdlciAoZm9yIG1haW4gdGhyZWFkIGtlcm5lbHMpXG4gICAgICB0aGlzLnNldHVwRXZlbnRGb3J3YXJkaW5nKGluc3RhbmNlKTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSBhY3Rpdml0eSB0cmFja2luZ1xuICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShpZCk7XG4gICAgICBcbiAgICAgIC8vIFNldCB1cCBpbmFjdGl2aXR5IHRpbWVvdXQgaWYgc3BlY2lmaWVkIGFuZCBncmVhdGVyIHRoYW4gMFxuICAgICAgaWYgKG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgJiYgb3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCA+IDApIHtcbiAgICAgICAgdGhpcy5zZXR1cEluYWN0aXZpdHlUaW1lb3V0KGlkLCBvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2V0dXAgaGFuZGxlcnMgZm9yIHN0YWxsZWQgZXhlY3V0aW9ucyBpZiBtYXhFeGVjdXRpb25UaW1lIGlzIHNwZWNpZmllZFxuICAgICAgaWYgKG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSAmJiBvcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgPiAwKSB7XG4gICAgICAgIHRoaXMuc2V0dXBTdGFsbGVkRXhlY3V0aW9uSGFuZGxlcihpZCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBpZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2V0dGluZyB1cCBwb29sIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICAvLyBFbWl0IGFuIGVycm9yIGV2ZW50IGZvciB0aGlzIGtlcm5lbFxuICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwge1xuICAgICAgICBrZXJuZWxJZDogaWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBlbmFtZTogXCJLZXJuZWxTZXR1cEVycm9yXCIsXG4gICAgICAgICAgZXZhbHVlOiBgRmFpbGVkIHRvIHNldHVwIGtlcm5lbDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCxcbiAgICAgICAgICB0cmFjZWJhY2s6IFtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gKGVycm9yLnN0YWNrIHx8IGVycm9yLm1lc3NhZ2UpIDogU3RyaW5nKGVycm9yKV1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjsgLy8gUmUtdGhyb3cgdG8gbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGEgcG9vbCBrZXJuZWwgd2l0aCBuZXcgSUQgYW5kIG9wdGlvbnMgKGZvciBhbHJlYWR5IHJlc29sdmVkIGtlcm5lbHMpXG4gICAqIEBwYXJhbSBwb29sS2VybmVsIEtlcm5lbCBmcm9tIHBvb2xcbiAgICogQHBhcmFtIGlkIE5ldyBrZXJuZWwgSURcbiAgICogQHBhcmFtIG9wdGlvbnMgS2VybmVsIG9wdGlvbnNcbiAgICogQHJldHVybnMgS2VybmVsIElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHNldHVwUG9vbEtlcm5lbChcbiAgICBwb29sS2VybmVsOiBJS2VybmVsSW5zdGFuY2UsIFxuICAgIGlkOiBzdHJpbmcsIFxuICAgIG9wdGlvbnM6IElNYW5hZ2VyS2VybmVsT3B0aW9uc1xuICApOiBzdHJpbmcge1xuICAgIC8vIFJlYXNzaWduIHRoZSBwb29sIGtlcm5lbCB3aXRoIHRoZSBuZXcgSUQgYW5kIG9wdGlvbnNcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMucmVhc3NpZ25Qb29sS2VybmVsKHBvb2xLZXJuZWwsIGlkLCBvcHRpb25zKTtcbiAgICBcbiAgICAvLyBGb3Igd29ya2VyIGtlcm5lbHMsIHdlIG5lZWQgdG8gcmVjcmVhdGUgdGhlIGV2ZW50IGhhbmRsZXIgd2l0aCB0aGUgbmV3IElEXG4gICAgaWYgKGluc3RhbmNlLm1vZGUgPT09IEtlcm5lbE1vZGUuV09SS0VSICYmIGluc3RhbmNlLndvcmtlcikge1xuICAgICAgLy8gR2V0IHRoZSB3b3JrZXIgYW5kIGNyZWF0ZSBuZXcgbWVzc2FnZSBjaGFubmVsXG4gICAgICBjb25zdCB3b3JrZXIgPSBpbnN0YW5jZS53b3JrZXI7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBtZXNzYWdlIGNoYW5uZWwgZm9yIHRoZSByZWFzc2lnbmVkIGtlcm5lbFxuICAgICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgXG4gICAgICAvLyBTZW5kIHRoZSBuZXcgZXZlbnQgcG9ydCB0byB0aGUgd29ya2VyXG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcIlNFVF9FVkVOVF9QT1JUXCIsXG4gICAgICAgIHBvcnQ6IHBvcnQyXG4gICAgICB9LCBbcG9ydDJdKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IGV2ZW50IGhhbmRsZXIgd2l0aCB0aGUgY29ycmVjdCBrZXJuZWwgSURcbiAgICAgIGNvbnN0IGV2ZW50SGFuZGxlciA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEudHlwZSkge1xuICAgICAgICAgIC8vIEVtaXQgdGhlIGV2ZW50IGZyb20gdGhlIG1hbmFnZXIgd2l0aCBrZXJuZWwgSURcbiAgICAgICAgICAvLyBUaGlzIHN0cnVjdHVyZSBtYXRjaGVzIHRoZSBzZXR1cEV2ZW50Rm9yd2FyZGluZyBtZXRob2QgZm9yIG1haW4gdGhyZWFkIGtlcm5lbHNcbiAgICAgICAgICBzdXBlci5lbWl0KGV2ZW50LmRhdGEudHlwZSwge1xuICAgICAgICAgICAga2VybmVsSWQ6IGlkLFxuICAgICAgICAgICAgZGF0YTogZXZlbnQuZGF0YS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIExpc3RlbiBmb3IgZXZlbnRzIGZyb20gdGhlIHdvcmtlciB3aXRoIHRoZSBuZXcgaGFuZGxlclxuICAgICAgcG9ydDEuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50SGFuZGxlcik7XG4gICAgICBwb3J0MS5zdGFydCgpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgdGhlIGRlc3Ryb3kgZnVuY3Rpb24gdG8gY2xlYW4gdXAgdGhlIG5ldyBldmVudCBoYW5kbGVyXG4gICAgICBjb25zdCBvcmlnaW5hbERlc3Ryb3kgPSBpbnN0YW5jZS5kZXN0cm95O1xuICAgICAgaW5zdGFuY2UuZGVzdHJveSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgcG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgIHBvcnQxLmNsb3NlKCk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbERlc3Ryb3koKTtcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIFN0b3JlIHRoZSBrZXJuZWwgaW5zdGFuY2VcbiAgICB0aGlzLmtlcm5lbHMuc2V0KGlkLCBpbnN0YW5jZSk7XG4gICAgXG4gICAgLy8gRm9yd2FyZCBrZXJuZWwgZXZlbnRzIHRvIG1hbmFnZXIgKGZvciBtYWluIHRocmVhZCBrZXJuZWxzKVxuICAgIHRoaXMuc2V0dXBFdmVudEZvcndhcmRpbmcoaW5zdGFuY2UpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgYWN0aXZpdHkgdHJhY2tpbmdcbiAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGlkKTtcbiAgICBcbiAgICAvLyBTZXQgdXAgaW5hY3Rpdml0eSB0aW1lb3V0IGlmIHNwZWNpZmllZCBhbmQgZ3JlYXRlciB0aGFuIDBcbiAgICBpZiAob3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCAmJiBvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0ID4gMCkge1xuICAgICAgdGhpcy5zZXR1cEluYWN0aXZpdHlUaW1lb3V0KGlkLCBvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0KTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0dXAgaGFuZGxlcnMgZm9yIHN0YWxsZWQgZXhlY3V0aW9ucyBpZiBtYXhFeGVjdXRpb25UaW1lIGlzIHNwZWNpZmllZFxuICAgIGlmIChvcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgJiYgb3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lID4gMCkge1xuICAgICAgdGhpcy5zZXR1cFN0YWxsZWRFeGVjdXRpb25IYW5kbGVyKGlkKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIFxuICAvKipcbiAgICogQ3JlYXRlIGEga2VybmVsIG9uLWRlbWFuZCAobm90IGZyb20gcG9vbClcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEBwYXJhbSBvcHRpb25zIEtlcm5lbCBvcHRpb25zXG4gICAqIEByZXR1cm5zIEtlcm5lbCBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVPbkRlbWFuZEtlcm5lbChcbiAgICBpZDogc3RyaW5nLCBcbiAgICBtb2RlOiBLZXJuZWxNb2RlLCBcbiAgICBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UsIFxuICAgIG9wdGlvbnM6IElNYW5hZ2VyS2VybmVsT3B0aW9uc1xuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIC8vIFN0b3JlIG9wdGlvbnMgdGVtcG9yYXJpbHkgdG8gYmUgdXNlZCBpbiBjcmVhdGVXb3JrZXJLZXJuZWxcbiAgICBjb25zdCB0ZW1wSW5zdGFuY2UgPSB7XG4gICAgICBpZCxcbiAgICAgIG9wdGlvbnM6IHsgLi4ub3B0aW9ucywgbGFuZzogbGFuZ3VhZ2UgfSxcbiAgICAgIG1vZGUsXG4gICAgICBsYW5ndWFnZVxuICAgIH07XG4gICAgdGhpcy5rZXJuZWxzLnNldChpZCwgdGVtcEluc3RhbmNlIGFzIHVua25vd24gYXMgSUtlcm5lbEluc3RhbmNlKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgdGhlIGFwcHJvcHJpYXRlIGtlcm5lbCBpbnN0YW5jZVxuICAgIGxldCBpbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlO1xuICAgIFxuICAgIGlmIChtb2RlID09PSBLZXJuZWxNb2RlLk1BSU5fVEhSRUFEKSB7XG4gICAgICBpbnN0YW5jZSA9IGF3YWl0IHRoaXMuY3JlYXRlTWFpblRocmVhZEtlcm5lbChpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlID0gYXdhaXQgdGhpcy5jcmVhdGVXb3JrZXJLZXJuZWwoaWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdG9yZSB0aGUga2VybmVsIGluc3RhbmNlXG4gICAgdGhpcy5rZXJuZWxzLnNldChpZCwgaW5zdGFuY2UpO1xuICAgIFxuICAgIC8vIEZvcndhcmQga2VybmVsIGV2ZW50cyB0byBtYW5hZ2VyXG4gICAgdGhpcy5zZXR1cEV2ZW50Rm9yd2FyZGluZyhpbnN0YW5jZSk7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBhY3Rpdml0eSB0cmFja2luZ1xuICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoaWQpO1xuICAgIFxuICAgIC8vIFNldCB1cCBpbmFjdGl2aXR5IHRpbWVvdXQgaWYgc3BlY2lmaWVkIGFuZCBncmVhdGVyIHRoYW4gMFxuICAgIGlmIChvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0ICYmIG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgPiAwKSB7XG4gICAgICB0aGlzLnNldHVwSW5hY3Rpdml0eVRpbWVvdXQoaWQsIG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTZXR1cCBoYW5kbGVycyBmb3Igc3RhbGxlZCBleGVjdXRpb25zIGlmIG1heEV4ZWN1dGlvblRpbWUgaXMgc3BlY2lmaWVkXG4gICAgaWYgKG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSAmJiBvcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgPiAwKSB7XG4gICAgICB0aGlzLnNldHVwU3RhbGxlZEV4ZWN1dGlvbkhhbmRsZXIoaWQpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBrZXJuZWwgaW5zdGFuY2UgcnVubmluZyBpbiB0aGUgbWFpbiB0aHJlYWRcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBLZXJuZWwgaW5zdGFuY2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlTWFpblRocmVhZEtlcm5lbChpZDogc3RyaW5nKTogUHJvbWlzZTxJS2VybmVsSW5zdGFuY2U+IHtcbiAgICAvLyBHZXQgb3B0aW9ucyBmcm9tIHRoZSB0ZW1wb3JhcnkgaW5zdGFuY2VcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5rZXJuZWxzLmdldChpZCk/Lm9wdGlvbnMgfHwge307XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBvcHRpb25zLmxhbmcgfHwgS2VybmVsTGFuZ3VhZ2UuUFlUSE9OO1xuICAgIFxuICAgIC8vIENyZWF0ZSB0aGUgUHl0aG9uIGtlcm5lbFxuICAgIGNvbnN0IGtlcm5lbCA9IG5ldyBLZXJuZWwoKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgdGhlIGtlcm5lbCBpbnN0YW5jZVxuICAgIGNvbnN0IGluc3RhbmNlOiBJS2VybmVsSW5zdGFuY2UgPSB7XG4gICAgICBpZCxcbiAgICAgIGtlcm5lbCxcbiAgICAgIG1vZGU6IEtlcm5lbE1vZGUuTUFJTl9USFJFQUQsXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBkZXN0cm95OiBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIE5vdGhpbmcgc3BlY2lhbCB0byBkbyBmb3IgbWFpbiB0aHJlYWQga2VybmVsXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgdGhlIGtlcm5lbCB3aXRoIGZpbGVzeXN0ZW0gb3B0aW9uc1xuICAgIGNvbnN0IGtlcm5lbE9wdGlvbnM6IElLZXJuZWxPcHRpb25zID0ge307XG5cbiAgICAvLyBBZGQgZmlsZXN5c3RlbSBvcHRpb25zIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnMuZmlsZXN5c3RlbSkge1xuICAgICAga2VybmVsT3B0aW9ucy5maWxlc3lzdGVtID0gb3B0aW9ucy5maWxlc3lzdGVtO1xuICAgIH1cblxuICAgIC8vIEFkZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaWYgcHJvdmlkZWRcbiAgICBpZiAob3B0aW9ucy5lbnYpIHtcbiAgICAgIGtlcm5lbE9wdGlvbnMuZW52ID0gb3B0aW9ucy5lbnY7XG4gICAgfVxuXG4gICAgLy8gQWRkIGxvY2tGaWxlVVJMIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnMubG9ja0ZpbGVVUkwpIHtcbiAgICAgIGtlcm5lbE9wdGlvbnMubG9ja0ZpbGVVUkwgPSBvcHRpb25zLmxvY2tGaWxlVVJMO1xuICAgIH1cblxuICAgIC8vIEFkZCBhdXRvU3luY0ZzIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnMuYXV0b1N5bmNGcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXJuZWxPcHRpb25zLmF1dG9TeW5jRnMgPSBvcHRpb25zLmF1dG9TeW5jRnM7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUga2VybmVsXG4gICAgYXdhaXQga2VybmVsLmluaXRpYWxpemUoa2VybmVsT3B0aW9ucyk7XG4gICAgXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIFxuICAvKipcbiAgICogQ3JlYXRlIGEga2VybmVsIGluc3RhbmNlIHJ1bm5pbmcgaW4gYSB3b3JrZXJcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBLZXJuZWwgaW5zdGFuY2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlV29ya2VyS2VybmVsKGlkOiBzdHJpbmcpOiBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT4ge1xuICAgIC8vIEdldCBwZXJtaXNzaW9ucyBmcm9tIG9wdGlvbnMgd2hlbiBjcmVhdGluZyB0aGUga2VybmVsXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMua2VybmVscy5nZXQoaWQpPy5vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxhbmd1YWdlID0gb3B0aW9ucy5sYW5nIHx8IEtlcm5lbExhbmd1YWdlLlBZVEhPTjtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBuZXcgd29ya2VyIHdpdGggb3B0aW9uYWwgcGVybWlzc2lvbnNcbiAgICBjb25zdCB3b3JrZXJPcHRpb25zOiBXb3JrZXJPcHRpb25zID0ge1xuICAgICAgdHlwZTogXCJtb2R1bGVcIixcbiAgICB9O1xuICAgIFxuICAgIC8vIElmIERlbm8gcGVybWlzc2lvbnMgYXJlIHByb3ZpZGVkLCB1c2UgdGhlbS5cbiAgICAvLyBPdGhlcndpc2UgZG9uJ3Qgc3BlY2lmeSBEZW5vIHBlcm1pc3Npb25zIGF0IGFsbCB0byBpbmhlcml0IGZyb20gaG9zdCBzY3JpcHRcbiAgICBpZiAob3B0aW9ucy5kZW5vPy5wZXJtaXNzaW9ucykge1xuICAgICAgd29ya2VyT3B0aW9ucy5kZW5vID0ge1xuICAgICAgICBwZXJtaXNzaW9uczogb3B0aW9ucy5kZW5vLnBlcm1pc3Npb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgdGhlIHdvcmtlciBVUkwgYmFzZWQgb24gdGhlIGVudmlyb25tZW50XG4gICAgY29uc3Qgd29ya2VyVXJsID0gdGhpcy5yZXNvbHZlV29ya2VyVXJsKCk7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVcmwsIHsgdHlwZTogJ2NsYXNzaWMnIH0pO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIG1lc3NhZ2UgY2hhbm5lbCBmb3IgZXZlbnRzXG4gICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiB0aGUga2VybmVsIGlzIGluaXRpYWxpemVkXG4gICAgY29uc3QgaW5pdFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBpbml0SGFuZGxlciA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIktFUk5FTF9JTklUSUFMSVpFRFwiKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmRhdGEuZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBwb3J0MS5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaW5pdEhhbmRsZXIpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3J0MS5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaW5pdEhhbmRsZXIpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIktlcm5lbCBpbml0aWFsaXphdGlvbiBmYWlsZWRcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHBvcnQxLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBpbml0SGFuZGxlcik7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gU2VuZCB0aGUgcG9ydCB0byB0aGUgd29ya2VyXG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJTRVRfRVZFTlRfUE9SVFwiLCBwb3J0OiBwb3J0MiB9LCBbcG9ydDJdKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBwcm94eSB0byB0aGUgd29ya2VyIHVzaW5nIENvbWxpbmtcbiAgICBjb25zdCBrZXJuZWxQcm94eSA9IENvbWxpbmsud3JhcDxJS2VybmVsPih3b3JrZXIpO1xuICAgIFxuICAgIC8vIEFkZCBhIGxvY2FsIGV2ZW50IGhhbmRsZXIgdG8gYnJpZGdlIHRoZSB3b3JrZXIgZXZlbnRzXG4gICAgLy8gVGhpcyB3b3JrcyBhcm91bmQgdGhlIGxpbWl0YXRpb24gdGhhdCBDb21saW5rIGRvZXNuJ3QgcHJveHkgZXZlbnQgZW1pdHRlcnNcbiAgICBjb25zdCBldmVudEhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS50eXBlKSB7XG4gICAgICAgIC8vIEVtaXQgdGhlIGV2ZW50IGZyb20gdGhlIG1hbmFnZXIgd2l0aCBrZXJuZWwgSURcbiAgICAgICAgLy8gVGhpcyBzdHJ1Y3R1cmUgbWF0Y2hlcyB0aGUgc2V0dXBFdmVudEZvcndhcmRpbmcgbWV0aG9kIGZvciBtYWluIHRocmVhZCBrZXJuZWxzXG4gICAgICAgIHN1cGVyLmVtaXQoZXZlbnQuZGF0YS50eXBlLCB7XG4gICAgICAgICAga2VybmVsSWQ6IGlkLFxuICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEuZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIExpc3RlbiBmb3IgZXZlbnRzIGZyb20gdGhlIHdvcmtlclxuICAgIHBvcnQxLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudEhhbmRsZXIpO1xuICAgIHBvcnQxLnN0YXJ0KCk7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUga2VybmVsIHdpdGggZmlsZXN5c3RlbSBvcHRpb25zXG4gICAgLy8gV2UgbmVlZCB0byBwYXNzIHRoZXNlIG9wdGlvbnMgdG8gdGhlIHdvcmtlclxuICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBcIklOSVRJQUxJWkVfS0VSTkVMXCIsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGZpbGVzeXN0ZW06IG9wdGlvbnMuZmlsZXN5c3RlbSxcbiAgICAgICAgZW52OiBvcHRpb25zLmVudixcbiAgICAgICAgbG9ja0ZpbGVVUkw6IG9wdGlvbnMubG9ja0ZpbGVVUkwsXG4gICAgICAgIGF1dG9TeW5jRnM6IG9wdGlvbnMuYXV0b1N5bmNGcyxcbiAgICAgICAgbGFuZzogbGFuZ3VhZ2VcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBXYWl0IGZvciBrZXJuZWwgaW5pdGlhbGl6YXRpb25cbiAgICBhd2FpdCBpbml0UHJvbWlzZTtcbiAgICBcbiAgICAvLyBTZXQgdXAgaW50ZXJydXB0IGJ1ZmZlciBhdXRvbWF0aWNhbGx5IGZvciB3b3JrZXIga2VybmVsc1xuICAgIGF3YWl0IHRoaXMuc2V0dXBXb3JrZXJJbnRlcnJ1cHRCdWZmZXIoaWQsIHdvcmtlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHRoZSBrZXJuZWwgaW5zdGFuY2VcbiAgICBjb25zdCBpbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlID0ge1xuICAgICAgaWQsXG4gICAgICBrZXJuZWw6IHtcbiAgICAgICAgLy8gTWFwIG1ldGhvZHMgZnJvbSB0aGUgQ29tbGluayBwcm94eSB0byB0aGUgSUtlcm5lbCBpbnRlcmZhY2VcbiAgICAgICAgaW5pdGlhbGl6ZTogYXN5bmMgKG9wdGlvbnM/OiBJS2VybmVsT3B0aW9ucykgPT4ge1xuICAgICAgICAgIHJldHVybiBrZXJuZWxQcm94eS5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBleGVjdXRlOiBhc3luYyAoY29kZTogc3RyaW5nLCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBrZXJuZWxQcm94eS5leGVjdXRlKGNvZGUsIHBhcmVudCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSGFuZGxlIFB5dGhvbiB3b3JrZXIgcmVzdWx0cyAobm8gc3BlY2lhbCBkaXNwbGF5IHJlY29uc3RydWN0aW9uIG5lZWRlZClcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBpc0luaXRpYWxpemVkOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGtlcm5lbFByb3h5LmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXRSZXBseTogYXN5bmMgKGNvbnRlbnQ6IHsgdmFsdWU6IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGtlcm5lbFByb3h5LmlucHV0UmVwbHkoY29udGVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1hcCBhc3luYyBnZXRTdGF0dXMgbWV0aG9kXG4gICAgICAgIGdldFN0YXR1czogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmdldFN0YXR1cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuZ2V0U3RhdHVzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBcInVua25vd25cIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1hcCBjb21wbGV0aW9uIG1ldGhvZHNcbiAgICAgICAgY29tcGxldGU6IGFzeW5jIChjb2RlOiBzdHJpbmcsIGN1cnNvcl9wb3M6IG51bWJlciwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuY29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmNvbXBsZXRlKGNvZGUsIGN1cnNvcl9wb3MsIHBhcmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiAnQ29tcGxldGlvbiBub3Qgc3VwcG9ydGVkJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiBTdHJpbmcoZXJyb3IpIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnNwZWN0OiBhc3luYyAoY29kZTogc3RyaW5nLCBjdXJzb3JfcG9zOiBudW1iZXIsIGRldGFpbF9sZXZlbDogMCB8IDEsIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5Lmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5Lmluc3BlY3QoY29kZSwgY3Vyc29yX3BvcywgZGV0YWlsX2xldmVsLCBwYXJlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogJ0luc3BlY3Rpb24gbm90IHN1cHBvcnRlZCcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogU3RyaW5nKGVycm9yKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXNDb21wbGV0ZTogYXN5bmMgKGNvZGU6IHN0cmluZywgcGFyZW50PzogYW55KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuaXNDb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuaXNDb21wbGV0ZShjb2RlLCBwYXJlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAndW5rbm93bicgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogU3RyaW5nKGVycm9yKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWFwIGludGVycnVwdCBtZXRob2RzXG4gICAgICAgIGludGVycnVwdDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmludGVycnVwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuaW50ZXJydXB0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludGVycnVwdEJ1ZmZlcjogKGJ1ZmZlcjogVWludDhBcnJheSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LnNldEludGVycnVwdEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBrZXJuZWxQcm94eS5zZXRJbnRlcnJ1cHRCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2V0IGludGVycnVwdCBidWZmZXI6JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWFwIG1vdW50RlMgbWV0aG9kXG4gICAgICAgIG1vdW50RlM6IGFzeW5jIChtb3VudFBhdGg6IHN0cmluZywgZGlySGFuZGxlPzogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSB8IG51bGwsIHBlcm1pc3Npb24/OiAncmVhZCcgfCAncmVhZHdyaXRlJykgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5Lm1vdW50RlMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5Lm1vdW50RlMobW91bnRQYXRoLCBkaXJIYW5kbGUsIHBlcm1pc3Npb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb3VudEZTIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBrZXJuZWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBNYXAgY29tbSBtZXRob2RzXG4gICAgICAgIGNvbW1JbmZvOiBhc3luYyAodGFyZ2V0X25hbWU6IHN0cmluZyB8IG51bGwsIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmNvbW1JbmZvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5jb21tSW5mbyh0YXJnZXRfbmFtZSwgcGFyZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGNvbW1zOiB7fSwgc3RhdHVzOiAnb2snIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbW1zOiB7fSwgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogU3RyaW5nKGVycm9yKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tbU9wZW46IGFzeW5jIChjb250ZW50OiBhbnksIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmNvbW1PcGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5jb21tT3Blbihjb250ZW50LCBwYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBvcGVuIGNvbW06JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tbU1zZzogYXN5bmMgKGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuY29tbU1zZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuY29tbU1zZyhjb250ZW50LCBwYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBzZW5kIGNvbW0gbWVzc2FnZTonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21tQ2xvc2U6IGFzeW5jIChjb250ZW50OiBhbnksIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmNvbW1DbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuY29tbUNsb3NlKGNvbnRlbnQsIHBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGNsb3NlIGNvbW06JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIElLZXJuZWwsXG4gICAgICBtb2RlOiBLZXJuZWxNb2RlLldPUktFUixcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgd29ya2VyLFxuICAgICAgY3JlYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgb3B0aW9ucywgLy8gU3RvcmUgdGhlIG9wdGlvbnMgZm9yIHJlZmVyZW5jZVxuICAgICAgZGVzdHJveTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBDbGVhbiB1cCB0aGUgd29ya2VyIGFuZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgcG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgIHBvcnQxLmNsb3NlKCk7XG4gICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIFxuICAvKipcbiAgICogU2V0dXAgZXZlbnQgZm9yd2FyZGluZyBmcm9tIGtlcm5lbCB0byBtYW5hZ2VyXG4gICAqIEBwYXJhbSBpbnN0YW5jZSBLZXJuZWwgaW5zdGFuY2VcbiAgICovXG4gIHByaXZhdGUgc2V0dXBFdmVudEZvcndhcmRpbmcoaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZSk6IHZvaWQge1xuICAgIC8vIE9ubHkgbmVlZGVkIGZvciBtYWluIHRocmVhZCBrZXJuZWxzIGFzIHdvcmtlciBldmVudHMgYXJlIGhhbmRsZWQgZGlyZWN0bHlcbiAgICBpZiAoaW5zdGFuY2UubW9kZSA9PT0gS2VybmVsTW9kZS5NQUlOX1RIUkVBRCkge1xuICAgICAgLy8gRm9yd2FyZCBhbGwga2VybmVsIGV2ZW50cyB0byB0aGUgbWFuYWdlciB3aXRoIGtlcm5lbCBJRFxuICAgICAgT2JqZWN0LnZhbHVlcyhLZXJuZWxFdmVudHMpLmZvckVhY2goKGV2ZW50VHlwZSkgPT4ge1xuICAgICAgICAvLyBBY2Nlc3MgdGhlIGtlcm5lbCBhcyBhIEtlcm5lbCBpbnN0YW5jZSB3aGljaCBleHRlbmRzIEV2ZW50RW1pdHRlclxuICAgICAgICBjb25zdCBrZXJuZWxFbWl0dGVyID0gaW5zdGFuY2Uua2VybmVsIGFzIHVua25vd24gYXMgRXZlbnRFbWl0dGVyO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyIHRvIGZvcndhcmQgZXZlbnRzXG4gICAgICAgIGtlcm5lbEVtaXR0ZXIub24oZXZlbnRUeXBlLCAoZGF0YTogYW55KSA9PiB7XG4gICAgICAgICAgc3VwZXIuZW1pdChldmVudFR5cGUsIHtcbiAgICAgICAgICAgIGtlcm5lbElkOiBpbnN0YW5jZS5pZCxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBrZXJuZWwgaW5zdGFuY2UgYnkgSURcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBLZXJuZWwgaW5zdGFuY2Ugb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgcHVibGljIGdldEtlcm5lbChpZDogc3RyaW5nKTogSUtlcm5lbEluc3RhbmNlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGFsbCBrZXJuZWwgSURzXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGtlcm5lbCBJRHNcbiAgICovXG4gIHB1YmxpYyBnZXRLZXJuZWxJZHMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua2VybmVscy5rZXlzKCkpO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBhbGwga2VybmVscyB3aXRoIHRoZWlyIGRldGFpbHNcbiAgICogQHBhcmFtIG5hbWVzcGFjZSBPcHRpb25hbCBuYW1lc3BhY2UgdG8gZmlsdGVyIGtlcm5lbHMgYnlcbiAgICogQHJldHVybnMgQXJyYXkgb2Yga2VybmVsIGluZm9ybWF0aW9uIG9iamVjdHNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0S2VybmVscyhuYW1lc3BhY2U/OiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG1vZGU6IEtlcm5lbE1vZGU7XG4gICAgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlO1xuICAgIHN0YXR1czogXCJhY3RpdmVcIiB8IFwiYnVzeVwiIHwgXCJ1bmtub3duXCI7XG4gICAgY3JlYXRlZDogc3RyaW5nO1xuICAgIG5hbWVzcGFjZT86IHN0cmluZztcbiAgICBkZW5vPzoge1xuICAgICAgcGVybWlzc2lvbnM/OiBJRGVub1Blcm1pc3Npb25zO1xuICAgIH07XG4gIH0+PiB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRLZXJuZWxzID0gQXJyYXkuZnJvbSh0aGlzLmtlcm5lbHMuZW50cmllcygpKVxuICAgICAgICAuZmlsdGVyKChbaWRdKSA9PiB7XG4gICAgICAgICAgLy8gRmlsdGVyIG91dCBwb29sIGtlcm5lbHMgKHRlbXBvcmFyeSBrZXJuZWxzIHdpdGggSURzIHN0YXJ0aW5nIHdpdGggXCJwb29sLVwiKVxuICAgICAgICAgIGlmIChpZC5zdGFydHNXaXRoKFwicG9vbC1cIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIW5hbWVzcGFjZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoYCR7bmFtZXNwYWNlfTpgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIFVzZSBQcm9taXNlLmFsbCB0byBnZXQgYWxsIHN0YXR1c2VzIGNvbmN1cnJlbnRseVxuICAgICAgY29uc3Qga2VybmVsSW5mb3MgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgZmlsdGVyZWRLZXJuZWxzLm1hcChhc3luYyAoW2lkLCBpbnN0YW5jZV0pID0+IHtcbiAgICAgICAgICAvLyBFeHRyYWN0IG5hbWVzcGFjZSBmcm9tIGlkIGlmIHByZXNlbnRcbiAgICAgICAgICBjb25zdCBuYW1lc3BhY2VNYXRjaCA9IGlkLm1hdGNoKC9eKFteOl0rKTovKTtcbiAgICAgICAgICBjb25zdCBleHRyYWN0ZWROYW1lc3BhY2UgPSBuYW1lc3BhY2VNYXRjaCA/IG5hbWVzcGFjZU1hdGNoWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCBzdGF0dXMgdXNpbmcgYXN5bmMgZ2V0U3RhdHVzIG1ldGhvZFxuICAgICAgICAgIGxldCBzdGF0dXM6IFwiYWN0aXZlXCIgfCBcImJ1c3lcIiB8IFwidW5rbm93blwiID0gXCJ1bmtub3duXCI7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5rZXJuZWwgJiYgdHlwZW9mIGluc3RhbmNlLmtlcm5lbC5nZXRTdGF0dXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgc3RhdHVzID0gYXdhaXQgaW5zdGFuY2Uua2VybmVsLmdldFN0YXR1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIGdldHRpbmcgc3RhdHVzIGZvciBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgc3RhdHVzID0gXCJ1bmtub3duXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG1vZGU6IGluc3RhbmNlLm1vZGUsXG4gICAgICAgICAgICBsYW5ndWFnZTogaW5zdGFuY2UubGFuZ3VhZ2UsXG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBjcmVhdGVkOiBpbnN0YW5jZS5jcmVhdGVkIHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogZXh0cmFjdGVkTmFtZXNwYWNlLFxuICAgICAgICAgICAgZGVubzogaW5zdGFuY2Uub3B0aW9ucz8uZGVub1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ga2VybmVsSW5mb3M7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBEZXN0cm95IGEga2VybmVsIGluc3RhbmNlXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiBrZXJuZWwgaXMgZGVzdHJveWVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVzdHJveUtlcm5lbChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAvLyBIYW5kbGUgZ3JhY2VmdWxseSAtIGtlcm5lbCBtYXkgYWxyZWFkeSBiZSBkZXN0cm95ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gVmVyaWZ5IHRoZSBkZXN0cm95IGZ1bmN0aW9uIGV4aXN0c1xuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgJHtpZH0gaXMgbWlzc2luZyBkZXN0cm95IGZ1bmN0aW9uICh0eXBlOiAke3R5cGVvZiBpbnN0YW5jZS5kZXN0cm95fSlgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWJvcnQgYWxsIG9uZ29pbmcgb3BlcmF0aW9ucyBmb3IgdGhpcyBrZXJuZWwgZmlyc3RcbiAgICB0aGlzLmFib3J0QWxsS2VybmVsT3BlcmF0aW9ucyhpZCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgYW55IGluYWN0aXZpdHkgdGltZXJcbiAgICB0aGlzLmNsZWFySW5hY3Rpdml0eVRpbWVvdXQoaWQpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGV4ZWN1dGlvbiB0aW1lb3V0c1xuICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVvdXRzLmhhcyhpZCkpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXRzID0gdGhpcy5leGVjdXRpb25UaW1lb3V0cy5nZXQoaWQpITtcbiAgICAgIGZvciAoY29uc3QgdGltZW91dElkIG9mIHRpbWVvdXRzLnZhbHVlcygpKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5leGVjdXRpb25UaW1lb3V0cy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBleGVjdXRpb24gc3RhcnQgdGltZXNcbiAgICBpZiAodGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmhhcyhpZCkpIHtcbiAgICAgIHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBleGVjdXRpb24gbWV0YWRhdGFcbiAgICBpZiAodGhpcy5leGVjdXRpb25NZXRhZGF0YS5oYXMoaWQpKSB7XG4gICAgICB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIGludGVycnVwdCBidWZmZXJzXG4gICAgaWYgKHRoaXMuaW50ZXJydXB0QnVmZmVycy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLmludGVycnVwdEJ1ZmZlcnMuZGVsZXRlKGlkKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgb25nb2luZyBleGVjdXRpb25zIHRyYWNraW5nXG4gICAgdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5kZWxldGUoaWQpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGFjdGl2aXR5IHRyYWNraW5nXG4gICAgdGhpcy5sYXN0QWN0aXZpdHlUaW1lLmRlbGV0ZShpZCk7XG4gICAgXG4gICAgLy8gUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMgZm9yIHRoaXMga2VybmVsXG4gICAgdGhpcy5yZW1vdmVBbGxLZXJuZWxMaXN0ZW5lcnMoaWQpO1xuICAgIFxuICAgIC8vIERlc3Ryb3kgdGhlIGtlcm5lbCBpbnN0YW5jZVxuICAgIGF3YWl0IGluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICBcbiAgICAvLyBSZW1vdmUgdGhlIGtlcm5lbCBmcm9tIHRoZSBtYXBcbiAgICB0aGlzLmtlcm5lbHMuZGVsZXRlKGlkKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIERlc3Ryb3kgYWxsIGtlcm5lbCBpbnN0YW5jZXNcbiAgICogQHBhcmFtIG5hbWVzcGFjZSBPcHRpb25hbCBuYW1lc3BhY2UgdG8gZmlsdGVyIGtlcm5lbHMgdG8gZGVzdHJveVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIGFsbCBrZXJuZWxzIGFyZSBkZXN0cm95ZWRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZXN0cm95QWxsKG5hbWVzcGFjZT86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGlkcyA9IEFycmF5LmZyb20odGhpcy5rZXJuZWxzLmtleXMoKSlcbiAgICAgIC5maWx0ZXIoaWQgPT4ge1xuICAgICAgICBpZiAoIW5hbWVzcGFjZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBpZC5zdGFydHNXaXRoKGAke25hbWVzcGFjZX06YCk7XG4gICAgICB9KTtcbiAgICBcbiAgICAvLyBEZXN0cm95IGFsbCBrZXJuZWxzLCBidXQgc2tpcCBpbmNvbXBsZXRlIGluc3RhbmNlc1xuICAgIGNvbnN0IGRlc3Ryb3lQcm9taXNlcyA9IGlkcy5tYXAoYXN5bmMgKGlkKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgICAgaWYgKCFpbnN0YW5jZSB8fCB0eXBlb2YgaW5zdGFuY2UuZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFNraXBwaW5nIGluY29tcGxldGUga2VybmVsIGluc3RhbmNlICR7aWR9IGR1cmluZyBkZXN0cm95QWxsYCk7XG4gICAgICAgIC8vIEp1c3QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcFxuICAgICAgICB0aGlzLmtlcm5lbHMuZGVsZXRlKGlkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveUtlcm5lbChpZCk7XG4gICAgfSk7XG4gICAgXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoZGVzdHJveVByb21pc2VzKTtcbiAgICBcbiAgICAvLyBJZiBubyBuYW1lc3BhY2Ugc3BlY2lmaWVkLCBhbHNvIGNsZWFuIHVwIHRoZSBwb29sXG4gICAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVzdHJveVBvb2woKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBEZXN0cm95IGFsbCBrZXJuZWxzIGluIHRoZSBwb29sXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGRlc3Ryb3lQb29sKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIFxuICAgIGNvbnN0IGRlc3Ryb3lQcm9taXNlczogUHJvbWlzZTx2b2lkPltdID0gW107XG4gICAgXG4gICAgZm9yIChjb25zdCBbcG9vbEtleSwgcHJvbWlzZXNdIG9mIHRoaXMucG9vbC5lbnRyaWVzKCkpIHtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBrZXJuZWxQcm9taXNlIG9mIHByb21pc2VzKSB7XG4gICAgICAgIC8vIEhhbmRsZSBlYWNoIHByb21pc2UgLSBpZiBpdCByZXNvbHZlcywgZGVzdHJveSB0aGUga2VybmVsXG4gICAgICAgIGNvbnN0IGRlc3Ryb3lQcm9taXNlID0ga2VybmVsUHJvbWlzZS50aGVuKGtlcm5lbCA9PiB7XG4gICAgICAgICAgcmV0dXJuIGtlcm5lbC5kZXN0cm95KCk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZXN0cm95aW5nIHBvb2wga2VybmVsIGZyb20gcHJvbWlzZTpgLCBlcnJvcik7XG4gICAgICAgICAgLy8gRG9uJ3QgcmUtdGhyb3cgdG8gYXZvaWQgdW5oYW5kbGVkIHJlamVjdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBkZXN0cm95UHJvbWlzZXMucHVzaChkZXN0cm95UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFdhaXQgZm9yIGFsbCBwb29sIGtlcm5lbHMgdG8gYmUgZGVzdHJveWVkXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoZGVzdHJveVByb21pc2VzKTtcbiAgICBcbiAgICAvLyBDbGVhciB0aGUgcG9vbCBhbmQgcHJlZmlsbGluZyBmbGFnc1xuICAgIHRoaXMucG9vbC5jbGVhcigpO1xuICAgIHRoaXMucHJlZmlsbGluZ0luUHJvZ3Jlc3MuY2xlYXIoKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBhIHNwZWNpZmljIGtlcm5lbCdzIGV2ZW50c1xuICAgKiBAcGFyYW0ga2VybmVsSWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBldmVudFR5cGUgRXZlbnQgdHlwZVxuICAgKiBAcGFyYW0gbGlzdGVuZXIgRXZlbnQgbGlzdGVuZXJcbiAgICovXG4gIHB1YmxpYyBvbktlcm5lbEV2ZW50KGtlcm5lbElkOiBzdHJpbmcsIGV2ZW50VHlwZTogS2VybmVsRXZlbnRzLCBsaXN0ZW5lcjogKGRhdGE6IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgIC8vIENoZWNrIGlmIGtlcm5lbCBleGlzdHNcbiAgICBpZiAoIXRoaXMua2VybmVscy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCB3aXRoIElEICR7a2VybmVsSWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgd3JhcHBlciB0aGF0IGZpbHRlcnMgZXZlbnRzIGZvciB0aGlzIHNwZWNpZmljIGtlcm5lbFxuICAgIGNvbnN0IHdyYXBwZXI6IExpc3RlbmVyV3JhcHBlciA9IHtcbiAgICAgIG9yaWdpbmFsOiBsaXN0ZW5lcixcbiAgICAgIHdyYXBwZWQ6IChldmVudDogeyBrZXJuZWxJZDogc3RyaW5nLCBkYXRhOiBhbnkgfSkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQua2VybmVsSWQgPT09IGtlcm5lbElkKSB7XG4gICAgICAgICAgLy8gUGFzcyBqdXN0IHRoZSBkYXRhIHRvIHRoZSBsaXN0ZW5lclxuICAgICAgICAgIC8vIFRoZSBkYXRhIHN0cnVjdHVyZSBpcyBjb25zaXN0ZW50IGFjcm9zcyBtYWluIHRocmVhZCBhbmQgd29ya2VyIG1vZGVzXG4gICAgICAgICAgbGlzdGVuZXIoZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIFN0b3JlIHRoZSB3cmFwcGVyIGZvciBsYXRlciByZW1vdmFsXG4gICAgdGhpcy5zdG9yZUxpc3RlbmVyKGtlcm5lbElkLCBldmVudFR5cGUsIGxpc3RlbmVyLCB3cmFwcGVyKTtcbiAgICBcbiAgICAvLyBBZGQgdGhlIHdyYXBwZWQgbGlzdGVuZXIgdG8gdGhlIG1hbmFnZXJcbiAgICBzdXBlci5vbihldmVudFR5cGUsIHdyYXBwZXIud3JhcHBlZCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWMga2VybmVsXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIGV2ZW50VHlwZSBFdmVudCB0eXBlXG4gICAqIEBwYXJhbSBsaXN0ZW5lciBFdmVudCBsaXN0ZW5lclxuICAgKi9cbiAgcHVibGljIG9mZktlcm5lbEV2ZW50KGtlcm5lbElkOiBzdHJpbmcsIGV2ZW50VHlwZTogS2VybmVsRXZlbnRzLCBsaXN0ZW5lcjogKGRhdGE6IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLmdldExpc3RlbmVyKGtlcm5lbElkLCBldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICBcbiAgICBpZiAod3JhcHBlcikge1xuICAgICAgLy8gUmVtb3ZlIHRoZSB3cmFwcGVkIGxpc3RlbmVyIGZyb20gdGhlIG1hbmFnZXJcbiAgICAgIHN1cGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50VHlwZSwgd3JhcHBlci53cmFwcGVkKTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIHRoZSB3cmFwcGVyIGZyb20gb3VyIHRyYWNraW5nIG1hcFxuICAgICAgdGhpcy5yZW1vdmVTdG9yZWRMaXN0ZW5lcihrZXJuZWxJZCwgZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogU3RvcmUgYSBsaXN0ZW5lciB3cmFwcGVyIGZvciBsYXRlciByZW1vdmFsXG4gICAqL1xuICBwcml2YXRlIHN0b3JlTGlzdGVuZXIoXG4gICAga2VybmVsSWQ6IHN0cmluZywgXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsIFxuICAgIG9yaWdpbmFsOiBGdW5jdGlvbiwgXG4gICAgd3JhcHBlcjogTGlzdGVuZXJXcmFwcGVyXG4gICk6IHZvaWQge1xuICAgIC8vIEdldCBvciBjcmVhdGUga2VybmVsIG1hcFxuICAgIGlmICghdGhpcy5saXN0ZW5lcldyYXBwZXJzLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJXcmFwcGVycy5zZXQoa2VybmVsSWQsIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbE1hcCA9IHRoaXMubGlzdGVuZXJXcmFwcGVycy5nZXQoa2VybmVsSWQpITtcbiAgICBcbiAgICAvLyBHZXQgb3IgY3JlYXRlIGV2ZW50IHR5cGUgbWFwXG4gICAgaWYgKCFrZXJuZWxNYXAuaGFzKGV2ZW50VHlwZSkpIHtcbiAgICAgIGtlcm5lbE1hcC5zZXQoZXZlbnRUeXBlLCBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBjb25zdCBldmVudE1hcCA9IGtlcm5lbE1hcC5nZXQoZXZlbnRUeXBlKSE7XG4gICAgXG4gICAgLy8gU3RvcmUgdGhlIHdyYXBwZXJcbiAgICBldmVudE1hcC5zZXQob3JpZ2luYWwsIHdyYXBwZXIpO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IGEgc3RvcmVkIGxpc3RlbmVyIHdyYXBwZXJcbiAgICovXG4gIHByaXZhdGUgZ2V0TGlzdGVuZXIoXG4gICAga2VybmVsSWQ6IHN0cmluZywgXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsIFxuICAgIG9yaWdpbmFsOiBGdW5jdGlvblxuICApOiBMaXN0ZW5lcldyYXBwZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGtlcm5lbE1hcCA9IHRoaXMubGlzdGVuZXJXcmFwcGVycy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsTWFwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIGNvbnN0IGV2ZW50TWFwID0ga2VybmVsTWFwLmdldChldmVudFR5cGUpO1xuICAgIGlmICghZXZlbnRNYXApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgcmV0dXJuIGV2ZW50TWFwLmdldChvcmlnaW5hbCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBzdG9yZWQgbGlzdGVuZXIgd3JhcHBlclxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVTdG9yZWRMaXN0ZW5lcihcbiAgICBrZXJuZWxJZDogc3RyaW5nLCBcbiAgICBldmVudFR5cGU6IHN0cmluZywgXG4gICAgb3JpZ2luYWw6IEZ1bmN0aW9uXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGtlcm5lbE1hcCA9IHRoaXMubGlzdGVuZXJXcmFwcGVycy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsTWFwKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZXZlbnRNYXAgPSBrZXJuZWxNYXAuZ2V0KGV2ZW50VHlwZSk7XG4gICAgaWYgKCFldmVudE1hcCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIFJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICBldmVudE1hcC5kZWxldGUob3JpZ2luYWwpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGVtcHR5IG1hcHNcbiAgICBpZiAoZXZlbnRNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAga2VybmVsTWFwLmRlbGV0ZShldmVudFR5cGUpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoa2VybmVsTWFwLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMubGlzdGVuZXJXcmFwcGVycy5kZWxldGUoa2VybmVsSWQpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIGtlcm5lbFxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVBbGxLZXJuZWxMaXN0ZW5lcnMoa2VybmVsSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGtlcm5lbE1hcCA9IHRoaXMubGlzdGVuZXJXcmFwcGVycy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsTWFwKSByZXR1cm47XG4gICAgXG4gICAgLy8gRm9yIGVhY2ggZXZlbnQgdHlwZVxuICAgIGZvciAoY29uc3QgW2V2ZW50VHlwZSwgZXZlbnRNYXBdIG9mIGtlcm5lbE1hcC5lbnRyaWVzKCkpIHtcbiAgICAgIC8vIEZvciBlYWNoIG9yaWdpbmFsIGxpc3RlbmVyXG4gICAgICBmb3IgKGNvbnN0IHdyYXBwZXIgb2YgZXZlbnRNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB3cmFwcGVkIGxpc3RlbmVyIGZyb20gdGhlIG1hbmFnZXJcbiAgICAgICAgc3VwZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnRUeXBlLCB3cmFwcGVyLndyYXBwZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhciB0aGUga2VybmVsJ3MgbGlzdGVuZXIgbWFwXG4gICAgdGhpcy5saXN0ZW5lcldyYXBwZXJzLmRlbGV0ZShrZXJuZWxJZCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYWxsIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBrZXJuZWwgYW5kIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIGtlcm5lbElkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gZXZlbnRUeXBlIEV2ZW50IHR5cGVcbiAgICogQHJldHVybnMgQXJyYXkgb2YgbGlzdGVuZXJzXG4gICAqL1xuICBwdWJsaWMgZ2V0TGlzdGVuZXJzKGtlcm5lbElkOiBzdHJpbmcsIGV2ZW50VHlwZTogS2VybmVsRXZlbnRzKTogKChkYXRhOiBhbnkpID0+IHZvaWQpW10ge1xuICAgIGNvbnN0IGtlcm5lbExpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJXcmFwcGVycy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsTGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0ga2VybmVsTGlzdGVuZXJzLmdldChldmVudFR5cGUpO1xuICAgIGlmICghZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZXZlbnRMaXN0ZW5lcnMua2V5cygpKSBhcyAoKGRhdGE6IGFueSkgPT4gdm9pZClbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIFB5dGhvbiBjb2RlIHdpdGggc3RyZWFtaW5nIG91dHB1dFxuICAgKiBUaGlzIG1ldGhvZCB3b3JrcyBpbiBib3RoIG1haW4gdGhyZWFkIGFuZCB3b3JrZXIgbW9kZXNcbiAgICogQHBhcmFtIGtlcm5lbElkIElEIG9mIHRoZSBrZXJuZWwgdG8gdXNlXG4gICAqIEBwYXJhbSBjb2RlIFRoZSBQeXRob24gY29kZSB0byBleGVjdXRlXG4gICAqIEBwYXJhbSBwYXJlbnQgT3B0aW9uYWwgcGFyZW50IG1lc3NhZ2UgaGVhZGVyXG4gICAqIEByZXR1cm5zIEFzeW5jR2VuZXJhdG9yIHlpZWxkaW5nIGludGVybWVkaWF0ZSBvdXRwdXRzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMqIGV4ZWN1dGVTdHJlYW0oXG4gICAga2VybmVsSWQ6IHN0cmluZywgXG4gICAgY29kZTogc3RyaW5nLCBcbiAgICBwYXJlbnQ6IGFueSA9IHt9XG4gICk6IEFzeW5jR2VuZXJhdG9yPGFueSwgeyBzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ/OiBhbnksIGVycm9yPzogRXJyb3IgfSwgdm9pZD4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRLZXJuZWwoa2VybmVsSWQpO1xuICAgIFxuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsIHdpdGggSUQgJHtrZXJuZWxJZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBrZXJuZWwgYWN0aXZpdHlcbiAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICBcbiAgICAvLyBUcmFjayB0aGlzIGV4ZWN1dGlvbiB3aXRoIHRoZSBjb2RlIGZvciBiZXR0ZXIgbW9uaXRvcmluZ1xuICAgIGNvbnN0IGV4ZWN1dGlvbklkID0gdGhpcy50cmFja0V4ZWN1dGlvbihrZXJuZWxJZCwgY29kZSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIEFib3J0Q29udHJvbGxlciBmb3IgdGhpcyBleGVjdXRpb24gdG8gZW5hYmxlIGNhbmNlbGxhdGlvblxuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLnN0b3JlQWJvcnRDb250cm9sbGVyKGtlcm5lbElkLCBleGVjdXRpb25JZCwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gRm9yIG1haW4gdGhyZWFkIGtlcm5lbHMsIHdlIGNhbiB1c2UgdGhlIGV4ZWN1dGVTdHJlYW0gbWV0aG9kIGRpcmVjdGx5XG4gICAgICBpZiAoaW5zdGFuY2UubW9kZSA9PT0gS2VybmVsTW9kZS5NQUlOX1RIUkVBRCkge1xuICAgICAgICBjb25zdCBrZXJuZWwgPSBpbnN0YW5jZS5rZXJuZWwgYXMgdW5rbm93biBhcyB7IFxuICAgICAgICAgIGV4ZWN1dGVTdHJlYW06IChjb2RlOiBzdHJpbmcsIHBhcmVudDogYW55KSA9PiBBc3luY0dlbmVyYXRvcjxhbnksIGFueSwgdm9pZD4gXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBGb3J3YXJkIHRvIHRoZSBrZXJuZWwncyBleGVjdXRlU3RyZWFtIG1ldGhvZFxuICAgICAgICBpZiAodHlwZW9mIGtlcm5lbC5leGVjdXRlU3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHlpZWxkKiBrZXJuZWwuZXhlY3V0ZVN0cmVhbShjb2RlLCBwYXJlbnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZpdHkgYWZ0ZXIgZXhlY3V0aW9uIGNvbXBsZXRlc1xuICAgICAgICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbXBsZXRlIGV4ZWN1dGlvbiB0cmFja2luZ1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUV4ZWN1dGlvbihrZXJuZWxJZCwgZXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIG1haW4gdGhyZWFkIGV4ZWN1dGVTdHJlYW06YCwgZXJyb3IpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZpdHkgZXZlbiBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ29tcGxldGUgZXhlY3V0aW9uIHRyYWNraW5nIGV2ZW4gb24gZXJyb3JcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVFeGVjdXRpb24oa2VybmVsSWQsIGV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRm9yIHdvcmtlciBtb2RlLCB3ZSBuZWVkIHRvIGltcGxlbWVudCBzdHJlYW1pbmcgdmlhIGV2ZW50cyB3aXRoIHByb3BlciBpc29sYXRpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEV2ZW50LWJhc2VkIGFwcHJvYWNoIGZvciB3b3JrZXIga2VybmVscyBvciBtYWluIHRocmVhZCBrZXJuZWxzIHdpdGhvdXQgZXhlY3V0ZVN0cmVhbVxuICAgICAgICBjb25zdCBzdHJlYW1RdWV1ZTogYW55W10gPSBbXTtcbiAgICAgICAgbGV0IGV4ZWN1dGlvbkNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIGxldCBleGVjdXRpb25SZXN1bHQ6IHsgc3VjY2VzczogYm9vbGVhbiwgcmVzdWx0PzogYW55LCBlcnJvcj86IEVycm9yIH0gPSB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIGhhbmRsZXIgcmVmZXJlbmNlcyBmb3IgZ3VhcmFudGVlZCBjbGVhbnVwXG4gICAgICAgIGNvbnN0IGV2ZW50SGFuZGxlcnMgPSBuZXcgTWFwPHN0cmluZywgKGV2ZW50OiB7IGtlcm5lbElkOiBzdHJpbmcsIGRhdGE6IGFueSB9KSA9PiB2b2lkPigpO1xuICAgICAgICBcbiAgICAgICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNsZWFuIHVwIGFsbCBldmVudCBoYW5kbGVyc1xuICAgICAgICBjb25zdCBjbGVhbnVwSGFuZGxlcnMgPSAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBbZXZlbnRUeXBlLCBoYW5kbGVyXSBvZiBldmVudEhhbmRsZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgc3VwZXIub2ZmKGV2ZW50VHlwZSBhcyBhbnksIGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudEhhbmRsZXJzLmNsZWFyKCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgZXhlY3V0aW9uLXNwZWNpZmljIGV2ZW50IGhhbmRsZXJzIHRoYXQgaW5jbHVkZSBleGVjdXRpb25JZCBjaGVja1xuICAgICAgICBjb25zdCBjcmVhdGVIYW5kbGVyID0gKGV2ZW50VHlwZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IChldmVudDogeyBrZXJuZWxJZDogc3RyaW5nLCBkYXRhOiBhbnkgfSkgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBwcm9jZXNzIGV2ZW50cyBmb3IgdGhpcyBzcGVjaWZpYyBrZXJuZWwgYW5kIHdoaWxlIHRoaXMgZXhlY3V0aW9uIGlzIGFjdGl2ZVxuICAgICAgICAgICAgaWYgKGV2ZW50Lmtlcm5lbElkID09PSBrZXJuZWxJZCAmJiAhZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgc3RyZWFtUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogZXZlbnRUeXBlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uSWQgLy8gSW5jbHVkZSBleGVjdXRpb24gSUQgZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEV2ZW50cyBhbHNvIGNvdW50IGFzIGFjdGl2aXR5XG4gICAgICAgICAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgZXZlbnRIYW5kbGVycy5zZXQoZXZlbnRUeXBlLCBoYW5kbGVyKTtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhbmQgcmVnaXN0ZXIgYWxsIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGNvbnN0IGhhbmRsZVN0cmVhbUV2ZW50ID0gY3JlYXRlSGFuZGxlcignc3RyZWFtJyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZURpc3BsYXlFdmVudCA9IGNyZWF0ZUhhbmRsZXIoJ2Rpc3BsYXlfZGF0YScpO1xuICAgICAgICBjb25zdCBoYW5kbGVVcGRhdGVEaXNwbGF5RXZlbnQgPSBjcmVhdGVIYW5kbGVyKCd1cGRhdGVfZGlzcGxheV9kYXRhJyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc3VsdEV2ZW50ID0gY3JlYXRlSGFuZGxlcignZXhlY3V0ZV9yZXN1bHQnKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRXJyb3JFdmVudCA9IGNyZWF0ZUhhbmRsZXIoJ2V4ZWN1dGVfZXJyb3InKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlZ2lzdGVyIGhhbmRsZXJzXG4gICAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5TVFJFQU0sIGhhbmRsZVN0cmVhbUV2ZW50KTtcbiAgICAgICAgc3VwZXIub24oS2VybmVsRXZlbnRzLkRJU1BMQVlfREFUQSwgaGFuZGxlRGlzcGxheUV2ZW50KTtcbiAgICAgICAgc3VwZXIub24oS2VybmVsRXZlbnRzLlVQREFURV9ESVNQTEFZX0RBVEEsIGhhbmRsZVVwZGF0ZURpc3BsYXlFdmVudCk7XG4gICAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5FWEVDVVRFX1JFU1VMVCwgaGFuZGxlUmVzdWx0RXZlbnQpO1xuICAgICAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwgaGFuZGxlRXJyb3JFdmVudCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvblByb21pc2UgPSBuZXcgUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgLy8gU2V0IHVwIGEgaGFuZGxlciBmb3IgZXhlY3V0aW9uIGVycm9ycyBzcGVjaWZpY2FsbHlcbiAgICAgICAgICBjb25zdCBoYW5kbGVFeGVjdXRpb25FcnJvciA9IChldmVudDogeyBrZXJuZWxJZDogc3RyaW5nLCBkYXRhOiBhbnkgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50Lmtlcm5lbElkID09PSBrZXJuZWxJZCAmJiAhZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgLy8gTWFyayBleGVjdXRpb24gYXMgY29tcGxldGUgdG8gc3RvcCBwcm9jZXNzaW5nIG1vcmUgZXZlbnRzXG4gICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBlcnJvciBmb3IgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgICAgICAgICBleGVjdXRpb25SZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgJHtldmVudC5kYXRhLmVuYW1lfTogJHtldmVudC5kYXRhLmV2YWx1ZX1gKSxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGV2ZW50LmRhdGFcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3Rpdml0eVxuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJlc29sdmUoZXhlY3V0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFkZCBlcnJvciBoYW5kbGVyIHRvIG91ciBjbGVhbnVwIGxpc3RcbiAgICAgICAgICBldmVudEhhbmRsZXJzLnNldCgnZXhlY3V0ZV9lcnJvcl9jb21wbGV0aW9uJywgaGFuZGxlRXhlY3V0aW9uRXJyb3IpO1xuICAgICAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCBoYW5kbGVFeGVjdXRpb25FcnJvcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBhYm9ydGVkXG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZXhlY3V0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdFeGVjdXRpb24gd2FzIGFib3J0ZWQnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNldCB1cCBhYm9ydCBoYW5kbGVyXG4gICAgICAgICAgY29uc3QgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+aqyBFeGVjdXRpb24gJHtleGVjdXRpb25JZH0gYWJvcnRlZGApO1xuICAgICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdFeGVjdXRpb24gd2FzIGFib3J0ZWQnKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNvZGVcbiAgICAgICAgICAvLyBXZSBrbm93IHRoZSBleGVjdXRlIG1ldGhvZCBpcyBhdmFpbGFibGUgZGlyZWN0bHkgb24gdGhlIGtlcm5lbCBvYmplY3RcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZVByb21pc2UgPSBpbnN0YW5jZS5rZXJuZWwuZXhlY3V0ZShjb2RlLCBwYXJlbnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleGVjdXRlUHJvbWlzZS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgLy8gT25seSBwcm9jZXNzIGlmIGV4ZWN1dGlvbiBoYXNuJ3QgYmVlbiBtYXJrZWQgY29tcGxldGUgYWxyZWFkeVxuICAgICAgICAgICAgICBpZiAoIWV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV4ZWN1dGlvbiByZXN1bHQgaW5kaWNhdGVzIGFuIGVycm9yIChmb3IgUHl0aG9uIGtlcm5lbHMpXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5yZXN1bHQgJiYgcmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGFzIGVycm9yXG4gICAgICAgICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzdWx0LnJlc3VsdC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGVuYW1lOiByZXN1bHQucmVzdWx0LmVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBldmFsdWU6IHJlc3VsdC5yZXN1bHQuZXZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZWJhY2s6IHJlc3VsdC5yZXN1bHQudHJhY2ViYWNrXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBQdXNoIGVycm9yIHRvIHN0cmVhbSBxdWV1ZSBkaXJlY3RseSBcbiAgICAgICAgICAgICAgICAgIHN0cmVhbVF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBlcnJvckRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbklkXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4ZWN1dGlvbiByZXN1bHQgdG8gcmVmbGVjdCB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvblJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYCR7cmVzdWx0LnJlc3VsdC5lbmFtZX06ICR7cmVzdWx0LnJlc3VsdC5ldmFsdWV9YCksXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LnJlc3VsdFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZXhlY3V0aW9uUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5IHdoZW4gZXhlY3V0aW9uIGNvbXBsZXRlc1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJlc29sdmUoZXhlY3V0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBpZiBleGVjdXRpb24gaGFzbid0IGJlZW4gbWFya2VkIGNvbXBsZXRlIGFscmVhZHlcbiAgICAgICAgICAgICAgaWYgKCFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGV4ZWN1dGUgZm9yIGtlcm5lbCAke2tlcm5lbElkfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIEtleWJvYXJkSW50ZXJydXB0IGFuZCBoYW5kbGUgaXQgc3BlY2lhbGx5XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzS2V5Ym9hcmRJbnRlcnJ1cHQoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgS2V5Ym9hcmRJbnRlcnJ1cHQgY2F1Z2h0IGluIGV4ZWN1dGVTdHJlYW0gZm9yIGtlcm5lbCAke2tlcm5lbElkfWApO1xuICAgICAgICAgICAgICAgICAgZXJyb3JSZXN1bHQgPSB0aGlzLmNyZWF0ZUtleWJvYXJkSW50ZXJydXB0UmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEFsc28gcHVzaCB0byBzdHJlYW0gcXVldWUgZm9yIGltbWVkaWF0ZSBmZWVkYmFja1xuICAgICAgICAgICAgICAgICAgc3RyZWFtUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGVycm9yUmVzdWx0LnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0aW9uSWRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgb3RoZXIgZXJyb3JzIG5vcm1hbGx5XG4gICAgICAgICAgICAgICAgICBlcnJvclJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleGVjdXRpb25SZXN1bHQgPSBlcnJvclJlc3VsdDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZpdHkgZXZlbiBvbiBlcnJvclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJlc29sdmUoZXJyb3JSZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gT25seSBwcm9jZXNzIGlmIGV4ZWN1dGlvbiBoYXNuJ3QgYmVlbiBtYXJrZWQgY29tcGxldGUgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKCFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjYWxsaW5nIGV4ZWN1dGUgZm9yIGtlcm5lbCAke2tlcm5lbElkfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBTaW1wbGUgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgICAgICAgY29uc3QgZXJyb3JSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZXhlY3V0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICBleGVjdXRpb25SZXN1bHQgPSBlcnJvclJlc3VsdDtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3Rpdml0eSBldmVuIG9uIGRpcmVjdCBlcnJvclxuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJlc29sdmUoZXJyb3JSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVc2UgdHJ5L2ZpbmFsbHkgdG8gZ3VhcmFudGVlIGNsZWFudXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBNb25pdG9yIHRoZSBzdHJlYW0gcXVldWUgYW5kIHlpZWxkIHJlc3VsdHNcbiAgICAgICAgICAvLyBDb250aW51ZSB1bnRpbCBleGVjdXRpb24gaXMgY29tcGxldGUgQU5EIGFsbCBxdWV1ZWQgZXZlbnRzIGhhdmUgYmVlbiB5aWVsZGVkXG4gICAgICAgICAgd2hpbGUgKCghZXhlY3V0aW9uQ29tcGxldGUgfHwgc3RyZWFtUXVldWUubGVuZ3RoID4gMCkgJiYgIWFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGl0ZW1zIGluIHRoZSBxdWV1ZSwgeWllbGQgdGhlbVxuICAgICAgICAgICAgaWYgKHN0cmVhbVF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBzdHJlYW1RdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIG5vIG1vcmUgZXZlbnRzIGJ1dCBleGVjdXRpb24gaXMgbm90IGNvbXBsZXRlLCB3YWl0IGEgbGl0dGxlXG4gICAgICAgICAgICBpZiAoIWV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIC8vIFVzZSBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSB3YWl0XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dChyZXNvbHZlLCAxMCk7XG4gICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQWJvcnRlZCcpKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIGFib3J0ZWQsIGJyZWFrIG91dCBvZiBsb29wXG4gICAgICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIGV4ZWN1dGlvbiB3YXMgYWJvcnRlZCBkdXJpbmcgc3RyZWFtIG1vbml0b3JpbmdcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkICYmICFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGVjdXRpb24gd2FzIGFib3J0ZWQgZHVyaW5nIHN0cmVhbSBtb25pdG9yaW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRpb25Qcm9taXNlO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gQUxXQVlTIGNsZWFuIHVwIGV2ZW50IGhhbmRsZXJzIHJlZ2FyZGxlc3Mgb2YgaG93IGV4ZWN1dGlvbiBlbmRzXG4gICAgICAgICAgY2xlYW51cEhhbmRsZXJzKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIEFib3J0Q29udHJvbGxlciB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWJvcnRDb250cm9sbGVyKGtlcm5lbElkLCBleGVjdXRpb25JZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ29tcGxldGUgZXhlY3V0aW9uIHRyYWNraW5nXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZUV4ZWN1dGlvbihrZXJuZWxJZCwgZXhlY3V0aW9uSWQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBDb21wbGV0ZSBleGVjdXRpb24gdHJhY2tpbmcgb24gYW55IG91dGVyIGVycm9yXG4gICAgICAgIHRoaXMuY29tcGxldGVFeGVjdXRpb24oa2VybmVsSWQsIGV4ZWN1dGlvbklkKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuZXhwZWN0ZWQgZXJyb3IgaW4gZXhlY3V0ZVN0cmVhbTpgLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gQ29tcGxldGUgZXhlY3V0aW9uIHRyYWNraW5nIG9uIGFueSBvdXRlciBlcnJvclxuICAgICAgdGhpcy5jb21wbGV0ZUV4ZWN1dGlvbihrZXJuZWxJZCwgZXhlY3V0aW9uSWQpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmVycm9yKGBVbmV4cGVjdGVkIGVycm9yIGluIGV4ZWN1dGVTdHJlYW06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFjayBhIG5ldyBleGVjdXRpb24gdGFzayBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGtlcm5lbElkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gY29kZSBPcHRpb25hbCBjb2RlIGJlaW5nIGV4ZWN1dGVkIGZvciBtZXRhZGF0YVxuICAgKiBAcmV0dXJucyBVbmlxdWUgZXhlY3V0aW9uIElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHRyYWNrRXhlY3V0aW9uKGtlcm5lbElkOiBzdHJpbmcsIGNvZGU/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBleGVjdXRpb24gSURcbiAgICBjb25zdCBleGVjdXRpb25JZCA9IGBleGVjLSR7Y3J5cHRvLnJhbmRvbVVVSUQoKX1gO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gUmVzZXQgaW50ZXJydXB0IGJ1ZmZlciBmb3Igd29ya2VyIGtlcm5lbHMgYmVmb3JlIGVhY2ggbmV3IGV4ZWN1dGlvblxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGUga2VybmVsIGNhbiBiZSBpbnRlcnJ1cHRlZCBtdWx0aXBsZSB0aW1lc1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLm1vZGUgPT09IEtlcm5lbE1vZGUuV09SS0VSICYmIHRoaXMuaW50ZXJydXB0QnVmZmVycy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICBjb25zdCBpbnRlcnJ1cHRCdWZmZXIgPSB0aGlzLmludGVycnVwdEJ1ZmZlcnMuZ2V0KGtlcm5lbElkKSE7XG4gICAgICAvLyBSZXNldCBidWZmZXIgdG8gMCAobm8gaW50ZXJydXB0IHNpZ25hbCkgdG8gZW5zdXJlIGNsZWFuIHN0YXRlXG4gICAgICBpbnRlcnJ1cHRCdWZmZXJbMF0gPSAwO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBzZXQgb2Ygb25nb2luZyBleGVjdXRpb25zIGZvciB0aGlzIGtlcm5lbFxuICAgIGlmICghdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLnNldChrZXJuZWxJZCwgbmV3IFNldCgpKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHRoaXMgZXhlY3V0aW9uIHRvIHRoZSBzZXRcbiAgICB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChrZXJuZWxJZCkhLmFkZChleGVjdXRpb25JZCk7XG4gICAgXG4gICAgLy8gVHJhY2sgZXhlY3V0aW9uIHN0YXJ0IHRpbWVcbiAgICBpZiAoIXRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICB0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuc2V0KGtlcm5lbElkLCBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICB0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuZ2V0KGtlcm5lbElkKSEuc2V0KGV4ZWN1dGlvbklkLCBzdGFydFRpbWUpO1xuICAgIFxuICAgIC8vIFRyYWNrIGV4ZWN1dGlvbiBtZXRhZGF0YVxuICAgIGlmICghdGhpcy5leGVjdXRpb25NZXRhZGF0YS5oYXMoa2VybmVsSWQpKSB7XG4gICAgICB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLnNldChrZXJuZWxJZCwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIGFjdGl2aXR5IHRpbWVzdGFtcFxuICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgIFxuICAgIC8vIElmIG1heEV4ZWN1dGlvblRpbWUgaXMgc2V0LCBjcmVhdGUgYSB0aW1lb3V0IHRvIGRldGVjdCBzdHVjay9kZWFkIGtlcm5lbHNcbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lICYmIGluc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSA+IDApIHtcbiAgICAgIC8vIEdldCBvciBjcmVhdGUgdGhlIG1hcCBvZiBleGVjdXRpb24gdGltZW91dHMgZm9yIHRoaXMga2VybmVsXG4gICAgICBpZiAoIXRoaXMuZXhlY3V0aW9uVGltZW91dHMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgICB0aGlzLmV4ZWN1dGlvblRpbWVvdXRzLnNldChrZXJuZWxJZCwgbmV3IE1hcCgpKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2V0IGEgdGltZW91dCBmb3IgdGhpcyBleGVjdXRpb24gd2l0aCBlbmhhbmNlZCBoYW5kbGluZ1xuICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRXhlY3V0aW9uICR7ZXhlY3V0aW9uSWR9IG9uIGtlcm5lbCAke2tlcm5lbElkfSBoYXMgYmVlbiBydW5uaW5nIGZvciAke2luc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZX1tcyBhbmQgbWF5IGJlIHN0dWNrL2RlYWQuYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgZXhlY3V0aW9uIG1ldGFkYXRhIGZvciBiZXR0ZXIgZXJyb3IgcmVwb3J0aW5nXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5leGVjdXRpb25NZXRhZGF0YS5nZXQoa2VybmVsSWQpPy5nZXQoZXhlY3V0aW9uSWQpO1xuICAgICAgICBjb25zdCBhY3R1YWxSdW50aW1lID0gRGF0ZS5ub3coKSAtIChtZXRhZGF0YT8uc3RhcnRUaW1lIHx8IHN0YXJ0VGltZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBFbWl0IGEgc3RhbGxlZCBleGVjdXRpb24gZXZlbnQgd2l0aCBlbmhhbmNlZCBpbmZvcm1hdGlvblxuICAgICAgICBzdXBlci5lbWl0KCdleGVjdXRpb25fc3RhbGxlZCcsIHtcbiAgICAgICAgICBrZXJuZWxJZCxcbiAgICAgICAgICBleGVjdXRpb25JZCxcbiAgICAgICAgICBtYXhFeGVjdXRpb25UaW1lOiBpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWUsXG4gICAgICAgICAgYWN0dWFsUnVudGltZSxcbiAgICAgICAgICBjb2RlOiBtZXRhZGF0YT8uY29kZSB8fCBjb2RlLFxuICAgICAgICAgIHN0YXJ0VGltZTogbWV0YWRhdGE/LnN0YXJ0VGltZSB8fCBzdGFydFRpbWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBdXRvLWhhbmRsZSBzdHVjayBleGVjdXRpb24gaWYgY29uZmlndXJlZFxuICAgICAgICB0aGlzLmhhbmRsZVN0dWNrRXhlY3V0aW9uKGtlcm5lbElkLCBleGVjdXRpb25JZCwgYWN0dWFsUnVudGltZSwgbWV0YWRhdGE/LmNvZGUgfHwgY29kZSk7XG4gICAgICB9LCBpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWUpO1xuICAgICAgXG4gICAgICAvLyBTdG9yZSB0aGUgdGltZW91dCBJRFxuICAgICAgdGhpcy5leGVjdXRpb25UaW1lb3V0cy5nZXQoa2VybmVsSWQpIS5zZXQoZXhlY3V0aW9uSWQsIHRpbWVvdXRJZCk7XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIG1ldGFkYXRhIGluY2x1ZGluZyB0aW1lb3V0IElEXG4gICAgICB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmdldChrZXJuZWxJZCkhLnNldChleGVjdXRpb25JZCwge1xuICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHRpbWVvdXRJZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0b3JlIG1ldGFkYXRhIHdpdGhvdXQgdGltZW91dCBJRFxuICAgICAgdGhpcy5leGVjdXRpb25NZXRhZGF0YS5nZXQoa2VybmVsSWQpIS5zZXQoZXhlY3V0aW9uSWQsIHtcbiAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICBjb2RlXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGV4ZWN1dGlvbklkO1xuICB9XG4gIFxuICAvKipcbiAgICogQ29tcGxldGUgdHJhY2tpbmcgZm9yIGFuIGV4ZWN1dGlvblxuICAgKiBAcGFyYW0ga2VybmVsSWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBleGVjdXRpb25JZCBFeGVjdXRpb24gSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgY29tcGxldGVFeGVjdXRpb24oa2VybmVsSWQ6IHN0cmluZywgZXhlY3V0aW9uSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIENsZWFyIGFueSBleGVjdXRpb24gdGltZW91dFxuICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVvdXRzLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXRzID0gdGhpcy5leGVjdXRpb25UaW1lb3V0cy5nZXQoa2VybmVsSWQpITtcbiAgICAgIGlmICh0aW1lb3V0cy5oYXMoZXhlY3V0aW9uSWQpKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0cy5nZXQoZXhlY3V0aW9uSWQpKTtcbiAgICAgICAgdGltZW91dHMuZGVsZXRlKGV4ZWN1dGlvbklkKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXAgZW1wdHkgbWFwc1xuICAgICAgaWYgKHRpbWVvdXRzLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5leGVjdXRpb25UaW1lb3V0cy5kZWxldGUoa2VybmVsSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBleGVjdXRpb24gc3RhcnQgdGltZXNcbiAgICBpZiAodGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZXMgPSB0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuZ2V0KGtlcm5lbElkKSE7XG4gICAgICBzdGFydFRpbWVzLmRlbGV0ZShleGVjdXRpb25JZCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHVwIGVtcHR5IG1hcHNcbiAgICAgIGlmIChzdGFydFRpbWVzLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmRlbGV0ZShrZXJuZWxJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIGV4ZWN1dGlvbiBtZXRhZGF0YVxuICAgIGlmICh0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5leGVjdXRpb25NZXRhZGF0YS5nZXQoa2VybmVsSWQpITtcbiAgICAgIG1ldGFkYXRhLmRlbGV0ZShleGVjdXRpb25JZCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHVwIGVtcHR5IG1hcHNcbiAgICAgIGlmIChtZXRhZGF0YS5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuZGVsZXRlKGtlcm5lbElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gUmVtb3ZlIGZyb20gb25nb2luZyBleGVjdXRpb25zXG4gICAgaWYgKHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgY29uc3QgZXhlY3V0aW9ucyA9IHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZ2V0KGtlcm5lbElkKSE7XG4gICAgICBleGVjdXRpb25zLmRlbGV0ZShleGVjdXRpb25JZCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHVwIGVtcHR5IHNldHNcbiAgICAgIGlmIChleGVjdXRpb25zLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5kZWxldGUoa2VybmVsSWQpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5IHRpbWVzdGFtcCBmb3IgY29tcGxldGVkIGV4ZWN1dGlvblxuICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGtlcm5lbCBoYXMgYW55IG9uZ29pbmcgZXhlY3V0aW9uc1xuICAgKiBAcGFyYW0ga2VybmVsSWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGtlcm5lbCBoYXMgb25nb2luZyBleGVjdXRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGhhc09uZ29pbmdFeGVjdXRpb25zKGtlcm5lbElkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5oYXMoa2VybmVsSWQpICYmIFxuICAgICAgICAgICB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChrZXJuZWxJZCkhLnNpemUgPiAwO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IHRoZSBjb3VudCBvZiBvbmdvaW5nIGV4ZWN1dGlvbnMgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgTnVtYmVyIG9mIG9uZ29pbmcgZXhlY3V0aW9uc1xuICAgKi9cbiAgcHVibGljIGdldE9uZ29pbmdFeGVjdXRpb25Db3VudChpZDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBpZiAoIXRoaXMub25nb2luZ0V4ZWN1dGlvbnMuaGFzKGlkKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChpZCkhLnNpemU7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZXQgdXAgYW4gaW5hY3Rpdml0eSB0aW1lb3V0IGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSB0aW1lb3V0IFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHNldHVwSW5hY3Rpdml0eVRpbWVvdXQoaWQ6IHN0cmluZywgdGltZW91dDogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gRG9uJ3Qgc2V0IHVwIGEgdGltZXIgaWYgdGltZW91dCBpcyAwIG9yIG5lZ2F0aXZlXG4gICAgaWYgKHRpbWVvdXQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBBbHdheXMgY2xlYXIgYW55IGV4aXN0aW5nIHRpbWVyIGZpcnN0XG4gICAgdGhpcy5jbGVhckluYWN0aXZpdHlUaW1lb3V0KGlkKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgcmVtYWluaW5nIHRpbWUgYmFzZWQgb24gbGFzdCBhY3Rpdml0eVxuICAgIGNvbnN0IGxhc3RBY3Rpdml0eSA9IHRoaXMubGFzdEFjdGl2aXR5VGltZS5nZXQoaWQpIHx8IERhdGUubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSBsYXN0QWN0aXZpdHk7XG4gICAgY29uc3QgcmVtYWluaW5nVGltZSA9IE1hdGgubWF4KDAsIHRpbWVvdXQgLSBlbGFwc2VkKTtcbiAgICBcbiAgICAvLyBJZiBubyB0aW1lIHJlbWFpbmluZywgZGVzdHJveSBpbW1lZGlhdGVseVxuICAgIGlmIChyZW1haW5pbmdUaW1lID09PSAwKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUga2VybmVsIGhhcyBvbmdvaW5nIGV4ZWN1dGlvbnMgYmVmb3JlIHNodXR0aW5nIGRvd25cbiAgICAgIGlmICh0aGlzLmhhc09uZ29pbmdFeGVjdXRpb25zKGlkKSkge1xuICAgICAgICAvLyBSZXNldCB0aGUgdGltZXIgdG8gY2hlY2sgYWdhaW4gbGF0ZXJcbiAgICAgICAgdGhpcy5zZXR1cEluYWN0aXZpdHlUaW1lb3V0KGlkLCB0aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZXN0cm95IGltbWVkaWF0ZWx5XG4gICAgICB0aGlzLmRlc3Ryb3lLZXJuZWwoaWQpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVzdHJveWluZyBpbmFjdGl2ZSBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBhIHRpbWVyIHRvIGRlc3Ryb3kgdGhlIGtlcm5lbCBhZnRlciB0aGUgcmVtYWluaW5nIHRpbWVvdXRcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGtlcm5lbCBoYXMgb25nb2luZyBleGVjdXRpb25zIGJlZm9yZSBzaHV0dGluZyBkb3duXG4gICAgICBpZiAodGhpcy5oYXNPbmdvaW5nRXhlY3V0aW9ucyhpZCkpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHRpbWVyIHRvIGNoZWNrIGFnYWluIGxhdGVyXG4gICAgICAgIHRoaXMuc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZCwgdGltZW91dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5kZXN0cm95S2VybmVsKGlkKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlc3Ryb3lpbmcgaW5hY3RpdmUga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0sIHJlbWFpbmluZ1RpbWUpO1xuICAgIFxuICAgIC8vIFN0b3JlIHRoZSB0aW1lciBJRFxuICAgIHRoaXMuaW5hY3Rpdml0eVRpbWVycy5zZXQoaWQsIHRpbWVyKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENsZWFyIGFueSBleGlzdGluZyBpbmFjdGl2aXR5IHRpbWVvdXQgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgY2xlYXJJbmFjdGl2aXR5VGltZW91dChpZDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaW5hY3Rpdml0eVRpbWVycy5oYXMoaWQpKSB7XG4gICAgICBjb25zdCB0aW1lcklkID0gdGhpcy5pbmFjdGl2aXR5VGltZXJzLmdldChpZCk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICB0aGlzLmluYWN0aXZpdHlUaW1lcnMuZGVsZXRlKGlkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGFjdGl2aXR5IHRpbWVzdGFtcCBmb3IgYSBrZXJuZWwgYW5kIHJlc2V0IGluYWN0aXZpdHkgdGltZXIgaWYgcHJlc2VudFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZUtlcm5lbEFjdGl2aXR5KGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgdGhlIGxhc3QgYWN0aXZpdHkgdGltZVxuICAgIHRoaXMubGFzdEFjdGl2aXR5VGltZS5zZXQoaWQsIERhdGUubm93KCkpO1xuICAgIFxuICAgIC8vIEdldCB0aGUga2VybmVsIG9wdGlvbnNcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCB0aW1lb3V0ID0gaW5zdGFuY2Uub3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dDtcbiAgICBcbiAgICAvLyBSZXNldCB0aGUgaW5hY3Rpdml0eSB0aW1lciBpZiB0aW1lb3V0IGlzIGVuYWJsZWQgKGdyZWF0ZXIgdGhhbiAwKVxuICAgIGlmICh0aW1lb3V0ICYmIHRpbWVvdXQgPiAwKSB7XG4gICAgICB0aGlzLnNldHVwSW5hY3Rpdml0eVRpbWVvdXQoaWQsIHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhc3QgYWN0aXZpdHkgdGltZSBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBMYXN0IGFjdGl2aXR5IHRpbWUgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoLCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAqL1xuICBwdWJsaWMgZ2V0TGFzdEFjdGl2aXR5VGltZShpZDogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5sYXN0QWN0aXZpdHlUaW1lLmdldChpZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbmFjdGl2aXR5IHRpbWVvdXQgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgSW5hY3Rpdml0eSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcywgb3IgdW5kZWZpbmVkIGlmIG5vdCBzZXRcbiAgICovXG4gIHB1YmxpYyBnZXRJbmFjdGl2aXR5VGltZW91dChpZDogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgcmV0dXJuIGluc3RhbmNlLm9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IG9yIHVwZGF0ZSB0aGUgaW5hY3Rpdml0eSB0aW1lb3V0IGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSB0aW1lb3V0IFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLCBvciAwIHRvIGRpc2FibGVcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdGltZW91dCB3YXMgc2V0LCBmYWxzZSBpZiB0aGUga2VybmVsIHdhcyBub3QgZm91bmRcbiAgICovXG4gIHB1YmxpYyBzZXRJbmFjdGl2aXR5VGltZW91dChpZDogc3RyaW5nLCB0aW1lb3V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBVcGRhdGUgdGhlIHRpbWVvdXQgaW4gdGhlIG9wdGlvbnNcbiAgICBpbnN0YW5jZS5vcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0ID0gdGltZW91dDtcbiAgICBcbiAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdGltZXJcbiAgICB0aGlzLmNsZWFySW5hY3Rpdml0eVRpbWVvdXQoaWQpO1xuICAgIFxuICAgIC8vIElmIHRpbWVvdXQgaXMgZ3JlYXRlciB0aGFuIDAsIHNldCB1cCBhIG5ldyB0aW1lclxuICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgdGhpcy5zZXR1cEluYWN0aXZpdHlUaW1lb3V0KGlkLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRpbWUgdW50aWwgYXV0by1zaHV0ZG93biBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBUaW1lIGluIG1pbGxpc2Vjb25kcyB1bnRpbCBhdXRvLXNodXRkb3duLCBvciB1bmRlZmluZWQgaWYgbm8gdGltZW91dCBpcyBzZXRcbiAgICovXG4gIHB1YmxpYyBnZXRUaW1lVW50aWxTaHV0ZG93bihpZDogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgY29uc3QgdGltZW91dCA9IGluc3RhbmNlLm9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQ7XG4gICAgaWYgKCF0aW1lb3V0IHx8IHRpbWVvdXQgPD0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBcbiAgICBjb25zdCBsYXN0QWN0aXZpdHkgPSB0aGlzLmxhc3RBY3Rpdml0eVRpbWUuZ2V0KGlkKTtcbiAgICBpZiAoIWxhc3RBY3Rpdml0eSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBcbiAgICBjb25zdCBlbGFwc2VkVGltZSA9IERhdGUubm93KCkgLSBsYXN0QWN0aXZpdHk7XG4gICAgY29uc3QgcmVtYWluaW5nVGltZSA9IHRpbWVvdXQgLSBlbGFwc2VkVGltZTtcbiAgICBcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgcmVtYWluaW5nVGltZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgb2YgaW5hY3Rpdml0eSB0aW1lcnMgKGZvciBkZWJ1Z2dpbmcvdGVzdGluZyBvbmx5KVxuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBrZXJuZWwgSURzIGFzIGtleXMgYW5kIHRpbWVyIElEcyBhcyB2YWx1ZXNcbiAgICovXG4gIHB1YmxpYyBnZXRJbmFjdGl2aXR5VGltZXJzKCk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xuICAgIC8vIENvbnZlcnQgTWFwIHRvIE9iamVjdCBmb3IgZWFzaWVyIGluc3BlY3Rpb25cbiAgICBjb25zdCB0aW1lcnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICB0aGlzLmluYWN0aXZpdHlUaW1lcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGltZXJzW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGltZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCBhIGhhbmRsZXIgZm9yIHN0YWxsZWQgZXhlY3V0aW9uc1xuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHNldHVwU3RhbGxlZEV4ZWN1dGlvbkhhbmRsZXIoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIExpc3RlbiBmb3Igc3RhbGxlZCBleGVjdXRpb24gZXZlbnRzXG4gICAgc3VwZXIub24oS2VybmVsRXZlbnRzLkVYRUNVVElPTl9TVEFMTEVELCAoZXZlbnQ6IHsga2VybmVsSWQ6IHN0cmluZywgZXhlY3V0aW9uSWQ6IHN0cmluZywgbWF4RXhlY3V0aW9uVGltZTogbnVtYmVyIH0pID0+IHtcbiAgICAgIGlmIChldmVudC5rZXJuZWxJZCA9PT0gaWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBIYW5kbGluZyBzdGFsbGVkIGV4ZWN1dGlvbiAke2V2ZW50LmV4ZWN1dGlvbklkfSBvbiBrZXJuZWwgJHtpZH0gKHJ1bm5pbmcgbG9uZ2VyIHRoYW4gJHtldmVudC5tYXhFeGVjdXRpb25UaW1lfW1zKWApO1xuICAgICAgICBcbiAgICAgICAgLy8gRW1pdCBhbiBldmVudCBmb3IgY2xpZW50cyB0byBoYW5kbGVcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwge1xuICAgICAgICAgICAga2VybmVsSWQ6IGlkLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBlbmFtZTogXCJFeGVjdXRpb25TdGFsbGVkRXJyb3JcIixcbiAgICAgICAgICAgICAgZXZhbHVlOiBgRXhlY3V0aW9uIHN0YWxsZWQgb3IgcG90ZW50aWFsbHkgZGVhZGxvY2tlZCAocnVubmluZyA+ICR7ZXZlbnQubWF4RXhlY3V0aW9uVGltZX1tcylgLFxuICAgICAgICAgICAgICB0cmFjZWJhY2s6IFtcIkV4ZWN1dGlvbiBtYXkgYmUgc3R1Y2sgaW4gYW4gaW5maW5pdGUgbG9vcCBvciBkZWFkbG9ja2VkLlwiXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgdGVybWluYXRlIGEgcG90ZW50aWFsbHkgc3R1Y2sga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIHJlYXNvbiBPcHRpb25hbCByZWFzb24gZm9yIHRlcm1pbmF0aW9uXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRydWUgaWYgdGhlIGtlcm5lbCB3YXMgdGVybWluYXRlZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGZvcmNlVGVybWluYXRlS2VybmVsKGlkOiBzdHJpbmcsIHJlYXNvbiA9IFwiRm9yY2UgdGVybWluYXRlZCBkdWUgdG8gc3RhbGxlZCBleGVjdXRpb25cIik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgXG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gTG9nIHRoZSBmb3JjZWQgdGVybWluYXRpb25cbiAgICAgIGNvbnNvbGUud2FybihgRm9yY2UgdGVybWluYXRpbmcga2VybmVsICR7aWR9OiAke3JlYXNvbn1gKTtcbiAgICAgIFxuICAgICAgLy8gRW1pdCBhbiBlcnJvciBldmVudCB0byBub3RpZnkgY2xpZW50c1xuICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwge1xuICAgICAgICBrZXJuZWxJZDogaWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBlbmFtZTogXCJLZXJuZWxGb3JjZWRUZXJtaW5hdGlvblwiLFxuICAgICAgICAgIGV2YWx1ZTogcmVhc29uLFxuICAgICAgICAgIHRyYWNlYmFjazogW1wiS2VybmVsIHdhcyBmb3JjZWZ1bGx5IHRlcm1pbmF0ZWQgYnkgdGhlIHN5c3RlbS5cIl1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIERlc3Ryb3kgdGhlIGtlcm5lbFxuICAgICAgYXdhaXQgdGhpcy5kZXN0cm95S2VybmVsKGlkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkdXJpbmcgZm9yY2VkIHRlcm1pbmF0aW9uIG9mIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBvbmdvaW5nIGV4ZWN1dGlvbnMgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgSW5mb3JtYXRpb24gYWJvdXQgb25nb2luZyBleGVjdXRpb25zIHdpdGggYWNjdXJhdGUgdGltaW5nXG4gICAqL1xuICBwdWJsaWMgZ2V0RXhlY3V0aW9uSW5mbyhpZDogc3RyaW5nKTogeyBcbiAgICBjb3VudDogbnVtYmVyOyBcbiAgICBpc1N0dWNrOiBib29sZWFuOyBcbiAgICBleGVjdXRpb25JZHM6IHN0cmluZ1tdO1xuICAgIGxvbmdlc3RSdW5uaW5nVGltZT86IG51bWJlcjtcbiAgICBleGVjdXRpb25zOiBBcnJheTx7XG4gICAgICBpZDogc3RyaW5nO1xuICAgICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgICBydW50aW1lOiBudW1iZXI7XG4gICAgICBjb2RlPzogc3RyaW5nO1xuICAgICAgaXNTdHVjazogYm9vbGVhbjtcbiAgICB9PjtcbiAgfSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4geyBjb3VudDogMCwgaXNTdHVjazogZmFsc2UsIGV4ZWN1dGlvbklkczogW10sIGV4ZWN1dGlvbnM6IFtdIH07XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBwYXJ0aWFsbHkgaW5pdGlhbGl6ZWQga2VybmVscyB3aGVyZSBvcHRpb25zIG1heSBub3QgYmUgZnVsbHkgc2V0XG4gICAgaWYgKCFpbnN0YW5jZS5vcHRpb25zKSB7XG4gICAgICByZXR1cm4geyBjb3VudDogMCwgaXNTdHVjazogZmFsc2UsIGV4ZWN1dGlvbklkczogW10sIGV4ZWN1dGlvbnM6IFtdIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGV4ZWN1dGlvbklkcyA9IHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZ2V0KGlkKSBcbiAgICAgID8gQXJyYXkuZnJvbSh0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChpZCkhKVxuICAgICAgOiBbXTtcbiAgICBcbiAgICBjb25zdCBjb3VudCA9IGV4ZWN1dGlvbklkcy5sZW5ndGg7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG1heEV4ZWN1dGlvblRpbWUgPSBpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWU7XG4gICAgXG4gICAgLy8gQnVpbGQgZGV0YWlsZWQgZXhlY3V0aW9uIGluZm9ybWF0aW9uXG4gICAgY29uc3QgZXhlY3V0aW9uczogQXJyYXk8e1xuICAgICAgaWQ6IHN0cmluZztcbiAgICAgIHN0YXJ0VGltZTogbnVtYmVyO1xuICAgICAgcnVudGltZTogbnVtYmVyO1xuICAgICAgY29kZT86IHN0cmluZztcbiAgICAgIGlzU3R1Y2s6IGJvb2xlYW47XG4gICAgfT4gPSBbXTtcbiAgICBcbiAgICBsZXQgbG9uZ2VzdFJ1bm5pbmdUaW1lOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IGFueVN0dWNrID0gZmFsc2U7XG4gICAgXG4gICAgLy8gR2V0IGV4ZWN1dGlvbiBzdGFydCB0aW1lcyBhbmQgbWV0YWRhdGFcbiAgICBjb25zdCBzdGFydFRpbWVzID0gdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmdldChpZCk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmdldChpZCk7XG4gICAgXG4gICAgZm9yIChjb25zdCBleGVjdXRpb25JZCBvZiBleGVjdXRpb25JZHMpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHN0YXJ0VGltZXM/LmdldChleGVjdXRpb25JZCk7XG4gICAgICBjb25zdCBleGVjTWV0YWRhdGEgPSBtZXRhZGF0YT8uZ2V0KGV4ZWN1dGlvbklkKTtcbiAgICAgIFxuICAgICAgaWYgKHN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHJ1bnRpbWUgPSBjdXJyZW50VGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgaXNTdHVjayA9IG1heEV4ZWN1dGlvblRpbWUgIT09IHVuZGVmaW5lZCAmJiBydW50aW1lID4gbWF4RXhlY3V0aW9uVGltZTtcbiAgICAgICAgXG4gICAgICAgIGV4ZWN1dGlvbnMucHVzaCh7XG4gICAgICAgICAgaWQ6IGV4ZWN1dGlvbklkLFxuICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICBydW50aW1lLFxuICAgICAgICAgIGNvZGU6IGV4ZWNNZXRhZGF0YT8uY29kZSxcbiAgICAgICAgICBpc1N0dWNrXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJhY2sgbG9uZ2VzdCBydW5uaW5nIHRpbWVcbiAgICAgICAgaWYgKGxvbmdlc3RSdW5uaW5nVGltZSA9PT0gdW5kZWZpbmVkIHx8IHJ1bnRpbWUgPiBsb25nZXN0UnVubmluZ1RpbWUpIHtcbiAgICAgICAgICBsb25nZXN0UnVubmluZ1RpbWUgPSBydW50aW1lO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBUcmFjayBpZiBhbnkgZXhlY3V0aW9uIGlzIHN0dWNrXG4gICAgICAgIGlmIChpc1N0dWNrKSB7XG4gICAgICAgICAgYW55U3R1Y2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayBmb3IgZXhlY3V0aW9ucyB3aXRob3V0IHN0YXJ0IHRpbWUgdHJhY2tpbmdcbiAgICAgICAgY29uc29sZS53YXJuKGBObyBzdGFydCB0aW1lIGZvdW5kIGZvciBleGVjdXRpb24gJHtleGVjdXRpb25JZH0gb24ga2VybmVsICR7aWR9YCk7XG4gICAgICAgIGV4ZWN1dGlvbnMucHVzaCh7XG4gICAgICAgICAgaWQ6IGV4ZWN1dGlvbklkLFxuICAgICAgICAgIHN0YXJ0VGltZTogMCxcbiAgICAgICAgICBydW50aW1lOiAwLFxuICAgICAgICAgIGNvZGU6IGV4ZWNNZXRhZGF0YT8uY29kZSxcbiAgICAgICAgICBpc1N0dWNrOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU29ydCBleGVjdXRpb25zIGJ5IHN0YXJ0IHRpbWUgKG9sZGVzdCBmaXJzdClcbiAgICBleGVjdXRpb25zLnNvcnQoKGEsIGIpID0+IGEuc3RhcnRUaW1lIC0gYi5zdGFydFRpbWUpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBjb3VudCxcbiAgICAgIGlzU3R1Y2s6IGFueVN0dWNrLFxuICAgICAgZXhlY3V0aW9uSWRzLFxuICAgICAgbG9uZ2VzdFJ1bm5pbmdUaW1lLFxuICAgICAgZXhlY3V0aW9uc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBQeXRob24gY29kZSBpbiBhIGtlcm5lbFxuICAgKiBVc2VzIGV4ZWN1dGVTdHJlYW0gdG8gY29sbGVjdCBhbGwgb3V0cHV0cyBhbmQgcmV0dXJuIHRoZW1cbiAgICogQHBhcmFtIGtlcm5lbElkIElEIG9mIHRoZSBrZXJuZWwgdG8gdXNlXG4gICAqIEBwYXJhbSBjb2RlIFB5dGhvbiBjb2RlIHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIHBhcmVudCBPcHRpb25hbCBwYXJlbnQgbWVzc2FnZSBoZWFkZXJcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gZXhlY3V0aW9uIHJlc3VsdCB3aXRoIGNvbGxlY3RlZCBvdXRwdXRzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZXhlY3V0ZShcbiAgICBrZXJuZWxJZDogc3RyaW5nLFxuICAgIGNvZGU6IHN0cmluZyxcbiAgICBwYXJlbnQ6IGFueSA9IHt9XG4gICk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuLCBvdXRwdXRzPzogYW55LCBlcnJvcj86IEVycm9yLCBlbmFtZT86IHN0cmluZywgZXZhbHVlPzogc3RyaW5nLCB0cmFjZWJhY2s/OiBhbnkgfT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRLZXJuZWwoa2VybmVsSWQpO1xuICAgIFxuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsIHdpdGggSUQgJHtrZXJuZWxJZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBpbnN0YW5jZS5rZXJuZWwuZXhlY3V0ZShjb2RlLCBwYXJlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEga2VybmVsIHR5cGUgaXMgYWxsb3dlZFxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGtlcm5lbCB0eXBlIGlzIGFsbG93ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgaXNLZXJuZWxUeXBlQWxsb3dlZChtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd2VkS2VybmVsVHlwZXMuc29tZSh0eXBlID0+IFxuICAgICAgdHlwZS5tb2RlID09PSBtb2RlICYmIHR5cGUubGFuZ3VhZ2UgPT09IGxhbmd1YWdlXG4gICAgKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBvZiBhbGxvd2VkIGtlcm5lbCB0eXBlc1xuICAgKiBAcmV0dXJucyBBcnJheSBvZiBhbGxvd2VkIGtlcm5lbCB0eXBlIGNvbmZpZ3VyYXRpb25zXG4gICAqL1xuICBwdWJsaWMgZ2V0QWxsb3dlZEtlcm5lbFR5cGVzKCk6IEFycmF5PHtcbiAgICBtb2RlOiBLZXJuZWxNb2RlO1xuICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgfT4ge1xuICAgIHJldHVybiBbLi4udGhpcy5hbGxvd2VkS2VybmVsVHlwZXNdOyAvLyBSZXR1cm4gYSBjb3B5IHRvIHByZXZlbnQgbW9kaWZpY2F0aW9uXG4gIH1cblxuICAvKipcbiAgICogUGluZyBhIGtlcm5lbCB0byByZXNldCBpdHMgYWN0aXZpdHkgdGltZXIgYW5kIGV4dGVuZCB0aGUgZGVhZGxpbmVcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBrZXJuZWwgd2FzIHBpbmdlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgcHVibGljIHBpbmdLZXJuZWwoaWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUga2VybmVsIGFjdGl2aXR5ICh0aGlzIHdpbGwgcmVzZXQgdGhlIGluYWN0aXZpdHkgdGltZXIpXG4gICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShpZCk7XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVzdGFydCBhIGtlcm5lbCBieSBkZXN0cm95aW5nIGl0IGFuZCBjcmVhdGluZyBhIG5ldyBvbmUgd2l0aCB0aGUgc2FtZSBJRCBhbmQgY29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRydWUgaWYgdGhlIGtlcm5lbCB3YXMgcmVzdGFydGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgbm90IGZvdW5kXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcmVzdGFydEtlcm5lbChpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENhbm5vdCByZXN0YXJ0IGtlcm5lbCAke2lkfToga2VybmVsIG5vdCBmb3VuZGApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvblxuICAgICAgY29uc3QgY3VycmVudENvbmZpZyA9IHtcbiAgICAgICAgbW9kZTogaW5zdGFuY2UubW9kZSxcbiAgICAgICAgbGFuZ3VhZ2U6IGluc3RhbmNlLmxhbmd1YWdlLFxuICAgICAgICBvcHRpb25zOiB7IC4uLmluc3RhbmNlLm9wdGlvbnMgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gRXh0cmFjdCBuYW1lc3BhY2UgZnJvbSBJRCBpZiBwcmVzZW50XG4gICAgICBsZXQgbmFtZXNwYWNlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICBsZXQgYmFzZUlkOiBzdHJpbmc7XG4gICAgICBcbiAgICAgIGlmIChpZC5pbmNsdWRlcygnOicpKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gaWQuc3BsaXQoJzonKTtcbiAgICAgICAgbmFtZXNwYWNlID0gcGFydHNbMF07XG4gICAgICAgIGJhc2VJZCA9IHBhcnRzWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUlkID0gaWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERlc3Ryb3kgdGhlIGV4aXN0aW5nIGtlcm5lbFxuICAgICAgYXdhaXQgdGhpcy5kZXN0cm95S2VybmVsKGlkKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IGtlcm5lbCB3aXRoIHRoZSBzYW1lIGNvbmZpZ3VyYXRpb25cbiAgICAgIGNvbnN0IHJlc3RhcnRPcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnMgPSB7XG4gICAgICAgIGlkOiBiYXNlSWQsXG4gICAgICAgIG1vZGU6IGN1cnJlbnRDb25maWcubW9kZSxcbiAgICAgICAgbGFuZzogY3VycmVudENvbmZpZy5sYW5ndWFnZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBkZW5vOiBjdXJyZW50Q29uZmlnLm9wdGlvbnMuZGVubyxcbiAgICAgICAgZmlsZXN5c3RlbTogY3VycmVudENvbmZpZy5vcHRpb25zLmZpbGVzeXN0ZW0sXG4gICAgICAgIGluYWN0aXZpdHlUaW1lb3V0OiBjdXJyZW50Q29uZmlnLm9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQsXG4gICAgICAgIG1heEV4ZWN1dGlvblRpbWU6IGN1cnJlbnRDb25maWcub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgdGhlIG5ldyBrZXJuZWxcbiAgICAgIGNvbnN0IG5ld0tlcm5lbElkID0gYXdhaXQgdGhpcy5jcmVhdGVLZXJuZWwocmVzdGFydE9wdGlvbnMpO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgdGhlIG5ldyBrZXJuZWwgaGFzIHRoZSBzYW1lIElEXG4gICAgICBpZiAobmV3S2VybmVsSWQgIT09IGlkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEtlcm5lbCByZXN0YXJ0IGZhaWxlZDogZXhwZWN0ZWQgSUQgJHtpZH0sIGdvdCAke25ld0tlcm5lbElkfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlc3RhcnRpbmcga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJydXB0IGEgcnVubmluZyBrZXJuZWwgZXhlY3V0aW9uXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZSBpZiB0aGUgaW50ZXJydXB0IHdhcyBzdWNjZXNzZnVsLCBmYWxzZSBpZiBub3QgZm91bmQgb3IgZmFpbGVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW50ZXJydXB0S2VybmVsKGlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ2Fubm90IGludGVycnVwdCBrZXJuZWwgJHtpZH06IGtlcm5lbCBub3QgZm91bmRgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGlmIChpbnN0YW5jZS5tb2RlID09PSBLZXJuZWxNb2RlLldPUktFUiAmJiBpbnN0YW5jZS53b3JrZXIpIHtcbiAgICAgICAgLy8gRm9yIHdvcmtlciBrZXJuZWxzLCB1c2UgU2hhcmVkQXJyYXlCdWZmZXIgaW50ZXJydXB0IG1ldGhvZFxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbnRlcnJ1cHRXb3JrZXJLZXJuZWwoaWQsIGluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBtYWluIHRocmVhZCBrZXJuZWxzLCB0cnkgdG8gaW50ZXJydXB0ICh3aWxsIHRocm93IGVycm9yIGlmIG5vdCBzdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmludGVycnVwdE1haW5UaHJlYWRLZXJuZWwoaWQsIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW50ZXJydXB0aW5nIGtlcm5lbCAke2lkfTpgLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcikpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEludGVycnVwdCBhIG1haW4gdGhyZWFkIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBpbnN0YW5jZSBLZXJuZWwgaW5zdGFuY2VcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gaW50ZXJydXB0IHN1Y2Nlc3NcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW50ZXJydXB0TWFpblRocmVhZEtlcm5lbChpZDogc3RyaW5nLCBpbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gTWFpbiB0aHJlYWQga2VybmVscyBkb24ndCBzdXBwb3J0IHByb3BlciBpbnRlcnJ1cHRpb24gbGlrZSB3b3JrZXIga2VybmVscyBkb1xuICAgIC8vIEV2ZW4gaWYgdGhleSBoYXZlIGFuIGludGVycnVwdCBtZXRob2QsIGl0J3MgbGltaXRlZCBhbmQgdW5yZWxpYWJsZVxuICAgIHRocm93IG5ldyBFcnJvcihgTWFpbiB0aHJlYWQga2VybmVsICR7aWR9IGRvZXMgbm90IHN1cHBvcnQgcmVsaWFibGUgaW50ZXJydXB0aW9uLiBVc2Ugd29ya2VyIGtlcm5lbHMgZm9yIGludGVycnVwdGlibGUgZXhlY3V0aW9uLmApO1xuICB9XG4gIFxuICAvKipcbiAgICogSW50ZXJydXB0IGEgd29ya2VyIGtlcm5lbCB1c2luZyBTaGFyZWRBcnJheUJ1ZmZlciBhY2NvcmRpbmcgdG8gUHlvZGlkZSBkb2N1bWVudGF0aW9uXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIGluc3RhbmNlIEtlcm5lbCBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBpbnRlcnJ1cHQgc3VjY2Vzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbnRlcnJ1cHRXb3JrZXJLZXJuZWwoaWQ6IHN0cmluZywgaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB3b3JrZXIgPSBpbnN0YW5jZS53b3JrZXI7XG4gICAgICBpZiAoIXdvcmtlcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXb3JrZXIgbm90IGZvdW5kIGZvciBrZXJuZWwgJHtpZH1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBpbnRlcnJ1cHRpb24gbW9kZSBpcyAna2VybmVsLWludGVycnVwdCcsIHVzZSBmYWxsYmFjayBkaXJlY3RseVxuICAgICAgaWYgKHRoaXMuaW50ZXJydXB0aW9uTW9kZSA9PT0gJ2tlcm5lbC1pbnRlcnJ1cHQnKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmludGVycnVwdFdvcmtlcktlcm5lbEZhbGxiYWNrKGlkLCB3b3JrZXIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgYW4gaW50ZXJydXB0IGJ1ZmZlciBmb3IgdGhpcyBrZXJuZWxcbiAgICAgIGxldCBpbnRlcnJ1cHRCdWZmZXIgPSB0aGlzLmludGVycnVwdEJ1ZmZlcnMuZ2V0KGlkKTtcbiAgICAgIFxuICAgICAgaWYgKCFpbnRlcnJ1cHRCdWZmZXIpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IFNoYXJlZEFycmF5QnVmZmVyIGZvciBpbnRlcnJ1cHQgY29udHJvbFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRyeSB0byBjcmVhdGUgU2hhcmVkQXJyYXlCdWZmZXIgKHJlcXVpcmVzIHNwZWNpZmljIHNlY3VyaXR5IGhlYWRlcnMpXG4gICAgICAgICAgY29uc3Qgc2hhcmVkQnVmZmVyID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpO1xuICAgICAgICAgIGludGVycnVwdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHNoYXJlZEJ1ZmZlcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSBidWZmZXIgdG8gMCAobm8gaW50ZXJydXB0IHNpZ25hbClcbiAgICAgICAgICBpbnRlcnJ1cHRCdWZmZXJbMF0gPSAwO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFN0b3JlIHRoZSBidWZmZXIgZm9yIGZ1dHVyZSB1c2VcbiAgICAgICAgICB0aGlzLmludGVycnVwdEJ1ZmZlcnMuc2V0KGlkLCBpbnRlcnJ1cHRCdWZmZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNlbmQgdGhlIGJ1ZmZlciB0byB0aGUgd29ya2VyIHRvIHNldCB1cCBweW9kaWRlLnNldEludGVycnVwdEJ1ZmZlcigpXG4gICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiU0VUX0lOVEVSUlVQVF9CVUZGRVJcIixcbiAgICAgICAgICAgIGJ1ZmZlcjogaW50ZXJydXB0QnVmZmVyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHdvcmtlciB0byBjb25maXJtIGJ1ZmZlciBzZXR1cFxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVvdXQgd2FpdGluZyBmb3IgaW50ZXJydXB0IGJ1ZmZlciBzZXR1cFwiKSk7XG4gICAgICAgICAgICB9LCAyMDAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIklOVEVSUlVQVF9CVUZGRVJfU0VUXCIpIHtcbiAgICAgICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBJbnRlcnJ1cHQgYnVmZmVyIHNldCB1cCBmb3Iga2VybmVsICR7aWR9YCk7XG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIGJhc2VkIG9uIGludGVycnVwdGlvbiBtb2RlXG4gICAgICAgICAgaWYgKHRoaXMuaW50ZXJydXB0aW9uTW9kZSA9PT0gJ3NoYXJlZC1hcnJheS1idWZmZXInKSB7XG4gICAgICAgICAgICAvLyBJZiBleHBsaWNpdGx5IHNldCB0byBzaGFyZWQtYXJyYXktYnVmZmVyLCB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgQ2Fubm90IGNyZWF0ZSBTaGFyZWRBcnJheUJ1ZmZlciBmb3IgaW50ZXJydXB0IGhhbmRsaW5nIGluIGtlcm5lbCAke2lkfWApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaGFyZWRBcnJheUJ1ZmZlciBpcyByZXF1aXJlZCBmb3IgaW50ZXJydXB0aW9uIG1vZGUgJ3NoYXJlZC1hcnJheS1idWZmZXInIGJ1dCBpcyBub3QgYXZhaWxhYmxlLlxuXG5UbyBmaXggdGhpcyBpc3N1ZSwgZWl0aGVyOlxuMS4gQ29uZmlndXJlIHlvdXIgd2ViIHNlcnZlciB3aXRoIHRoZXNlIGhlYWRlcnM6XG4gICAtIENyb3NzLU9yaWdpbi1PcGVuZXItUG9saWN5OiBzYW1lLW9yaWdpblxuICAgLSBDcm9zcy1PcmlnaW4tRW1iZWRkZXItUG9saWN5OiByZXF1aXJlLWNvcnBcblxuMi4gT3IgY2hhbmdlIHRoZSBpbnRlcnJ1cHRpb24gbW9kZSB3aGVuIGNyZWF0aW5nIEtlcm5lbE1hbmFnZXI6XG4gICBuZXcgS2VybmVsTWFuYWdlcih7IGludGVycnVwdGlvbk1vZGU6ICdhdXRvJyB9KWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBdXRvIG1vZGU6IGZhbGwgYmFjayB0byBrZXJuZWwuaW50ZXJydXB0KClcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhg4oS577iPIFVzaW5nIG1lc3NhZ2UtYmFzZWQgaW50ZXJydXB0IGZvciBrZXJuZWwgJHtpZH0gKFNoYXJlZEFycmF5QnVmZmVyIG5vdCBhdmFpbGFibGUpYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrOiB1c2UgbWVzc2FnZS1iYXNlZCBpbnRlcnJ1cHRcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmludGVycnVwdFdvcmtlcktlcm5lbEZhbGxiYWNrKGlkLCB3b3JrZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBY2NvcmRpbmcgdG8gUHlvZGlkZSBkb2NzOiBTZXQgaW50ZXJydXB0IHNpZ25hbCAoMiA9IFNJR0lOVClcbiAgICAgIGNvbnNvbGUubG9nKGBTZXR0aW5nIGludGVycnVwdCBzaWduYWwgZm9yIGtlcm5lbCAke2lkfS4uLmApO1xuICAgICAgaW50ZXJydXB0QnVmZmVyWzBdID0gMjtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgUHlvZGlkZSB0byBwcm9jZXNzIHRoZSBpbnRlcnJ1cHRcbiAgICAgIC8vIFB5b2RpZGUgd2lsbCByZXNldCB0aGUgYnVmZmVyIHRvIDAgd2hlbiBpdCBwcm9jZXNzZXMgdGhlIGludGVycnVwdFxuICAgICAgbGV0IGF0dGVtcHRzID0gMDtcbiAgICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNTA7IC8vIENoZWNrIGZvciB1cCB0byA1IHNlY29uZHMgKDUwICogMTAwbXMpXG4gICAgICBcbiAgICAgIHdoaWxlIChhdHRlbXB0cyA8IG1heEF0dGVtcHRzICYmIGludGVycnVwdEJ1ZmZlclswXSAhPT0gMCkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICAgIGF0dGVtcHRzKys7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChpbnRlcnJ1cHRCdWZmZXJbMF0gPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYEludGVycnVwdCBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5IGZvciBrZXJuZWwgJHtpZH0gYWZ0ZXIgJHthdHRlbXB0cyAqIDEwMH1tc2ApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW50ZXJydXB0IHNpZ25hbCBub3QgcHJvY2Vzc2VkIGZvciBrZXJuZWwgJHtpZH0gYWZ0ZXIgJHttYXhBdHRlbXB0cyAqIDEwMH1tc2ApO1xuICAgICAgICAvLyBTdGlsbCByZXR1cm4gdHJ1ZSBhcyB3ZSBzZXQgdGhlIHNpZ25hbCAtIHRoZSBpbnRlcnJ1cHQgbWF5IGJlIHByb2Nlc3NlZCBsYXRlclxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbnRlcnJ1cHRpbmcgd29ya2VyIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogRmFsbGJhY2sgaW50ZXJydXB0IG1ldGhvZCBmb3Igd29ya2VyIGtlcm5lbHMgd2hlbiBTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIHdvcmtlciBXb3JrZXIgaW5zdGFuY2VcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gaW50ZXJydXB0IHN1Y2Nlc3NcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW50ZXJydXB0V29ya2VyS2VybmVsRmFsbGJhY2soaWQ6IHN0cmluZywgd29ya2VyOiBXb3JrZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8Ym9vbGVhbj4oKHJlc29sdmUpID0+IHtcbiAgICAgIC8vIFNldCB1cCBhIGxpc3RlbmVyIGZvciB0aGUgaW50ZXJydXB0IHJlc3BvbnNlXG4gICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJJTlRFUlJVUFRfVFJJR0dFUkVEXCIpIHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICAgICAgICBjb25zdCBzdWNjZXNzID0gZXZlbnQuZGF0YS5kYXRhPy5zdWNjZXNzIHx8IGZhbHNlO1xuICAgICAgICAgIHJlc29sdmUoc3VjY2Vzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIExpc3RlbiBmb3IgdGhlIHJlc3BvbnNlXG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICAgIFxuICAgICAgLy8gU2VuZCB0aGUgaW50ZXJydXB0IG1lc3NhZ2VcbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiSU5URVJSVVBUX0tFUk5FTFwiXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2V0IGEgdGltZW91dCBpbiBjYXNlIHdlIGRvbid0IGdldCBhIHJlc3BvbnNlXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgICAgIGNvbnNvbGUud2Fybihg4o+x77iPIEludGVycnVwdCByZXF1ZXN0IHRpbWVkIG91dCBmb3Iga2VybmVsICR7aWR9IGFmdGVyIDUgc2Vjb25kcy5cblRoaXMgbWF5IGhhcHBlbiBpZjpcbi0gVGhlIGtlcm5lbCBpcyBydW5uaW5nIGNvZGUgdGhhdCBjYW5ub3QgYmUgaW50ZXJydXB0ZWRcbi0gVGhlIGtlcm5lbCBpcyBpbiBhbiB1bnJlc3BvbnNpdmUgc3RhdGVcbllvdSBtYXkgbmVlZCB0byByZXN0YXJ0IHRoZSBrZXJuZWwgaWYgaXQgcmVtYWlucyB1bnJlc3BvbnNpdmUuYCk7XG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgfSwgNTAwMCk7IC8vIDUgc2Vjb25kIHRpbWVvdXRcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBzdHVjayBleGVjdXRpb24gd2l0aCBjb25maWd1cmFibGUgc3RyYXRlZ2llc1xuICAgKiBAcGFyYW0ga2VybmVsSWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBleGVjdXRpb25JZCBFeGVjdXRpb24gSUQgdGhhdCdzIHN0dWNrXG4gICAqIEBwYXJhbSBhY3R1YWxSdW50aW1lIEhvdyBsb25nIHRoZSBleGVjdXRpb24gaGFzIGJlZW4gcnVubmluZ1xuICAgKiBAcGFyYW0gY29kZSBUaGUgY29kZSB0aGF0IHdhcyBiZWluZyBleGVjdXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVTdHVja0V4ZWN1dGlvbihrZXJuZWxJZDogc3RyaW5nLCBleGVjdXRpb25JZDogc3RyaW5nLCBhY3R1YWxSdW50aW1lOiBudW1iZXIsIGNvZGU/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS53YXJuKGBIYW5kbGluZyBzdHVjayBleGVjdXRpb24gJHtleGVjdXRpb25JZH0gb24ga2VybmVsICR7a2VybmVsSWR9IChydW50aW1lOiAke2FjdHVhbFJ1bnRpbWV9bXMpYCk7XG4gICAgXG4gICAgLy8gU3RyYXRlZ3kgMTogVHJ5IHRvIGludGVycnVwdCB0aGUga2VybmVsIGZpcnN0XG4gICAgY29uc3QgaW50ZXJydXB0U3VjY2VzcyA9IGF3YWl0IHRoaXMuaW50ZXJydXB0S2VybmVsKGtlcm5lbElkKTtcbiAgICBcbiAgICBpZiAoaW50ZXJydXB0U3VjY2Vzcykge1xuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBpbnRlcnJ1cHRlZCBrZXJuZWwgJHtrZXJuZWxJZH1gKTtcbiAgICAgIFxuICAgICAgLy8gRW1pdCBhbiBleGVjdXRpb24gZXJyb3IgdG8gbm90aWZ5IGNsaWVudHNcbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsIHtcbiAgICAgICAga2VybmVsSWQ6IGtlcm5lbElkLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZW5hbWU6IFwiRXhlY3V0aW9uSW50ZXJydXB0ZWRcIixcbiAgICAgICAgICBldmFsdWU6IGBFeGVjdXRpb24gYXV0b21hdGljYWxseSBpbnRlcnJ1cHRlZCBhZnRlciAke2FjdHVhbFJ1bnRpbWV9bXMgKGV4Y2VlZGVkIG1heEV4ZWN1dGlvblRpbWUpYCxcbiAgICAgICAgICB0cmFjZWJhY2s6IFtcbiAgICAgICAgICAgIGBFeGVjdXRpb24gd2FzIGF1dG9tYXRpY2FsbHkgaW50ZXJydXB0ZWQgZHVlIHRvIHRpbWVvdXQuYCxcbiAgICAgICAgICAgIGBSdW50aW1lOiAke2FjdHVhbFJ1bnRpbWV9bXNgLFxuICAgICAgICAgICAgYE1heCBhbGxvd2VkOiAke2luc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZX1tc2AsXG4gICAgICAgICAgICBjb2RlID8gYENvZGU6ICR7Y29kZS5zdWJzdHJpbmcoMCwgMjAwKX0ke2NvZGUubGVuZ3RoID4gMjAwID8gJy4uLicgOiAnJ31gIDogJ0NvZGU6IDx1bmtub3duPidcbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFN0cmF0ZWd5IDI6IElmIGludGVycnVwdCBmYWlsZWQsIHRyeSByZXN0YXJ0aW5nIHRoZSBrZXJuZWxcbiAgICBjb25zb2xlLndhcm4oYEludGVycnVwdCBmYWlsZWQgZm9yIGtlcm5lbCAke2tlcm5lbElkfSwgYXR0ZW1wdGluZyByZXN0YXJ0Li4uYCk7XG4gICAgY29uc3QgcmVzdGFydFN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnJlc3RhcnRLZXJuZWwoa2VybmVsSWQpO1xuICAgIFxuICAgIGlmIChyZXN0YXJ0U3VjY2Vzcykge1xuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSByZXN0YXJ0ZWQga2VybmVsICR7a2VybmVsSWR9YCk7XG4gICAgICBcbiAgICAgIC8vIEVtaXQgYSByZXN0YXJ0IG5vdGlmaWNhdGlvblxuICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwge1xuICAgICAgICBrZXJuZWxJZDoga2VybmVsSWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBlbmFtZTogXCJLZXJuZWxSZXN0YXJ0ZWRcIixcbiAgICAgICAgICBldmFsdWU6IGBLZXJuZWwgYXV0b21hdGljYWxseSByZXN0YXJ0ZWQgZHVlIHRvIHN0dWNrIGV4ZWN1dGlvbiAocnVudGltZTogJHthY3R1YWxSdW50aW1lfW1zKWAsXG4gICAgICAgICAgdHJhY2ViYWNrOiBbXG4gICAgICAgICAgICBgS2VybmVsIHdhcyBhdXRvbWF0aWNhbGx5IHJlc3RhcnRlZCBkdWUgdG8gc3R1Y2sgZXhlY3V0aW9uLmAsXG4gICAgICAgICAgICBgUnVudGltZTogJHthY3R1YWxSdW50aW1lfW1zYCxcbiAgICAgICAgICAgIGBNYXggYWxsb3dlZDogJHtpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWV9bXNgLFxuICAgICAgICAgICAgYEludGVycnVwdCBhdHRlbXB0IGZhaWxlZCwga2VybmVsIHdhcyByZXN0YXJ0ZWQgaW5zdGVhZC5gLFxuICAgICAgICAgICAgY29kZSA/IGBDb2RlOiAke2NvZGUuc3Vic3RyaW5nKDAsIDIwMCl9JHtjb2RlLmxlbmd0aCA+IDIwMCA/ICcuLi4nIDogJyd9YCA6ICdDb2RlOiA8dW5rbm93bj4nXG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdHJhdGVneSAzOiBJZiByZXN0YXJ0IGZhaWxlZCwgZm9yY2UgdGVybWluYXRlIHRoZSBrZXJuZWxcbiAgICBjb25zb2xlLmVycm9yKGBSZXN0YXJ0IGZhaWxlZCBmb3Iga2VybmVsICR7a2VybmVsSWR9LCBmb3JjZSB0ZXJtaW5hdGluZy4uLmApO1xuICAgIGNvbnN0IHRlcm1pbmF0ZVN1Y2Nlc3MgPSBhd2FpdCB0aGlzLmZvcmNlVGVybWluYXRlS2VybmVsKFxuICAgICAga2VybmVsSWQsIFxuICAgICAgYFN0dWNrIGV4ZWN1dGlvbiBjb3VsZCBub3QgYmUgaW50ZXJydXB0ZWQgb3IgcmVzdGFydGVkIChydW50aW1lOiAke2FjdHVhbFJ1bnRpbWV9bXMpYFxuICAgICk7XG4gICAgXG4gICAgaWYgKHRlcm1pbmF0ZVN1Y2Nlc3MpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgdGVybWluYXRlZCBrZXJuZWwgJHtrZXJuZWxJZH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHRlcm1pbmF0ZSBrZXJuZWwgJHtrZXJuZWxJZH0gLSBtYW51YWwgaW50ZXJ2ZW50aW9uIG1heSBiZSByZXF1aXJlZGApO1xuICAgICAgXG4gICAgICAvLyBFbWl0IGEgY3JpdGljYWwgZXJyb3JcbiAgICAgIHN1cGVyLmVtaXQoJ2tlcm5lbF91bnJlY292ZXJhYmxlJywge1xuICAgICAgICBrZXJuZWxJZDoga2VybmVsSWQsXG4gICAgICAgIGV4ZWN1dGlvbklkOiBleGVjdXRpb25JZCxcbiAgICAgICAgYWN0dWFsUnVudGltZTogYWN0dWFsUnVudGltZSxcbiAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgbWVzc2FnZTogJ0tlcm5lbCBpcyBzdHVjayBhbmQgY291bGQgbm90IGJlIHJlY292ZXJlZCB0aHJvdWdoIGludGVycnVwdCwgcmVzdGFydCwgb3IgdGVybWluYXRpb24nXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IHN0dWNrIGV4ZWN1dGlvbnMgYWNyb3NzIGFsbCBrZXJuZWxzXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIHN0dWNrIGV4ZWN1dGlvbiBkZXRhaWxzXG4gICAqL1xuICBwdWJsaWMgZ2V0U3R1Y2tFeGVjdXRpb25zKCk6IEFycmF5PHtcbiAgICBrZXJuZWxJZDogc3RyaW5nO1xuICAgIGV4ZWN1dGlvbklkOiBzdHJpbmc7XG4gICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgcnVudGltZTogbnVtYmVyO1xuICAgIG1heEFsbG93ZWQ6IG51bWJlcjtcbiAgICBjb2RlPzogc3RyaW5nO1xuICAgIGtlcm5lbE1vZGU6IEtlcm5lbE1vZGU7XG4gICAga2VybmVsTGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlO1xuICB9PiB7XG4gICAgY29uc3Qgc3R1Y2tFeGVjdXRpb25zOiBBcnJheTx7XG4gICAgICBrZXJuZWxJZDogc3RyaW5nO1xuICAgICAgZXhlY3V0aW9uSWQ6IHN0cmluZztcbiAgICAgIHN0YXJ0VGltZTogbnVtYmVyO1xuICAgICAgcnVudGltZTogbnVtYmVyO1xuICAgICAgbWF4QWxsb3dlZDogbnVtYmVyO1xuICAgICAgY29kZT86IHN0cmluZztcbiAgICAgIGtlcm5lbE1vZGU6IEtlcm5lbE1vZGU7XG4gICAgICBrZXJuZWxMYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gICAgfT4gPSBbXTtcbiAgICBcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgZm9yIChjb25zdCBba2VybmVsSWQsIGluc3RhbmNlXSBvZiB0aGlzLmtlcm5lbHMuZW50cmllcygpKSB7XG4gICAgICAvLyBTa2lwIHBvb2wga2VybmVsc1xuICAgICAgaWYgKGtlcm5lbElkLnN0YXJ0c1dpdGgoXCJwb29sLVwiKSkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIFNraXAga2VybmVscyB3aXRob3V0IG1heEV4ZWN1dGlvblRpbWUgY29uZmlndXJlZFxuICAgICAgaWYgKCFpbnN0YW5jZS5vcHRpb25zPy5tYXhFeGVjdXRpb25UaW1lIHx8IGluc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSA8PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBtYXhFeGVjdXRpb25UaW1lID0gaW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lcyA9IHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5nZXQoa2VybmVsSWQpO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmdldChrZXJuZWxJZCk7XG4gICAgICBjb25zdCBvbmdvaW5nRXhlY3MgPSB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChrZXJuZWxJZCk7XG4gICAgICBcbiAgICAgIGlmICghb25nb2luZ0V4ZWNzIHx8IG9uZ29pbmdFeGVjcy5zaXplID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGV4ZWN1dGlvbklkIG9mIG9uZ29pbmdFeGVjcykge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBzdGFydFRpbWVzPy5nZXQoZXhlY3V0aW9uSWQpO1xuICAgICAgICBpZiAoc3RhcnRUaW1lID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcnVudGltZSA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBleGVjdXRpb24gaXMgc3R1Y2tcbiAgICAgICAgaWYgKHJ1bnRpbWUgPiBtYXhFeGVjdXRpb25UaW1lKSB7XG4gICAgICAgICAgY29uc3QgZXhlY01ldGFkYXRhID0gbWV0YWRhdGE/LmdldChleGVjdXRpb25JZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgc3R1Y2tFeGVjdXRpb25zLnB1c2goe1xuICAgICAgICAgICAga2VybmVsSWQsXG4gICAgICAgICAgICBleGVjdXRpb25JZCxcbiAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgIHJ1bnRpbWUsXG4gICAgICAgICAgICBtYXhBbGxvd2VkOiBtYXhFeGVjdXRpb25UaW1lLFxuICAgICAgICAgICAgY29kZTogZXhlY01ldGFkYXRhPy5jb2RlLFxuICAgICAgICAgICAga2VybmVsTW9kZTogaW5zdGFuY2UubW9kZSxcbiAgICAgICAgICAgIGtlcm5lbExhbmd1YWdlOiBpbnN0YW5jZS5sYW5ndWFnZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNvcnQgYnkgcnVudGltZSAobG9uZ2VzdCBydW5uaW5nIGZpcnN0KVxuICAgIHN0dWNrRXhlY3V0aW9ucy5zb3J0KChhLCBiKSA9PiBiLnJ1bnRpbWUgLSBhLnJ1bnRpbWUpO1xuICAgIFxuICAgIHJldHVybiBzdHVja0V4ZWN1dGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgaW50ZXJydXB0IGFsbCBzdHVjayBleGVjdXRpb25zIGFjcm9zcyBhbGwga2VybmVsc1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBpbnRlcnZlbnRpb24gcmVzdWx0c1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGhhbmRsZUFsbFN0dWNrRXhlY3V0aW9ucygpOiBQcm9taXNlPEFycmF5PHtcbiAgICBrZXJuZWxJZDogc3RyaW5nO1xuICAgIGV4ZWN1dGlvbklkOiBzdHJpbmc7XG4gICAgYWN0aW9uOiAnaW50ZXJydXB0ZWQnIHwgJ3Jlc3RhcnRlZCcgfCAndGVybWluYXRlZCcgfCAnZmFpbGVkJztcbiAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgIGVycm9yPzogc3RyaW5nO1xuICB9Pj4ge1xuICAgIGNvbnN0IHN0dWNrRXhlY3V0aW9ucyA9IHRoaXMuZ2V0U3R1Y2tFeGVjdXRpb25zKCk7XG4gICAgY29uc3QgcmVzdWx0czogQXJyYXk8e1xuICAgICAga2VybmVsSWQ6IHN0cmluZztcbiAgICAgIGV4ZWN1dGlvbklkOiBzdHJpbmc7XG4gICAgICBhY3Rpb246ICdpbnRlcnJ1cHRlZCcgfCAncmVzdGFydGVkJyB8ICd0ZXJtaW5hdGVkJyB8ICdmYWlsZWQnO1xuICAgICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICAgIGVycm9yPzogc3RyaW5nO1xuICAgIH0+ID0gW107XG4gICAgXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7c3R1Y2tFeGVjdXRpb25zLmxlbmd0aH0gc3R1Y2sgZXhlY3V0aW9ucyB0byBoYW5kbGVgKTtcbiAgICBcbiAgICAvLyBHcm91cCBieSBrZXJuZWwgdG8gYXZvaWQgbXVsdGlwbGUgaW50ZXJ2ZW50aW9ucyBvbiB0aGUgc2FtZSBrZXJuZWxcbiAgICBjb25zdCBrZXJuZWxHcm91cHMgPSBuZXcgTWFwPHN0cmluZywgdHlwZW9mIHN0dWNrRXhlY3V0aW9ucz4oKTtcbiAgICBmb3IgKGNvbnN0IGV4ZWMgb2Ygc3R1Y2tFeGVjdXRpb25zKSB7XG4gICAgICBpZiAoIWtlcm5lbEdyb3Vwcy5oYXMoZXhlYy5rZXJuZWxJZCkpIHtcbiAgICAgICAga2VybmVsR3JvdXBzLnNldChleGVjLmtlcm5lbElkLCBbXSk7XG4gICAgICB9XG4gICAgICBrZXJuZWxHcm91cHMuZ2V0KGV4ZWMua2VybmVsSWQpIS5wdXNoKGV4ZWMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgZWFjaCBrZXJuZWwncyBzdHVjayBleGVjdXRpb25zXG4gICAgZm9yIChjb25zdCBba2VybmVsSWQsIGV4ZWN1dGlvbnNdIG9mIGtlcm5lbEdyb3Vwcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gUGljayB0aGUgbG9uZ2VzdCBydW5uaW5nIGV4ZWN1dGlvbiBhcyB0aGUgcHJpbWFyeSBvbmVcbiAgICAgICAgY29uc3QgcHJpbWFyeUV4ZWMgPSBleGVjdXRpb25zWzBdOyAvLyBBbHJlYWR5IHNvcnRlZCBieSBydW50aW1lIGRlc2NcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBIYW5kbGluZyBzdHVjayBrZXJuZWwgJHtrZXJuZWxJZH0gd2l0aCAke2V4ZWN1dGlvbnMubGVuZ3RofSBzdHVjayBleGVjdXRpb25zIChwcmltYXJ5OiAke3ByaW1hcnlFeGVjLnJ1bnRpbWV9bXMpYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVc2UgdGhlIGF1dG9tYXRlZCBoYW5kbGluZyBzeXN0ZW1cbiAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVTdHVja0V4ZWN1dGlvbihcbiAgICAgICAgICBrZXJuZWxJZCwgXG4gICAgICAgICAgcHJpbWFyeUV4ZWMuZXhlY3V0aW9uSWQsIFxuICAgICAgICAgIHByaW1hcnlFeGVjLnJ1bnRpbWUsIFxuICAgICAgICAgIHByaW1hcnlFeGVjLmNvZGVcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1hcmsgYWxsIGV4ZWN1dGlvbnMgZm9yIHRoaXMga2VybmVsIGFzIGhhbmRsZWRcbiAgICAgICAgZm9yIChjb25zdCBleGVjIG9mIGV4ZWN1dGlvbnMpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAga2VybmVsSWQ6IGV4ZWMua2VybmVsSWQsXG4gICAgICAgICAgICBleGVjdXRpb25JZDogZXhlYy5leGVjdXRpb25JZCxcbiAgICAgICAgICAgIGFjdGlvbjogJ2ludGVycnVwdGVkJywgLy8gV2UgZG9uJ3Qga25vdyB0aGUgZXhhY3QgYWN0aW9uLCBidXQgaXQgd2FzIGhhbmRsZWRcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGhhbmRsaW5nIHN0dWNrIGV4ZWN1dGlvbnMgZm9yIGtlcm5lbCAke2tlcm5lbElkfTpgLCBlcnJvcik7XG4gICAgICAgIFxuICAgICAgICAvLyBNYXJrIGFsbCBleGVjdXRpb25zIGZvciB0aGlzIGtlcm5lbCBhcyBmYWlsZWRcbiAgICAgICAgZm9yIChjb25zdCBleGVjIG9mIGV4ZWN1dGlvbnMpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAga2VybmVsSWQ6IGV4ZWMua2VybmVsSWQsXG4gICAgICAgICAgICBleGVjdXRpb25JZDogZXhlYy5leGVjdXRpb25JZCxcbiAgICAgICAgICAgIGFjdGlvbjogJ2ZhaWxlZCcsXG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgaW50ZXJydXB0IGJ1ZmZlciBmb3IgYSB3b3JrZXIga2VybmVsIGR1cmluZyBjcmVhdGlvblxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSB3b3JrZXIgV29ya2VyIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNldHVwV29ya2VySW50ZXJydXB0QnVmZmVyKGlkOiBzdHJpbmcsIHdvcmtlcjogV29ya2VyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gU2tpcCBTaGFyZWRBcnJheUJ1ZmZlciBzZXR1cCBpZiBtb2RlIGlzICdrZXJuZWwtaW50ZXJydXB0J1xuICAgIGlmICh0aGlzLmludGVycnVwdGlvbk1vZGUgPT09ICdrZXJuZWwtaW50ZXJydXB0Jykge1xuICAgICAgY29uc29sZS5sb2coYFNraXBwaW5nIFNoYXJlZEFycmF5QnVmZmVyIHNldHVwIGZvciBrZXJuZWwgJHtpZH0gLSB1c2luZyBrZXJuZWwuaW50ZXJydXB0KCkgbW9kZWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gUHl0aG9uIGtlcm5lbHMgc3VwcG9ydCBpbnRlcnJ1cHQgYnVmZmVyc1xuICAgICAgXG4gICAgICAvLyBGb3IgUHl0aG9uIGtlcm5lbHMsIGNyZWF0ZSBhY3R1YWwgU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAgIGNvbnN0IHNoYXJlZEJ1ZmZlciA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKTtcbiAgICAgIGNvbnN0IGludGVycnVwdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHNoYXJlZEJ1ZmZlcik7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgYnVmZmVyIHRvIDAgKG5vIGludGVycnVwdCBzaWduYWwpXG4gICAgICBpbnRlcnJ1cHRCdWZmZXJbMF0gPSAwO1xuICAgICAgXG4gICAgICAvLyBTdG9yZSB0aGUgYnVmZmVyIGZvciBmdXR1cmUgdXNlXG4gICAgICB0aGlzLmludGVycnVwdEJ1ZmZlcnMuc2V0KGlkLCBpbnRlcnJ1cHRCdWZmZXIpO1xuICAgICAgXG4gICAgICAvLyBTZW5kIHRoZSBidWZmZXIgdG8gdGhlIHdvcmtlciB0byBzZXQgdXAgcHlvZGlkZS5zZXRJbnRlcnJ1cHRCdWZmZXIoKVxuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJTRVRfSU5URVJSVVBUX0JVRkZFUlwiLFxuICAgICAgICBidWZmZXI6IGludGVycnVwdEJ1ZmZlclxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSB3b3JrZXIgdG8gY29uZmlybSBidWZmZXIgc2V0dXBcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lb3V0IHdhaXRpbmcgZm9yIGludGVycnVwdCBidWZmZXIgc2V0dXBcIikpO1xuICAgICAgICB9LCA1MDAwKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIklOVEVSUlVQVF9CVUZGRVJfU0VUXCIpIHtcbiAgICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBIYW5kbGUgYmFzZWQgb24gaW50ZXJydXB0aW9uIG1vZGVcbiAgICAgIGlmICh0aGlzLmludGVycnVwdGlvbk1vZGUgPT09ICdzaGFyZWQtYXJyYXktYnVmZmVyJykge1xuICAgICAgICAvLyBJZiBleHBsaWNpdGx5IHNldCB0byBzaGFyZWQtYXJyYXktYnVmZmVyLCB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBTaGFyZWRBcnJheUJ1ZmZlciByZXF1aXJlZCBidXQgbm90IGF2YWlsYWJsZSBmb3Iga2VybmVsICR7aWR9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2hhcmVkQXJyYXlCdWZmZXIgaXMgcmVxdWlyZWQgYnV0IG5vdCBhdmFpbGFibGUuIFRvIGVuYWJsZSBTaGFyZWRBcnJheUJ1ZmZlciwgeW91ciBzZXJ2ZXIgbXVzdCBzZXQgdGhlc2UgaGVhZGVyczpcbi0gQ3Jvc3MtT3JpZ2luLU9wZW5lci1Qb2xpY3k6IHNhbWUtb3JpZ2luXG4tIENyb3NzLU9yaWdpbi1FbWJlZGRlci1Qb2xpY3k6IHJlcXVpcmUtY29ycFxuXG5BbHRlcm5hdGl2ZWx5LCB1c2UgaW50ZXJydXB0aW9uTW9kZTogJ2tlcm5lbC1pbnRlcnJ1cHQnIG9yICdhdXRvJyBpbiBLZXJuZWxNYW5hZ2VyIG9wdGlvbnMuYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdXRvIG1vZGU6IGZhbGwgYmFjayB0byBrZXJuZWwuaW50ZXJydXB0KClcbiAgICAgICAgY29uc29sZS5pbmZvKGDihLnvuI8gU2hhcmVkQXJyYXlCdWZmZXIgbm90IGF2YWlsYWJsZSBmb3Iga2VybmVsICR7aWR9LiBVc2luZyBhbHRlcm5hdGl2ZSBpbnRlcnJ1cHQgbWV0aG9kLlxuXG5UbyBlbmFibGUgZmFzdGVyIGludGVycnVwdHMsIGNvbmZpZ3VyZSB5b3VyIHNlcnZlciB3aXRoIHRoZXNlIGhlYWRlcnM6XG4tIENyb3NzLU9yaWdpbi1PcGVuZXItUG9saWN5OiBzYW1lLW9yaWdpblxuLSBDcm9zcy1PcmlnaW4tRW1iZWRkZXItUG9saWN5OiByZXF1aXJlLWNvcnBcblxuTm90ZTogU29tZSBkZXZlbG9wbWVudCBzZXJ2ZXJzIChlLmcuLCBWaXRlLCB3ZWJwYWNrLWRldi1zZXJ2ZXIpIGNhbiBiZSBjb25maWd1cmVkIHRvIGFkZCB0aGVzZSBoZWFkZXJzLlxuVGhlIGFsdGVybmF0aXZlIGludGVycnVwdCBtZXRob2Qgd2lsbCBzdGlsbCB3b3JrIGJ1dCBtYXkgYmUgbGVzcyByZXNwb25zaXZlIGZvciBsb25nLXJ1bm5pbmcgY29kZS5gKTtcbiAgICAgICAgLy8gRG9uJ3QgdGhyb3cgLSBrZXJuZWwgY2FuIHN0aWxsIHdvcmsgd2l0aG91dCBpbnRlcnJ1cHQgYnVmZmVyXG4gICAgICB9XG4gICAgfVxuICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/manager.ts\n\n}");

/***/ }),

/***/ "./src/pyodide-loader.ts":
/*!*******************************!*\
  !*** ./src/pyodide-loader.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadPyodide: () => (/* binding */ loadPyodide)\n/* harmony export */ });\n/* unused harmony exports isPyodideLoaded, getPyodideCDNUrl, getPyodideIndexUrl */\n/**\n * Pyodide CDN Loader Utility\n * Dynamically loads Pyodide from CDN for both main thread and web workers\n */\nconst PYODIDE_CDN_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js';\nconst PYODIDE_INDEX_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/';\n// Global flag to track if Pyodide is loaded\nlet pyodideLoaded = false;\nlet pyodideLoadPromise = null;\n/**\n * Load Pyodide script dynamically in main thread\n */\nfunction loadPyodideScript() {\n    return new Promise((resolve, reject) => {\n        // Check if script is already loaded\n        if (typeof globalThis.loadPyodide !== 'undefined') {\n            resolve();\n            return;\n        }\n        const script = document.createElement('script');\n        script.src = PYODIDE_CDN_URL;\n        script.onload = () => resolve();\n        script.onerror = () => reject(new Error(`Failed to load Pyodide from ${PYODIDE_CDN_URL}`));\n        document.head.appendChild(script);\n    });\n}\n/**\n * Load Pyodide in web worker using importScripts\n */\nfunction loadPyodideInWorker() {\n    return new Promise((resolve, reject) => {\n        try {\n            // Check if we're in a worker environment\n            if (typeof importScripts === 'undefined') {\n                reject(new Error('importScripts is not available - not in a worker context'));\n                return;\n            }\n            // Check if already loaded\n            if (typeof globalThis.loadPyodide !== 'undefined') {\n                resolve();\n                return;\n            }\n            importScripts(PYODIDE_CDN_URL);\n            resolve();\n        }\n        catch (error) {\n            reject(new Error(`Failed to import Pyodide in worker: ${error}`));\n        }\n    });\n}\n/**\n * Initialize Pyodide with proper configuration\n */\nasync function loadPyodide(config = {}) {\n    // Return existing promise if already loading\n    if (pyodideLoadPromise) {\n        return pyodideLoadPromise;\n    }\n    pyodideLoadPromise = (async () => {\n        try {\n            // Determine if we're in a worker or main thread\n            const isWorker = typeof importScripts !== 'undefined';\n            // Load the Pyodide script\n            if (isWorker) {\n                await loadPyodideInWorker();\n            }\n            else {\n                await loadPyodideScript();\n            }\n            // Get the global loadPyodide function\n            const globalLoadPyodide = globalThis.loadPyodide;\n            if (!globalLoadPyodide) {\n                throw new Error('loadPyodide function not found after script load');\n            }\n            // Configure default options\n            const defaultConfig = {\n                indexURL: PYODIDE_INDEX_URL,\n                ...config\n            };\n            // Initialize Pyodide\n            const pyodide = await globalLoadPyodide(defaultConfig);\n            pyodideLoaded = true;\n            console.log('âœ… Pyodide loaded successfully from CDN');\n            return pyodide;\n        }\n        catch (error) {\n            pyodideLoadPromise = null; // Reset on failure\n            throw error;\n        }\n    })();\n    return pyodideLoadPromise;\n}\n/**\n * Check if Pyodide is already loaded\n */\nfunction isPyodideLoaded() {\n    return pyodideLoaded && typeof globalThis.loadPyodide !== 'undefined';\n}\n/**\n * Get Pyodide CDN URL for external use\n */\nfunction getPyodideCDNUrl() {\n    return PYODIDE_CDN_URL;\n}\n/**\n * Get Pyodide index URL for external use\n */\nfunction getPyodideIndexUrl() {\n    return PYODIDE_INDEX_URL;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFDcEIsUUFBUSxFQUFFLGlCQUFpQjtnQkFDM0IsR0FBRyxNQUFNO2FBQ1YsQ0FBQztZQUVGLHFCQUFxQjtZQUNyQixNQUFNLE9BQU8sR0FBRyxNQUFNLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3ZELGFBQWEsR0FBRyxJQUFJLENBQUM7WUFFckIsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO1lBQ3RELE9BQU8sT0FBTyxDQUFDO1FBQ2pCLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2Ysa0JBQWtCLEdBQUcsSUFBSSxDQUFDLENBQUMsbUJBQW1CO1lBQzlDLE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUMsQ0FBQyxFQUFFLENBQUM7SUFFTCxPQUFPLGtCQUFrQixDQUFDO0FBQzVCLENBQUM7QUFFRDs7R0FFRztBQUNJLFNBQVMsZUFBZTtJQUM3QixPQUFPLGFBQWEsSUFBSSxPQUFRLFVBQWtCLENBQUMsV0FBVyxLQUFLLFdBQVcsQ0FBQztBQUNqRixDQUFDO0FBRUQ7O0dBRUc7QUFDSSxTQUFTLGdCQUFnQjtJQUM5QixPQUFPLGVBQWUsQ0FBQztBQUN6QixDQUFDO0FBRUQ7O0dBRUc7QUFDSSxTQUFTLGtCQUFrQjtJQUNoQyxPQUFPLGlCQUFpQixDQUFDO0FBQzNCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItcHl0aG9uLWtlcm5lbC8uL3NyYy9weW9kaWRlLWxvYWRlci50cz81MDExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUHlvZGlkZSBDRE4gTG9hZGVyIFV0aWxpdHlcbiAqIER5bmFtaWNhbGx5IGxvYWRzIFB5b2RpZGUgZnJvbSBDRE4gZm9yIGJvdGggbWFpbiB0aHJlYWQgYW5kIHdlYiB3b3JrZXJzXG4gKi9cblxuY29uc3QgUFlPRElERV9DRE5fVVJMID0gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9weW9kaWRlL3YwLjI4LjAvZnVsbC9weW9kaWRlLmpzJztcbmNvbnN0IFBZT0RJREVfSU5ERVhfVVJMID0gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9weW9kaWRlL3YwLjI4LjAvZnVsbC8nO1xuXG4vLyBHbG9iYWwgZmxhZyB0byB0cmFjayBpZiBQeW9kaWRlIGlzIGxvYWRlZFxubGV0IHB5b2RpZGVMb2FkZWQgPSBmYWxzZTtcbmxldCBweW9kaWRlTG9hZFByb21pc2U6IFByb21pc2U8YW55PiB8IG51bGwgPSBudWxsO1xuXG4vKipcbiAqIExvYWQgUHlvZGlkZSBzY3JpcHQgZHluYW1pY2FsbHkgaW4gbWFpbiB0aHJlYWRcbiAqL1xuZnVuY3Rpb24gbG9hZFB5b2RpZGVTY3JpcHQoKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgc2NyaXB0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgaWYgKHR5cGVvZiAoZ2xvYmFsVGhpcyBhcyBhbnkpLmxvYWRQeW9kaWRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdC5zcmMgPSBQWU9ESURFX0NETl9VUkw7XG4gICAgc2NyaXB0Lm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcbiAgICBzY3JpcHQub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIFB5b2RpZGUgZnJvbSAke1BZT0RJREVfQ0ROX1VSTH1gKSk7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBMb2FkIFB5b2RpZGUgaW4gd2ViIHdvcmtlciB1c2luZyBpbXBvcnRTY3JpcHRzXG4gKi9cbmZ1bmN0aW9uIGxvYWRQeW9kaWRlSW5Xb3JrZXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIGEgd29ya2VyIGVudmlyb25tZW50XG4gICAgICBpZiAodHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2ltcG9ydFNjcmlwdHMgaXMgbm90IGF2YWlsYWJsZSAtIG5vdCBpbiBhIHdvcmtlciBjb250ZXh0JykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgbG9hZGVkXG4gICAgICBpZiAodHlwZW9mIChnbG9iYWxUaGlzIGFzIGFueSkubG9hZFB5b2RpZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbXBvcnRTY3JpcHRzKFBZT0RJREVfQ0ROX1VSTCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBpbXBvcnQgUHlvZGlkZSBpbiB3b3JrZXI6ICR7ZXJyb3J9YCkpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBQeW9kaWRlIHdpdGggcHJvcGVyIGNvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRQeW9kaWRlKGNvbmZpZzogYW55ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAvLyBSZXR1cm4gZXhpc3RpbmcgcHJvbWlzZSBpZiBhbHJlYWR5IGxvYWRpbmdcbiAgaWYgKHB5b2RpZGVMb2FkUHJvbWlzZSkge1xuICAgIHJldHVybiBweW9kaWRlTG9hZFByb21pc2U7XG4gIH1cblxuICBweW9kaWRlTG9hZFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBEZXRlcm1pbmUgaWYgd2UncmUgaW4gYSB3b3JrZXIgb3IgbWFpbiB0aHJlYWRcbiAgICAgIGNvbnN0IGlzV29ya2VyID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnO1xuICAgICAgXG4gICAgICAvLyBMb2FkIHRoZSBQeW9kaWRlIHNjcmlwdFxuICAgICAgaWYgKGlzV29ya2VyKSB7XG4gICAgICAgIGF3YWl0IGxvYWRQeW9kaWRlSW5Xb3JrZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGxvYWRQeW9kaWRlU2NyaXB0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgZ2xvYmFsIGxvYWRQeW9kaWRlIGZ1bmN0aW9uXG4gICAgICBjb25zdCBnbG9iYWxMb2FkUHlvZGlkZSA9IChnbG9iYWxUaGlzIGFzIGFueSkubG9hZFB5b2RpZGU7XG4gICAgICBpZiAoIWdsb2JhbExvYWRQeW9kaWRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9hZFB5b2RpZGUgZnVuY3Rpb24gbm90IGZvdW5kIGFmdGVyIHNjcmlwdCBsb2FkJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbmZpZ3VyZSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgIGluZGV4VVJMOiBQWU9ESURFX0lOREVYX1VSTCxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIFB5b2RpZGVcbiAgICAgIGNvbnN0IHB5b2RpZGUgPSBhd2FpdCBnbG9iYWxMb2FkUHlvZGlkZShkZWZhdWx0Q29uZmlnKTtcbiAgICAgIHB5b2RpZGVMb2FkZWQgPSB0cnVlO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFB5b2RpZGUgbG9hZGVkIHN1Y2Nlc3NmdWxseSBmcm9tIENETicpO1xuICAgICAgcmV0dXJuIHB5b2RpZGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHB5b2RpZGVMb2FkUHJvbWlzZSA9IG51bGw7IC8vIFJlc2V0IG9uIGZhaWx1cmVcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSkoKTtcblxuICByZXR1cm4gcHlvZGlkZUxvYWRQcm9taXNlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIFB5b2RpZGUgaXMgYWxyZWFkeSBsb2FkZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHlvZGlkZUxvYWRlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIHB5b2RpZGVMb2FkZWQgJiYgdHlwZW9mIChnbG9iYWxUaGlzIGFzIGFueSkubG9hZFB5b2RpZGUgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIEdldCBQeW9kaWRlIENETiBVUkwgZm9yIGV4dGVybmFsIHVzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHlvZGlkZUNETlVybCgpOiBzdHJpbmcge1xuICByZXR1cm4gUFlPRElERV9DRE5fVVJMO1xufVxuXG4vKipcbiAqIEdldCBQeW9kaWRlIGluZGV4IFVSTCBmb3IgZXh0ZXJuYWwgdXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQeW9kaWRlSW5kZXhVcmwoKTogc3RyaW5nIHtcbiAgcmV0dXJuIFBZT0RJREVfSU5ERVhfVVJMO1xufSAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pyodide-loader.ts\n\n}");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KernelEvents: () => (/* binding */ KernelEvents)\n/* harmony export */ });\n// Shared types and interfaces to prevent circular dependencies\n// These are extracted from index.ts to break the circular dependency\n// Events enum\nvar KernelEvents;\n(function (KernelEvents) {\n    // IOPub Channel Messages\n    KernelEvents[\"STREAM\"] = \"stream\";\n    KernelEvents[\"DISPLAY_DATA\"] = \"display_data\";\n    KernelEvents[\"UPDATE_DISPLAY_DATA\"] = \"update_display_data\";\n    KernelEvents[\"EXECUTE_RESULT\"] = \"execute_result\";\n    KernelEvents[\"EXECUTE_ERROR\"] = \"execute_error\";\n    KernelEvents[\"EXECUTE_REQUEST\"] = \"execute_request\";\n    // Input request\n    KernelEvents[\"INPUT_REQUEST\"] = \"input_request\";\n    // Output control\n    KernelEvents[\"CLEAR_OUTPUT\"] = \"clear_output\";\n    // Comm messages\n    KernelEvents[\"COMM_OPEN\"] = \"comm_open\";\n    KernelEvents[\"COMM_MSG\"] = \"comm_msg\";\n    KernelEvents[\"COMM_CLOSE\"] = \"comm_close\";\n    // Internal Events\n    KernelEvents[\"KERNEL_READY\"] = \"kernel_ready\";\n    KernelEvents[\"KERNEL_BUSY\"] = \"kernel_busy\";\n    KernelEvents[\"KERNEL_IDLE\"] = \"kernel_idle\";\n    // Special catchall for internal use\n    KernelEvents[\"ALL\"] = \"*\";\n    // Execution monitoring events\n    KernelEvents[\"EXECUTION_STALLED\"] = \"execution_stalled\";\n    // Enhanced stuck kernel handling events\n    KernelEvents[\"KERNEL_UNRECOVERABLE\"] = \"kernel_unrecoverable\";\n    KernelEvents[\"EXECUTION_INTERRUPTED\"] = \"execution_interrupted\";\n    KernelEvents[\"KERNEL_RESTARTED\"] = \"kernel_restarted\";\n    KernelEvents[\"KERNEL_TERMINATED\"] = \"kernel_terminated\";\n})(KernelEvents || (KernelEvents = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHlwZXMudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEsK0RBQStEO0FBQy9ELHFFQUFxRTtBQUVyRSxjQUFjO0FBQ2QsSUFBWSxZQW9DWDtBQXBDRCxXQUFZLFlBQVk7SUFDdEIseUJBQXlCO0lBQ3pCLGlDQUFpQjtJQUNqQiw2Q0FBNkI7SUFDN0IsMkRBQTJDO0lBQzNDLGlEQUFpQztJQUNqQywrQ0FBK0I7SUFDL0IsbURBQW1DO0lBRW5DLGdCQUFnQjtJQUNoQiwrQ0FBK0I7SUFFL0IsaUJBQWlCO0lBQ2pCLDZDQUE2QjtJQUU3QixnQkFBZ0I7SUFDaEIsdUNBQXVCO0lBQ3ZCLHFDQUFxQjtJQUNyQix5Q0FBeUI7SUFFekIsa0JBQWtCO0lBQ2xCLDZDQUE2QjtJQUM3QiwyQ0FBMkI7SUFDM0IsMkNBQTJCO0lBRTNCLG9DQUFvQztJQUNwQyx5QkFBUztJQUVULDhCQUE4QjtJQUM5Qix1REFBdUM7SUFFdkMsd0NBQXdDO0lBQ3hDLDZEQUE2QztJQUM3QywrREFBK0M7SUFDL0MscURBQXFDO0lBQ3JDLHVEQUF1QztBQUN6QyxDQUFDLEVBcENXLFlBQVksS0FBWixZQUFZLFFBb0N2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1weXRob24ta2VybmVsLy4vc3JjL3R5cGVzLnRzP2E3NmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2hhcmVkIHR5cGVzIGFuZCBpbnRlcmZhY2VzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4vLyBUaGVzZSBhcmUgZXh0cmFjdGVkIGZyb20gaW5kZXgudHMgdG8gYnJlYWsgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3lcblxuLy8gRXZlbnRzIGVudW1cbmV4cG9ydCBlbnVtIEtlcm5lbEV2ZW50cyB7XG4gIC8vIElPUHViIENoYW5uZWwgTWVzc2FnZXNcbiAgU1RSRUFNID0gXCJzdHJlYW1cIixcbiAgRElTUExBWV9EQVRBID0gXCJkaXNwbGF5X2RhdGFcIixcbiAgVVBEQVRFX0RJU1BMQVlfREFUQSA9IFwidXBkYXRlX2Rpc3BsYXlfZGF0YVwiLFxuICBFWEVDVVRFX1JFU1VMVCA9IFwiZXhlY3V0ZV9yZXN1bHRcIixcbiAgRVhFQ1VURV9FUlJPUiA9IFwiZXhlY3V0ZV9lcnJvclwiLFxuICBFWEVDVVRFX1JFUVVFU1QgPSBcImV4ZWN1dGVfcmVxdWVzdFwiLFxuICBcbiAgLy8gSW5wdXQgcmVxdWVzdFxuICBJTlBVVF9SRVFVRVNUID0gXCJpbnB1dF9yZXF1ZXN0XCIsXG4gIFxuICAvLyBPdXRwdXQgY29udHJvbFxuICBDTEVBUl9PVVRQVVQgPSBcImNsZWFyX291dHB1dFwiLFxuICBcbiAgLy8gQ29tbSBtZXNzYWdlc1xuICBDT01NX09QRU4gPSBcImNvbW1fb3BlblwiLFxuICBDT01NX01TRyA9IFwiY29tbV9tc2dcIixcbiAgQ09NTV9DTE9TRSA9IFwiY29tbV9jbG9zZVwiLFxuICBcbiAgLy8gSW50ZXJuYWwgRXZlbnRzXG4gIEtFUk5FTF9SRUFEWSA9IFwia2VybmVsX3JlYWR5XCIsXG4gIEtFUk5FTF9CVVNZID0gXCJrZXJuZWxfYnVzeVwiLFxuICBLRVJORUxfSURMRSA9IFwia2VybmVsX2lkbGVcIixcbiAgXG4gIC8vIFNwZWNpYWwgY2F0Y2hhbGwgZm9yIGludGVybmFsIHVzZVxuICBBTEwgPSBcIipcIiwgLy8gV2lsZGNhcmQgZXZlbnQgdHlwZVxuICBcbiAgLy8gRXhlY3V0aW9uIG1vbml0b3JpbmcgZXZlbnRzXG4gIEVYRUNVVElPTl9TVEFMTEVEID0gXCJleGVjdXRpb25fc3RhbGxlZFwiLFxuICBcbiAgLy8gRW5oYW5jZWQgc3R1Y2sga2VybmVsIGhhbmRsaW5nIGV2ZW50c1xuICBLRVJORUxfVU5SRUNPVkVSQUJMRSA9IFwia2VybmVsX3VucmVjb3ZlcmFibGVcIixcbiAgRVhFQ1VUSU9OX0lOVEVSUlVQVEVEID0gXCJleGVjdXRpb25faW50ZXJydXB0ZWRcIixcbiAgS0VSTkVMX1JFU1RBUlRFRCA9IFwia2VybmVsX3Jlc3RhcnRlZFwiLFxuICBLRVJORUxfVEVSTUlOQVRFRCA9IFwia2VybmVsX3Rlcm1pbmF0ZWRcIlxufVxuXG4vLyBFdmVudEVtaXR0ZXIgaW50ZXJmYWNlIGZvciB0eXBpbmdcbmV4cG9ydCBpbnRlcmZhY2UgSUV2ZW50RW1pdHRlciB7XG4gIG9uKGV2ZW50TmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogRnVuY3Rpb24pOiB2b2lkO1xuICBvZmYoZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbik6IHZvaWQ7XG4gIGVtaXQoZXZlbnROYW1lOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKTogdm9pZDtcbiAgc2V0TWF4TGlzdGVuZXJzKG46IG51bWJlcik6IHZvaWQ7XG59XG5cbi8vIEZpbGVzeXN0ZW0gbW91bnQgb3B0aW9uc1xuZXhwb3J0IGludGVyZmFjZSBJRmlsZXN5c3RlbU1vdW50T3B0aW9ucyB7XG4gIGVuYWJsZWQ/OiBib29sZWFuO1xuICByb290Pzogc3RyaW5nO1xuICBtb3VudFBvaW50Pzogc3RyaW5nO1xufVxuXG4vLyBLZXJuZWwgb3B0aW9ucyBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSUtlcm5lbE9wdGlvbnMge1xuICBmaWxlc3lzdGVtPzogSUZpbGVzeXN0ZW1Nb3VudE9wdGlvbnM7XG4gIGVudj86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47IC8vIEVudmlyb25tZW50IHZhcmlhYmxlcyB0byBzZXQgaW4gdGhlIGtlcm5lbFxuICBsb2NrRmlsZVVSTD86IHN0cmluZzsgLy8gVVJMIHRvIHB5b2RpZGUtbG9jay5qc29uIGZpbGUgZm9yIGZhc3RlciBsb2FkaW5nXG4gIGF1dG9TeW5jRnM/OiBib29sZWFuOyAvLyBBdXRvbWF0aWNhbGx5IHN5bmMgbmF0aXZlIGZpbGVzeXN0ZW0gYWZ0ZXIgY29kZSBleGVjdXRpb24gKGRlZmF1bHQ6IGZhbHNlKVxufVxuXG4vLyBOYXRpdmUgZmlsZXN5c3RlbSBoYW5kbGUgdHlwZVxuZXhwb3J0IGludGVyZmFjZSBJTmF0aXZlRlNIYW5kbGUge1xuICBzeW5jZnMoKTogUHJvbWlzZTx2b2lkPjtcbn1cblxuLy8gS2VybmVsIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsIGV4dGVuZHMgSUV2ZW50RW1pdHRlciB7XG4gIGluaXRpYWxpemUob3B0aW9ucz86IElLZXJuZWxPcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcbiAgZXhlY3V0ZShjb2RlOiBzdHJpbmcsIHBhcmVudD86IGFueSk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ/OiBhbnksIGVycm9yPzogRXJyb3IgfT47XG4gIGV4ZWN1dGVTdHJlYW0/KGNvZGU6IHN0cmluZywgcGFyZW50PzogYW55KTogQXN5bmNHZW5lcmF0b3I8YW55LCB7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9LCB2b2lkPjtcbiAgaXNJbml0aWFsaXplZCgpOiBib29sZWFuO1xuICBpbnB1dFJlcGx5KGNvbnRlbnQ6IHsgdmFsdWU6IHN0cmluZyB9KTogUHJvbWlzZTx2b2lkPjtcbiAgZ2V0U3RhdHVzKCk6IFByb21pc2U8XCJhY3RpdmVcIiB8IFwiYnVzeVwiIHwgXCJ1bmtub3duXCI+O1xuXG4gIC8vIEludGVycnVwdCBmdW5jdGlvbmFsaXR5XG4gIGludGVycnVwdD8oKTogUHJvbWlzZTxib29sZWFuPjtcbiAgc2V0SW50ZXJydXB0QnVmZmVyPyhidWZmZXI6IFVpbnQ4QXJyYXkpOiB2b2lkO1xuXG4gIC8vIE5hdGl2ZSBmaWxlc3lzdGVtIG1vdW50aW5nXG4gIG1vdW50RlM/KG1vdW50UGF0aDogc3RyaW5nLCBkaXJIYW5kbGU/OiBGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHwgbnVsbCwgcGVybWlzc2lvbj86ICdyZWFkJyB8ICdyZWFkd3JpdGUnKTogUHJvbWlzZTxJTmF0aXZlRlNIYW5kbGU+O1xuICBnZXRNb3VudGVkRmlsZXN5c3RlbXM/KCk6IEFycmF5PHsgbW91bnRQYXRoOiBzdHJpbmc7IHBlcm1pc3Npb246ICdyZWFkJyB8ICdyZWFkd3JpdGUnOyBjYW5TeW5jOiBib29sZWFuOyB9PjtcbiAgc3luY0ZpbGVzeXN0ZW0/KG1vdW50UGF0aDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+O1xuICB1cGdyYWRlRmlsZXN5c3RlbVBlcm1pc3Npb24/KG1vdW50UGF0aDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+O1xuXG4gIC8vIE9wdGlvbmFsIG1ldGhvZHNcbiAgY29tcGxldGU/KGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPGFueT47XG4gIGluc3BlY3Q/KGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBkZXRhaWxfbGV2ZWw6IDAgfCAxLCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPGFueT47XG4gIGlzQ29tcGxldGU/KGNvZGU6IHN0cmluZywgcGFyZW50PzogYW55KTogUHJvbWlzZTxhbnk+O1xuICBjb21tSW5mbz8odGFyZ2V0X25hbWU6IHN0cmluZyB8IG51bGwsIHBhcmVudD86IGFueSk6IFByb21pc2U8YW55PjtcbiAgY29tbU9wZW4/KGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KTogUHJvbWlzZTx2b2lkPjtcbiAgY29tbU1zZz8oY29udGVudDogYW55LCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPHZvaWQ+O1xuICBjb21tQ2xvc2U/KGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KTogUHJvbWlzZTx2b2lkPjtcbn1cblxuLy8gRXhlY3V0ZSBvcHRpb25zIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsRXhlY3V0ZU9wdGlvbnMge1xuICBjb2RlOiBzdHJpbmc7XG4gIHNpbGVudD86IGJvb2xlYW47XG4gIHN0b3JlSGlzdG9yeT86IGJvb2xlYW47XG59XG5cbi8vIE1lc3NhZ2UgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIElNZXNzYWdlIHtcbiAgdHlwZTogc3RyaW5nO1xuICBidW5kbGU/OiBhbnk7XG4gIGNvbnRlbnQ/OiBhbnk7XG4gIG1ldGFkYXRhPzogYW55O1xuICBwYXJlbnRIZWFkZXI/OiBhbnk7XG4gIGJ1ZmZlcnM/OiBhbnk7XG4gIGlkZW50PzogYW55O1xufVxuXG4vLyBFdmVudCBkYXRhIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBJRXZlbnREYXRhIHtcbiAgdHlwZTogc3RyaW5nO1xuICBkYXRhOiBhbnk7XG59ICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/types.ts\n\n}");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval-source-map devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/kernel.worker.ts");
/******/ 
