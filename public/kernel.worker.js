/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./node_modules/comlink/dist/esm/comlink.mjs":
/*!***************************************************!*\
  !*** ./node_modules/comlink/dist/esm/comlink.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   expose: () => (/* binding */ expose),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* unused harmony exports createEndpoint, finalizer, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint */\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously Â¯\\_(ãƒ„)_/Â¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didnâ€™t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\n\n//# sourceMappingURL=comlink.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tbGluay9kaXN0L2VzbS9jb21saW5rLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUIsa0JBQWtCLFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCLElBQUk7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlEQUF5RCxnQkFBZ0IsSUFBSTtBQUM3RSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpSTtBQUNqSSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1weXRob24ta2VybmVsLy4vbm9kZV9tb2R1bGVzL2NvbWxpbmsvZGlzdC9lc20vY29tbGluay5tanM/Mjc5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBwcm94eU1hcmtlciA9IFN5bWJvbChcIkNvbWxpbmsucHJveHlcIik7XG5jb25zdCBjcmVhdGVFbmRwb2ludCA9IFN5bWJvbChcIkNvbWxpbmsuZW5kcG9pbnRcIik7XG5jb25zdCByZWxlYXNlUHJveHkgPSBTeW1ib2woXCJDb21saW5rLnJlbGVhc2VQcm94eVwiKTtcbmNvbnN0IGZpbmFsaXplciA9IFN5bWJvbChcIkNvbWxpbmsuZmluYWxpemVyXCIpO1xuY29uc3QgdGhyb3dNYXJrZXIgPSBTeW1ib2woXCJDb21saW5rLnRocm93blwiKTtcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsKSB8fCB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCI7XG4vKipcbiAqIEludGVybmFsIHRyYW5zZmVyIGhhbmRsZSB0byBoYW5kbGUgb2JqZWN0cyBtYXJrZWQgdG8gcHJveHkuXG4gKi9cbmNvbnN0IHByb3h5VHJhbnNmZXJIYW5kbGVyID0ge1xuICAgIGNhbkhhbmRsZTogKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiB2YWxbcHJveHlNYXJrZXJdLFxuICAgIHNlcmlhbGl6ZShvYmopIHtcbiAgICAgICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBleHBvc2Uob2JqLCBwb3J0MSk7XG4gICAgICAgIHJldHVybiBbcG9ydDIsIFtwb3J0Ml1dO1xuICAgIH0sXG4gICAgZGVzZXJpYWxpemUocG9ydCkge1xuICAgICAgICBwb3J0LnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB3cmFwKHBvcnQpO1xuICAgIH0sXG59O1xuLyoqXG4gKiBJbnRlcm5hbCB0cmFuc2ZlciBoYW5kbGVyIHRvIGhhbmRsZSB0aHJvd24gZXhjZXB0aW9ucy5cbiAqL1xuY29uc3QgdGhyb3dUcmFuc2ZlckhhbmRsZXIgPSB7XG4gICAgY2FuSGFuZGxlOiAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiB0aHJvd01hcmtlciBpbiB2YWx1ZSxcbiAgICBzZXJpYWxpemUoeyB2YWx1ZSB9KSB7XG4gICAgICAgIGxldCBzZXJpYWxpemVkO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgc2VyaWFsaXplZCA9IHtcbiAgICAgICAgICAgICAgICBpc0Vycm9yOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHZhbHVlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiB2YWx1ZS5zdGFjayxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSB7IGlzRXJyb3I6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc2VyaWFsaXplZCwgW11dO1xuICAgIH0sXG4gICAgZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgICAgICBpZiAoc2VyaWFsaXplZC5pc0Vycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihzZXJpYWxpemVkLnZhbHVlLm1lc3NhZ2UpLCBzZXJpYWxpemVkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBzZXJpYWxpemVkLnZhbHVlO1xuICAgIH0sXG59O1xuLyoqXG4gKiBBbGxvd3MgY3VzdG9taXppbmcgdGhlIHNlcmlhbGl6YXRpb24gb2YgY2VydGFpbiB2YWx1ZXMuXG4gKi9cbmNvbnN0IHRyYW5zZmVySGFuZGxlcnMgPSBuZXcgTWFwKFtcbiAgICBbXCJwcm94eVwiLCBwcm94eVRyYW5zZmVySGFuZGxlcl0sXG4gICAgW1widGhyb3dcIiwgdGhyb3dUcmFuc2ZlckhhbmRsZXJdLFxuXSk7XG5mdW5jdGlvbiBpc0FsbG93ZWRPcmlnaW4oYWxsb3dlZE9yaWdpbnMsIG9yaWdpbikge1xuICAgIGZvciAoY29uc3QgYWxsb3dlZE9yaWdpbiBvZiBhbGxvd2VkT3JpZ2lucykge1xuICAgICAgICBpZiAob3JpZ2luID09PSBhbGxvd2VkT3JpZ2luIHx8IGFsbG93ZWRPcmlnaW4gPT09IFwiKlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dlZE9yaWdpbiBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBhbGxvd2VkT3JpZ2luLnRlc3Qob3JpZ2luKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXhwb3NlKG9iaiwgZXAgPSBnbG9iYWxUaGlzLCBhbGxvd2VkT3JpZ2lucyA9IFtcIipcIl0pIHtcbiAgICBlcC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBjYWxsYmFjayhldikge1xuICAgICAgICBpZiAoIWV2IHx8ICFldi5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FsbG93ZWRPcmlnaW4oYWxsb3dlZE9yaWdpbnMsIGV2Lm9yaWdpbikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBvcmlnaW4gJyR7ZXYub3JpZ2lufScgZm9yIGNvbWxpbmsgcHJveHlgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlkLCB0eXBlLCBwYXRoIH0gPSBPYmplY3QuYXNzaWduKHsgcGF0aDogW10gfSwgZXYuZGF0YSk7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50TGlzdCA9IChldi5kYXRhLmFyZ3VtZW50TGlzdCB8fCBbXSkubWFwKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICBsZXQgcmV0dXJuVmFsdWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLnNsaWNlKDAsIC0xKS5yZWR1Y2UoKG9iaiwgcHJvcCkgPT4gb2JqW3Byb3BdLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgcmF3VmFsdWUgPSBwYXRoLnJlZHVjZSgob2JqLCBwcm9wKSA9PiBvYmpbcHJvcF0sIG9iaik7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiR0VUXCIgLyogTWVzc2FnZVR5cGUuR0VUICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJhd1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJTRVRcIiAvKiBNZXNzYWdlVHlwZS5TRVQgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFtwYXRoLnNsaWNlKC0xKVswXV0gPSBmcm9tV2lyZVZhbHVlKGV2LmRhdGEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBUFBMWVwiIC8qIE1lc3NhZ2VUeXBlLkFQUExZICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJhd1ZhbHVlLmFwcGx5KHBhcmVudCwgYXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQ09OU1RSVUNUXCIgLyogTWVzc2FnZVR5cGUuQ09OU1RSVUNUICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyByYXdWYWx1ZSguLi5hcmd1bWVudExpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBwcm94eSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkVORFBPSU5UXCIgLyogTWVzc2FnZVR5cGUuRU5EUE9JTlQgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9zZShvYmosIHBvcnQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJhbnNmZXIocG9ydDEsIFtwb3J0MV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJSRUxFQVNFXCIgLyogTWVzc2FnZVR5cGUuUkVMRUFTRSAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKVxuICAgICAgICAgICAgLmNhdGNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIFt0aHJvd01hcmtlcl06IDAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXR1cm5WYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdpcmVWYWx1ZSksIHsgaWQgfSksIHRyYW5zZmVyYWJsZXMpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiUkVMRUFTRVwiIC8qIE1lc3NhZ2VUeXBlLlJFTEVBU0UgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBkZXRhY2ggYW5kIGRlYWN0aXZlIGFmdGVyIHNlbmRpbmcgcmVsZWFzZSByZXNwb25zZSBhYm92ZS5cbiAgICAgICAgICAgICAgICBlcC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgY2xvc2VFbmRQb2ludChlcCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsaXplciBpbiBvYmogJiYgdHlwZW9mIG9ialtmaW5hbGl6ZXJdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2ZpbmFsaXplcl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBTZW5kIFNlcmlhbGl6YXRpb24gRXJyb3IgVG8gQ2FsbGVyXG4gICAgICAgICAgICBjb25zdCBbd2lyZVZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IHRvV2lyZVZhbHVlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFR5cGVFcnJvcihcIlVuc2VyaWFsaXphYmxlIHJldHVybiB2YWx1ZVwiKSxcbiAgICAgICAgICAgICAgICBbdGhyb3dNYXJrZXJdOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdpcmVWYWx1ZSksIHsgaWQgfSksIHRyYW5zZmVyYWJsZXMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoZXAuc3RhcnQpIHtcbiAgICAgICAgZXAuc3RhcnQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc01lc3NhZ2VQb3J0KGVuZHBvaW50KSB7XG4gICAgcmV0dXJuIGVuZHBvaW50LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiTWVzc2FnZVBvcnRcIjtcbn1cbmZ1bmN0aW9uIGNsb3NlRW5kUG9pbnQoZW5kcG9pbnQpIHtcbiAgICBpZiAoaXNNZXNzYWdlUG9ydChlbmRwb2ludCkpXG4gICAgICAgIGVuZHBvaW50LmNsb3NlKCk7XG59XG5mdW5jdGlvbiB3cmFwKGVwLCB0YXJnZXQpIHtcbiAgICBjb25zdCBwZW5kaW5nTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIGVwLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXYpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBldjtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBwZW5kaW5nTGlzdGVuZXJzLmdldChkYXRhLmlkKTtcbiAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNvbHZlcihkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHBlbmRpbmdMaXN0ZW5lcnMuZGVsZXRlKGRhdGEuaWQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBbXSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUmVsZWFzZWQpIHtcbiAgICBpZiAoaXNSZWxlYXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm94eSBoYXMgYmVlbiByZWxlYXNlZCBhbmQgaXMgbm90IHVzZWFibGVcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVsZWFzZUVuZHBvaW50KGVwKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIG5ldyBNYXAoKSwge1xuICAgICAgICB0eXBlOiBcIlJFTEVBU0VcIiAvKiBNZXNzYWdlVHlwZS5SRUxFQVNFICovLFxuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBjbG9zZUVuZFBvaW50KGVwKTtcbiAgICB9KTtcbn1cbmNvbnN0IHByb3h5Q291bnRlciA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBwcm94eUZpbmFsaXplcnMgPSBcIkZpbmFsaXphdGlvblJlZ2lzdHJ5XCIgaW4gZ2xvYmFsVGhpcyAmJlxuICAgIG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoZXApID0+IHtcbiAgICAgICAgY29uc3QgbmV3Q291bnQgPSAocHJveHlDb3VudGVyLmdldChlcCkgfHwgMCkgLSAxO1xuICAgICAgICBwcm94eUNvdW50ZXIuc2V0KGVwLCBuZXdDb3VudCk7XG4gICAgICAgIGlmIChuZXdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmVsZWFzZUVuZHBvaW50KGVwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuZnVuY3Rpb24gcmVnaXN0ZXJQcm94eShwcm94eSwgZXApIHtcbiAgICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSArIDE7XG4gICAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpO1xuICAgIGlmIChwcm94eUZpbmFsaXplcnMpIHtcbiAgICAgICAgcHJveHlGaW5hbGl6ZXJzLnJlZ2lzdGVyKHByb3h5LCBlcCwgcHJveHkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJQcm94eShwcm94eSkge1xuICAgIGlmIChwcm94eUZpbmFsaXplcnMpIHtcbiAgICAgICAgcHJveHlGaW5hbGl6ZXJzLnVucmVnaXN0ZXIocHJveHkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBwYXRoID0gW10sIHRhcmdldCA9IGZ1bmN0aW9uICgpIHsgfSkge1xuICAgIGxldCBpc1Byb3h5UmVsZWFzZWQgPSBmYWxzZTtcbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIHtcbiAgICAgICAgZ2V0KF90YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gcmVsZWFzZVByb3h5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3RlclByb3h5KHByb3h5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZUVuZHBvaW50KGVwKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0xpc3RlbmVycy5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICBpc1Byb3h5UmVsZWFzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJ0aGVuXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGhlbjogKCkgPT4gcHJveHkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJHRVRcIiAvKiBNZXNzYWdlVHlwZS5HRVQgKi8sXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIudGhlbi5iaW5kKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBbLi4ucGF0aCwgcHJvcF0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoX3RhcmdldCwgcHJvcCwgcmF3VmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICAgICAgICAvLyBGSVhNRTogRVM2IFByb3h5IEhhbmRsZXIgYHNldGAgbWV0aG9kcyBhcmUgc3VwcG9zZWQgdG8gcmV0dXJuIGFcbiAgICAgICAgICAgIC8vIGJvb2xlYW4uIFRvIHNob3cgZ29vZCB3aWxsLCB3ZSByZXR1cm4gdHJ1ZSBhc3luY2hyb25vdXNseSDCr1xcXyjjg4QpXy/Cr1xuICAgICAgICAgICAgY29uc3QgW3ZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IHRvV2lyZVZhbHVlKHJhd1ZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJTRVRcIiAvKiBNZXNzYWdlVHlwZS5TRVQgKi8sXG4gICAgICAgICAgICAgICAgcGF0aDogWy4uLnBhdGgsIHByb3BdLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGx5KF90YXJnZXQsIF90aGlzQXJnLCByYXdBcmd1bWVudExpc3QpIHtcbiAgICAgICAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICAgICAgICBjb25zdCBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGxhc3QgPT09IGNyZWF0ZUVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJFTkRQT0lOVFwiIC8qIE1lc3NhZ2VUeXBlLkVORFBPSU5UICovLFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBqdXN0IHByZXRlbmQgdGhhdCBgYmluZCgpYCBkaWRu4oCZdCBoYXBwZW4uXG4gICAgICAgICAgICBpZiAobGFzdCA9PT0gXCJiaW5kXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJveHkoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFthcmd1bWVudExpc3QsIHRyYW5zZmVyYWJsZXNdID0gcHJvY2Vzc0FyZ3VtZW50cyhyYXdBcmd1bWVudExpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkFQUExZXCIgLyogTWVzc2FnZVR5cGUuQVBQTFkgKi8sXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgYXJndW1lbnRMaXN0LFxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uc3RydWN0KF90YXJnZXQsIHJhd0FyZ3VtZW50TGlzdCkge1xuICAgICAgICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgICAgICAgIGNvbnN0IFthcmd1bWVudExpc3QsIHRyYW5zZmVyYWJsZXNdID0gcHJvY2Vzc0FyZ3VtZW50cyhyYXdBcmd1bWVudExpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkNPTlNUUlVDVFwiIC8qIE1lc3NhZ2VUeXBlLkNPTlNUUlVDVCAqLyxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudExpc3QsXG4gICAgICAgICAgICB9LCB0cmFuc2ZlcmFibGVzKS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJlZ2lzdGVyUHJveHkocHJveHksIGVwKTtcbiAgICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiBteUZsYXQoYXJyKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycik7XG59XG5mdW5jdGlvbiBwcm9jZXNzQXJndW1lbnRzKGFyZ3VtZW50TGlzdCkge1xuICAgIGNvbnN0IHByb2Nlc3NlZCA9IGFyZ3VtZW50TGlzdC5tYXAodG9XaXJlVmFsdWUpO1xuICAgIHJldHVybiBbcHJvY2Vzc2VkLm1hcCgodikgPT4gdlswXSksIG15RmxhdChwcm9jZXNzZWQubWFwKCh2KSA9PiB2WzFdKSldO1xufVxuY29uc3QgdHJhbnNmZXJDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB0cmFuc2ZlcihvYmosIHRyYW5zZmVycykge1xuICAgIHRyYW5zZmVyQ2FjaGUuc2V0KG9iaiwgdHJhbnNmZXJzKTtcbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gcHJveHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCB7IFtwcm94eU1hcmtlcl06IHRydWUgfSk7XG59XG5mdW5jdGlvbiB3aW5kb3dFbmRwb2ludCh3LCBjb250ZXh0ID0gZ2xvYmFsVGhpcywgdGFyZ2V0T3JpZ2luID0gXCIqXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3N0TWVzc2FnZTogKG1zZywgdHJhbnNmZXJhYmxlcykgPT4gdy5wb3N0TWVzc2FnZShtc2csIHRhcmdldE9yaWdpbiwgdHJhbnNmZXJhYmxlcyksXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGNvbnRleHQuYWRkRXZlbnRMaXN0ZW5lci5iaW5kKGNvbnRleHQpLFxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBjb250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZChjb250ZXh0KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9XaXJlVmFsdWUodmFsdWUpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBoYW5kbGVyXSBvZiB0cmFuc2ZlckhhbmRsZXJzKSB7XG4gICAgICAgIGlmIChoYW5kbGVyLmNhbkhhbmRsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtzZXJpYWxpemVkVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gaGFuZGxlci5zZXJpYWxpemUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiSEFORExFUlwiIC8qIFdpcmVWYWx1ZVR5cGUuSEFORExFUiAqLyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNlcmlhbGl6ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUkFXXCIgLyogV2lyZVZhbHVlVHlwZS5SQVcgKi8sXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmZXJDYWNoZS5nZXQodmFsdWUpIHx8IFtdLFxuICAgIF07XG59XG5mdW5jdGlvbiBmcm9tV2lyZVZhbHVlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJIQU5ETEVSXCIgLyogV2lyZVZhbHVlVHlwZS5IQU5ETEVSICovOlxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZmVySGFuZGxlcnMuZ2V0KHZhbHVlLm5hbWUpLmRlc2VyaWFsaXplKHZhbHVlLnZhbHVlKTtcbiAgICAgICAgY2FzZSBcIlJBV1wiIC8qIFdpcmVWYWx1ZVR5cGUuUkFXICovOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHBlbmRpbmdMaXN0ZW5lcnMsIG1zZywgdHJhbnNmZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVVVUlEKCk7XG4gICAgICAgIHBlbmRpbmdMaXN0ZW5lcnMuc2V0KGlkLCByZXNvbHZlKTtcbiAgICAgICAgaWYgKGVwLnN0YXJ0KSB7XG4gICAgICAgICAgICBlcC5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGVwLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oeyBpZCB9LCBtc2cpLCB0cmFuc2ZlcnMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuICAgIHJldHVybiBuZXcgQXJyYXkoNClcbiAgICAgICAgLmZpbGwoMClcbiAgICAgICAgLm1hcCgoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikudG9TdHJpbmcoMTYpKVxuICAgICAgICAuam9pbihcIi1cIik7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUVuZHBvaW50LCBleHBvc2UsIGZpbmFsaXplciwgcHJveHksIHByb3h5TWFya2VyLCByZWxlYXNlUHJveHksIHRyYW5zZmVyLCB0cmFuc2ZlckhhbmRsZXJzLCB3aW5kb3dFbmRwb2ludCwgd3JhcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbGluay5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/comlink/dist/esm/comlink.mjs\n\n}");

/***/ }),

/***/ "./src/_pypi.ts":
/*!**********************!*\
  !*** ./src/_pypi.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allJSONUrl: () => (/* binding */ allJSONUrl),\n/* harmony export */   ipykernelWheelUrl: () => (/* binding */ ipykernelWheelUrl),\n/* harmony export */   pipliteWheelUrl: () => (/* binding */ pipliteWheelUrl),\n/* harmony export */   pyodide_kernelWheelUrl: () => (/* binding */ pyodide_kernelWheelUrl),\n/* harmony export */   widgetsnbextensionWheelUrl: () => (/* binding */ widgetsnbextensionWheelUrl),\n/* harmony export */   widgetsnbextensionWheelUrl1: () => (/* binding */ widgetsnbextensionWheelUrl1)\n/* harmony export */ });\n// this file is autogenerated from the wheels in the pypi directory\nconst allJSONUrl = \"pypi/all.json\";\nconst ipykernelWheelUrl = \"pypi/ipykernel-6.9.2-py3-none-any.whl\";\nconst pipliteWheelUrl = \"pypi/piplite-0.6.0a5-py3-none-any.whl\";\nconst pyodide_kernelWheelUrl = \"pypi/pyodide_kernel-0.6.0a5-py3-none-any.whl\";\nconst widgetsnbextensionWheelUrl = \"pypi/widgetsnbextension-3.6.999-py3-none-any.whl\";\nconst widgetsnbextensionWheelUrl1 = \"pypi/widgetsnbextension-4.0.999-py3-none-any.whl\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvX3B5cGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxtRUFBbUU7QUFDNUQsTUFBTSxVQUFVLEdBQUcsZUFBZSxDQUFDO0FBQ25DLE1BQU0saUJBQWlCLEdBQUcsdUNBQXVDLENBQUM7QUFDbEUsTUFBTSxlQUFlLEdBQUcsdUNBQXVDLENBQUM7QUFDaEUsTUFBTSxzQkFBc0IsR0FBRyw4Q0FBOEMsQ0FBQztBQUM5RSxNQUFNLDBCQUEwQixHQUFHLGtEQUFrRCxDQUFDO0FBQ3RGLE1BQU0sMkJBQTJCLEdBQUcsa0RBQWtELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItcHl0aG9uLWtlcm5lbC8uL3NyYy9fcHlwaS50cz9lODZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRoaXMgZmlsZSBpcyBhdXRvZ2VuZXJhdGVkIGZyb20gdGhlIHdoZWVscyBpbiB0aGUgcHlwaSBkaXJlY3RvcnlcbmV4cG9ydCBjb25zdCBhbGxKU09OVXJsID0gXCJweXBpL2FsbC5qc29uXCI7XG5leHBvcnQgY29uc3QgaXB5a2VybmVsV2hlZWxVcmwgPSBcInB5cGkvaXB5a2VybmVsLTYuOS4yLXB5My1ub25lLWFueS53aGxcIjtcbmV4cG9ydCBjb25zdCBwaXBsaXRlV2hlZWxVcmwgPSBcInB5cGkvcGlwbGl0ZS0wLjYuMGE1LXB5My1ub25lLWFueS53aGxcIjtcbmV4cG9ydCBjb25zdCBweW9kaWRlX2tlcm5lbFdoZWVsVXJsID0gXCJweXBpL3B5b2RpZGVfa2VybmVsLTAuNi4wYTUtcHkzLW5vbmUtYW55LndobFwiO1xuZXhwb3J0IGNvbnN0IHdpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsID0gXCJweXBpL3dpZGdldHNuYmV4dGVuc2lvbi0zLjYuOTk5LXB5My1ub25lLWFueS53aGxcIjtcbmV4cG9ydCBjb25zdCB3aWRnZXRzbmJleHRlbnNpb25XaGVlbFVybDEgPSBcInB5cGkvd2lkZ2V0c25iZXh0ZW5zaW9uLTQuMC45OTktcHkzLW5vbmUtYW55LndobFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/_pypi.ts\n\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Kernel: () => (/* binding */ Kernel)\n/* harmony export */ });\n/* harmony import */ var _pyodide_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pyodide-loader */ \"./src/pyodide-loader.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _pypi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_pypi */ \"./src/_pypi.ts\");\n/* harmony import */ var _manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./manager */ \"./src/manager.ts\");\n// Kernel implementation for Deno using Pyodide directly\n// Based on the PyodideRemoteKernel but adapted for direct execution in main thread\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    }\n    off(eventName, listener) {\n        if (!this.events[eventName])\n            return;\n        const index = this.events[eventName].indexOf(listener);\n        if (index > -1) {\n            this.events[eventName].splice(index, 1);\n        }\n    }\n    emit(eventName, ...args) {\n        if (!this.events[eventName])\n            return;\n        this.events[eventName].forEach(listener => listener(...args));\n    }\n    setMaxListeners(n) {\n        // No-op for browser compatibility\n    }\n}\n// @ts-ignore Importing from npm\n\n// Import types and enums\n\n// Import PyPI URLs\n\n// Event types from JupyterLab\n// Re-export types to maintain backward compatibility\n\n\nclass Kernel extends EventEmitter {\n    constructor() {\n        super();\n        this.initialized = false;\n        this.initPromise = null;\n        // FileSystem options\n        this.filesystemOptions = {\n            enabled: false,\n            root: \".\",\n            mountPoint: \"/home/pyodide\"\n        };\n        // Input handling\n        this._resolveInputReply = null;\n        // Execution state\n        this._parent_header = {};\n        this.executionCount = 0;\n        this._status = \"unknown\";\n        // Interrupt handling\n        this._interruptBuffer = null;\n        this._interruptSupported = false;\n        // Environment variables\n        this.environmentVariables = {};\n        // Native filesystem handles\n        this.nativeFsHandles = new Map();\n        this.autoSyncFs = false;\n        super.setMaxListeners(20);\n        // Generate a unique ID for this kernel instance\n        this.kernelId = `kernel_${Math.random().toString(36).substring(2)}_${Date.now()}`;\n    }\n    // Async method for kernel status\n    async getStatus() {\n        return this._status;\n    }\n    /**\n     * Initialize the kernel with maximum performance optimizations\n     * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n     */\n    async initialize(options) {\n        if (this.initialized) {\n            return;\n        }\n        if (this.initPromise) {\n            return this.initPromise;\n        }\n        // Set filesystem options if provided\n        if (options?.filesystem) {\n            this.filesystemOptions = {\n                ...this.filesystemOptions,\n                ...options.filesystem\n            };\n        }\n        // Set environment variables if provided\n        if (options?.env) {\n            this.environmentVariables = { ...options.env };\n        }\n        // Set lockFileURL if provided\n        if (options?.lockFileURL) {\n            this.lockFileURL = options.lockFileURL;\n        }\n        // Set autoSyncFs if provided\n        if (options?.autoSyncFs !== undefined) {\n            this.autoSyncFs = options.autoSyncFs;\n        }\n        this.initPromise = this._initializeInternal();\n        return this.initPromise;\n    }\n    /**\n     * Initialize the kernel with maximum performance optimizations\n     * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n     */\n    async _initializeInternal() {\n        const startTime = Date.now();\n        console.log(\"ðŸš€ Starting optimized kernel initialization...\");\n        try {\n            // Load Pyodide from CDN\n            const pyodideStartTime = Date.now();\n            // Configure pyodide options\n            const pyodideConfig = {};\n            if (this.lockFileURL) {\n                pyodideConfig.lockFileURL = this.lockFileURL;\n                console.log(`ðŸ”’ Using lockFileURL: ${this.lockFileURL}`);\n            }\n            // Use our CDN loader - it will automatically handle main thread vs worker\n            this.pyodide = await (0,_pyodide_loader__WEBPACK_IMPORTED_MODULE_0__.loadPyodide)(pyodideConfig);\n            const pyodideTime = Date.now() - pyodideStartTime;\n            console.log(`âœ… Pyodide loaded in ${pyodideTime}ms`);\n            // Initialize core components in parallel\n            if (this.lockFileURL) {\n                // When using lockFileURL, packages are pre-installed, skip package installation\n                console.log(\"ðŸš€ Using lock file - skipping package installation\");\n                const [,] = await Promise.all([\n                    // 1. FileSystem mounting (if enabled)\n                    this.filesystemOptions.enabled ? this.mountFileSystem() : Promise.resolve(),\n                    // 2. Environment variables setup\n                    this.setEnvironmentVariables()\n                ]);\n                // Initialize globals directly (packages are already available)\n                await this.initGlobals();\n            }\n            else {\n                // Standard initialization with package installation\n                const [, ,] = await Promise.all([\n                    // 1. FileSystem mounting (if enabled)\n                    this.filesystemOptions.enabled ? this.mountFileSystem() : Promise.resolve(),\n                    // 2. Package manager initialization\n                    this.initPackageManager(),\n                    // 3. Environment variables setup\n                    this.setEnvironmentVariables()\n                ]);\n                // Install packages and initialize globals\n                await this.initKernel();\n                await this.initGlobals();\n            }\n            const totalTime = Date.now() - startTime;\n            console.log(`ðŸŽ¯ KERNEL INITIALIZATION COMPLETE in ${totalTime}ms`);\n            console.log(`âš¡ Performance: Pyodide(${pyodideTime}ms) + Setup(${totalTime - pyodideTime}ms)`);\n            // Mark as initialized\n            this.initialized = true;\n            this._status = \"active\";\n            console.log(\"ðŸŸ¢ Kernel is now ACTIVE and ready for execution!\");\n        }\n        catch (error) {\n            console.error(\"âŒ Kernel initialization failed:\", error);\n            this._status = \"unknown\";\n            throw error;\n        }\n    }\n    /**\n     * Mount the local filesystem to the Pyodide environment\n     */\n    async mountFileSystem() {\n        try {\n            console.log(`Mounting filesystem from ${this.filesystemOptions.root} to ${this.filesystemOptions.mountPoint}`);\n            // Use the same approach as in deno-demo-fs-asgi.js for maximum compatibility\n            // Simple and direct mounting of the filesystem\n            await this.pyodide.FS.mount(this.pyodide.FS.filesystems.NODEFS, { root: this.filesystemOptions.root || \".\" }, this.filesystemOptions.mountPoint || \"/home/pyodide\");\n            console.log(\"FileSystem mounted successfully\");\n            // Verify the mount by listing the directory\n            try {\n                const mountedFiles = this.pyodide.FS.readdir(this.filesystemOptions.mountPoint || \"/home/pyodide\");\n                console.log(`Files in ${this.filesystemOptions.mountPoint} directory: ${mountedFiles.join(\", \")}`);\n            }\n            catch (error) {\n                console.error(`Error listing mounted directory: ${error}`);\n            }\n        }\n        catch (error) {\n            console.error(\"Error mounting filesystem:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Initialize the Pyodide package manager with optimized wheel loading\n     * OPTIMIZED: Smart caching and parallel wheel installation\n     */\n    async initPackageManager() {\n        const startTime = Date.now();\n        console.log(\"âš¡ Initializing optimized package manager...\");\n        try {\n            // Load micropip and packaging in parallel\n            console.log(\"ðŸ“¦ Loading micropip, packaging...\");\n            await this.pyodide.loadPackage(['micropip', 'packaging']);\n            console.log(\"âœ… Loaded micropip, packaging\");\n            // Get the base URL - use window.location for browser or fallback for worker\n            let baseUrl;\n            if (typeof window !== 'undefined' && window.location) {\n                // In main thread - use window.location\n                baseUrl = new URL(\".\", window.location.href).href;\n            }\n            else if (typeof self !== 'undefined' && self.location) {\n                // In web worker - use self.location\n                baseUrl = new URL(\".\", self.location.href).href;\n            }\n            else {\n                // Fallback - assume current origin\n                baseUrl = \"/\";\n            }\n            const allJsonPath = new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.allJSONUrl, baseUrl).href;\n            // Prepare all wheel URLs for parallel loading\n            const wheelFiles = [\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.pipliteWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.pyodide_kernelWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.ipykernelWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.widgetsnbextensionWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.widgetsnbextensionWheelUrl1, baseUrl).href,\n            ];\n            console.log(`ðŸš€ Installing ${wheelFiles.length} wheel packages in parallel...`);\n            // Install all wheel packages in parallel for maximum speed\n            const wheelPromises = wheelFiles.map(async (wheelUrl, index) => {\n                const wheelStartTime = Date.now();\n                try {\n                    await this.pyodide.runPythonAsync(`\nimport micropip\nawait micropip.install('${wheelUrl}', keep_going=True)\nprint(f\"âœ… Wheel ${index + 1}/${wheelFiles.length} installed\")\n`);\n                    const wheelTime = Date.now() - wheelStartTime;\n                    console.log(`âš¡ Wheel ${index + 1} installed in ${wheelTime}ms`);\n                    return { index, success: true, time: wheelTime };\n                }\n                catch (error) {\n                    const wheelTime = Date.now() - wheelStartTime;\n                    console.warn(`âš ï¸ Wheel ${index + 1} failed after ${wheelTime}ms:`, error);\n                    return { index, success: false, time: wheelTime, error };\n                }\n            });\n            // Wait for all wheel installations\n            const wheelResults = await Promise.all(wheelPromises);\n            const successful = wheelResults.filter(r => r.success);\n            const failed = wheelResults.filter(r => !r.success);\n            console.log(`ðŸ“Š Wheels: ${successful.length}/${wheelFiles.length} successful`);\n            if (failed.length > 0) {\n                console.warn(`âš ï¸ Failed wheels: ${failed.map(f => f.index + 1).join(', ')}`);\n            }\n            // Set up piplite configuration with performance optimizations (if available)\n            try {\n                await this.pyodide.runPythonAsync(`\ntry:\n    import piplite.piplite\n    import json\n\n    # Load package index for faster lookups\n    try:\n        piplite.piplite.PIPLITE_URL = \"${allJsonPath}\"\n        # Pre-load package index for faster installation\n        print(\"ðŸ“‹ Package index configured\")\n    except Exception as e:\n        print(f\"âš ï¸ Package index setup warning: {e}\")\n\n    # Configure piplite for optimal performance\n    piplite.piplite.REPODATA_INFO = {}\n    print(\"âš¡ Piplite optimized for performance\")\nexcept ImportError:\n    print(\"âš ï¸ Piplite not available, continuing without it\")\nexcept Exception as e:\n    print(f\"âš ï¸ Piplite setup failed: {e}\")\n`);\n            }\n            catch (error) {\n                console.warn(\"âš ï¸ Piplite configuration failed, continuing without it:\", error);\n            }\n            const totalTime = Date.now() - startTime;\n            console.log(`ðŸŽ¯ Package manager initialized in ${totalTime}ms`);\n        }\n        catch (error) {\n            console.error(\"âŒ Package manager initialization failed:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Initialize the kernel with required Python packages\n     * OPTIMIZED: Maximum parallelization with intelligent dependency resolution\n     */\n    async initKernel() {\n        const startTime = Date.now();\n        console.log(\"ðŸš€ Initializing kernel packages with maximum optimization...\");\n        // All packages to install with priority and dependency information\n        const packageConfig = [\n            // High priority: CDN packages (fastest)\n            { name: 'pure-eval', priority: 1, source: 'pyodide' },\n            { name: 'stack-data', priority: 1, source: 'pyodide' },\n            { name: 'pygments', priority: 1, source: 'pyodide' },\n            { name: 'ssl', priority: 1, source: 'pyodide' },\n            { name: 'sqlite3', priority: 1, source: 'pyodide' },\n            { name: 'prompt_toolkit', priority: 1, source: 'pyodide' },\n            { name: 'jedi', priority: 1, source: 'pyodide' },\n            { name: 'ipython', priority: 1, source: 'pyodide' },\n            // Medium priority: pip packages\n            { name: 'comm', priority: 2, source: 'pip' },\n            { name: 'hypha-rpc', priority: 2, source: 'pip' },\n            { name: 'nbformat', priority: 2, source: 'pip' },\n            // Lower priority: complex packages\n            { name: 'ipykernel', priority: 3, source: 'pip' },\n            { name: 'pyodide_kernel', priority: 3, source: 'pip' }\n        ];\n        try {\n            console.log(`ðŸ“¦ Installing ${packageConfig.length} packages with intelligent optimization...`);\n            // Install ALL packages in parallel with advanced error handling and caching\n            await this.installPackagesWithIntelligentOptimization(packageConfig);\n            // Import the kernel (must be done after packages are installed)\n            console.log(\"ðŸ“¥ Importing pyodide_kernel...\");\n            const importStartTime = Date.now();\n            await this.pyodide.runPythonAsync('import pyodide_kernel');\n            const importTime = Date.now() - importStartTime;\n            console.log(`âœ… pyodide_kernel imported in ${importTime}ms`);\n            const totalTime = Date.now() - startTime;\n            console.log(`ðŸŽ¯ Kernel packages initialized in ${totalTime}ms`);\n        }\n        catch (error) {\n            console.error(\"âŒ Kernel package initialization failed:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Install packages with intelligent optimization and advanced caching\n     * OPTIMIZED: Smart source selection, parallel installation, and performance monitoring\n     */\n    async installPackagesWithIntelligentOptimization(packageConfig) {\n        console.log(`âš¡ Starting intelligent parallel installation of ${packageConfig.length} packages...`);\n        const installPromises = packageConfig.map(async (pkg) => {\n            const startTime = Date.now();\n            try {\n                console.log(`ðŸ”„ Installing ${pkg.name} (priority: ${pkg.priority}, preferred: ${pkg.source})...`);\n                // Try preferred source first, with intelligent fallback\n                if (pkg.source === 'pyodide') {\n                    try {\n                        await this.pyodide.loadPackage([pkg.name]);\n                        const duration = Date.now() - startTime;\n                        console.log(`âœ… ${pkg.name} loaded from Pyodide CDN (${duration}ms)`);\n                        return { package: pkg.name, method: 'pyodide', duration, success: true, priority: pkg.priority };\n                    }\n                    catch (pyodideError) {\n                        // Fallback to pip with enhanced error handling\n                        console.log(`ðŸ“¦ ${pkg.name} not available on CDN, trying pip...`);\n                        await this.installViaPipWithOptimizations(pkg.name);\n                        const duration = Date.now() - startTime;\n                        console.log(`âœ… ${pkg.name} installed via pip fallback (${duration}ms)`);\n                        return { package: pkg.name, method: 'pip-fallback', duration, success: true, priority: pkg.priority };\n                    }\n                }\n                else {\n                    // Direct pip installation with optimizations\n                    await this.installViaPipWithOptimizations(pkg.name);\n                    const duration = Date.now() - startTime;\n                    console.log(`âœ… ${pkg.name} installed via pip (${duration}ms)`);\n                    return { package: pkg.name, method: 'pip', duration, success: true, priority: pkg.priority };\n                }\n            }\n            catch (error) {\n                const duration = Date.now() - startTime;\n                console.warn(`âŒ Failed to install ${pkg.name} after ${duration}ms:`, error);\n                return { package: pkg.name, method: 'failed', duration, success: false, priority: pkg.priority, error };\n            }\n        });\n        // Wait for all installations with detailed analysis\n        const results = await Promise.all(installPromises);\n        // Comprehensive performance analysis\n        this.analyzeInstallationResults(results);\n    }\n    /**\n     * Install package via pip with performance optimizations\n     */\n    async installViaPipWithOptimizations(packageName) {\n        await this.pyodide.runPythonAsync(`\ntry:\n    # Import piplite first\n    import piplite\n    # Use optimized pip installation with caching\n    await piplite.install('${packageName}', keep_going=True, deps=True)\n    print(\"âœ… Successfully installed ${packageName} via optimized pip\")\nexcept Exception as e:\n    print(\"âš ï¸ Warning: Failed to install ${packageName}:\", str(e))\n    # Try alternative installation method\n    try:\n        import micropip\n        await micropip.install('${packageName}', keep_going=True)\n        print(\"âœ… Successfully installed ${packageName} via micropip fallback\")\n    except Exception as e2:\n        print(\"âŒ Both pip methods failed for ${packageName}:\", str(e2))\n        raise e2\n`);\n    }\n    /**\n     * Analyze installation results and provide performance insights\n     */\n    analyzeInstallationResults(results) {\n        const successful = results.filter(r => r.success);\n        const failed = results.filter(r => !r.success);\n        const pyodideInstalls = successful.filter(r => r.method === 'pyodide');\n        const pipInstalls = successful.filter(r => r.method === 'pip');\n        const fallbackInstalls = successful.filter(r => r.method === 'pip-fallback');\n        const totalDuration = Math.max(...results.map(r => r.duration));\n        const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;\n        const estimatedSequential = results.reduce((sum, r) => sum + r.duration, 0);\n        console.log(`ðŸŽ¯ INTELLIGENT INSTALLATION COMPLETE!`);\n        console.log(`ðŸ“Š Results: ${successful.length}/${results.length} successful`);\n        console.log(`âš¡ Pyodide CDN: ${pyodideInstalls.length} packages`);\n        console.log(`ðŸ“¦ Direct pip: ${pipInstalls.length} packages`);\n        console.log(`ðŸ”„ Pip fallback: ${fallbackInstalls.length} packages`);\n        console.log(`âŒ Failed: ${failed.length} packages`);\n        console.log(`â±ï¸  Total time: ${totalDuration}ms (vs ~${estimatedSequential}ms sequential)`);\n        console.log(`ðŸš€ Speed improvement: ~${Math.round(estimatedSequential / totalDuration)}x faster`);\n        console.log(`ðŸ“ˆ Average per package: ${Math.round(avgDuration)}ms`);\n        if (failed.length > 0) {\n            console.warn(`âš ï¸  Failed packages: ${failed.map(f => f.package).join(', ')}`);\n            // Log specific failure reasons for debugging\n            failed.forEach(f => {\n                console.warn(`   - ${f.package}: ${f.error?.message || 'Unknown error'}`);\n            });\n        }\n        // Performance insights\n        const fastestInstall = Math.min(...successful.map(r => r.duration));\n        const slowestInstall = Math.max(...successful.map(r => r.duration));\n        console.log(`ðŸ“Š Performance range: ${fastestInstall}ms (fastest) to ${slowestInstall}ms (slowest)`);\n    }\n    /**\n     * Initialize global objects from the pyodide_kernel package\n     * Based on the PyodideRemoteKernel implementation\n     */\n    async initGlobals() {\n        console.log(\"Initializing globals...\");\n        // Get the globals from the Python environment\n        const { globals } = this.pyodide;\n        // Get the kernel instance and related objects\n        this._kernel = globals.get('pyodide_kernel').kernel_instance.copy();\n        this._stdout_stream = globals.get('pyodide_kernel').stdout_stream.copy();\n        this._stderr_stream = globals.get('pyodide_kernel').stderr_stream.copy();\n        this._interpreter = this._kernel.interpreter.copy();\n        // Set up communication handlers\n        this._interpreter.send_comm = this.sendComm.bind(this);\n        // Set up callbacks\n        this.setupCallbacks();\n    }\n    /**\n     * Setup all necessary callbacks for the Python environment\n     */\n    setupCallbacks() {\n        // Execution result callback\n        const publishExecutionResult = (prompt_count, data, metadata) => {\n            const bundle = {\n                execution_count: prompt_count,\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'execute_result',\n            });\n        };\n        // Error callback\n        const publishExecutionError = (ename, evalue, traceback) => {\n            const bundle = {\n                ename: ename,\n                evalue: evalue,\n                traceback: traceback,\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'execute_error',\n            });\n        };\n        // Clear output callback\n        const clearOutputCallback = (wait) => {\n            const bundle = {\n                wait: this.formatResult(wait),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'clear_output',\n            });\n        };\n        // Display data callback\n        const displayDataCallback = (data, metadata, transient) => {\n            const bundle = {\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n                transient: this.formatResult(transient),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'display_data',\n            });\n        };\n        // Update display data callback\n        const updateDisplayDataCallback = (data, metadata, transient) => {\n            const bundle = {\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n                transient: this.formatResult(transient),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'update_display_data',\n            });\n        };\n        // Stream callback\n        const publishStreamCallback = (name, text) => {\n            const bundle = {\n                name: this.formatResult(name),\n                text: this.formatResult(text),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'stream',\n            });\n        };\n        // Assign callbacks to the Python objects\n        this._stdout_stream.publish_stream_callback = publishStreamCallback;\n        this._stderr_stream.publish_stream_callback = publishStreamCallback;\n        this._interpreter.display_pub.clear_output_callback = clearOutputCallback;\n        this._interpreter.display_pub.display_data_callback = displayDataCallback;\n        this._interpreter.display_pub.update_display_data_callback = updateDisplayDataCallback;\n        this._interpreter.displayhook.publish_execution_result = publishExecutionResult;\n        this._interpreter.input = this.input.bind(this);\n        this._interpreter.getpass = this.getpass.bind(this);\n    }\n    /**\n     * Process a message from Python environment\n     */\n    _sendMessage(msg) {\n        this._processMessage(msg);\n    }\n    /**\n     * Process a message by emitting the appropriate event\n     */\n    _processMessage(msg) {\n        if (!msg.type) {\n            return;\n        }\n        let eventData;\n        switch (msg.type) {\n            case 'stream': {\n                const bundle = msg.bundle ?? { name: 'stdout', text: '' };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.STREAM, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'input_request': {\n                const content = msg.content ?? { prompt: '', password: false };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.INPUT_REQUEST, content);\n                eventData = content;\n                break;\n            }\n            case 'display_data': {\n                const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.DISPLAY_DATA, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'update_display_data': {\n                const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.UPDATE_DISPLAY_DATA, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'clear_output': {\n                const bundle = msg.bundle ?? { wait: false };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.CLEAR_OUTPUT, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'execute_result': {\n                const bundle = msg.bundle ?? {\n                    execution_count: this.executionCount,\n                    data: {},\n                    metadata: {},\n                };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_RESULT, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'execute_error': {\n                const bundle = msg.bundle ?? { ename: '', evalue: '', traceback: [] };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'comm_open':\n            case 'comm_msg':\n            case 'comm_close': {\n                const content = msg.content ?? {};\n                super.emit(msg.type, content, msg.metadata, msg.buffers);\n                eventData = {\n                    content,\n                    metadata: msg.metadata,\n                    buffers: msg.buffers\n                };\n                break;\n            }\n        }\n        // Emit the ALL event with standardized format\n        if (eventData) {\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, {\n                type: msg.type,\n                data: eventData\n            });\n        }\n    }\n    /**\n     * Check if the kernel has been initialized\n     */\n    isInitialized() {\n        return this.initialized;\n    }\n    /**\n     * Makes sure pyodide is ready before continuing, and cache the parent message.\n     */\n    async setup(parent) {\n        await this.initialize();\n        this._parent_header = this.pyodide.toPy(parent || {});\n    }\n    /**\n     * Execute code in the kernel with proper message-based completion detection\n     *\n     * @param code The code to execute\n     * @param parent Parent message header\n     * @returns The result of the execution\n     */\n    async execute(code, parent = {}) {\n        // Simple implementation that collects all outputs from executeStream\n        const outputs = [];\n        try {\n            // Use executeStream to get all outputs\n            for await (const output of this.executeStream(code, parent)) {\n                outputs.push(output);\n            }\n            // Process collected outputs to create a comprehensive result\n            const result = {\n                outputs: [],\n                data: {},\n                metadata: {},\n                execution_count: this.executionCount\n            };\n            // Collect all output types\n            for (const output of outputs) {\n                if (output.type === 'stream') {\n                    // Collect stdout/stderr\n                    if (!result.stdout)\n                        result.stdout = '';\n                    if (!result.stderr)\n                        result.stderr = '';\n                    if (output.data.name === 'stdout') {\n                        result.stdout += output.data.text;\n                    }\n                    else if (output.data.name === 'stderr') {\n                        result.stderr += output.data.text;\n                    }\n                    result.outputs.push(output.data);\n                }\n                else if (output.type === 'display_data' || output.type === 'execute_result') {\n                    // Collect display data\n                    if (output.data.data) {\n                        Object.assign(result.data, output.data.data);\n                    }\n                    if (output.data.metadata) {\n                        Object.assign(result.metadata, output.data.metadata);\n                    }\n                    result.outputs.push(output.data);\n                }\n                else if (output.type === 'execute_error' || output.type === 'error') {\n                    // Handle errors\n                    const errorData = output.data;\n                    return {\n                        success: false,\n                        error: new Error(`${errorData.ename}: ${errorData.evalue}`),\n                        ename: errorData.ename,\n                        evalue: errorData.evalue,\n                        traceback: errorData.traceback,\n                        outputs: result.outputs\n                    };\n                }\n                else {\n                    // Store any other output type\n                    result.outputs.push(output);\n                }\n            }\n            // Return collected results\n            result.success = true;\n            // Auto-sync native filesystems if enabled\n            if (this.autoSyncFs) {\n                await this.syncAllNativeFs();\n            }\n            return result;\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Execute error:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    /**\n     * Format the result from the Pyodide evaluation\n     * Based on PyodideRemoteKernel implementation\n     */\n    formatResult(res) {\n        if (!(res instanceof this.pyodide.ffi.PyProxy)) {\n            return res;\n        }\n        try {\n            // Convert PyProxy to JS\n            const m = res.toJs();\n            const results = this.mapToObject(m);\n            return results;\n        }\n        catch (error) {\n            console.error(\"Error formatting result:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    }\n    /**\n     * Convert a Map to a JavaScript object recursively\n     * Based on PyodideRemoteKernel implementation\n     */\n    mapToObject(obj) {\n        const out = obj instanceof Array ? [] : {};\n        obj.forEach((value, key) => {\n            out[key] =\n                value instanceof Map || value instanceof Array\n                    ? this.mapToObject(value)\n                    : value;\n        });\n        return out;\n    }\n    /**\n     * Handle input reply from user\n     */\n    async inputReply(content) {\n        if (this._resolveInputReply) {\n            this._resolveInputReply(content);\n            this._resolveInputReply = null;\n        }\n    }\n    /**\n     * Send a input request to the front-end.\n     */\n    async sendInputRequest(prompt, password) {\n        const content = {\n            prompt,\n            password,\n        };\n        this._sendMessage({\n            type: 'input_request',\n            content,\n            parentHeader: this.formatResult(this._parent_header)['header']\n        });\n    }\n    /**\n     * Get password input (with hidden input)\n     */\n    async getpass(prompt) {\n        prompt = typeof prompt === 'undefined' ? '' : prompt;\n        await this.sendInputRequest(prompt, true);\n        const replyPromise = new Promise((resolve) => {\n            this._resolveInputReply = resolve;\n        });\n        const result = await replyPromise;\n        return result.value;\n    }\n    /**\n     * Get text input\n     */\n    async input(prompt) {\n        prompt = typeof prompt === 'undefined' ? '' : prompt;\n        await this.sendInputRequest(prompt, false);\n        const replyPromise = new Promise((resolve) => {\n            this._resolveInputReply = resolve;\n        });\n        const result = await replyPromise;\n        return result.value;\n    }\n    /**\n     * Send a comm message to the front-end.\n     */\n    async sendComm(type, content, metadata, ident, buffers) {\n        this._sendMessage({\n            type: type,\n            content: this.formatResult(content),\n            metadata: this.formatResult(metadata),\n            ident: this.formatResult(ident),\n            buffers: this.formatResult(buffers),\n            parentHeader: this.formatResult(this._parent_header)['header'],\n        });\n    }\n    /**\n     * Complete the code submitted by a user.\n     */\n    async complete(code, cursor_pos, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.complete(code, cursor_pos);\n        return this.formatResult(res);\n    }\n    /**\n     * Inspect the code submitted by a user.\n     */\n    async inspect(code, cursor_pos, detail_level, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.inspect(code, cursor_pos, detail_level);\n        return this.formatResult(res);\n    }\n    /**\n     * Check code for completeness.\n     */\n    async isComplete(code, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.is_complete(code);\n        return this.formatResult(res);\n    }\n    /**\n     * Get information about available comms.\n     */\n    async commInfo(target_name, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_info(target_name);\n        return {\n            comms: this.formatResult(res),\n            status: 'ok',\n        };\n    }\n    /**\n     * Open a COMM\n     */\n    async commOpen(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_open(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Send a message through a COMM\n     */\n    async commMsg(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_msg(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Close a COMM\n     */\n    async commClose(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_close(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Execute Python code with streaming output\n     * @param code The Python code to execute\n     * @param parent Parent message header\n     * @returns AsyncGenerator yielding intermediate outputs and finally the execution result\n     */\n    async *executeStream(code, parent = {}) {\n        if (!this.initialized) {\n            await this.initialize();\n        }\n        try {\n            this._status = \"busy\";\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_BUSY, {});\n            await this.setup(parent);\n            // Create event listeners for streaming\n            const eventQueue = [];\n            let executionComplete = false;\n            let executionResult = null;\n            let executionError = null;\n            const handleAllEvents = (eventData) => {\n                eventQueue.push(eventData);\n            };\n            // Listen for all events BEFORE executing code\n            super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, handleAllEvents);\n            try {\n                // Execute the code directly\n                this._kernel.run(code).then((result) => {\n                    console.log(\"[KERNEL] Python execution finished\");\n                    executionResult = this.formatResult(result);\n                    // Check if the result indicates an error and emit it as an event\n                    if (executionResult && executionResult.status === 'error') {\n                        console.log(\"[KERNEL] Execution completed with error status, emitting execute_error event\");\n                        // Emit the error event so the UI can display it\n                        this._sendMessage({\n                            parentHeader: this.formatResult(this._parent_header)['header'],\n                            bundle: {\n                                ename: executionResult.ename || 'Error',\n                                evalue: executionResult.evalue || 'Unknown error',\n                                traceback: executionResult.traceback || []\n                            },\n                            type: 'execute_error',\n                        });\n                    }\n                    // Wait a small amount of time for any remaining messages to be processed\n                    setTimeout(() => {\n                        executionComplete = true;\n                    }, 100); // 100ms should be enough for message processing\n                }).catch((error) => {\n                    console.error(\"[KERNEL] Python execution error:\", error);\n                    executionError = error instanceof Error ? error : new Error(String(error));\n                    // Still wait for messages to settle before completing\n                    setTimeout(() => {\n                        executionComplete = true;\n                    }, 100);\n                });\n                // Stream events as they arrive\n                while (!executionComplete || eventQueue.length > 0) {\n                    // Yield queued events\n                    if (eventQueue.length > 0) {\n                        const event = eventQueue.shift();\n                        yield event;\n                    }\n                    else if (!executionComplete) {\n                        // Wait a bit for more events\n                        await new Promise(resolve => setTimeout(resolve, 10));\n                    }\n                }\n                // Process final result\n                this._status = \"active\";\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_IDLE, {});\n                if (executionError) {\n                    return {\n                        success: false,\n                        error: executionError,\n                        result: executionResult\n                    };\n                }\n                // Check if result indicates an error\n                if (executionResult && executionResult.status === 'error') {\n                    const errorMsg = `${executionResult.ename || 'Error'}: ${executionResult.evalue || 'Unknown error'}`;\n                    return {\n                        success: false,\n                        error: new Error(errorMsg),\n                        result: executionResult\n                    };\n                }\n                // Auto-sync native filesystems if enabled\n                if (this.autoSyncFs) {\n                    await this.syncAllNativeFs();\n                }\n                return {\n                    success: true,\n                    result: executionResult\n                };\n            }\n            finally {\n                // Clean up listener\n                super.off(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, handleAllEvents);\n            }\n        }\n        catch (error) {\n            console.error(\"[KERNEL] ExecuteStream error:\", error);\n            this._status = \"active\";\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_IDLE, {});\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    // Interrupt functionality\n    async interrupt() {\n        if (!this.initialized || !this.pyodide) {\n            console.warn(\"[KERNEL] Cannot interrupt: kernel not initialized\");\n            return false;\n        }\n        console.log(\"[KERNEL] Attempting to interrupt execution...\");\n        try {\n            // First priority: Use interrupt buffer if available\n            if (this._interruptBuffer && this._interruptSupported) {\n                console.log(\"[KERNEL] Using interrupt buffer method\");\n                // Set interrupt signal (2 = SIGINT)\n                this._interruptBuffer[0] = 2;\n                // Give the interrupt a moment to be processed\n                await new Promise(resolve => setTimeout(resolve, 100));\n                // Check if the interrupt was processed (buffer should be reset to 0)\n                const wasProcessed = this._interruptBuffer[0] === 0;\n                if (wasProcessed) {\n                    console.log(\"[KERNEL] Interrupt processed successfully via buffer\");\n                    return true;\n                }\n            }\n            // Second priority: Try Python-level interrupt\n            try {\n                console.log(\"[KERNEL] Attempting Python-level interrupt\");\n                // Try to raise KeyboardInterrupt in Python\n                await this.pyodide.runPythonAsync(`\nimport sys\nimport _thread\n# Try to interrupt the main thread\n_thread.interrupt_main()\n`);\n                console.log(\"[KERNEL] Python interrupt signal sent\");\n                return true;\n            }\n            catch (pythonError) {\n                console.log(\"[KERNEL] Python interrupt attempt failed:\", pythonError);\n            }\n            // Third priority: Try interpreter interrupt if available\n            if (this._interpreter && typeof this._interpreter.interrupt === 'function') {\n                console.log(\"[KERNEL] Using interpreter interrupt method\");\n                this._interpreter.interrupt();\n                return true;\n            }\n            // Last resort: Send interrupt messages for UI feedback\n            console.log(\"[KERNEL] Sending interrupt messages for UI feedback\");\n            // Send stderr stream first (for Jupyter notebook UI compatibility)\n            this._sendMessage({\n                type: 'stream',\n                bundle: {\n                    name: 'stderr',\n                    text: 'KeyboardInterrupt: Execution interrupted by user\\n'\n                }\n            });\n            this._sendMessage({\n                type: 'execute_error',\n                bundle: {\n                    ename: 'KeyboardInterrupt',\n                    evalue: 'Execution interrupted by user',\n                    traceback: ['KeyboardInterrupt: Execution interrupted by user']\n                }\n            });\n            // Return false since we couldn't actually interrupt the execution\n            return false;\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Error during interrupt:\", error);\n            return false;\n        }\n    }\n    setInterruptBuffer(buffer) {\n        this._interruptBuffer = buffer;\n        try {\n            if (this.pyodide && typeof this.pyodide.setInterruptBuffer === 'function') {\n                this.pyodide.setInterruptBuffer(buffer);\n                this._interruptSupported = true;\n            }\n            else {\n                console.warn(\"[KERNEL] pyodide.setInterruptBuffer not available, interrupt support limited\");\n                this._interruptSupported = false;\n            }\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Error setting interrupt buffer:\", error);\n            this._interruptSupported = false;\n        }\n    }\n    /**\n     * Verify and request permission for a file system handle\n     * @private\n     */\n    async verifyPermission(fileHandle, permission) {\n        const opts = {};\n        if (permission === 'readwrite') {\n            opts.mode = 'readwrite';\n        }\n        console.log(`[KERNEL] Verifying ${permission} permission for file handle...`);\n        // Check if permission APIs are supported\n        if (typeof fileHandle.queryPermission !== 'function') {\n            console.warn('[KERNEL] queryPermission not supported, assuming permission granted');\n            return true;\n        }\n        try {\n            // Check if we already have permission, if so, return true.\n            const queryResult = await fileHandle.queryPermission(opts);\n            console.log('[KERNEL] Query result:', queryResult);\n            if (queryResult === 'granted') {\n                console.log(`[KERNEL] Permission already granted for ${permission} access`);\n                return true;\n            }\n            // Request permission to the file, if the user grants permission, return true.\n            if (typeof fileHandle.requestPermission === 'function') {\n                console.log(`[KERNEL] Requesting ${permission} permission from user...`);\n                try {\n                    const requestResult = await fileHandle.requestPermission(opts);\n                    console.log('[KERNEL] Request result:', requestResult);\n                    if (requestResult === 'granted') {\n                        console.log(`[KERNEL] Permission granted for ${permission} access`);\n                        return true;\n                    }\n                }\n                catch (requestError) {\n                    console.log('[KERNEL] Permission request failed or was dismissed:', requestError);\n                }\n            }\n            // The user did not grant permission, return false.\n            console.log(`[KERNEL] ${permission} permission not granted`);\n            return false;\n        }\n        catch (error) {\n            console.error('[KERNEL] Error checking permission:', error);\n            // If permission check fails, assume it's granted (more permissive approach)\n            console.warn('[KERNEL] Permission check failed, assuming granted as fallback');\n            return true;\n        }\n    }\n    /**\n     * Mount a native file system directory into the Pyodide filesystem\n     * @param mountPath The path where the directory should be mounted in the Python filesystem\n     * @param dirHandle Optional FileSystemDirectoryHandle. If null/undefined, shows directory picker\n     * @param permission Permission mode:\n     *   - 'read': Read-only access, no syncing capabilities, auto-sync will be skipped (default)\n     *   - 'readwrite': Full read/write access with syncing capabilities\n     * @returns Promise resolving to a handle with syncfs() method for syncing changes\n     * @note syncfs() will throw an error if called on a read-only mounted filesystem\n     * @note Many browsers only offer read permission initially. Explicitly request 'readwrite' if you need write access.\n     */\n    async mountFS(mountPath, dirHandle, permission = 'read') {\n        if (!this.initialized || !this.pyodide) {\n            throw new Error(\"Kernel must be initialized before mounting filesystem\");\n        }\n        // Check if mountNativeFS is available\n        if (typeof this.pyodide.mountNativeFS !== 'function') {\n            throw new Error(\"pyodide.mountNativeFS is not available. Make sure you're using Pyodide 0.23.0 or later.\");\n        }\n        let handle = dirHandle;\n        // If no dirHandle provided, show directory picker\n        if (!handle) {\n            // Check if we're in a worker context\n            if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n                throw new Error(\"Cannot show directory picker in worker context. Please provide a dirHandle parameter.\");\n            }\n            // Check if showDirectoryPicker is available\n            if (typeof window !== 'undefined' && 'showDirectoryPicker' in window) {\n                try {\n                    handle = await window.showDirectoryPicker({\n                        mode: 'readwrite',\n                    });\n                }\n                catch (error) {\n                    throw new Error(`Failed to show directory picker: ${error instanceof Error ? error.message : String(error)}`);\n                }\n            }\n            else {\n                throw new Error(\"showDirectoryPicker is not supported in this browser. Please provide a dirHandle parameter.\");\n            }\n        }\n        if (!handle) {\n            throw new Error(\"No directory handle available\");\n        }\n        // Verify and request permissions before mounting\n        console.log(`[KERNEL] Verifying ${permission} permissions before mounting...`);\n        const hasRequestedPermission = await this.verifyPermission(handle, permission);\n        if (!hasRequestedPermission) {\n            if (permission === 'readwrite') {\n                throw new Error(`Failed to obtain write permission for directory. ` +\n                    `The browser may only be offering read permission. ` +\n                    `Try mounting with permission: 'read' if you only need to read files, ` +\n                    `or ensure the browser supports write access to this directory.`);\n            }\n            else {\n                throw new Error(`Failed to obtain ${permission} permission for directory.`);\n            }\n        }\n        const actualPermission = permission;\n        // Mount the native filesystem\n        try {\n            console.log(`[KERNEL] Mounting native filesystem at ${mountPath} with ${actualPermission} permission`);\n            // Check if the mount point already exists and handle cleanup\n            try {\n                const pathInfo = this.pyodide.FS.analyzePath(mountPath);\n                if (pathInfo.exists) {\n                    console.log(`[KERNEL] Path ${mountPath} exists, checking if it's a mount point`);\n                    // Try to unmount if it's already mounted\n                    try {\n                        await this.pyodide.FS.unmount(mountPath);\n                        console.log(`[KERNEL] Successfully unmounted existing filesystem at ${mountPath}`);\n                    }\n                    catch (unmountError) {\n                        // If unmount fails, it might not be a mount point or might be busy\n                        console.log(`[KERNEL] Unmount failed (this is normal if not mounted): ${unmountError}`);\n                    }\n                    // Remove the directory if it exists but is empty\n                    try {\n                        this.pyodide.FS.rmdir(mountPath);\n                        console.log(`[KERNEL] Removed existing directory at ${mountPath}`);\n                    }\n                    catch (rmdirError) {\n                        // Directory might not be empty or might not exist, that's okay\n                        console.log(`[KERNEL] Could not remove directory (this is normal): ${rmdirError}`);\n                    }\n                }\n            }\n            catch (analyzeError) {\n                // analyzePath might fail, that's okay - the path probably doesn't exist\n                console.log(`[KERNEL] Path analysis failed (path probably doesn't exist): ${analyzeError}`);\n            }\n            // Ensure the parent directory exists\n            const parentPath = mountPath.substring(0, mountPath.lastIndexOf('/')) || '/';\n            try {\n                if (parentPath !== '/' && !this.pyodide.FS.analyzePath(parentPath).exists) {\n                    this.pyodide.FS.mkdir(parentPath);\n                    console.log(`[KERNEL] Created parent directory ${parentPath}`);\n                }\n            }\n            catch (parentError) {\n                console.log(`[KERNEL] Parent directory handling: ${parentError}`);\n            }\n            const nativefs = await this.pyodide.mountNativeFS(mountPath, handle);\n            console.log(`[KERNEL] Successfully mounted native filesystem at ${mountPath} with ${actualPermission} permission`);\n            // Create a handle with syncfs method and permission recovery\n            const fsHandle = {\n                syncfs: async () => {\n                    // Check if filesystem is read-only\n                    if (actualPermission === 'read') {\n                        throw new Error(`Cannot sync read-only filesystem at ${mountPath}. Use upgradeFileSystemPermission() to request write access.`);\n                    }\n                    try {\n                        await nativefs.syncfs();\n                        console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                    }\n                    catch (error) {\n                        throw new Error(`Failed to sync filesystem: ${error instanceof Error ? error.message : String(error)}`);\n                    }\n                },\n                dirHandle: handle,\n                permission: actualPermission,\n                nativefs: nativefs\n            };\n            // Store the handle for auto-sync\n            this.nativeFsHandles.set(mountPath, fsHandle);\n            return { syncfs: fsHandle.syncfs };\n        }\n        catch (error) {\n            throw new Error(`Failed to mount native filesystem: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    /**\n     * Sync all mounted native filesystems with permission recovery\n     * Only syncs filesystems mounted with 'readwrite' permission\n     * @private\n     */\n    async syncAllNativeFs() {\n        if (this.nativeFsHandles.size === 0) {\n            return;\n        }\n        const syncResults = [];\n        for (const [mountPath, fsHandle] of this.nativeFsHandles.entries()) {\n            // Skip read-only filesystems\n            if (fsHandle.permission === 'read') {\n                syncResults.push({ mountPath, success: true, skipped: true });\n                console.log(`[KERNEL] Skipping sync for read-only filesystem at ${mountPath}`);\n                continue;\n            }\n            try {\n                // First, try to sync directly\n                await fsHandle.syncfs();\n                syncResults.push({ mountPath, success: true });\n                console.log(`[KERNEL] Successfully synced filesystem at ${mountPath}`);\n            }\n            catch (error) {\n                // If sync fails, check if it's a permission error\n                const errorMessage = error instanceof Error ? error.message : String(error);\n                if (errorMessage.includes('not allowed by the user agent') ||\n                    errorMessage.includes('getFileHandle') ||\n                    errorMessage.includes('permission')) {\n                    console.warn(`[KERNEL] Permission error syncing ${mountPath}, attempting recovery...`);\n                    try {\n                        // Try to recover by re-verifying permissions\n                        const hasPermission = await this.verifyPermission(fsHandle.dirHandle, fsHandle.permission);\n                        if (hasPermission) {\n                            // Try to remount and sync\n                            console.log(`[KERNEL] Permission recovered for ${mountPath}, attempting remount...`);\n                            const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n                            // Update the stored handle with the new nativefs\n                            fsHandle.nativefs = newNativefs;\n                            fsHandle.syncfs = async () => {\n                                try {\n                                    await newNativefs.syncfs();\n                                    console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                                }\n                                catch (syncError) {\n                                    throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                                }\n                            };\n                            // Try sync again with the new handle\n                            await fsHandle.syncfs();\n                            syncResults.push({ mountPath, success: true });\n                            console.log(`[KERNEL] Successfully recovered and synced filesystem at ${mountPath}`);\n                        }\n                        else {\n                            syncResults.push({\n                                mountPath,\n                                success: false,\n                                error: 'Permission denied by user'\n                            });\n                            console.warn(`[KERNEL] User denied permission for ${mountPath}, skipping sync`);\n                        }\n                    }\n                    catch (recoveryError) {\n                        const recoveryMessage = recoveryError instanceof Error ? recoveryError.message : String(recoveryError);\n                        syncResults.push({\n                            mountPath,\n                            success: false,\n                            error: `Recovery failed: ${recoveryMessage}`\n                        });\n                        console.error(`[KERNEL] Failed to recover permissions for ${mountPath}:`, recoveryError);\n                    }\n                }\n                else {\n                    // Non-permission error\n                    syncResults.push({\n                        mountPath,\n                        success: false,\n                        error: errorMessage\n                    });\n                    console.error(`[KERNEL] Non-permission error syncing ${mountPath}:`, error);\n                }\n            }\n        }\n        // Log summary\n        const successful = syncResults.filter(r => r.success && !r.skipped).length;\n        const skipped = syncResults.filter(r => r.skipped).length;\n        const failed = syncResults.filter(r => !r.success);\n        if (successful > 0 || skipped > 0) {\n            const parts = [];\n            if (successful > 0)\n                parts.push(`${successful} synced`);\n            if (skipped > 0)\n                parts.push(`${skipped} read-only skipped`);\n            console.log(`[KERNEL] Auto-sync completed: ${parts.join(', ')} (${syncResults.length} total filesystems)`);\n        }\n        if (failed.length > 0) {\n            console.warn(`[KERNEL] Auto-sync issues:`, failed.map(f => `${f.mountPath}: ${f.error}`));\n        }\n        // Don't throw - we don't want to fail execution just because sync failed\n    }\n    /**\n     * Get information about mounted native filesystems and their permission status\n     * @returns Array of mounted filesystem information\n     */\n    getMountedFileSystems() {\n        const result = [];\n        for (const [mountPath, fsHandle] of this.nativeFsHandles.entries()) {\n            result.push({\n                mountPath,\n                permission: fsHandle.permission,\n                canSync: fsHandle.permission === 'readwrite'\n            });\n        }\n        return result;\n    }\n    /**\n     * Manually sync a specific mounted filesystem\n     * @param mountPath The path of the mounted filesystem to sync\n     * @returns Promise resolving to success status\n     */\n    async syncFileSystem(mountPath) {\n        const fsHandle = this.nativeFsHandles.get(mountPath);\n        if (!fsHandle) {\n            return {\n                success: false,\n                error: `No filesystem mounted at ${mountPath}`\n            };\n        }\n        // Check if filesystem is read-only\n        if (fsHandle.permission === 'read') {\n            return {\n                success: false,\n                error: `Cannot sync read-only filesystem at ${mountPath}. Mount with 'readwrite' permission to enable syncing.`\n            };\n        }\n        try {\n            await fsHandle.syncfs();\n            return { success: true };\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            // Try permission recovery if it's a permission error\n            if (errorMessage.includes('not allowed by the user agent') ||\n                errorMessage.includes('getFileHandle') ||\n                errorMessage.includes('permission')) {\n                console.log(`[KERNEL] Permission error syncing ${mountPath}, attempting recovery...`);\n                try {\n                    const hasPermission = await this.verifyPermission(fsHandle.dirHandle, fsHandle.permission);\n                    if (hasPermission) {\n                        // Remount and try again\n                        const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n                        fsHandle.nativefs = newNativefs;\n                        fsHandle.syncfs = async () => {\n                            try {\n                                await newNativefs.syncfs();\n                                console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                            }\n                            catch (syncError) {\n                                throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                            }\n                        };\n                        await fsHandle.syncfs();\n                        return { success: true };\n                    }\n                    else {\n                        return {\n                            success: false,\n                            error: 'Permission denied by user'\n                        };\n                    }\n                }\n                catch (recoveryError) {\n                    return {\n                        success: false,\n                        error: `Recovery failed: ${recoveryError instanceof Error ? recoveryError.message : String(recoveryError)}`\n                    };\n                }\n            }\n            return {\n                success: false,\n                error: errorMessage\n            };\n        }\n    }\n    /**\n     * Upgrade a mounted filesystem from read-only to read-write permission\n     * @param mountPath The path of the mounted filesystem to upgrade\n     * @returns Promise resolving to success status\n     */\n    async upgradeFileSystemPermission(mountPath) {\n        const fsHandle = this.nativeFsHandles.get(mountPath);\n        if (!fsHandle) {\n            return {\n                success: false,\n                error: `No filesystem mounted at ${mountPath}`\n            };\n        }\n        if (fsHandle.permission === 'readwrite') {\n            return {\n                success: true,\n                error: `FileSystem at ${mountPath} already has readwrite permission`\n            };\n        }\n        try {\n            console.log(`[KERNEL] Attempting to upgrade ${mountPath} to readwrite permission...`);\n            // Try to get readwrite permission\n            const hasWritePermission = await this.verifyPermission(fsHandle.dirHandle, 'readwrite');\n            if (!hasWritePermission) {\n                return {\n                    success: false,\n                    error: 'User denied write permission or browser does not support write access to this directory'\n                };\n            }\n            // Remount with write permission\n            const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n            // Update the stored handle\n            fsHandle.permission = 'readwrite';\n            fsHandle.nativefs = newNativefs;\n            fsHandle.syncfs = async () => {\n                try {\n                    await newNativefs.syncfs();\n                    console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                }\n                catch (syncError) {\n                    throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                }\n            };\n            console.log(`[KERNEL] Successfully upgraded ${mountPath} to readwrite permission`);\n            return { success: true };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Failed to upgrade permission: ${error instanceof Error ? error.message : String(error)}`\n            };\n        }\n    }\n    /**\n     * Set environment variables with performance optimization\n     * OPTIMIZED: Parallel variable setting and validation with proper escaping and edge case handling\n     */\n    async setEnvironmentVariables() {\n        if (Object.keys(this.environmentVariables).length === 0) {\n            return; // No variables to set\n        }\n        const startTime = Date.now();\n        console.log(`ðŸŒ Setting ${Object.keys(this.environmentVariables).length} environment variables...`);\n        try {\n            // Set each environment variable individually to avoid escaping issues\n            for (const [key, value] of Object.entries(this.environmentVariables)) {\n                // Handle edge cases: null, undefined, etc.\n                let processedValue;\n                if (value === null) {\n                    processedValue = ''; // Convert null to empty string\n                }\n                else if (value === undefined) {\n                    processedValue = ''; // Convert undefined to empty string\n                }\n                else {\n                    processedValue = String(value); // Convert everything else to string\n                }\n                await this.pyodide.runPythonAsync(`\nimport os\nos.environ[${JSON.stringify(key)}] = ${JSON.stringify(processedValue)}\n`);\n            }\n            const duration = Date.now() - startTime;\n            console.log(`âš¡ Environment variables set in ${duration}ms`);\n        }\n        catch (error) {\n            console.error(\"âŒ Failed to set environment variables:\", error);\n            throw error;\n        }\n    }\n}\n// Only Python kernel is supported\n// Export the manager for advanced usage\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxJQUFJLGNBQXNCLENBQUM7Z0JBQzNCLElBQUksS0FBSyxLQUFLLElBQUksRUFBRSxDQUFDO29CQUNuQixjQUFjLEdBQUcsRUFBRSxDQUFDLENBQUUsK0JBQStCO2dCQUN2RCxDQUFDO3FCQUFNLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRSxDQUFDO29CQUMvQixjQUFjLEdBQUcsRUFBRSxDQUFDLENBQUUsb0NBQW9DO2dCQUM1RCxDQUFDO3FCQUFNLENBQUM7b0JBQ04sY0FBYyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFFLG9DQUFvQztnQkFDdkUsQ0FBQztnQkFFRCxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDOzthQUU3QixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDO0NBQ3BFLENBQUMsQ0FBQztZQUNHLENBQUM7WUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsU0FBUyxDQUFDO1lBQ3hDLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0NBQWtDLFFBQVEsSUFBSSxDQUFDLENBQUM7UUFDOUQsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLHdDQUF3QyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQy9ELE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUM7Q0FDRjtBQUVELGtDQUFrQztBQUVsQyx3Q0FBd0M7QUFDRSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1weXRob24ta2VybmVsLy4vc3JjL2luZGV4LnRzP2ZmYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gS2VybmVsIGltcGxlbWVudGF0aW9uIGZvciBEZW5vIHVzaW5nIFB5b2RpZGUgZGlyZWN0bHlcbi8vIEJhc2VkIG9uIHRoZSBQeW9kaWRlUmVtb3RlS2VybmVsIGJ1dCBhZGFwdGVkIGZvciBkaXJlY3QgZXhlY3V0aW9uIGluIG1haW4gdGhyZWFkXG5cbi8vIEB0cy1pZ25vcmUgSW1wb3J0aW5nIGZyb20gbnBtXG4vLyBVc2UgYSBicm93c2VyLWNvbXBhdGlibGUgRXZlbnRFbWl0dGVyXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGV2ZW50czogeyBba2V5OiBzdHJpbmddOiBGdW5jdGlvbltdIH0gPSB7fTtcblxuICBvbihldmVudE5hbWU6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gW107XG4gICAgfVxuICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICBvZmYoZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikge1xuICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkgcmV0dXJuO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIGVtaXQoZXZlbnROYW1lOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSByZXR1cm47XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKC4uLmFyZ3MpKTtcbiAgfVxuXG4gIHNldE1heExpc3RlbmVycyhuOiBudW1iZXIpIHtcbiAgICAvLyBOby1vcCBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4gIH1cbn1cblxuLy8gQHRzLWlnbm9yZSBJbXBvcnRpbmcgZnJvbSBucG1cbmltcG9ydCB7IGxvYWRQeW9kaWRlIH0gZnJvbSBcIi4vcHlvZGlkZS1sb2FkZXJcIjtcblxuLy8gSW1wb3J0IHR5cGVzIGFuZCBlbnVtc1xuaW1wb3J0IHsgS2VybmVsRXZlbnRzLCBJRXZlbnREYXRhLCBJTWVzc2FnZSwgSUtlcm5lbCwgSUtlcm5lbE9wdGlvbnMsIElGaWxlU3lzdGVtTW91bnRPcHRpb25zLCBJS2VybmVsRXhlY3V0ZU9wdGlvbnMsIElFdmVudEVtaXR0ZXIgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG4vLyBJbXBvcnQgUHlQSSBVUkxzXG5pbXBvcnQge1xuICBwaXBsaXRlV2hlZWxVcmwsXG4gIHB5b2RpZGVfa2VybmVsV2hlZWxVcmwsXG4gIGlweWtlcm5lbFdoZWVsVXJsLFxuICBhbGxKU09OVXJsLFxuICB3aWRnZXRzbmJleHRlbnNpb25XaGVlbFVybCxcbiAgd2lkZ2V0c25iZXh0ZW5zaW9uV2hlZWxVcmwxXG59IGZyb20gJy4vX3B5cGknO1xuXG4vLyBFdmVudCB0eXBlcyBmcm9tIEp1cHl0ZXJMYWJcbi8vIFJlLWV4cG9ydCB0eXBlcyB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5leHBvcnQgeyBLZXJuZWxFdmVudHMgfSBmcm9tIFwiLi90eXBlc1wiO1xuZXhwb3J0IHR5cGUge1xuICBJS2VybmVsLFxuICBJS2VybmVsT3B0aW9ucyxcbiAgSUZpbGVTeXN0ZW1Nb3VudE9wdGlvbnMsXG4gIElLZXJuZWxFeGVjdXRlT3B0aW9ucyxcbiAgSU1lc3NhZ2UsXG4gIElFdmVudERhdGEsXG4gIElFdmVudEVtaXR0ZXIsXG4gIElOYXRpdmVGU0hhbmRsZVxufSBmcm9tIFwiLi90eXBlc1wiO1xuXG5leHBvcnQgeyBLZXJuZWxNb2RlLCBLZXJuZWxMYW5ndWFnZSB9IGZyb20gXCIuL21hbmFnZXJcIjtcblxuXG5cblxuZXhwb3J0IGNsYXNzIEtlcm5lbCBleHRlbmRzIEV2ZW50RW1pdHRlciBpbXBsZW1lbnRzIElLZXJuZWwge1xuICBwcml2YXRlIHB5b2RpZGU6IGFueTtcbiAgcHJpdmF0ZSBpbml0aWFsaXplZCA9IGZhbHNlO1xuICBwcml2YXRlIGluaXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gIFxuICAvLyBGaWxlU3lzdGVtIG9wdGlvbnNcbiAgcHJpdmF0ZSBmaWxlc3lzdGVtT3B0aW9uczogSUZpbGVTeXN0ZW1Nb3VudE9wdGlvbnMgPSB7XG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgcm9vdDogXCIuXCIsXG4gICAgbW91bnRQb2ludDogXCIvaG9tZS9weW9kaWRlXCJcbiAgfTtcbiAgXG4gIC8vIEtlcm5lbCBvcHRpb25zXG4gIHByaXZhdGUgbG9ja0ZpbGVVUkw/OiBzdHJpbmc7XG4gIFxuICAvLyBLZXJuZWwgY29tcG9uZW50c1xuICBwcml2YXRlIF9rZXJuZWw6IGFueTtcbiAgcHJpdmF0ZSBfaW50ZXJwcmV0ZXI6IGFueTtcbiAgcHJpdmF0ZSBfc3Rkb3V0X3N0cmVhbTogYW55O1xuICBwcml2YXRlIF9zdGRlcnJfc3RyZWFtOiBhbnk7XG4gIFxuICAvLyBJbnB1dCBoYW5kbGluZ1xuICBwcml2YXRlIF9yZXNvbHZlSW5wdXRSZXBseTogKCh2YWx1ZTogYW55KSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gRXhlY3V0aW9uIHN0YXRlXG4gIHByaXZhdGUgX3BhcmVudF9oZWFkZXI6IGFueSA9IHt9O1xuICBwcml2YXRlIGV4ZWN1dGlvbkNvdW50ID0gMDtcbiAgcHJpdmF0ZSBfc3RhdHVzOiBcImFjdGl2ZVwiIHwgXCJidXN5XCIgfCBcInVua25vd25cIiA9IFwidW5rbm93blwiO1xuICBcbiAgLy8gSW50ZXJydXB0IGhhbmRsaW5nXG4gIHByaXZhdGUgX2ludGVycnVwdEJ1ZmZlcjogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9pbnRlcnJ1cHRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgXG4gIC8vIEVudmlyb25tZW50IHZhcmlhYmxlc1xuICBwcml2YXRlIGVudmlyb25tZW50VmFyaWFibGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgLy8gTmF0aXZlIGZpbGVzeXN0ZW0gaGFuZGxlc1xuICBwcml2YXRlIG5hdGl2ZUZzSGFuZGxlczogTWFwPHN0cmluZywgeyBcbiAgICBzeW5jZnM6ICgpID0+IFByb21pc2U8dm9pZD47IFxuICAgIGRpckhhbmRsZTogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZTtcbiAgICBwZXJtaXNzaW9uOiAncmVhZCcgfCAncmVhZHdyaXRlJztcbiAgICBuYXRpdmVmczogYW55O1xuICB9PiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBhdXRvU3luY0ZzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLy8gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMga2VybmVsIGluc3RhbmNlXG4gIHByaXZhdGUgcmVhZG9ubHkga2VybmVsSWQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHN1cGVyLnNldE1heExpc3RlbmVycygyMCk7XG4gICAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgSUQgZm9yIHRoaXMga2VybmVsIGluc3RhbmNlXG4gICAgdGhpcy5rZXJuZWxJZCA9IGBrZXJuZWxfJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMil9XyR7RGF0ZS5ub3coKX1gO1xuICB9XG5cbiAgLy8gQXN5bmMgbWV0aG9kIGZvciBrZXJuZWwgc3RhdHVzXG4gIGFzeW5jIGdldFN0YXR1cygpOiBQcm9taXNlPFwiYWN0aXZlXCIgfCBcImJ1c3lcIiB8IFwidW5rbm93blwiPiB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBrZXJuZWwgd2l0aCBtYXhpbXVtIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnNcbiAgICogT1BUSU1JWkVEOiBGdWxsIHBhcmFsbGVsaXphdGlvbiB3aXRoIHNtYXJ0IGNhY2hpbmcgYW5kIHBlcmZvcm1hbmNlIG1vbml0b3JpbmdcbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbml0aWFsaXplKG9wdGlvbnM/OiBJS2VybmVsT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLmluaXRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgICB9XG5cbiAgICAvLyBTZXQgZmlsZXN5c3RlbSBvcHRpb25zIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnM/LmZpbGVzeXN0ZW0pIHtcbiAgICAgIHRoaXMuZmlsZXN5c3RlbU9wdGlvbnMgPSB7XG4gICAgICAgIC4uLnRoaXMuZmlsZXN5c3RlbU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMuZmlsZXN5c3RlbVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBTZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnM/LmVudikge1xuICAgICAgdGhpcy5lbnZpcm9ubWVudFZhcmlhYmxlcyA9IHsgLi4ub3B0aW9ucy5lbnYgfTtcbiAgICB9XG5cbiAgICAvLyBTZXQgbG9ja0ZpbGVVUkwgaWYgcHJvdmlkZWRcbiAgICBpZiAob3B0aW9ucz8ubG9ja0ZpbGVVUkwpIHtcbiAgICAgIHRoaXMubG9ja0ZpbGVVUkwgPSBvcHRpb25zLmxvY2tGaWxlVVJMO1xuICAgIH1cblxuICAgIC8vIFNldCBhdXRvU3luY0ZzIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnM/LmF1dG9TeW5jRnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hdXRvU3luY0ZzID0gb3B0aW9ucy5hdXRvU3luY0ZzO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdFByb21pc2UgPSB0aGlzLl9pbml0aWFsaXplSW50ZXJuYWwoKTtcbiAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGtlcm5lbCB3aXRoIG1heGltdW0gcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uc1xuICAgKiBPUFRJTUlaRUQ6IEZ1bGwgcGFyYWxsZWxpemF0aW9uIHdpdGggc21hcnQgY2FjaGluZyBhbmQgcGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfaW5pdGlhbGl6ZUludGVybmFsKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc29sZS5sb2coXCLwn5qAIFN0YXJ0aW5nIG9wdGltaXplZCBrZXJuZWwgaW5pdGlhbGl6YXRpb24uLi5cIik7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIExvYWQgUHlvZGlkZSBmcm9tIENETlxuICAgICAgY29uc3QgcHlvZGlkZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBcbiAgICAgIC8vIENvbmZpZ3VyZSBweW9kaWRlIG9wdGlvbnNcbiAgICAgIGNvbnN0IHB5b2RpZGVDb25maWc6IGFueSA9IHt9O1xuICAgICAgaWYgKHRoaXMubG9ja0ZpbGVVUkwpIHtcbiAgICAgICAgcHlvZGlkZUNvbmZpZy5sb2NrRmlsZVVSTCA9IHRoaXMubG9ja0ZpbGVVUkw7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SSIFVzaW5nIGxvY2tGaWxlVVJMOiAke3RoaXMubG9ja0ZpbGVVUkx9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVzZSBvdXIgQ0ROIGxvYWRlciAtIGl0IHdpbGwgYXV0b21hdGljYWxseSBoYW5kbGUgbWFpbiB0aHJlYWQgdnMgd29ya2VyXG4gICAgICB0aGlzLnB5b2RpZGUgPSBhd2FpdCBsb2FkUHlvZGlkZShweW9kaWRlQ29uZmlnKTtcbiAgICAgIGNvbnN0IHB5b2RpZGVUaW1lID0gRGF0ZS5ub3coKSAtIHB5b2RpZGVTdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFB5b2RpZGUgbG9hZGVkIGluICR7cHlvZGlkZVRpbWV9bXNgKTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSBjb3JlIGNvbXBvbmVudHMgaW4gcGFyYWxsZWxcbiAgICAgIGlmICh0aGlzLmxvY2tGaWxlVVJMKSB7XG4gICAgICAgIC8vIFdoZW4gdXNpbmcgbG9ja0ZpbGVVUkwsIHBhY2thZ2VzIGFyZSBwcmUtaW5zdGFsbGVkLCBza2lwIHBhY2thZ2UgaW5zdGFsbGF0aW9uXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+agCBVc2luZyBsb2NrIGZpbGUgLSBza2lwcGluZyBwYWNrYWdlIGluc3RhbGxhdGlvblwiKTtcbiAgICAgICAgY29uc3QgWyxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIC8vIDEuIEZpbGVTeXN0ZW0gbW91bnRpbmcgKGlmIGVuYWJsZWQpXG4gICAgICAgICAgdGhpcy5maWxlc3lzdGVtT3B0aW9ucy5lbmFibGVkID8gdGhpcy5tb3VudEZpbGVTeXN0ZW0oKSA6IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgICAgIC8vIDIuIEVudmlyb25tZW50IHZhcmlhYmxlcyBzZXR1cFxuICAgICAgICAgIHRoaXMuc2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKVxuICAgICAgICBdKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEluaXRpYWxpemUgZ2xvYmFscyBkaXJlY3RseSAocGFja2FnZXMgYXJlIGFscmVhZHkgYXZhaWxhYmxlKVxuICAgICAgICBhd2FpdCB0aGlzLmluaXRHbG9iYWxzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGFuZGFyZCBpbml0aWFsaXphdGlvbiB3aXRoIHBhY2thZ2UgaW5zdGFsbGF0aW9uXG4gICAgICAgIGNvbnN0IFssICxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIC8vIDEuIEZpbGVTeXN0ZW0gbW91bnRpbmcgKGlmIGVuYWJsZWQpXG4gICAgICAgICAgdGhpcy5maWxlc3lzdGVtT3B0aW9ucy5lbmFibGVkID8gdGhpcy5tb3VudEZpbGVTeXN0ZW0oKSA6IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgICAgIC8vIDIuIFBhY2thZ2UgbWFuYWdlciBpbml0aWFsaXphdGlvblxuICAgICAgICAgIHRoaXMuaW5pdFBhY2thZ2VNYW5hZ2VyKCksXG4gICAgICAgICAgLy8gMy4gRW52aXJvbm1lbnQgdmFyaWFibGVzIHNldHVwXG4gICAgICAgICAgdGhpcy5zZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpXG4gICAgICAgIF0pO1xuICAgICAgICBcbiAgICAgICAgLy8gSW5zdGFsbCBwYWNrYWdlcyBhbmQgaW5pdGlhbGl6ZSBnbG9iYWxzXG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdEtlcm5lbCgpO1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRHbG9iYWxzKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OryBLRVJORUwgSU5JVElBTElaQVRJT04gQ09NUExFVEUgaW4gJHt0b3RhbFRpbWV9bXNgKTtcbiAgICAgIGNvbnNvbGUubG9nKGDimqEgUGVyZm9ybWFuY2U6IFB5b2RpZGUoJHtweW9kaWRlVGltZX1tcykgKyBTZXR1cCgke3RvdGFsVGltZSAtIHB5b2RpZGVUaW1lfW1zKWApO1xuICAgICAgXG4gICAgICAvLyBNYXJrIGFzIGluaXRpYWxpemVkXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IFwiYWN0aXZlXCI7XG4gICAgICBjb25zb2xlLmxvZyhcIvCfn6IgS2VybmVsIGlzIG5vdyBBQ1RJVkUgYW5kIHJlYWR5IGZvciBleGVjdXRpb24hXCIpO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgS2VybmVsIGluaXRpYWxpemF0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gXCJ1bmtub3duXCI7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBNb3VudCB0aGUgbG9jYWwgZmlsZXN5c3RlbSB0byB0aGUgUHlvZGlkZSBlbnZpcm9ubWVudFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBtb3VudEZpbGVTeXN0ZW0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBNb3VudGluZyBmaWxlc3lzdGVtIGZyb20gJHt0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLnJvb3R9IHRvICR7dGhpcy5maWxlc3lzdGVtT3B0aW9ucy5tb3VudFBvaW50fWApO1xuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgYXBwcm9hY2ggYXMgaW4gZGVuby1kZW1vLWZzLWFzZ2kuanMgZm9yIG1heGltdW0gY29tcGF0aWJpbGl0eVxuICAgICAgLy8gU2ltcGxlIGFuZCBkaXJlY3QgbW91bnRpbmcgb2YgdGhlIGZpbGVzeXN0ZW1cbiAgICAgIGF3YWl0IHRoaXMucHlvZGlkZS5GUy5tb3VudChcbiAgICAgICAgdGhpcy5weW9kaWRlLkZTLmZpbGVzeXN0ZW1zLk5PREVGUyxcbiAgICAgICAgeyByb290OiB0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLnJvb3QgfHwgXCIuXCIgfSxcbiAgICAgICAgdGhpcy5maWxlc3lzdGVtT3B0aW9ucy5tb3VudFBvaW50IHx8IFwiL2hvbWUvcHlvZGlkZVwiXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIkZpbGVTeXN0ZW0gbW91bnRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0aGUgbW91bnQgYnkgbGlzdGluZyB0aGUgZGlyZWN0b3J5XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtb3VudGVkRmlsZXMgPSB0aGlzLnB5b2RpZGUuRlMucmVhZGRpcih0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLm1vdW50UG9pbnQgfHwgXCIvaG9tZS9weW9kaWRlXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRmlsZXMgaW4gJHt0aGlzLmZpbGVzeXN0ZW1PcHRpb25zLm1vdW50UG9pbnR9IGRpcmVjdG9yeTogJHttb3VudGVkRmlsZXMuam9pbihcIiwgXCIpfWApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgbGlzdGluZyBtb3VudGVkIGRpcmVjdG9yeTogJHtlcnJvcn1gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG1vdW50aW5nIGZpbGVzeXN0ZW06XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBQeW9kaWRlIHBhY2thZ2UgbWFuYWdlciB3aXRoIG9wdGltaXplZCB3aGVlbCBsb2FkaW5nXG4gICAqIE9QVElNSVpFRDogU21hcnQgY2FjaGluZyBhbmQgcGFyYWxsZWwgd2hlZWwgaW5zdGFsbGF0aW9uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRQYWNrYWdlTWFuYWdlcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnNvbGUubG9nKFwi4pqhIEluaXRpYWxpemluZyBvcHRpbWl6ZWQgcGFja2FnZSBtYW5hZ2VyLi4uXCIpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBMb2FkIG1pY3JvcGlwIGFuZCBwYWNrYWdpbmcgaW4gcGFyYWxsZWxcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+TpiBMb2FkaW5nIG1pY3JvcGlwLCBwYWNrYWdpbmcuLi5cIik7XG4gICAgICBhd2FpdCB0aGlzLnB5b2RpZGUubG9hZFBhY2thZ2UoWydtaWNyb3BpcCcsICdwYWNrYWdpbmcnXSk7XG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBMb2FkZWQgbWljcm9waXAsIHBhY2thZ2luZ1wiKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBiYXNlIFVSTCAtIHVzZSB3aW5kb3cubG9jYXRpb24gZm9yIGJyb3dzZXIgb3IgZmFsbGJhY2sgZm9yIHdvcmtlclxuICAgICAgbGV0IGJhc2VVcmw6IHN0cmluZztcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgICAgLy8gSW4gbWFpbiB0aHJlYWQgLSB1c2Ugd2luZG93LmxvY2F0aW9uXG4gICAgICAgIGJhc2VVcmwgPSBuZXcgVVJMKFwiLlwiLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYubG9jYXRpb24pIHtcbiAgICAgICAgLy8gSW4gd2ViIHdvcmtlciAtIHVzZSBzZWxmLmxvY2F0aW9uXG4gICAgICAgIGJhc2VVcmwgPSBuZXcgVVJMKFwiLlwiLCBzZWxmLmxvY2F0aW9uLmhyZWYpLmhyZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayAtIGFzc3VtZSBjdXJyZW50IG9yaWdpblxuICAgICAgICBiYXNlVXJsID0gXCIvXCI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGFsbEpzb25QYXRoID0gbmV3IFVSTChhbGxKU09OVXJsLCBiYXNlVXJsKS5ocmVmO1xuICAgICAgXG4gICAgICAvLyBQcmVwYXJlIGFsbCB3aGVlbCBVUkxzIGZvciBwYXJhbGxlbCBsb2FkaW5nXG4gICAgICBjb25zdCB3aGVlbEZpbGVzID0gW1xuICAgICAgICBuZXcgVVJMKHBpcGxpdGVXaGVlbFVybCwgYmFzZVVybCkuaHJlZixcbiAgICAgICAgbmV3IFVSTChweW9kaWRlX2tlcm5lbFdoZWVsVXJsLCBiYXNlVXJsKS5ocmVmLFxuICAgICAgICBuZXcgVVJMKGlweWtlcm5lbFdoZWVsVXJsLCBiYXNlVXJsKS5ocmVmLFxuICAgICAgICBuZXcgVVJMKHdpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsLCBiYXNlVXJsKS5ocmVmLFxuICAgICAgICBuZXcgVVJMKHdpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsMSwgYmFzZVVybCkuaHJlZixcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5qAIEluc3RhbGxpbmcgJHt3aGVlbEZpbGVzLmxlbmd0aH0gd2hlZWwgcGFja2FnZXMgaW4gcGFyYWxsZWwuLi5gKTtcbiAgICAgIFxuICAgICAgLy8gSW5zdGFsbCBhbGwgd2hlZWwgcGFja2FnZXMgaW4gcGFyYWxsZWwgZm9yIG1heGltdW0gc3BlZWRcbiAgICAgIGNvbnN0IHdoZWVsUHJvbWlzZXMgPSB3aGVlbEZpbGVzLm1hcChhc3luYyAod2hlZWxVcmwsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHdoZWVsU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxuaW1wb3J0IG1pY3JvcGlwXG5hd2FpdCBtaWNyb3BpcC5pbnN0YWxsKCcke3doZWVsVXJsfScsIGtlZXBfZ29pbmc9VHJ1ZSlcbnByaW50KGZcIuKchSBXaGVlbCAke2luZGV4ICsgMX0vJHt3aGVlbEZpbGVzLmxlbmd0aH0gaW5zdGFsbGVkXCIpXG5gKTtcbiAgICAgICAgICBjb25zdCB3aGVlbFRpbWUgPSBEYXRlLm5vdygpIC0gd2hlZWxTdGFydFRpbWU7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKaoSBXaGVlbCAke2luZGV4ICsgMX0gaW5zdGFsbGVkIGluICR7d2hlZWxUaW1lfW1zYCk7XG4gICAgICAgICAgcmV0dXJuIHsgaW5kZXgsIHN1Y2Nlc3M6IHRydWUsIHRpbWU6IHdoZWVsVGltZSB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnN0IHdoZWVsVGltZSA9IERhdGUubm93KCkgLSB3aGVlbFN0YXJ0VGltZTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBXaGVlbCAke2luZGV4ICsgMX0gZmFpbGVkIGFmdGVyICR7d2hlZWxUaW1lfW1zOmAsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm4geyBpbmRleCwgc3VjY2VzczogZmFsc2UsIHRpbWU6IHdoZWVsVGltZSwgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIGFsbCB3aGVlbCBpbnN0YWxsYXRpb25zXG4gICAgICBjb25zdCB3aGVlbFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh3aGVlbFByb21pc2VzKTtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSB3aGVlbFJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdWNjZXNzKTtcbiAgICAgIGNvbnN0IGZhaWxlZCA9IHdoZWVsUmVzdWx0cy5maWx0ZXIociA9PiAhci5zdWNjZXNzKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYPCfk4ogV2hlZWxzOiAke3N1Y2Nlc3NmdWwubGVuZ3RofS8ke3doZWVsRmlsZXMubGVuZ3RofSBzdWNjZXNzZnVsYCk7XG4gICAgICBpZiAoZmFpbGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gRmFpbGVkIHdoZWVsczogJHtmYWlsZWQubWFwKGYgPT4gZi5pbmRleCArIDEpLmpvaW4oJywgJyl9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNldCB1cCBwaXBsaXRlIGNvbmZpZ3VyYXRpb24gd2l0aCBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zIChpZiBhdmFpbGFibGUpXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxudHJ5OlxuICAgIGltcG9ydCBwaXBsaXRlLnBpcGxpdGVcbiAgICBpbXBvcnQganNvblxuXG4gICAgIyBMb2FkIHBhY2thZ2UgaW5kZXggZm9yIGZhc3RlciBsb29rdXBzXG4gICAgdHJ5OlxuICAgICAgICBwaXBsaXRlLnBpcGxpdGUuUElQTElURV9VUkwgPSBcIiR7YWxsSnNvblBhdGh9XCJcbiAgICAgICAgIyBQcmUtbG9hZCBwYWNrYWdlIGluZGV4IGZvciBmYXN0ZXIgaW5zdGFsbGF0aW9uXG4gICAgICAgIHByaW50KFwi8J+TiyBQYWNrYWdlIGluZGV4IGNvbmZpZ3VyZWRcIilcbiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6XG4gICAgICAgIHByaW50KGZcIuKaoO+4jyBQYWNrYWdlIGluZGV4IHNldHVwIHdhcm5pbmc6IHtlfVwiKVxuXG4gICAgIyBDb25maWd1cmUgcGlwbGl0ZSBmb3Igb3B0aW1hbCBwZXJmb3JtYW5jZVxuICAgIHBpcGxpdGUucGlwbGl0ZS5SRVBPREFUQV9JTkZPID0ge31cbiAgICBwcmludChcIuKaoSBQaXBsaXRlIG9wdGltaXplZCBmb3IgcGVyZm9ybWFuY2VcIilcbmV4Y2VwdCBJbXBvcnRFcnJvcjpcbiAgICBwcmludChcIuKaoO+4jyBQaXBsaXRlIG5vdCBhdmFpbGFibGUsIGNvbnRpbnVpbmcgd2l0aG91dCBpdFwiKVxuZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOlxuICAgIHByaW50KGZcIuKaoO+4jyBQaXBsaXRlIHNldHVwIGZhaWxlZDoge2V9XCIpXG5gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBQaXBsaXRlIGNvbmZpZ3VyYXRpb24gZmFpbGVkLCBjb250aW51aW5nIHdpdGhvdXQgaXQ6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdG90YWxUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIFBhY2thZ2UgbWFuYWdlciBpbml0aWFsaXplZCBpbiAke3RvdGFsVGltZX1tc2ApO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgUGFja2FnZSBtYW5hZ2VyIGluaXRpYWxpemF0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGtlcm5lbCB3aXRoIHJlcXVpcmVkIFB5dGhvbiBwYWNrYWdlc1xuICAgKiBPUFRJTUlaRUQ6IE1heGltdW0gcGFyYWxsZWxpemF0aW9uIHdpdGggaW50ZWxsaWdlbnQgZGVwZW5kZW5jeSByZXNvbHV0aW9uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRLZXJuZWwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zb2xlLmxvZyhcIvCfmoAgSW5pdGlhbGl6aW5nIGtlcm5lbCBwYWNrYWdlcyB3aXRoIG1heGltdW0gb3B0aW1pemF0aW9uLi4uXCIpO1xuICAgIFxuICAgIC8vIEFsbCBwYWNrYWdlcyB0byBpbnN0YWxsIHdpdGggcHJpb3JpdHkgYW5kIGRlcGVuZGVuY3kgaW5mb3JtYXRpb25cbiAgICBjb25zdCBwYWNrYWdlQ29uZmlnID0gW1xuICAgICAgLy8gSGlnaCBwcmlvcml0eTogQ0ROIHBhY2thZ2VzIChmYXN0ZXN0KVxuICAgICAgeyBuYW1lOiAncHVyZS1ldmFsJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdzdGFjay1kYXRhJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdweWdtZW50cycsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnc3NsJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdzcWxpdGUzJywgcHJpb3JpdHk6IDEsIHNvdXJjZTogJ3B5b2RpZGUnIH0sXG4gICAgICB7IG5hbWU6ICdwcm9tcHRfdG9vbGtpdCcsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnamVkaScsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnaXB5dGhvbicsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgXG4gICAgICAvLyBNZWRpdW0gcHJpb3JpdHk6IHBpcCBwYWNrYWdlc1xuICAgICAgeyBuYW1lOiAnY29tbScsIHByaW9yaXR5OiAyLCBzb3VyY2U6ICdwaXAnIH0sXG4gICAgICB7IG5hbWU6ICdoeXBoYS1ycGMnLCBwcmlvcml0eTogMiwgc291cmNlOiAncGlwJyB9LFxuICAgICAgeyBuYW1lOiAnbmJmb3JtYXQnLCBwcmlvcml0eTogMiwgc291cmNlOiAncGlwJyB9LFxuICAgICAgXG4gICAgICAvLyBMb3dlciBwcmlvcml0eTogY29tcGxleCBwYWNrYWdlc1xuICAgICAgeyBuYW1lOiAnaXB5a2VybmVsJywgcHJpb3JpdHk6IDMsIHNvdXJjZTogJ3BpcCcgfSxcbiAgICAgIHsgbmFtZTogJ3B5b2RpZGVfa2VybmVsJywgcHJpb3JpdHk6IDMsIHNvdXJjZTogJ3BpcCcgfVxuICAgIF07XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCfk6YgSW5zdGFsbGluZyAke3BhY2thZ2VDb25maWcubGVuZ3RofSBwYWNrYWdlcyB3aXRoIGludGVsbGlnZW50IG9wdGltaXphdGlvbi4uLmApO1xuICAgICAgXG4gICAgICAvLyBJbnN0YWxsIEFMTCBwYWNrYWdlcyBpbiBwYXJhbGxlbCB3aXRoIGFkdmFuY2VkIGVycm9yIGhhbmRsaW5nIGFuZCBjYWNoaW5nXG4gICAgICBhd2FpdCB0aGlzLmluc3RhbGxQYWNrYWdlc1dpdGhJbnRlbGxpZ2VudE9wdGltaXphdGlvbihwYWNrYWdlQ29uZmlnKTtcbiAgICAgIFxuICAgICAgLy8gSW1wb3J0IHRoZSBrZXJuZWwgKG11c3QgYmUgZG9uZSBhZnRlciBwYWNrYWdlcyBhcmUgaW5zdGFsbGVkKVxuICAgICAgY29uc29sZS5sb2coXCLwn5OlIEltcG9ydGluZyBweW9kaWRlX2tlcm5lbC4uLlwiKTtcbiAgICAgIGNvbnN0IGltcG9ydFN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoJ2ltcG9ydCBweW9kaWRlX2tlcm5lbCcpO1xuICAgICAgY29uc3QgaW1wb3J0VGltZSA9IERhdGUubm93KCkgLSBpbXBvcnRTdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg4pyFIHB5b2RpZGVfa2VybmVsIGltcG9ydGVkIGluICR7aW1wb3J0VGltZX1tc2ApO1xuICAgICAgXG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYPCfjq8gS2VybmVsIHBhY2thZ2VzIGluaXRpYWxpemVkIGluICR7dG90YWxUaW1lfW1zYCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBLZXJuZWwgcGFja2FnZSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEluc3RhbGwgcGFja2FnZXMgd2l0aCBpbnRlbGxpZ2VudCBvcHRpbWl6YXRpb24gYW5kIGFkdmFuY2VkIGNhY2hpbmdcbiAgICogT1BUSU1JWkVEOiBTbWFydCBzb3VyY2Ugc2VsZWN0aW9uLCBwYXJhbGxlbCBpbnN0YWxsYXRpb24sIGFuZCBwZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluc3RhbGxQYWNrYWdlc1dpdGhJbnRlbGxpZ2VudE9wdGltaXphdGlvbihwYWNrYWdlQ29uZmlnOiBBcnJheTx7bmFtZTogc3RyaW5nLCBwcmlvcml0eTogbnVtYmVyLCBzb3VyY2U6IHN0cmluZ30+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coYOKaoSBTdGFydGluZyBpbnRlbGxpZ2VudCBwYXJhbGxlbCBpbnN0YWxsYXRpb24gb2YgJHtwYWNrYWdlQ29uZmlnLmxlbmd0aH0gcGFja2FnZXMuLi5gKTtcbiAgICBcbiAgICBjb25zdCBpbnN0YWxsUHJvbWlzZXMgPSBwYWNrYWdlQ29uZmlnLm1hcChhc3luYyAocGtnKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgSW5zdGFsbGluZyAke3BrZy5uYW1lfSAocHJpb3JpdHk6ICR7cGtnLnByaW9yaXR5fSwgcHJlZmVycmVkOiAke3BrZy5zb3VyY2V9KS4uLmApO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHByZWZlcnJlZCBzb3VyY2UgZmlyc3QsIHdpdGggaW50ZWxsaWdlbnQgZmFsbGJhY2tcbiAgICAgICAgaWYgKHBrZy5zb3VyY2UgPT09ICdweW9kaWRlJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUubG9hZFBhY2thZ2UoW3BrZy5uYW1lXSk7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7cGtnLm5hbWV9IGxvYWRlZCBmcm9tIFB5b2RpZGUgQ0ROICgke2R1cmF0aW9ufW1zKWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFja2FnZTogcGtnLm5hbWUsIG1ldGhvZDogJ3B5b2RpZGUnLCBkdXJhdGlvbiwgc3VjY2VzczogdHJ1ZSwgcHJpb3JpdHk6IHBrZy5wcmlvcml0eSB9O1xuICAgICAgICAgIH0gY2F0Y2ggKHB5b2RpZGVFcnJvcikge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcGlwIHdpdGggZW5oYW5jZWQgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OmICR7cGtnLm5hbWV9IG5vdCBhdmFpbGFibGUgb24gQ0ROLCB0cnlpbmcgcGlwLi4uYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluc3RhbGxWaWFQaXBXaXRoT3B0aW1pemF0aW9ucyhwa2cubmFtZSk7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7cGtnLm5hbWV9IGluc3RhbGxlZCB2aWEgcGlwIGZhbGxiYWNrICgke2R1cmF0aW9ufW1zKWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFja2FnZTogcGtnLm5hbWUsIG1ldGhvZDogJ3BpcC1mYWxsYmFjaycsIGR1cmF0aW9uLCBzdWNjZXNzOiB0cnVlLCBwcmlvcml0eTogcGtnLnByaW9yaXR5IH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERpcmVjdCBwaXAgaW5zdGFsbGF0aW9uIHdpdGggb3B0aW1pemF0aW9uc1xuICAgICAgICAgIGF3YWl0IHRoaXMuaW5zdGFsbFZpYVBpcFdpdGhPcHRpbWl6YXRpb25zKHBrZy5uYW1lKTtcbiAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSAke3BrZy5uYW1lfSBpbnN0YWxsZWQgdmlhIHBpcCAoJHtkdXJhdGlvbn1tcylgKTtcbiAgICAgICAgICByZXR1cm4geyBwYWNrYWdlOiBwa2cubmFtZSwgbWV0aG9kOiAncGlwJywgZHVyYXRpb24sIHN1Y2Nlc3M6IHRydWUsIHByaW9yaXR5OiBwa2cucHJpb3JpdHkgfTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICBjb25zb2xlLndhcm4oYOKdjCBGYWlsZWQgdG8gaW5zdGFsbCAke3BrZy5uYW1lfSBhZnRlciAke2R1cmF0aW9ufW1zOmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgcGFja2FnZTogcGtnLm5hbWUsIG1ldGhvZDogJ2ZhaWxlZCcsIGR1cmF0aW9uLCBzdWNjZXNzOiBmYWxzZSwgcHJpb3JpdHk6IHBrZy5wcmlvcml0eSwgZXJyb3IgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBXYWl0IGZvciBhbGwgaW5zdGFsbGF0aW9ucyB3aXRoIGRldGFpbGVkIGFuYWx5c2lzXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGluc3RhbGxQcm9taXNlcyk7XG4gICAgXG4gICAgLy8gQ29tcHJlaGVuc2l2ZSBwZXJmb3JtYW5jZSBhbmFseXNpc1xuICAgIHRoaXMuYW5hbHl6ZUluc3RhbGxhdGlvblJlc3VsdHMocmVzdWx0cyk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbnN0YWxsIHBhY2thZ2UgdmlhIHBpcCB3aXRoIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnNcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5zdGFsbFZpYVBpcFdpdGhPcHRpbWl6YXRpb25zKHBhY2thZ2VOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxudHJ5OlxuICAgICMgSW1wb3J0IHBpcGxpdGUgZmlyc3RcbiAgICBpbXBvcnQgcGlwbGl0ZVxuICAgICMgVXNlIG9wdGltaXplZCBwaXAgaW5zdGFsbGF0aW9uIHdpdGggY2FjaGluZ1xuICAgIGF3YWl0IHBpcGxpdGUuaW5zdGFsbCgnJHtwYWNrYWdlTmFtZX0nLCBrZWVwX2dvaW5nPVRydWUsIGRlcHM9VHJ1ZSlcbiAgICBwcmludChcIuKchSBTdWNjZXNzZnVsbHkgaW5zdGFsbGVkICR7cGFja2FnZU5hbWV9IHZpYSBvcHRpbWl6ZWQgcGlwXCIpXG5leGNlcHQgRXhjZXB0aW9uIGFzIGU6XG4gICAgcHJpbnQoXCLimqDvuI8gV2FybmluZzogRmFpbGVkIHRvIGluc3RhbGwgJHtwYWNrYWdlTmFtZX06XCIsIHN0cihlKSlcbiAgICAjIFRyeSBhbHRlcm5hdGl2ZSBpbnN0YWxsYXRpb24gbWV0aG9kXG4gICAgdHJ5OlxuICAgICAgICBpbXBvcnQgbWljcm9waXBcbiAgICAgICAgYXdhaXQgbWljcm9waXAuaW5zdGFsbCgnJHtwYWNrYWdlTmFtZX0nLCBrZWVwX2dvaW5nPVRydWUpXG4gICAgICAgIHByaW50KFwi4pyFIFN1Y2Nlc3NmdWxseSBpbnN0YWxsZWQgJHtwYWNrYWdlTmFtZX0gdmlhIG1pY3JvcGlwIGZhbGxiYWNrXCIpXG4gICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlMjpcbiAgICAgICAgcHJpbnQoXCLinYwgQm90aCBwaXAgbWV0aG9kcyBmYWlsZWQgZm9yICR7cGFja2FnZU5hbWV9OlwiLCBzdHIoZTIpKVxuICAgICAgICByYWlzZSBlMlxuYCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBBbmFseXplIGluc3RhbGxhdGlvbiByZXN1bHRzIGFuZCBwcm92aWRlIHBlcmZvcm1hbmNlIGluc2lnaHRzXG4gICAqL1xuICBwcml2YXRlIGFuYWx5emVJbnN0YWxsYXRpb25SZXN1bHRzKHJlc3VsdHM6IEFycmF5PGFueT4pOiB2b2lkIHtcbiAgICBjb25zdCBzdWNjZXNzZnVsID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN1Y2Nlc3MpO1xuICAgIGNvbnN0IGZhaWxlZCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gIXIuc3VjY2Vzcyk7XG4gICAgY29uc3QgcHlvZGlkZUluc3RhbGxzID0gc3VjY2Vzc2Z1bC5maWx0ZXIociA9PiByLm1ldGhvZCA9PT0gJ3B5b2RpZGUnKTtcbiAgICBjb25zdCBwaXBJbnN0YWxscyA9IHN1Y2Nlc3NmdWwuZmlsdGVyKHIgPT4gci5tZXRob2QgPT09ICdwaXAnKTtcbiAgICBjb25zdCBmYWxsYmFja0luc3RhbGxzID0gc3VjY2Vzc2Z1bC5maWx0ZXIociA9PiByLm1ldGhvZCA9PT0gJ3BpcC1mYWxsYmFjaycpO1xuICAgIFxuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBNYXRoLm1heCguLi5yZXN1bHRzLm1hcChyID0+IHIuZHVyYXRpb24pKTtcbiAgICBjb25zdCBhdmdEdXJhdGlvbiA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuZHVyYXRpb24sIDApIC8gcmVzdWx0cy5sZW5ndGg7XG4gICAgY29uc3QgZXN0aW1hdGVkU2VxdWVudGlhbCA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuZHVyYXRpb24sIDApO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn46vIElOVEVMTElHRU5UIElOU1RBTExBVElPTiBDT01QTEVURSFgKTtcbiAgICBjb25zb2xlLmxvZyhg8J+TiiBSZXN1bHRzOiAke3N1Y2Nlc3NmdWwubGVuZ3RofS8ke3Jlc3VsdHMubGVuZ3RofSBzdWNjZXNzZnVsYCk7XG4gICAgY29uc29sZS5sb2coYOKaoSBQeW9kaWRlIENETjogJHtweW9kaWRlSW5zdGFsbHMubGVuZ3RofSBwYWNrYWdlc2ApO1xuICAgIGNvbnNvbGUubG9nKGDwn5OmIERpcmVjdCBwaXA6ICR7cGlwSW5zdGFsbHMubGVuZ3RofSBwYWNrYWdlc2ApO1xuICAgIGNvbnNvbGUubG9nKGDwn5SEIFBpcCBmYWxsYmFjazogJHtmYWxsYmFja0luc3RhbGxzLmxlbmd0aH0gcGFja2FnZXNgKTtcbiAgICBjb25zb2xlLmxvZyhg4p2MIEZhaWxlZDogJHtmYWlsZWQubGVuZ3RofSBwYWNrYWdlc2ApO1xuICAgIGNvbnNvbGUubG9nKGDij7HvuI8gIFRvdGFsIHRpbWU6ICR7dG90YWxEdXJhdGlvbn1tcyAodnMgfiR7ZXN0aW1hdGVkU2VxdWVudGlhbH1tcyBzZXF1ZW50aWFsKWApO1xuICAgIGNvbnNvbGUubG9nKGDwn5qAIFNwZWVkIGltcHJvdmVtZW50OiB+JHtNYXRoLnJvdW5kKGVzdGltYXRlZFNlcXVlbnRpYWwgLyB0b3RhbER1cmF0aW9uKX14IGZhc3RlcmApO1xuICAgIGNvbnNvbGUubG9nKGDwn5OIIEF2ZXJhZ2UgcGVyIHBhY2thZ2U6ICR7TWF0aC5yb3VuZChhdmdEdXJhdGlvbil9bXNgKTtcbiAgICBcbiAgICBpZiAoZmFpbGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPICBGYWlsZWQgcGFja2FnZXM6ICR7ZmFpbGVkLm1hcChmID0+IGYucGFja2FnZSkuam9pbignLCAnKX1gKTtcbiAgICAgIC8vIExvZyBzcGVjaWZpYyBmYWlsdXJlIHJlYXNvbnMgZm9yIGRlYnVnZ2luZ1xuICAgICAgZmFpbGVkLmZvckVhY2goZiA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihgICAgLSAke2YucGFja2FnZX06ICR7Zi5lcnJvcj8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gUGVyZm9ybWFuY2UgaW5zaWdodHNcbiAgICBjb25zdCBmYXN0ZXN0SW5zdGFsbCA9IE1hdGgubWluKC4uLnN1Y2Nlc3NmdWwubWFwKHIgPT4gci5kdXJhdGlvbikpO1xuICAgIGNvbnN0IHNsb3dlc3RJbnN0YWxsID0gTWF0aC5tYXgoLi4uc3VjY2Vzc2Z1bC5tYXAociA9PiByLmR1cmF0aW9uKSk7XG4gICAgY29uc29sZS5sb2coYPCfk4ogUGVyZm9ybWFuY2UgcmFuZ2U6ICR7ZmFzdGVzdEluc3RhbGx9bXMgKGZhc3Rlc3QpIHRvICR7c2xvd2VzdEluc3RhbGx9bXMgKHNsb3dlc3QpYCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGdsb2JhbCBvYmplY3RzIGZyb20gdGhlIHB5b2RpZGVfa2VybmVsIHBhY2thZ2VcbiAgICogQmFzZWQgb24gdGhlIFB5b2RpZGVSZW1vdGVLZXJuZWwgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5pdEdsb2JhbHMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coXCJJbml0aWFsaXppbmcgZ2xvYmFscy4uLlwiKTtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGdsb2JhbHMgZnJvbSB0aGUgUHl0aG9uIGVudmlyb25tZW50XG4gICAgY29uc3QgeyBnbG9iYWxzIH0gPSB0aGlzLnB5b2RpZGU7XG4gICAgXG4gICAgLy8gR2V0IHRoZSBrZXJuZWwgaW5zdGFuY2UgYW5kIHJlbGF0ZWQgb2JqZWN0c1xuICAgIHRoaXMuX2tlcm5lbCA9IGdsb2JhbHMuZ2V0KCdweW9kaWRlX2tlcm5lbCcpLmtlcm5lbF9pbnN0YW5jZS5jb3B5KCk7XG4gICAgdGhpcy5fc3Rkb3V0X3N0cmVhbSA9IGdsb2JhbHMuZ2V0KCdweW9kaWRlX2tlcm5lbCcpLnN0ZG91dF9zdHJlYW0uY29weSgpO1xuICAgIHRoaXMuX3N0ZGVycl9zdHJlYW0gPSBnbG9iYWxzLmdldCgncHlvZGlkZV9rZXJuZWwnKS5zdGRlcnJfc3RyZWFtLmNvcHkoKTtcbiAgICB0aGlzLl9pbnRlcnByZXRlciA9IHRoaXMuX2tlcm5lbC5pbnRlcnByZXRlci5jb3B5KCk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGNvbW11bmljYXRpb24gaGFuZGxlcnNcbiAgICB0aGlzLl9pbnRlcnByZXRlci5zZW5kX2NvbW0gPSB0aGlzLnNlbmRDb21tLmJpbmQodGhpcyk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGNhbGxiYWNrc1xuICAgIHRoaXMuc2V0dXBDYWxsYmFja3MoKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNldHVwIGFsbCBuZWNlc3NhcnkgY2FsbGJhY2tzIGZvciB0aGUgUHl0aG9uIGVudmlyb25tZW50XG4gICAqL1xuICBwcml2YXRlIHNldHVwQ2FsbGJhY2tzKCk6IHZvaWQge1xuICAgIC8vIEV4ZWN1dGlvbiByZXN1bHQgY2FsbGJhY2tcbiAgICBjb25zdCBwdWJsaXNoRXhlY3V0aW9uUmVzdWx0ID0gKFxuICAgICAgcHJvbXB0X2NvdW50OiBhbnksXG4gICAgICBkYXRhOiBhbnksXG4gICAgICBtZXRhZGF0YTogYW55LFxuICAgICk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgYnVuZGxlID0ge1xuICAgICAgICBleGVjdXRpb25fY291bnQ6IHByb21wdF9jb3VudCxcbiAgICAgICAgZGF0YTogdGhpcy5mb3JtYXRSZXN1bHQoZGF0YSksXG4gICAgICAgIG1ldGFkYXRhOiB0aGlzLmZvcm1hdFJlc3VsdChtZXRhZGF0YSksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgICAgICBidW5kbGUsXG4gICAgICAgIHR5cGU6ICdleGVjdXRlX3Jlc3VsdCcsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRXJyb3IgY2FsbGJhY2tcbiAgICBjb25zdCBwdWJsaXNoRXhlY3V0aW9uRXJyb3IgPSAoZW5hbWU6IGFueSwgZXZhbHVlOiBhbnksIHRyYWNlYmFjazogYW55KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSB7XG4gICAgICAgIGVuYW1lOiBlbmFtZSxcbiAgICAgICAgZXZhbHVlOiBldmFsdWUsXG4gICAgICAgIHRyYWNlYmFjazogdHJhY2ViYWNrLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgYnVuZGxlLFxuICAgICAgICAgIHR5cGU6ICdleGVjdXRlX2Vycm9yJyxcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBDbGVhciBvdXRwdXQgY2FsbGJhY2tcbiAgICBjb25zdCBjbGVhck91dHB1dENhbGxiYWNrID0gKHdhaXQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICAgICAgd2FpdDogdGhpcy5mb3JtYXRSZXN1bHQod2FpdCksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgICAgICBidW5kbGUsXG4gICAgICAgICAgdHlwZTogJ2NsZWFyX291dHB1dCcsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRGlzcGxheSBkYXRhIGNhbGxiYWNrXG4gICAgY29uc3QgZGlzcGxheURhdGFDYWxsYmFjayA9IChkYXRhOiBhbnksIG1ldGFkYXRhOiBhbnksIHRyYW5zaWVudDogYW55KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSB7XG4gICAgICAgIGRhdGE6IHRoaXMuZm9ybWF0UmVzdWx0KGRhdGEpLFxuICAgICAgICBtZXRhZGF0YTogdGhpcy5mb3JtYXRSZXN1bHQobWV0YWRhdGEpLFxuICAgICAgICB0cmFuc2llbnQ6IHRoaXMuZm9ybWF0UmVzdWx0KHRyYW5zaWVudCksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgICAgICBidW5kbGUsXG4gICAgICAgIHR5cGU6ICdkaXNwbGF5X2RhdGEnLFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSBkaXNwbGF5IGRhdGEgY2FsbGJhY2tcbiAgICBjb25zdCB1cGRhdGVEaXNwbGF5RGF0YUNhbGxiYWNrID0gKFxuICAgICAgZGF0YTogYW55LFxuICAgICAgbWV0YWRhdGE6IGFueSxcbiAgICAgIHRyYW5zaWVudDogYW55LFxuICAgICk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgYnVuZGxlID0ge1xuICAgICAgICBkYXRhOiB0aGlzLmZvcm1hdFJlc3VsdChkYXRhKSxcbiAgICAgICAgbWV0YWRhdGE6IHRoaXMuZm9ybWF0UmVzdWx0KG1ldGFkYXRhKSxcbiAgICAgICAgdHJhbnNpZW50OiB0aGlzLmZvcm1hdFJlc3VsdCh0cmFuc2llbnQpLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgYnVuZGxlLFxuICAgICAgICB0eXBlOiAndXBkYXRlX2Rpc3BsYXlfZGF0YScsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gU3RyZWFtIGNhbGxiYWNrXG4gICAgY29uc3QgcHVibGlzaFN0cmVhbUNhbGxiYWNrID0gKG5hbWU6IGFueSwgdGV4dDogYW55KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMuZm9ybWF0UmVzdWx0KG5hbWUpLFxuICAgICAgICB0ZXh0OiB0aGlzLmZvcm1hdFJlc3VsdCh0ZXh0KSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgcGFyZW50SGVhZGVyOiB0aGlzLmZvcm1hdFJlc3VsdCh0aGlzLl9wYXJlbnRfaGVhZGVyKVsnaGVhZGVyJ10sXG4gICAgICAgIGJ1bmRsZSxcbiAgICAgICAgdHlwZTogJ3N0cmVhbScsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQXNzaWduIGNhbGxiYWNrcyB0byB0aGUgUHl0aG9uIG9iamVjdHNcbiAgICB0aGlzLl9zdGRvdXRfc3RyZWFtLnB1Ymxpc2hfc3RyZWFtX2NhbGxiYWNrID0gcHVibGlzaFN0cmVhbUNhbGxiYWNrO1xuICAgIHRoaXMuX3N0ZGVycl9zdHJlYW0ucHVibGlzaF9zdHJlYW1fY2FsbGJhY2sgPSBwdWJsaXNoU3RyZWFtQ2FsbGJhY2s7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuZGlzcGxheV9wdWIuY2xlYXJfb3V0cHV0X2NhbGxiYWNrID0gY2xlYXJPdXRwdXRDYWxsYmFjaztcbiAgICB0aGlzLl9pbnRlcnByZXRlci5kaXNwbGF5X3B1Yi5kaXNwbGF5X2RhdGFfY2FsbGJhY2sgPSBkaXNwbGF5RGF0YUNhbGxiYWNrO1xuICAgIHRoaXMuX2ludGVycHJldGVyLmRpc3BsYXlfcHViLnVwZGF0ZV9kaXNwbGF5X2RhdGFfY2FsbGJhY2sgPSB1cGRhdGVEaXNwbGF5RGF0YUNhbGxiYWNrO1xuICAgIHRoaXMuX2ludGVycHJldGVyLmRpc3BsYXlob29rLnB1Ymxpc2hfZXhlY3V0aW9uX3Jlc3VsdCA9IHB1Ymxpc2hFeGVjdXRpb25SZXN1bHQ7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuaW5wdXQgPSB0aGlzLmlucHV0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuZ2V0cGFzcyA9IHRoaXMuZ2V0cGFzcy5iaW5kKHRoaXMpO1xuICB9XG4gIFxuICAvKipcbiAgICogUHJvY2VzcyBhIG1lc3NhZ2UgZnJvbSBQeXRob24gZW52aXJvbm1lbnRcbiAgICovXG4gIHByaXZhdGUgX3NlbmRNZXNzYWdlKG1zZzogSU1lc3NhZ2UpOiB2b2lkIHtcbiAgICB0aGlzLl9wcm9jZXNzTWVzc2FnZShtc2cpO1xuICB9XG4gIFxuICAvKipcbiAgICogUHJvY2VzcyBhIG1lc3NhZ2UgYnkgZW1pdHRpbmcgdGhlIGFwcHJvcHJpYXRlIGV2ZW50XG4gICAqL1xuICBwcml2YXRlIF9wcm9jZXNzTWVzc2FnZShtc2c6IElNZXNzYWdlKTogdm9pZCB7XG4gICAgaWYgKCFtc2cudHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBldmVudERhdGE6IGFueTtcblxuICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmVhbSc6IHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbXNnLmJ1bmRsZSA/PyB7IG5hbWU6ICdzdGRvdXQnLCB0ZXh0OiAnJyB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5TVFJFQU0sIGJ1bmRsZSk7XG4gICAgICAgIGV2ZW50RGF0YSA9IGJ1bmRsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdpbnB1dF9yZXF1ZXN0Jzoge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gbXNnLmNvbnRlbnQgPz8geyBwcm9tcHQ6ICcnLCBwYXNzd29yZDogZmFsc2UgfTtcbiAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuSU5QVVRfUkVRVUVTVCwgY29udGVudCk7XG4gICAgICAgIGV2ZW50RGF0YSA9IGNvbnRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZGlzcGxheV9kYXRhJzoge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBtc2cuYnVuZGxlID8/IHsgZGF0YToge30sIG1ldGFkYXRhOiB7fSwgdHJhbnNpZW50OiB7fSB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5ESVNQTEFZX0RBVEEsIGJ1bmRsZSk7XG4gICAgICAgIGV2ZW50RGF0YSA9IGJ1bmRsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICd1cGRhdGVfZGlzcGxheV9kYXRhJzoge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBtc2cuYnVuZGxlID8/IHsgZGF0YToge30sIG1ldGFkYXRhOiB7fSwgdHJhbnNpZW50OiB7fSB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5VUERBVEVfRElTUExBWV9EQVRBLCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnY2xlYXJfb3V0cHV0Jzoge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBtc2cuYnVuZGxlID8/IHsgd2FpdDogZmFsc2UgfTtcbiAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuQ0xFQVJfT1VUUFVULCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZXhlY3V0ZV9yZXN1bHQnOiB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IG1zZy5idW5kbGUgPz8ge1xuICAgICAgICAgIGV4ZWN1dGlvbl9jb3VudDogdGhpcy5leGVjdXRpb25Db3VudCxcbiAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfUkVTVUxULCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZXhlY3V0ZV9lcnJvcic6IHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbXNnLmJ1bmRsZSA/PyB7IGVuYW1lOiAnJywgZXZhbHVlOiAnJywgdHJhY2ViYWNrOiBbXSB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnY29tbV9vcGVuJzpcbiAgICAgIGNhc2UgJ2NvbW1fbXNnJzpcbiAgICAgIGNhc2UgJ2NvbW1fY2xvc2UnOiB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBtc2cuY29udGVudCA/PyB7fTtcbiAgICAgICAgc3VwZXIuZW1pdChtc2cudHlwZSwgY29udGVudCwgbXNnLm1ldGFkYXRhLCBtc2cuYnVmZmVycyk7XG4gICAgICAgIGV2ZW50RGF0YSA9IHtcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIG1ldGFkYXRhOiBtc2cubWV0YWRhdGEsXG4gICAgICAgICAgYnVmZmVyczogbXNnLmJ1ZmZlcnNcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW1pdCB0aGUgQUxMIGV2ZW50IHdpdGggc3RhbmRhcmRpemVkIGZvcm1hdFxuICAgIGlmIChldmVudERhdGEpIHtcbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkFMTCwge1xuICAgICAgICB0eXBlOiBtc2cudHlwZSxcbiAgICAgICAgZGF0YTogZXZlbnREYXRhXG4gICAgICB9IGFzIElFdmVudERhdGEpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBrZXJuZWwgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbiAgICovXG4gIHB1YmxpYyBpc0luaXRpYWxpemVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVkO1xuICB9XG4gIFxuICAvKipcbiAgICogTWFrZXMgc3VyZSBweW9kaWRlIGlzIHJlYWR5IGJlZm9yZSBjb250aW51aW5nLCBhbmQgY2FjaGUgdGhlIHBhcmVudCBtZXNzYWdlLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZXR1cChwYXJlbnQ6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIHRoaXMuX3BhcmVudF9oZWFkZXIgPSB0aGlzLnB5b2RpZGUudG9QeShwYXJlbnQgfHwge30pO1xuICB9XG4gIFxuICAvKipcbiAgICogRXhlY3V0ZSBjb2RlIGluIHRoZSBrZXJuZWwgd2l0aCBwcm9wZXIgbWVzc2FnZS1iYXNlZCBjb21wbGV0aW9uIGRldGVjdGlvblxuICAgKiBcbiAgICogQHBhcmFtIGNvZGUgVGhlIGNvZGUgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0gcGFyZW50IFBhcmVudCBtZXNzYWdlIGhlYWRlclxuICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBleGVjdXRpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBleGVjdXRlKGNvZGU6IHN0cmluZywgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuLCBvdXRwdXRzPzogYW55LCBlcnJvcj86IEVycm9yLCBlbmFtZT86IHN0cmluZywgZXZhbHVlPzogc3RyaW5nLCB0cmFjZWJhY2s/OiBhbnkgfT4ge1xuICAgIC8vIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiB0aGF0IGNvbGxlY3RzIGFsbCBvdXRwdXRzIGZyb20gZXhlY3V0ZVN0cmVhbVxuICAgIGNvbnN0IG91dHB1dHM6IGFueVtdID0gW107XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBleGVjdXRlU3RyZWFtIHRvIGdldCBhbGwgb3V0cHV0c1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBvdXRwdXQgb2YgdGhpcy5leGVjdXRlU3RyZWFtKGNvZGUsIHBhcmVudCkpIHtcbiAgICAgICAgb3V0cHV0cy5wdXNoKG91dHB1dCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgY29sbGVjdGVkIG91dHB1dHMgdG8gY3JlYXRlIGEgY29tcHJlaGVuc2l2ZSByZXN1bHRcbiAgICAgIGNvbnN0IHJlc3VsdDogYW55ID0ge1xuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgZGF0YToge30sXG4gICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgZXhlY3V0aW9uX2NvdW50OiB0aGlzLmV4ZWN1dGlvbkNvdW50XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBDb2xsZWN0IGFsbCBvdXRwdXQgdHlwZXNcbiAgICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgICAgaWYgKG91dHB1dC50eXBlID09PSAnc3RyZWFtJykge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc3Rkb3V0L3N0ZGVyclxuICAgICAgICAgIGlmICghcmVzdWx0LnN0ZG91dCkgcmVzdWx0LnN0ZG91dCA9ICcnO1xuICAgICAgICAgIGlmICghcmVzdWx0LnN0ZGVycikgcmVzdWx0LnN0ZGVyciA9ICcnO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChvdXRwdXQuZGF0YS5uYW1lID09PSAnc3Rkb3V0Jykge1xuICAgICAgICAgICAgcmVzdWx0LnN0ZG91dCArPSBvdXRwdXQuZGF0YS50ZXh0O1xuICAgICAgICAgIH0gZWxzZSBpZiAob3V0cHV0LmRhdGEubmFtZSA9PT0gJ3N0ZGVycicpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGRlcnIgKz0gb3V0cHV0LmRhdGEudGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0Lm91dHB1dHMucHVzaChvdXRwdXQuZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3V0cHV0LnR5cGUgPT09ICdkaXNwbGF5X2RhdGEnIHx8IG91dHB1dC50eXBlID09PSAnZXhlY3V0ZV9yZXN1bHQnKSB7XG4gICAgICAgICAgLy8gQ29sbGVjdCBkaXNwbGF5IGRhdGFcbiAgICAgICAgICBpZiAob3V0cHV0LmRhdGEuZGF0YSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQuZGF0YSwgb3V0cHV0LmRhdGEuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdXRwdXQuZGF0YS5tZXRhZGF0YSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQubWV0YWRhdGEsIG91dHB1dC5kYXRhLm1ldGFkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0Lm91dHB1dHMucHVzaChvdXRwdXQuZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3V0cHV0LnR5cGUgPT09ICdleGVjdXRlX2Vycm9yJyB8fCBvdXRwdXQudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgIC8vIEhhbmRsZSBlcnJvcnNcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBvdXRwdXQuZGF0YTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGAke2Vycm9yRGF0YS5lbmFtZX06ICR7ZXJyb3JEYXRhLmV2YWx1ZX1gKSxcbiAgICAgICAgICAgIGVuYW1lOiBlcnJvckRhdGEuZW5hbWUsXG4gICAgICAgICAgICBldmFsdWU6IGVycm9yRGF0YS5ldmFsdWUsXG4gICAgICAgICAgICB0cmFjZWJhY2s6IGVycm9yRGF0YS50cmFjZWJhY2ssXG4gICAgICAgICAgICBvdXRwdXRzOiByZXN1bHQub3V0cHV0c1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU3RvcmUgYW55IG90aGVyIG91dHB1dCB0eXBlXG4gICAgICAgICAgcmVzdWx0Lm91dHB1dHMucHVzaChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZXR1cm4gY29sbGVjdGVkIHJlc3VsdHNcbiAgICAgIHJlc3VsdC5zdWNjZXNzID0gdHJ1ZTtcblxuICAgICAgLy8gQXV0by1zeW5jIG5hdGl2ZSBmaWxlc3lzdGVtcyBpZiBlbmFibGVkXG4gICAgICBpZiAodGhpcy5hdXRvU3luY0ZzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3luY0FsbE5hdGl2ZUZzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltLRVJORUxdIEV4ZWN1dGUgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEZvcm1hdCB0aGUgcmVzdWx0IGZyb20gdGhlIFB5b2RpZGUgZXZhbHVhdGlvblxuICAgKiBCYXNlZCBvbiBQeW9kaWRlUmVtb3RlS2VybmVsIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBwcml2YXRlIGZvcm1hdFJlc3VsdChyZXM6IGFueSk6IGFueSB7XG4gICAgaWYgKCEocmVzIGluc3RhbmNlb2YgdGhpcy5weW9kaWRlLmZmaS5QeVByb3h5KSkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnZlcnQgUHlQcm94eSB0byBKU1xuICAgICAgY29uc3QgbSA9IHJlcy50b0pzKCk7XG4gICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5tYXBUb09iamVjdChtKTtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZm9ybWF0dGluZyByZXN1bHQ6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgTWFwIHRvIGEgSmF2YVNjcmlwdCBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICogQmFzZWQgb24gUHlvZGlkZVJlbW90ZUtlcm5lbCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBtYXBUb09iamVjdChvYmo6IGFueSkge1xuICAgIGNvbnN0IG91dDogYW55ID0gb2JqIGluc3RhbmNlb2YgQXJyYXkgPyBbXSA6IHt9O1xuICAgIFxuICAgIG9iai5mb3JFYWNoKCh2YWx1ZTogYW55LCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgb3V0W2tleV0gPSBcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgID8gdGhpcy5tYXBUb09iamVjdCh2YWx1ZSlcbiAgICAgICAgICA6IHZhbHVlO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBIYW5kbGUgaW5wdXQgcmVwbHkgZnJvbSB1c2VyXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW5wdXRSZXBseShjb250ZW50OiB7IHZhbHVlOiBzdHJpbmcgfSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLl9yZXNvbHZlSW5wdXRSZXBseSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZUlucHV0UmVwbHkoY29udGVudCk7XG4gICAgICB0aGlzLl9yZXNvbHZlSW5wdXRSZXBseSA9IG51bGw7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogU2VuZCBhIGlucHV0IHJlcXVlc3QgdG8gdGhlIGZyb250LWVuZC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc2VuZElucHV0UmVxdWVzdChwcm9tcHQ6IHN0cmluZywgcGFzc3dvcmQ6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjb250ZW50ID0ge1xuICAgICAgcHJvbXB0LFxuICAgICAgcGFzc3dvcmQsXG4gICAgfTtcblxuICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgIHR5cGU6ICdpbnB1dF9yZXF1ZXN0JyxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwYXNzd29yZCBpbnB1dCAod2l0aCBoaWRkZW4gaW5wdXQpXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldHBhc3MocHJvbXB0OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHByb21wdCA9IHR5cGVvZiBwcm9tcHQgPT09ICd1bmRlZmluZWQnID8gJycgOiBwcm9tcHQ7XG4gICAgYXdhaXQgdGhpcy5zZW5kSW5wdXRSZXF1ZXN0KHByb21wdCwgdHJ1ZSk7XG4gICAgY29uc3QgcmVwbHlQcm9taXNlID0gbmV3IFByb21pc2U8eyB2YWx1ZTogc3RyaW5nIH0+KChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9yZXNvbHZlSW5wdXRSZXBseSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwbHlQcm9taXNlO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRleHQgaW5wdXRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5wdXQocHJvbXB0OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHByb21wdCA9IHR5cGVvZiBwcm9tcHQgPT09ICd1bmRlZmluZWQnID8gJycgOiBwcm9tcHQ7XG4gICAgYXdhaXQgdGhpcy5zZW5kSW5wdXRSZXF1ZXN0KHByb21wdCwgZmFsc2UpO1xuICAgIGNvbnN0IHJlcGx5UHJvbWlzZSA9IG5ldyBQcm9taXNlPHsgdmFsdWU6IHN0cmluZyB9PigocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZUlucHV0UmVwbHkgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGx5UHJvbWlzZTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICB9XG4gIFxuICAvKipcbiAgICogU2VuZCBhIGNvbW0gbWVzc2FnZSB0byB0aGUgZnJvbnQtZW5kLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZW5kQ29tbSh0eXBlOiBzdHJpbmcsIGNvbnRlbnQ6IGFueSwgbWV0YWRhdGE6IGFueSwgaWRlbnQ6IGFueSwgYnVmZmVyczogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuZm9ybWF0UmVzdWx0KGNvbnRlbnQpLFxuICAgICAgbWV0YWRhdGE6IHRoaXMuZm9ybWF0UmVzdWx0KG1ldGFkYXRhKSxcbiAgICAgIGlkZW50OiB0aGlzLmZvcm1hdFJlc3VsdChpZGVudCksXG4gICAgICBidWZmZXJzOiB0aGlzLmZvcm1hdFJlc3VsdChidWZmZXJzKSxcbiAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogQ29tcGxldGUgdGhlIGNvZGUgc3VibWl0dGVkIGJ5IGEgdXNlci5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBjb21wbGV0ZShjb2RlOiBzdHJpbmcsIGN1cnNvcl9wb3M6IG51bWJlciwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgIFxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2tlcm5lbC5jb21wbGV0ZShjb2RlLCBjdXJzb3JfcG9zKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHQocmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNwZWN0IHRoZSBjb2RlIHN1Ym1pdHRlZCBieSBhIHVzZXIuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW5zcGVjdChjb2RlOiBzdHJpbmcsIGN1cnNvcl9wb3M6IG51bWJlciwgZGV0YWlsX2xldmVsOiAwIHwgMSwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgIFxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2tlcm5lbC5pbnNwZWN0KGNvZGUsIGN1cnNvcl9wb3MsIGRldGFpbF9sZXZlbCk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0KHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgY29kZSBmb3IgY29tcGxldGVuZXNzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGlzQ29tcGxldGUoY29kZTogc3RyaW5nLCBwYXJlbnQ6IGFueSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBhd2FpdCB0aGlzLnNldHVwKHBhcmVudCk7XG4gICAgXG4gICAgY29uc3QgcmVzID0gdGhpcy5fa2VybmVsLmlzX2NvbXBsZXRlKGNvZGUpO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdChyZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhdmFpbGFibGUgY29tbXMuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY29tbUluZm8odGFyZ2V0X25hbWU6IHN0cmluZyB8IG51bGwsIHBhcmVudDogYW55ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICBcbiAgICBjb25zdCByZXMgPSB0aGlzLl9rZXJuZWwuY29tbV9pbmZvKHRhcmdldF9uYW1lKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29tbXM6IHRoaXMuZm9ybWF0UmVzdWx0KHJlcyksXG4gICAgICBzdGF0dXM6ICdvaycsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIGEgQ09NTVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNvbW1PcGVuKGNvbnRlbnQ6IGFueSwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICBcbiAgICBjb25zdCByZXMgPSB0aGlzLl9rZXJuZWwuY29tbV9tYW5hZ2VyLmNvbW1fb3BlbihcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KG51bGwpLFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkobnVsbCksXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShjb250ZW50KVxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0KHJlcyk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZW5kIGEgbWVzc2FnZSB0aHJvdWdoIGEgQ09NTVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNvbW1Nc2coY29udGVudDogYW55LCBwYXJlbnQ6IGFueSA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgIFxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2tlcm5lbC5jb21tX21hbmFnZXIuY29tbV9tc2coXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShudWxsKSxcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KG51bGwpLFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkoY29udGVudClcbiAgICApO1xuICAgIFxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdChyZXMpO1xuICB9XG4gIFxuICAvKipcbiAgICogQ2xvc2UgYSBDT01NXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY29tbUNsb3NlKGNvbnRlbnQ6IGFueSwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICBcbiAgICBjb25zdCByZXMgPSB0aGlzLl9rZXJuZWwuY29tbV9tYW5hZ2VyLmNvbW1fY2xvc2UoXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShudWxsKSxcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KG51bGwpLFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkoY29udGVudClcbiAgICApO1xuICAgIFxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdChyZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgUHl0aG9uIGNvZGUgd2l0aCBzdHJlYW1pbmcgb3V0cHV0XG4gICAqIEBwYXJhbSBjb2RlIFRoZSBQeXRob24gY29kZSB0byBleGVjdXRlXG4gICAqIEBwYXJhbSBwYXJlbnQgUGFyZW50IG1lc3NhZ2UgaGVhZGVyXG4gICAqIEByZXR1cm5zIEFzeW5jR2VuZXJhdG9yIHlpZWxkaW5nIGludGVybWVkaWF0ZSBvdXRwdXRzIGFuZCBmaW5hbGx5IHRoZSBleGVjdXRpb24gcmVzdWx0XG4gICAqL1xuICBwdWJsaWMgYXN5bmMqIGV4ZWN1dGVTdHJlYW0oY29kZTogc3RyaW5nLCBwYXJlbnQ6IGFueSA9IHt9KTogQXN5bmNHZW5lcmF0b3I8YW55LCB7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9LCB2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fc3RhdHVzID0gXCJidXN5XCI7XG4gICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5LRVJORUxfQlVTWSwge30pO1xuICAgICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgICAgLy8gQ3JlYXRlIGV2ZW50IGxpc3RlbmVycyBmb3Igc3RyZWFtaW5nXG4gICAgICBjb25zdCBldmVudFF1ZXVlOiBJRXZlbnREYXRhW10gPSBbXTtcbiAgICAgIGxldCBleGVjdXRpb25Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgbGV0IGV4ZWN1dGlvblJlc3VsdDogYW55ID0gbnVsbDtcbiAgICAgIGxldCBleGVjdXRpb25FcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbDtcbiAgICAgIFxuICAgICAgY29uc3QgaGFuZGxlQWxsRXZlbnRzID0gKGV2ZW50RGF0YTogSUV2ZW50RGF0YSkgPT4ge1xuICAgICAgICBldmVudFF1ZXVlLnB1c2goZXZlbnREYXRhKTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIExpc3RlbiBmb3IgYWxsIGV2ZW50cyBCRUZPUkUgZXhlY3V0aW5nIGNvZGVcbiAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5BTEwsIGhhbmRsZUFsbEV2ZW50cyk7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNvZGUgZGlyZWN0bHlcbiAgICAgICAgdGhpcy5fa2VybmVsLnJ1bihjb2RlKS50aGVuKChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0tFUk5FTF0gUHl0aG9uIGV4ZWN1dGlvbiBmaW5pc2hlZFwiKTtcbiAgICAgICAgICBleGVjdXRpb25SZXN1bHQgPSB0aGlzLmZvcm1hdFJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSByZXN1bHQgaW5kaWNhdGVzIGFuIGVycm9yIGFuZCBlbWl0IGl0IGFzIGFuIGV2ZW50XG4gICAgICAgICAgaWYgKGV4ZWN1dGlvblJlc3VsdCAmJiBleGVjdXRpb25SZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIEV4ZWN1dGlvbiBjb21wbGV0ZWQgd2l0aCBlcnJvciBzdGF0dXMsIGVtaXR0aW5nIGV4ZWN1dGVfZXJyb3IgZXZlbnRcIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEVtaXQgdGhlIGVycm9yIGV2ZW50IHNvIHRoZSBVSSBjYW4gZGlzcGxheSBpdFxuICAgICAgICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgICAgICAgYnVuZGxlOiB7XG4gICAgICAgICAgICAgICAgZW5hbWU6IGV4ZWN1dGlvblJlc3VsdC5lbmFtZSB8fCAnRXJyb3InLFxuICAgICAgICAgICAgICAgIGV2YWx1ZTogZXhlY3V0aW9uUmVzdWx0LmV2YWx1ZSB8fCAnVW5rbm93biBlcnJvcicsXG4gICAgICAgICAgICAgICAgdHJhY2ViYWNrOiBleGVjdXRpb25SZXN1bHQudHJhY2ViYWNrIHx8IFtdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHR5cGU6ICdleGVjdXRlX2Vycm9yJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXYWl0IGEgc21hbGwgYW1vdW50IG9mIHRpbWUgZm9yIGFueSByZW1haW5pbmcgbWVzc2FnZXMgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgfSwgMTAwKTsgLy8gMTAwbXMgc2hvdWxkIGJlIGVub3VnaCBmb3IgbWVzc2FnZSBwcm9jZXNzaW5nXG4gICAgICAgICAgXG4gICAgICAgIH0pLmNhdGNoKChlcnJvcjogYW55KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIltLRVJORUxdIFB5dGhvbiBleGVjdXRpb24gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICBleGVjdXRpb25FcnJvciA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdGlsbCB3YWl0IGZvciBtZXNzYWdlcyB0byBzZXR0bGUgYmVmb3JlIGNvbXBsZXRpbmdcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0cmVhbSBldmVudHMgYXMgdGhleSBhcnJpdmVcbiAgICAgICAgd2hpbGUgKCFleGVjdXRpb25Db21wbGV0ZSB8fCBldmVudFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBZaWVsZCBxdWV1ZWQgZXZlbnRzXG4gICAgICAgICAgaWYgKGV2ZW50UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudFF1ZXVlLnNoaWZ0KCkhO1xuICAgICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgYSBiaXQgZm9yIG1vcmUgZXZlbnRzXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFByb2Nlc3MgZmluYWwgcmVzdWx0XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IFwiYWN0aXZlXCI7XG4gICAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLktFUk5FTF9JRExFLCB7fSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXhlY3V0aW9uRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXhlY3V0aW9uRXJyb3IsXG4gICAgICAgICAgICByZXN1bHQ6IGV4ZWN1dGlvblJlc3VsdFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHJlc3VsdCBpbmRpY2F0ZXMgYW4gZXJyb3JcbiAgICAgICAgaWYgKGV4ZWN1dGlvblJlc3VsdCAmJiBleGVjdXRpb25SZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JNc2cgPSBgJHtleGVjdXRpb25SZXN1bHQuZW5hbWUgfHwgJ0Vycm9yJ306ICR7ZXhlY3V0aW9uUmVzdWx0LmV2YWx1ZSB8fCAnVW5rbm93biBlcnJvcid9YDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGVycm9yTXNnKSxcbiAgICAgICAgICAgIHJlc3VsdDogZXhlY3V0aW9uUmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF1dG8tc3luYyBuYXRpdmUgZmlsZXN5c3RlbXMgaWYgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5hdXRvU3luY0ZzKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zeW5jQWxsTmF0aXZlRnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICByZXN1bHQ6IGV4ZWN1dGlvblJlc3VsdFxuICAgICAgICB9O1xuXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBDbGVhbiB1cCBsaXN0ZW5lclxuICAgICAgICBzdXBlci5vZmYoS2VybmVsRXZlbnRzLkFMTCwgaGFuZGxlQWxsRXZlbnRzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW0tFUk5FTF0gRXhlY3V0ZVN0cmVhbSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gXCJhY3RpdmVcIjtcbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLktFUk5FTF9JRExFLCB7fSk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIEludGVycnVwdCBmdW5jdGlvbmFsaXR5XG4gIHB1YmxpYyBhc3luYyBpbnRlcnJ1cHQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkIHx8ICF0aGlzLnB5b2RpZGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltLRVJORUxdIENhbm5vdCBpbnRlcnJ1cHQ6IGtlcm5lbCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiW0tFUk5FTF0gQXR0ZW1wdGluZyB0byBpbnRlcnJ1cHQgZXhlY3V0aW9uLi4uXCIpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCBwcmlvcml0eTogVXNlIGludGVycnVwdCBidWZmZXIgaWYgYXZhaWxhYmxlXG4gICAgICBpZiAodGhpcy5faW50ZXJydXB0QnVmZmVyICYmIHRoaXMuX2ludGVycnVwdFN1cHBvcnRlZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIFVzaW5nIGludGVycnVwdCBidWZmZXIgbWV0aG9kXCIpO1xuICAgICAgICAvLyBTZXQgaW50ZXJydXB0IHNpZ25hbCAoMiA9IFNJR0lOVClcbiAgICAgICAgdGhpcy5faW50ZXJydXB0QnVmZmVyWzBdID0gMjtcbiAgICAgICAgXG4gICAgICAgIC8vIEdpdmUgdGhlIGludGVycnVwdCBhIG1vbWVudCB0byBiZSBwcm9jZXNzZWRcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGludGVycnVwdCB3YXMgcHJvY2Vzc2VkIChidWZmZXIgc2hvdWxkIGJlIHJlc2V0IHRvIDApXG4gICAgICAgIGNvbnN0IHdhc1Byb2Nlc3NlZCA9IHRoaXMuX2ludGVycnVwdEJ1ZmZlclswXSA9PT0gMDtcbiAgICAgICAgaWYgKHdhc1Byb2Nlc3NlZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0tFUk5FTF0gSW50ZXJydXB0IHByb2Nlc3NlZCBzdWNjZXNzZnVsbHkgdmlhIGJ1ZmZlclwiKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZWNvbmQgcHJpb3JpdHk6IFRyeSBQeXRob24tbGV2ZWwgaW50ZXJydXB0XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIEF0dGVtcHRpbmcgUHl0aG9uLWxldmVsIGludGVycnVwdFwiKTtcbiAgICAgICAgLy8gVHJ5IHRvIHJhaXNlIEtleWJvYXJkSW50ZXJydXB0IGluIFB5dGhvblxuICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxuaW1wb3J0IHN5c1xuaW1wb3J0IF90aHJlYWRcbiMgVHJ5IHRvIGludGVycnVwdCB0aGUgbWFpbiB0aHJlYWRcbl90aHJlYWQuaW50ZXJydXB0X21haW4oKVxuYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0tFUk5FTF0gUHl0aG9uIGludGVycnVwdCBzaWduYWwgc2VudFwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChweXRob25FcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIFB5dGhvbiBpbnRlcnJ1cHQgYXR0ZW1wdCBmYWlsZWQ6XCIsIHB5dGhvbkVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVGhpcmQgcHJpb3JpdHk6IFRyeSBpbnRlcnByZXRlciBpbnRlcnJ1cHQgaWYgYXZhaWxhYmxlXG4gICAgICBpZiAodGhpcy5faW50ZXJwcmV0ZXIgJiYgdHlwZW9mIHRoaXMuX2ludGVycHJldGVyLmludGVycnVwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIFVzaW5nIGludGVycHJldGVyIGludGVycnVwdCBtZXRob2RcIik7XG4gICAgICAgIHRoaXMuX2ludGVycHJldGVyLmludGVycnVwdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTGFzdCByZXNvcnQ6IFNlbmQgaW50ZXJydXB0IG1lc3NhZ2VzIGZvciBVSSBmZWVkYmFja1xuICAgICAgY29uc29sZS5sb2coXCJbS0VSTkVMXSBTZW5kaW5nIGludGVycnVwdCBtZXNzYWdlcyBmb3IgVUkgZmVlZGJhY2tcIik7XG4gICAgICBcbiAgICAgIC8vIFNlbmQgc3RkZXJyIHN0cmVhbSBmaXJzdCAoZm9yIEp1cHl0ZXIgbm90ZWJvb2sgVUkgY29tcGF0aWJpbGl0eSlcbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ3N0cmVhbScsXG4gICAgICAgIGJ1bmRsZToge1xuICAgICAgICAgIG5hbWU6ICdzdGRlcnInLFxuICAgICAgICAgIHRleHQ6ICdLZXlib2FyZEludGVycnVwdDogRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXJcXG4nXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdleGVjdXRlX2Vycm9yJyxcbiAgICAgICAgYnVuZGxlOiB7XG4gICAgICAgICAgZW5hbWU6ICdLZXlib2FyZEludGVycnVwdCcsXG4gICAgICAgICAgZXZhbHVlOiAnRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXInLFxuICAgICAgICAgIHRyYWNlYmFjazogWydLZXlib2FyZEludGVycnVwdDogRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXInXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gUmV0dXJuIGZhbHNlIHNpbmNlIHdlIGNvdWxkbid0IGFjdHVhbGx5IGludGVycnVwdCB0aGUgZXhlY3V0aW9uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbS0VSTkVMXSBFcnJvciBkdXJpbmcgaW50ZXJydXB0OlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldEludGVycnVwdEJ1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICB0aGlzLl9pbnRlcnJ1cHRCdWZmZXIgPSBidWZmZXI7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMucHlvZGlkZSAmJiB0eXBlb2YgdGhpcy5weW9kaWRlLnNldEludGVycnVwdEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnB5b2RpZGUuc2V0SW50ZXJydXB0QnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2ludGVycnVwdFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbS0VSTkVMXSBweW9kaWRlLnNldEludGVycnVwdEJ1ZmZlciBub3QgYXZhaWxhYmxlLCBpbnRlcnJ1cHQgc3VwcG9ydCBsaW1pdGVkXCIpO1xuICAgICAgICB0aGlzLl9pbnRlcnJ1cHRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltLRVJORUxdIEVycm9yIHNldHRpbmcgaW50ZXJydXB0IGJ1ZmZlcjpcIiwgZXJyb3IpO1xuICAgICAgdGhpcy5faW50ZXJydXB0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBhbmQgcmVxdWVzdCBwZXJtaXNzaW9uIGZvciBhIGZpbGUgc3lzdGVtIGhhbmRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB2ZXJpZnlQZXJtaXNzaW9uKFxuICAgIGZpbGVIYW5kbGU6IEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUsXG4gICAgcGVybWlzc2lvbjogJ3JlYWQnIHwgJ3JlYWR3cml0ZSdcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3Qgb3B0czogYW55ID0ge307XG4gICAgaWYgKHBlcm1pc3Npb24gPT09ICdyZWFkd3JpdGUnKSB7XG4gICAgICBvcHRzLm1vZGUgPSAncmVhZHdyaXRlJztcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gVmVyaWZ5aW5nICR7cGVybWlzc2lvbn0gcGVybWlzc2lvbiBmb3IgZmlsZSBoYW5kbGUuLi5gKTtcblxuICAgIC8vIENoZWNrIGlmIHBlcm1pc3Npb24gQVBJcyBhcmUgc3VwcG9ydGVkXG4gICAgaWYgKHR5cGVvZiAoZmlsZUhhbmRsZSBhcyBhbnkpLnF1ZXJ5UGVybWlzc2lvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS53YXJuKCdbS0VSTkVMXSBxdWVyeVBlcm1pc3Npb24gbm90IHN1cHBvcnRlZCwgYXNzdW1pbmcgcGVybWlzc2lvbiBncmFudGVkJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIHBlcm1pc3Npb24sIGlmIHNvLCByZXR1cm4gdHJ1ZS5cbiAgICAgIGNvbnN0IHF1ZXJ5UmVzdWx0ID0gYXdhaXQgKGZpbGVIYW5kbGUgYXMgYW55KS5xdWVyeVBlcm1pc3Npb24ob3B0cyk7XG4gICAgICBjb25zb2xlLmxvZygnW0tFUk5FTF0gUXVlcnkgcmVzdWx0OicsIHF1ZXJ5UmVzdWx0KTtcbiAgICAgIFxuICAgICAgaWYgKHF1ZXJ5UmVzdWx0ID09PSAnZ3JhbnRlZCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBlcm1pc3Npb24gYWxyZWFkeSBncmFudGVkIGZvciAke3Blcm1pc3Npb259IGFjY2Vzc2ApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVxdWVzdCBwZXJtaXNzaW9uIHRvIHRoZSBmaWxlLCBpZiB0aGUgdXNlciBncmFudHMgcGVybWlzc2lvbiwgcmV0dXJuIHRydWUuXG4gICAgICBpZiAodHlwZW9mIChmaWxlSGFuZGxlIGFzIGFueSkucmVxdWVzdFBlcm1pc3Npb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFJlcXVlc3RpbmcgJHtwZXJtaXNzaW9ufSBwZXJtaXNzaW9uIGZyb20gdXNlci4uLmApO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0UmVzdWx0ID0gYXdhaXQgKGZpbGVIYW5kbGUgYXMgYW55KS5yZXF1ZXN0UGVybWlzc2lvbihvcHRzKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW0tFUk5FTF0gUmVxdWVzdCByZXN1bHQ6JywgcmVxdWVzdFJlc3VsdCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHJlcXVlc3RSZXN1bHQgPT09ICdncmFudGVkJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBlcm1pc3Npb24gZ3JhbnRlZCBmb3IgJHtwZXJtaXNzaW9ufSBhY2Nlc3NgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAocmVxdWVzdEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tLRVJORUxdIFBlcm1pc3Npb24gcmVxdWVzdCBmYWlsZWQgb3Igd2FzIGRpc21pc3NlZDonLCByZXF1ZXN0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSB1c2VyIGRpZCBub3QgZ3JhbnQgcGVybWlzc2lvbiwgcmV0dXJuIGZhbHNlLlxuICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdICR7cGVybWlzc2lvbn0gcGVybWlzc2lvbiBub3QgZ3JhbnRlZGApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tLRVJORUxdIEVycm9yIGNoZWNraW5nIHBlcm1pc3Npb246JywgZXJyb3IpO1xuICAgICAgLy8gSWYgcGVybWlzc2lvbiBjaGVjayBmYWlscywgYXNzdW1lIGl0J3MgZ3JhbnRlZCAobW9yZSBwZXJtaXNzaXZlIGFwcHJvYWNoKVxuICAgICAgY29uc29sZS53YXJuKCdbS0VSTkVMXSBQZXJtaXNzaW9uIGNoZWNrIGZhaWxlZCwgYXNzdW1pbmcgZ3JhbnRlZCBhcyBmYWxsYmFjaycpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdW50IGEgbmF0aXZlIGZpbGUgc3lzdGVtIGRpcmVjdG9yeSBpbnRvIHRoZSBQeW9kaWRlIGZpbGVzeXN0ZW1cbiAgICogQHBhcmFtIG1vdW50UGF0aCBUaGUgcGF0aCB3aGVyZSB0aGUgZGlyZWN0b3J5IHNob3VsZCBiZSBtb3VudGVkIGluIHRoZSBQeXRob24gZmlsZXN5c3RlbVxuICAgKiBAcGFyYW0gZGlySGFuZGxlIE9wdGlvbmFsIEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUuIElmIG51bGwvdW5kZWZpbmVkLCBzaG93cyBkaXJlY3RvcnkgcGlja2VyXG4gICAqIEBwYXJhbSBwZXJtaXNzaW9uIFBlcm1pc3Npb24gbW9kZTpcbiAgICogICAtICdyZWFkJzogUmVhZC1vbmx5IGFjY2Vzcywgbm8gc3luY2luZyBjYXBhYmlsaXRpZXMsIGF1dG8tc3luYyB3aWxsIGJlIHNraXBwZWQgKGRlZmF1bHQpXG4gICAqICAgLSAncmVhZHdyaXRlJzogRnVsbCByZWFkL3dyaXRlIGFjY2VzcyB3aXRoIHN5bmNpbmcgY2FwYWJpbGl0aWVzXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgaGFuZGxlIHdpdGggc3luY2ZzKCkgbWV0aG9kIGZvciBzeW5jaW5nIGNoYW5nZXNcbiAgICogQG5vdGUgc3luY2ZzKCkgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBjYWxsZWQgb24gYSByZWFkLW9ubHkgbW91bnRlZCBmaWxlc3lzdGVtXG4gICAqIEBub3RlIE1hbnkgYnJvd3NlcnMgb25seSBvZmZlciByZWFkIHBlcm1pc3Npb24gaW5pdGlhbGx5LiBFeHBsaWNpdGx5IHJlcXVlc3QgJ3JlYWR3cml0ZScgaWYgeW91IG5lZWQgd3JpdGUgYWNjZXNzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIG1vdW50RlMoXG4gICAgbW91bnRQYXRoOiBzdHJpbmcsXG4gICAgZGlySGFuZGxlPzogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSB8IG51bGwsXG4gICAgcGVybWlzc2lvbjogJ3JlYWQnIHwgJ3JlYWR3cml0ZScgPSAncmVhZCdcbiAgKTogUHJvbWlzZTx7IHN5bmNmczogKCkgPT4gUHJvbWlzZTx2b2lkPiB9PiB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkIHx8ICF0aGlzLnB5b2RpZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktlcm5lbCBtdXN0IGJlIGluaXRpYWxpemVkIGJlZm9yZSBtb3VudGluZyBmaWxlc3lzdGVtXCIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIG1vdW50TmF0aXZlRlMgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB0aGlzLnB5b2RpZGUubW91bnROYXRpdmVGUyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHlvZGlkZS5tb3VudE5hdGl2ZUZTIGlzIG5vdCBhdmFpbGFibGUuIE1ha2Ugc3VyZSB5b3UncmUgdXNpbmcgUHlvZGlkZSAwLjIzLjAgb3IgbGF0ZXIuXCIpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGUgPSBkaXJIYW5kbGU7XG5cbiAgICAvLyBJZiBubyBkaXJIYW5kbGUgcHJvdmlkZWQsIHNob3cgZGlyZWN0b3J5IHBpY2tlclxuICAgIGlmICghaGFuZGxlKSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBpbiBhIHdvcmtlciBjb250ZXh0XG4gICAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNob3cgZGlyZWN0b3J5IHBpY2tlciBpbiB3b3JrZXIgY29udGV4dC4gUGxlYXNlIHByb3ZpZGUgYSBkaXJIYW5kbGUgcGFyYW1ldGVyLlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgc2hvd0RpcmVjdG9yeVBpY2tlciBpcyBhdmFpbGFibGVcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnc2hvd0RpcmVjdG9yeVBpY2tlcicgaW4gd2luZG93KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGFuZGxlID0gYXdhaXQgKHdpbmRvdyBhcyBhbnkpLnNob3dEaXJlY3RvcnlQaWNrZXIoe1xuICAgICAgICAgICAgbW9kZTogJ3JlYWR3cml0ZScsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2hvdyBkaXJlY3RvcnkgcGlja2VyOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hvd0RpcmVjdG9yeVBpY2tlciBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gUGxlYXNlIHByb3ZpZGUgYSBkaXJIYW5kbGUgcGFyYW1ldGVyLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZGlyZWN0b3J5IGhhbmRsZSBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IGFuZCByZXF1ZXN0IHBlcm1pc3Npb25zIGJlZm9yZSBtb3VudGluZ1xuICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBWZXJpZnlpbmcgJHtwZXJtaXNzaW9ufSBwZXJtaXNzaW9ucyBiZWZvcmUgbW91bnRpbmcuLi5gKTtcbiAgICBjb25zdCBoYXNSZXF1ZXN0ZWRQZXJtaXNzaW9uID0gYXdhaXQgdGhpcy52ZXJpZnlQZXJtaXNzaW9uKGhhbmRsZSwgcGVybWlzc2lvbik7XG4gICAgXG4gICAgaWYgKCFoYXNSZXF1ZXN0ZWRQZXJtaXNzaW9uKSB7XG4gICAgICBpZiAocGVybWlzc2lvbiA9PT0gJ3JlYWR3cml0ZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gb2J0YWluIHdyaXRlIHBlcm1pc3Npb24gZm9yIGRpcmVjdG9yeS4gYCArXG4gICAgICAgICAgYFRoZSBicm93c2VyIG1heSBvbmx5IGJlIG9mZmVyaW5nIHJlYWQgcGVybWlzc2lvbi4gYCArXG4gICAgICAgICAgYFRyeSBtb3VudGluZyB3aXRoIHBlcm1pc3Npb246ICdyZWFkJyBpZiB5b3Ugb25seSBuZWVkIHRvIHJlYWQgZmlsZXMsIGAgK1xuICAgICAgICAgIGBvciBlbnN1cmUgdGhlIGJyb3dzZXIgc3VwcG9ydHMgd3JpdGUgYWNjZXNzIHRvIHRoaXMgZGlyZWN0b3J5LmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIG9idGFpbiAke3Blcm1pc3Npb259IHBlcm1pc3Npb24gZm9yIGRpcmVjdG9yeS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgYWN0dWFsUGVybWlzc2lvbiA9IHBlcm1pc3Npb247XG5cbiAgICAvLyBNb3VudCB0aGUgbmF0aXZlIGZpbGVzeXN0ZW1cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIE1vdW50aW5nIG5hdGl2ZSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofSB3aXRoICR7YWN0dWFsUGVybWlzc2lvbn0gcGVybWlzc2lvbmApO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGUgbW91bnQgcG9pbnQgYWxyZWFkeSBleGlzdHMgYW5kIGhhbmRsZSBjbGVhbnVwXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXRoSW5mbyA9IHRoaXMucHlvZGlkZS5GUy5hbmFseXplUGF0aChtb3VudFBhdGgpO1xuICAgICAgICBpZiAocGF0aEluZm8uZXhpc3RzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBhdGggJHttb3VudFBhdGh9IGV4aXN0cywgY2hlY2tpbmcgaWYgaXQncyBhIG1vdW50IHBvaW50YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIHVubW91bnQgaWYgaXQncyBhbHJlYWR5IG1vdW50ZWRcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5weW9kaWRlLkZTLnVubW91bnQobW91bnRQYXRoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTdWNjZXNzZnVsbHkgdW5tb3VudGVkIGV4aXN0aW5nIGZpbGVzeXN0ZW0gYXQgJHttb3VudFBhdGh9YCk7XG4gICAgICAgICAgfSBjYXRjaCAodW5tb3VudEVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiB1bm1vdW50IGZhaWxzLCBpdCBtaWdodCBub3QgYmUgYSBtb3VudCBwb2ludCBvciBtaWdodCBiZSBidXN5XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gVW5tb3VudCBmYWlsZWQgKHRoaXMgaXMgbm9ybWFsIGlmIG5vdCBtb3VudGVkKTogJHt1bm1vdW50RXJyb3J9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZGlyZWN0b3J5IGlmIGl0IGV4aXN0cyBidXQgaXMgZW1wdHlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5weW9kaWRlLkZTLnJtZGlyKG1vdW50UGF0aCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gUmVtb3ZlZCBleGlzdGluZyBkaXJlY3RvcnkgYXQgJHttb3VudFBhdGh9YCk7XG4gICAgICAgICAgfSBjYXRjaCAocm1kaXJFcnJvcikge1xuICAgICAgICAgICAgLy8gRGlyZWN0b3J5IG1pZ2h0IG5vdCBiZSBlbXB0eSBvciBtaWdodCBub3QgZXhpc3QsIHRoYXQncyBva2F5XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gQ291bGQgbm90IHJlbW92ZSBkaXJlY3RvcnkgKHRoaXMgaXMgbm9ybWFsKTogJHtybWRpckVycm9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoYW5hbHl6ZUVycm9yKSB7XG4gICAgICAgIC8vIGFuYWx5emVQYXRoIG1pZ2h0IGZhaWwsIHRoYXQncyBva2F5IC0gdGhlIHBhdGggcHJvYmFibHkgZG9lc24ndCBleGlzdFxuICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gUGF0aCBhbmFseXNpcyBmYWlsZWQgKHBhdGggcHJvYmFibHkgZG9lc24ndCBleGlzdCk6ICR7YW5hbHl6ZUVycm9yfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFbnN1cmUgdGhlIHBhcmVudCBkaXJlY3RvcnkgZXhpc3RzXG4gICAgICBjb25zdCBwYXJlbnRQYXRoID0gbW91bnRQYXRoLnN1YnN0cmluZygwLCBtb3VudFBhdGgubGFzdEluZGV4T2YoJy8nKSkgfHwgJy8nO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHBhcmVudFBhdGggIT09ICcvJyAmJiAhdGhpcy5weW9kaWRlLkZTLmFuYWx5emVQYXRoKHBhcmVudFBhdGgpLmV4aXN0cykge1xuICAgICAgICAgIHRoaXMucHlvZGlkZS5GUy5ta2RpcihwYXJlbnRQYXRoKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gQ3JlYXRlZCBwYXJlbnQgZGlyZWN0b3J5ICR7cGFyZW50UGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAocGFyZW50RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBhcmVudCBkaXJlY3RvcnkgaGFuZGxpbmc6ICR7cGFyZW50RXJyb3J9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IG5hdGl2ZWZzID0gYXdhaXQgdGhpcy5weW9kaWRlLm1vdW50TmF0aXZlRlMobW91bnRQYXRoLCBoYW5kbGUpO1xuXG4gICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gU3VjY2Vzc2Z1bGx5IG1vdW50ZWQgbmF0aXZlIGZpbGVzeXN0ZW0gYXQgJHttb3VudFBhdGh9IHdpdGggJHthY3R1YWxQZXJtaXNzaW9ufSBwZXJtaXNzaW9uYCk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIGhhbmRsZSB3aXRoIHN5bmNmcyBtZXRob2QgYW5kIHBlcm1pc3Npb24gcmVjb3ZlcnlcbiAgICAgIGNvbnN0IGZzSGFuZGxlID0ge1xuICAgICAgICBzeW5jZnM6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBmaWxlc3lzdGVtIGlzIHJlYWQtb25seVxuICAgICAgICAgIGlmIChhY3R1YWxQZXJtaXNzaW9uID09PSAncmVhZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHN5bmMgcmVhZC1vbmx5IGZpbGVzeXN0ZW0gYXQgJHttb3VudFBhdGh9LiBVc2UgdXBncmFkZUZpbGVTeXN0ZW1QZXJtaXNzaW9uKCkgdG8gcmVxdWVzdCB3cml0ZSBhY2Nlc3MuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBuYXRpdmVmcy5zeW5jZnMoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTeW5jZWQgY2hhbmdlcyB0byBuYXRpdmUgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH1gKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3luYyBmaWxlc3lzdGVtOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpckhhbmRsZTogaGFuZGxlLFxuICAgICAgICBwZXJtaXNzaW9uOiBhY3R1YWxQZXJtaXNzaW9uLFxuICAgICAgICBuYXRpdmVmczogbmF0aXZlZnNcbiAgICAgIH07XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBoYW5kbGUgZm9yIGF1dG8tc3luY1xuICAgICAgdGhpcy5uYXRpdmVGc0hhbmRsZXMuc2V0KG1vdW50UGF0aCwgZnNIYW5kbGUpO1xuXG4gICAgICByZXR1cm4geyBzeW5jZnM6IGZzSGFuZGxlLnN5bmNmcyB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBtb3VudCBuYXRpdmUgZmlsZXN5c3RlbTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmMgYWxsIG1vdW50ZWQgbmF0aXZlIGZpbGVzeXN0ZW1zIHdpdGggcGVybWlzc2lvbiByZWNvdmVyeVxuICAgKiBPbmx5IHN5bmNzIGZpbGVzeXN0ZW1zIG1vdW50ZWQgd2l0aCAncmVhZHdyaXRlJyBwZXJtaXNzaW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHN5bmNBbGxOYXRpdmVGcygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5uYXRpdmVGc0hhbmRsZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN5bmNSZXN1bHRzOiBBcnJheTx7IG1vdW50UGF0aDogc3RyaW5nOyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZzsgc2tpcHBlZD86IGJvb2xlYW4gfT4gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW21vdW50UGF0aCwgZnNIYW5kbGVdIG9mIHRoaXMubmF0aXZlRnNIYW5kbGVzLmVudHJpZXMoKSkge1xuICAgICAgLy8gU2tpcCByZWFkLW9ubHkgZmlsZXN5c3RlbXNcbiAgICAgIGlmIChmc0hhbmRsZS5wZXJtaXNzaW9uID09PSAncmVhZCcpIHtcbiAgICAgICAgc3luY1Jlc3VsdHMucHVzaCh7IG1vdW50UGF0aCwgc3VjY2VzczogdHJ1ZSwgc2tpcHBlZDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFNraXBwaW5nIHN5bmMgZm9yIHJlYWQtb25seSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyc3QsIHRyeSB0byBzeW5jIGRpcmVjdGx5XG4gICAgICAgIGF3YWl0IGZzSGFuZGxlLnN5bmNmcygpO1xuICAgICAgICBzeW5jUmVzdWx0cy5wdXNoKHsgbW91bnRQYXRoLCBzdWNjZXNzOiB0cnVlIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gU3VjY2Vzc2Z1bGx5IHN5bmNlZCBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgc3luYyBmYWlscywgY2hlY2sgaWYgaXQncyBhIHBlcm1pc3Npb24gZXJyb3JcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnbm90IGFsbG93ZWQgYnkgdGhlIHVzZXIgYWdlbnQnKSB8fCBcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcygnZ2V0RmlsZUhhbmRsZScpIHx8XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ3Blcm1pc3Npb24nKSkge1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUud2FybihgW0tFUk5FTF0gUGVybWlzc2lvbiBlcnJvciBzeW5jaW5nICR7bW91bnRQYXRofSwgYXR0ZW1wdGluZyByZWNvdmVyeS4uLmApO1xuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gcmVjb3ZlciBieSByZS12ZXJpZnlpbmcgcGVybWlzc2lvbnNcbiAgICAgICAgICAgIGNvbnN0IGhhc1Blcm1pc3Npb24gPSBhd2FpdCB0aGlzLnZlcmlmeVBlcm1pc3Npb24oZnNIYW5kbGUuZGlySGFuZGxlLCBmc0hhbmRsZS5wZXJtaXNzaW9uKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGhhc1Blcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJlbW91bnQgYW5kIHN5bmNcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBlcm1pc3Npb24gcmVjb3ZlcmVkIGZvciAke21vdW50UGF0aH0sIGF0dGVtcHRpbmcgcmVtb3VudC4uLmApO1xuICAgICAgICAgICAgICBjb25zdCBuZXdOYXRpdmVmcyA9IGF3YWl0IHRoaXMucHlvZGlkZS5tb3VudE5hdGl2ZUZTKG1vdW50UGF0aCwgZnNIYW5kbGUuZGlySGFuZGxlKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RvcmVkIGhhbmRsZSB3aXRoIHRoZSBuZXcgbmF0aXZlZnNcbiAgICAgICAgICAgICAgZnNIYW5kbGUubmF0aXZlZnMgPSBuZXdOYXRpdmVmcztcbiAgICAgICAgICAgICAgZnNIYW5kbGUuc3luY2ZzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCBuZXdOYXRpdmVmcy5zeW5jZnMoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTeW5jZWQgY2hhbmdlcyB0byBuYXRpdmUgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH1gKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChzeW5jRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHN5bmMgZmlsZXN5c3RlbTogJHtzeW5jRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHN5bmNFcnJvci5tZXNzYWdlIDogU3RyaW5nKHN5bmNFcnJvcil9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gVHJ5IHN5bmMgYWdhaW4gd2l0aCB0aGUgbmV3IGhhbmRsZVxuICAgICAgICAgICAgICBhd2FpdCBmc0hhbmRsZS5zeW5jZnMoKTtcbiAgICAgICAgICAgICAgc3luY1Jlc3VsdHMucHVzaCh7IG1vdW50UGF0aCwgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFN1Y2Nlc3NmdWxseSByZWNvdmVyZWQgYW5kIHN5bmNlZCBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3luY1Jlc3VsdHMucHVzaCh7IFxuICAgICAgICAgICAgICAgIG1vdW50UGF0aCwgXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgICAgICAgIGVycm9yOiAnUGVybWlzc2lvbiBkZW5pZWQgYnkgdXNlcicgXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtLRVJORUxdIFVzZXIgZGVuaWVkIHBlcm1pc3Npb24gZm9yICR7bW91bnRQYXRofSwgc2tpcHBpbmcgc3luY2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHJlY292ZXJ5RXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY292ZXJ5TWVzc2FnZSA9IHJlY292ZXJ5RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHJlY292ZXJ5RXJyb3IubWVzc2FnZSA6IFN0cmluZyhyZWNvdmVyeUVycm9yKTtcbiAgICAgICAgICAgIHN5bmNSZXN1bHRzLnB1c2goeyBcbiAgICAgICAgICAgICAgbW91bnRQYXRoLCBcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgICAgICBlcnJvcjogYFJlY292ZXJ5IGZhaWxlZDogJHtyZWNvdmVyeU1lc3NhZ2V9YCBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW0tFUk5FTF0gRmFpbGVkIHRvIHJlY292ZXIgcGVybWlzc2lvbnMgZm9yICR7bW91bnRQYXRofTpgLCByZWNvdmVyeUVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9uLXBlcm1pc3Npb24gZXJyb3JcbiAgICAgICAgICBzeW5jUmVzdWx0cy5wdXNoKHsgXG4gICAgICAgICAgICBtb3VudFBhdGgsIFxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbS0VSTkVMXSBOb24tcGVybWlzc2lvbiBlcnJvciBzeW5jaW5nICR7bW91bnRQYXRofTpgLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMb2cgc3VtbWFyeVxuICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSBzeW5jUmVzdWx0cy5maWx0ZXIociA9PiByLnN1Y2Nlc3MgJiYgIXIuc2tpcHBlZCkubGVuZ3RoO1xuICAgIGNvbnN0IHNraXBwZWQgPSBzeW5jUmVzdWx0cy5maWx0ZXIociA9PiByLnNraXBwZWQpLmxlbmd0aDtcbiAgICBjb25zdCBmYWlsZWQgPSBzeW5jUmVzdWx0cy5maWx0ZXIociA9PiAhci5zdWNjZXNzKTtcbiAgICBcbiAgICBpZiAoc3VjY2Vzc2Z1bCA+IDAgfHwgc2tpcHBlZCA+IDApIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICBpZiAoc3VjY2Vzc2Z1bCA+IDApIHBhcnRzLnB1c2goYCR7c3VjY2Vzc2Z1bH0gc3luY2VkYCk7XG4gICAgICBpZiAoc2tpcHBlZCA+IDApIHBhcnRzLnB1c2goYCR7c2tpcHBlZH0gcmVhZC1vbmx5IHNraXBwZWRgKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBBdXRvLXN5bmMgY29tcGxldGVkOiAke3BhcnRzLmpvaW4oJywgJyl9ICgke3N5bmNSZXN1bHRzLmxlbmd0aH0gdG90YWwgZmlsZXN5c3RlbXMpYCk7XG4gICAgfVxuICAgIFxuICAgIGlmIChmYWlsZWQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS53YXJuKGBbS0VSTkVMXSBBdXRvLXN5bmMgaXNzdWVzOmAsIGZhaWxlZC5tYXAoZiA9PiBgJHtmLm1vdW50UGF0aH06ICR7Zi5lcnJvcn1gKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIERvbid0IHRocm93IC0gd2UgZG9uJ3Qgd2FudCB0byBmYWlsIGV4ZWN1dGlvbiBqdXN0IGJlY2F1c2Ugc3luYyBmYWlsZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgbW91bnRlZCBuYXRpdmUgZmlsZXN5c3RlbXMgYW5kIHRoZWlyIHBlcm1pc3Npb24gc3RhdHVzXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIG1vdW50ZWQgZmlsZXN5c3RlbSBpbmZvcm1hdGlvblxuICAgKi9cbiAgcHVibGljIGdldE1vdW50ZWRGaWxlU3lzdGVtcygpOiBBcnJheTx7XG4gICAgbW91bnRQYXRoOiBzdHJpbmc7XG4gICAgcGVybWlzc2lvbjogJ3JlYWQnIHwgJ3JlYWR3cml0ZSc7XG4gICAgY2FuU3luYzogYm9vbGVhbjtcbiAgfT4ge1xuICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8e1xuICAgICAgbW91bnRQYXRoOiBzdHJpbmc7XG4gICAgICBwZXJtaXNzaW9uOiAncmVhZCcgfCAncmVhZHdyaXRlJztcbiAgICAgIGNhblN5bmM6IGJvb2xlYW47XG4gICAgfT4gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW21vdW50UGF0aCwgZnNIYW5kbGVdIG9mIHRoaXMubmF0aXZlRnNIYW5kbGVzLmVudHJpZXMoKSkge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBtb3VudFBhdGgsXG4gICAgICAgIHBlcm1pc3Npb246IGZzSGFuZGxlLnBlcm1pc3Npb24sXG4gICAgICAgIGNhblN5bmM6IGZzSGFuZGxlLnBlcm1pc3Npb24gPT09ICdyZWFkd3JpdGUnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1hbnVhbGx5IHN5bmMgYSBzcGVjaWZpYyBtb3VudGVkIGZpbGVzeXN0ZW1cbiAgICogQHBhcmFtIG1vdW50UGF0aCBUaGUgcGF0aCBvZiB0aGUgbW91bnRlZCBmaWxlc3lzdGVtIHRvIHN5bmNcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gc3VjY2VzcyBzdGF0dXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBzeW5jRmlsZVN5c3RlbShtb3VudFBhdGg6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgY29uc3QgZnNIYW5kbGUgPSB0aGlzLm5hdGl2ZUZzSGFuZGxlcy5nZXQobW91bnRQYXRoKTtcbiAgICBcbiAgICBpZiAoIWZzSGFuZGxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBObyBmaWxlc3lzdGVtIG1vdW50ZWQgYXQgJHttb3VudFBhdGh9YFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBmaWxlc3lzdGVtIGlzIHJlYWQtb25seVxuICAgIGlmIChmc0hhbmRsZS5wZXJtaXNzaW9uID09PSAncmVhZCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogYENhbm5vdCBzeW5jIHJlYWQtb25seSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofS4gTW91bnQgd2l0aCAncmVhZHdyaXRlJyBwZXJtaXNzaW9uIHRvIGVuYWJsZSBzeW5jaW5nLmBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzSGFuZGxlLnN5bmNmcygpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICBcbiAgICAgIC8vIFRyeSBwZXJtaXNzaW9uIHJlY292ZXJ5IGlmIGl0J3MgYSBwZXJtaXNzaW9uIGVycm9yXG4gICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdub3QgYWxsb3dlZCBieSB0aGUgdXNlciBhZ2VudCcpIHx8IFxuICAgICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcygnZ2V0RmlsZUhhbmRsZScpIHx8XG4gICAgICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdwZXJtaXNzaW9uJykpIHtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBQZXJtaXNzaW9uIGVycm9yIHN5bmNpbmcgJHttb3VudFBhdGh9LCBhdHRlbXB0aW5nIHJlY292ZXJ5Li4uYCk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGhhc1Blcm1pc3Npb24gPSBhd2FpdCB0aGlzLnZlcmlmeVBlcm1pc3Npb24oZnNIYW5kbGUuZGlySGFuZGxlLCBmc0hhbmRsZS5wZXJtaXNzaW9uKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaGFzUGVybWlzc2lvbikge1xuICAgICAgICAgICAgLy8gUmVtb3VudCBhbmQgdHJ5IGFnYWluXG4gICAgICAgICAgICBjb25zdCBuZXdOYXRpdmVmcyA9IGF3YWl0IHRoaXMucHlvZGlkZS5tb3VudE5hdGl2ZUZTKG1vdW50UGF0aCwgZnNIYW5kbGUuZGlySGFuZGxlKTtcbiAgICAgICAgICAgIGZzSGFuZGxlLm5hdGl2ZWZzID0gbmV3TmF0aXZlZnM7XG4gICAgICAgICAgICBmc0hhbmRsZS5zeW5jZnMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3TmF0aXZlZnMuc3luY2ZzKCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFN5bmNlZCBjaGFuZ2VzIHRvIG5hdGl2ZSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChzeW5jRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzeW5jIGZpbGVzeXN0ZW06ICR7c3luY0Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBzeW5jRXJyb3IubWVzc2FnZSA6IFN0cmluZyhzeW5jRXJyb3IpfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhd2FpdCBmc0hhbmRsZS5zeW5jZnMoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiAnUGVybWlzc2lvbiBkZW5pZWQgYnkgdXNlcidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChyZWNvdmVyeUVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGBSZWNvdmVyeSBmYWlsZWQ6ICR7cmVjb3ZlcnlFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gcmVjb3ZlcnlFcnJvci5tZXNzYWdlIDogU3RyaW5nKHJlY292ZXJ5RXJyb3IpfWBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIGEgbW91bnRlZCBmaWxlc3lzdGVtIGZyb20gcmVhZC1vbmx5IHRvIHJlYWQtd3JpdGUgcGVybWlzc2lvblxuICAgKiBAcGFyYW0gbW91bnRQYXRoIFRoZSBwYXRoIG9mIHRoZSBtb3VudGVkIGZpbGVzeXN0ZW0gdG8gdXBncmFkZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBzdWNjZXNzIHN0YXR1c1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHVwZ3JhZGVGaWxlU3lzdGVtUGVybWlzc2lvbihtb3VudFBhdGg6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgY29uc3QgZnNIYW5kbGUgPSB0aGlzLm5hdGl2ZUZzSGFuZGxlcy5nZXQobW91bnRQYXRoKTtcbiAgICBcbiAgICBpZiAoIWZzSGFuZGxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBObyBmaWxlc3lzdGVtIG1vdW50ZWQgYXQgJHttb3VudFBhdGh9YFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoZnNIYW5kbGUucGVybWlzc2lvbiA9PT0gJ3JlYWR3cml0ZScpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGVycm9yOiBgRmlsZVN5c3RlbSBhdCAke21vdW50UGF0aH0gYWxyZWFkeSBoYXMgcmVhZHdyaXRlIHBlcm1pc3Npb25gXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gQXR0ZW1wdGluZyB0byB1cGdyYWRlICR7bW91bnRQYXRofSB0byByZWFkd3JpdGUgcGVybWlzc2lvbi4uLmApO1xuICAgICAgXG4gICAgICAvLyBUcnkgdG8gZ2V0IHJlYWR3cml0ZSBwZXJtaXNzaW9uXG4gICAgICBjb25zdCBoYXNXcml0ZVBlcm1pc3Npb24gPSBhd2FpdCB0aGlzLnZlcmlmeVBlcm1pc3Npb24oZnNIYW5kbGUuZGlySGFuZGxlLCAncmVhZHdyaXRlJyk7XG4gICAgICBcbiAgICAgIGlmICghaGFzV3JpdGVQZXJtaXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6ICdVc2VyIGRlbmllZCB3cml0ZSBwZXJtaXNzaW9uIG9yIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB3cml0ZSBhY2Nlc3MgdG8gdGhpcyBkaXJlY3RvcnknXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW91bnQgd2l0aCB3cml0ZSBwZXJtaXNzaW9uXG4gICAgICBjb25zdCBuZXdOYXRpdmVmcyA9IGF3YWl0IHRoaXMucHlvZGlkZS5tb3VudE5hdGl2ZUZTKG1vdW50UGF0aCwgZnNIYW5kbGUuZGlySGFuZGxlKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHRoZSBzdG9yZWQgaGFuZGxlXG4gICAgICBmc0hhbmRsZS5wZXJtaXNzaW9uID0gJ3JlYWR3cml0ZSc7XG4gICAgICBmc0hhbmRsZS5uYXRpdmVmcyA9IG5ld05hdGl2ZWZzO1xuICAgICAgZnNIYW5kbGUuc3luY2ZzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG5ld05hdGl2ZWZzLnN5bmNmcygpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTeW5jZWQgY2hhbmdlcyB0byBuYXRpdmUgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH1gKTtcbiAgICAgICAgfSBjYXRjaCAoc3luY0Vycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3luYyBmaWxlc3lzdGVtOiAke3N5bmNFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gc3luY0Vycm9yLm1lc3NhZ2UgOiBTdHJpbmcoc3luY0Vycm9yKX1gKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFN1Y2Nlc3NmdWxseSB1cGdyYWRlZCAke21vdW50UGF0aH0gdG8gcmVhZHdyaXRlIHBlcm1pc3Npb25gKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gdXBncmFkZSBwZXJtaXNzaW9uOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpdGggcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uXG4gICAqIE9QVElNSVpFRDogUGFyYWxsZWwgdmFyaWFibGUgc2V0dGluZyBhbmQgdmFsaWRhdGlvbiB3aXRoIHByb3BlciBlc2NhcGluZyBhbmQgZWRnZSBjYXNlIGhhbmRsaW5nXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNldEVudmlyb25tZW50VmFyaWFibGVzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmVudmlyb25tZW50VmFyaWFibGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gTm8gdmFyaWFibGVzIHRvIHNldFxuICAgIH1cbiAgICBcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnNvbGUubG9nKGDwn4yNIFNldHRpbmcgJHtPYmplY3Qua2V5cyh0aGlzLmVudmlyb25tZW50VmFyaWFibGVzKS5sZW5ndGh9IGVudmlyb25tZW50IHZhcmlhYmxlcy4uLmApO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBTZXQgZWFjaCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpbmRpdmlkdWFsbHkgdG8gYXZvaWQgZXNjYXBpbmcgaXNzdWVzXG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmVudmlyb25tZW50VmFyaWFibGVzKSkge1xuICAgICAgICAvLyBIYW5kbGUgZWRnZSBjYXNlczogbnVsbCwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGxldCBwcm9jZXNzZWRWYWx1ZTogc3RyaW5nO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBwcm9jZXNzZWRWYWx1ZSA9ICcnOyAgLy8gQ29udmVydCBudWxsIHRvIGVtcHR5IHN0cmluZ1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9jZXNzZWRWYWx1ZSA9ICcnOyAgLy8gQ29udmVydCB1bmRlZmluZWQgdG8gZW1wdHkgc3RyaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzc2VkVmFsdWUgPSBTdHJpbmcodmFsdWUpOyAgLy8gQ29udmVydCBldmVyeXRoaW5nIGVsc2UgdG8gc3RyaW5nXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGF3YWl0IHRoaXMucHlvZGlkZS5ydW5QeXRob25Bc3luYyhgXG5pbXBvcnQgb3Ncbm9zLmVudmlyb25bJHtKU09OLnN0cmluZ2lmeShrZXkpfV0gPSAke0pTT04uc3RyaW5naWZ5KHByb2Nlc3NlZFZhbHVlKX1cbmApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg4pqhIEVudmlyb25tZW50IHZhcmlhYmxlcyBzZXQgaW4gJHtkdXJhdGlvbn1tc2ApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEZhaWxlZCB0byBzZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLy8gT25seSBQeXRob24ga2VybmVsIGlzIHN1cHBvcnRlZFxuXG4vLyBFeHBvcnQgdGhlIG1hbmFnZXIgZm9yIGFkdmFuY2VkIHVzYWdlXG5leHBvcnQgeyBLZXJuZWxNYW5hZ2VyIH0gZnJvbSBcIi4vbWFuYWdlclwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.ts\n\n}");

/***/ }),

/***/ "./src/kernel.worker.ts":
/*!******************************!*\
  !*** ./src/kernel.worker.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

eval("{/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! comlink */ \"./node_modules/comlink/dist/esm/comlink.mjs\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ \"./src/index.ts\");\n// Web Worker file for running the Kernel in a separate thread\n// Import necessary modules\n\n\n\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    }\n    off(eventName, listener) {\n        if (!this.events[eventName])\n            return;\n        const index = this.events[eventName].indexOf(listener);\n        if (index > -1) {\n            this.events[eventName].splice(index, 1);\n        }\n    }\n    emit(eventName, ...args) {\n        if (!this.events[eventName])\n            return;\n        this.events[eventName].forEach(listener => listener(...args));\n    }\n}\n// Create a new kernel instance\nconst kernel = new _index__WEBPACK_IMPORTED_MODULE_2__.Kernel();\n// Variable to store the event port\nlet eventPort = null;\n// Store kernel initialization options\nlet kernelOptions = {};\n// Track current event listeners for cleanup\nlet currentEventListeners = new Map();\n// Interrupt handling for worker\nlet interruptBuffer = null;\n// Helper function to check if an error is a KeyboardInterrupt\nfunction isKeyboardInterrupt(error) {\n    return error &&\n        typeof error === 'object' &&\n        (error.type === \"KeyboardInterrupt\" ||\n            (error.message && error.message.includes(\"KeyboardInterrupt\")));\n}\n// Helper function to create KeyboardInterrupt error result\nfunction createKeyboardInterruptResult() {\n    return {\n        success: false,\n        error: new Error(\"KeyboardInterrupt: Execution interrupted by user\"),\n        result: {\n            payload: [],\n            status: \"error\",\n            ename: \"KeyboardInterrupt\",\n            evalue: \"Execution interrupted by user\",\n            traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n        }\n    };\n}\n// Global error handlers to prevent worker crashes\nself.addEventListener(\"error\", (event) => {\n    console.error(\"[WORKER] Global error caught:\", event.error);\n    event.preventDefault();\n});\nself.addEventListener(\"unhandledrejection\", (event) => {\n    if (isKeyboardInterrupt(event.reason)) {\n        console.log(\"[WORKER] KeyboardInterrupt caught in unhandled rejection handler - this is expected during interrupts\");\n        // Send interrupt acknowledgment if we have an event port\n        if (eventPort) {\n            eventPort.postMessage({\n                type: _types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR,\n                data: {\n                    ename: \"KeyboardInterrupt\",\n                    evalue: \"Execution interrupted by user\",\n                    traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n                }\n            });\n        }\n    }\n    else {\n        console.error(\"[WORKER] Unhandled promise rejection:\", event.reason);\n    }\n    event.preventDefault();\n});\n// Listen for messages to set up the event port and initialize kernel\nself.addEventListener(\"message\", (event) => {\n    if (event.data?.type === \"SET_EVENT_PORT\" && event.data?.port) {\n        // Clean up old event listeners and port before setting up new ones\n        cleanupEventForwarding();\n        // Set the new port\n        eventPort = event.data.port;\n        // If the kernel is already initialized, set up event forwarding immediately\n        if (kernel.isInitialized()) {\n            setupEventForwarding();\n        }\n    }\n    else if (event.data?.type === \"INITIALIZE_KERNEL\") {\n        // Save the options for kernel initialization\n        kernelOptions = event.data.options || {};\n        // Initialize the kernel with the provided options\n        initializeKernel(kernelOptions).catch(error => {\n            console.error(\"[WORKER] Error initializing kernel in worker:\", error);\n            if (eventPort) {\n                eventPort.postMessage({\n                    type: _types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR,\n                    data: {\n                        ename: \"WorkerInitError\",\n                        evalue: `Failed to initialize kernel: ${error.message}`,\n                        traceback: [error.stack || \"\"]\n                    }\n                });\n            }\n        });\n    }\n    else if (event.data?.type === \"SET_INTERRUPT_BUFFER\") {\n        // Handle interrupt buffer setup\n        interruptBuffer = event.data.buffer;\n        // Set the interrupt buffer in the kernel if it's initialized\n        if (kernel.isInitialized() && interruptBuffer && typeof kernel.setInterruptBuffer === 'function') {\n            kernel.setInterruptBuffer(interruptBuffer);\n            console.log(\"[WORKER] Interrupt buffer set in pyodide kernel\");\n        }\n        else if (interruptBuffer) {\n            console.log(\"[WORKER] Interrupt buffer stored, will be set when kernel initializes\");\n        }\n        const responseMessage = {\n            type: \"INTERRUPT_BUFFER_SET\",\n            data: { success: true }\n        };\n        // Send response on both channels to ensure it's received\n        if (eventPort) {\n            eventPort.postMessage(responseMessage);\n        }\n        // Also send on main worker channel in case eventPort isn't set up yet\n        self.postMessage(responseMessage);\n    }\n    else if (event.data?.type === \"INTERRUPT_KERNEL\") {\n        // Handle interrupt request\n        if (interruptBuffer) {\n            // Set interrupt signal (2 = SIGINT)\n            interruptBuffer[0] = 2;\n            const responseMessage = {\n                type: \"INTERRUPT_TRIGGERED\",\n                data: { success: true, method: \"buffer\" }\n            };\n            // Send response on both channels\n            if (eventPort) {\n                eventPort.postMessage(responseMessage);\n            }\n            self.postMessage(responseMessage);\n        }\n        else {\n            console.log(\"[WORKER] No interrupt buffer available, trying kernel.interrupt()\");\n            // Fallback to kernel interrupt method\n            if (typeof kernel.interrupt === 'function') {\n                kernel.interrupt().then(success => {\n                    const responseMessage = {\n                        type: \"INTERRUPT_TRIGGERED\",\n                        data: { success, method: \"kernel\" }\n                    };\n                    if (eventPort) {\n                        eventPort.postMessage(responseMessage);\n                    }\n                    self.postMessage(responseMessage);\n                }).catch(error => {\n                    console.error(\"[WORKER] Error during kernel interrupt:\", error);\n                    const responseMessage = {\n                        type: \"INTERRUPT_TRIGGERED\",\n                        data: { success: false, error: error.message, method: \"kernel\" }\n                    };\n                    if (eventPort) {\n                        eventPort.postMessage(responseMessage);\n                    }\n                    self.postMessage(responseMessage);\n                });\n            }\n            else {\n                console.warn(\"[WORKER] No interrupt method available\");\n                const responseMessage = {\n                    type: \"INTERRUPT_TRIGGERED\",\n                    data: { success: false, error: \"No interrupt method available\", method: \"none\" }\n                };\n                if (eventPort) {\n                    eventPort.postMessage(responseMessage);\n                }\n                self.postMessage(responseMessage);\n            }\n        }\n    }\n});\n// Initialize the kernel with provided options\nasync function initializeKernel(options) {\n    try {\n        await kernel.initialize(options);\n        // Set up the interrupt buffer if it's available and the kernel supports it\n        if (interruptBuffer && typeof kernel.setInterruptBuffer === 'function') {\n            kernel.setInterruptBuffer(interruptBuffer);\n        }\n        // Set up event forwarding AFTER kernel is initialized\n        setupEventForwarding();\n        if (eventPort) {\n            eventPort.postMessage({\n                type: \"KERNEL_INITIALIZED\",\n                data: { success: true }\n            });\n        }\n    }\n    catch (error) {\n        console.error(\"Kernel initialization failed:\", error);\n        throw error;\n    }\n}\n// Clean up old event listeners and port\nfunction cleanupEventForwarding() {\n    if (currentEventListeners.size > 0) {\n        // Remove all current event listeners\n        for (const [eventType, listener] of currentEventListeners.entries()) {\n            kernel.off(eventType, listener);\n        }\n        // Clear the listeners map\n        currentEventListeners.clear();\n    }\n    // Close the old port if it exists\n    if (eventPort) {\n        eventPort.close();\n        eventPort = null;\n    }\n}\n// Set up event forwarding from kernel to main thread\nfunction setupEventForwarding() {\n    if (!eventPort) {\n        console.error(\"[WORKER] Cannot set up event forwarding: no event port available\");\n        return;\n    }\n    // Forward all kernel events to the main thread\n    Object.values(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents).forEach((eventType) => {\n        // Create a listener function for this event type\n        const listener = (data) => {\n            if (eventPort) {\n                // Send just the event type and raw data\n                // This matches the structure used in main thread mode\n                eventPort.postMessage({\n                    type: eventType,\n                    data: data\n                });\n            }\n        };\n        // Store the listener for later cleanup\n        currentEventListeners.set(eventType, listener);\n        // Add the listener to the kernel\n        kernel.on(eventType, listener);\n    });\n}\n// Handle cleanup when worker is terminated\nself.addEventListener(\"beforeunload\", async () => {\n    // Close any resources or connections\n    try {\n        // Send a final message before termination if needed\n        if (eventPort) {\n            eventPort.postMessage({\n                type: \"WORKER_TERMINATING\",\n                data: { message: \"Worker is shutting down\" }\n            });\n        }\n    }\n    catch (error) {\n        console.error(\"Error during worker cleanup:\", error);\n    }\n});\n// Log available methods for debugging\n// Create a simplified proxy that only exposes the methods we need\n// We're not trying to implement the full EventEmitter interface\nconst simpleProxy = {\n    // Required methods from IKernel interface\n    initialize: async (options) => {\n        try {\n            await kernel.initialize(options);\n            return undefined;\n        }\n        catch (error) {\n            console.error(\"[WORKER] Initialize error:\", error);\n            throw error;\n        }\n    },\n    execute: async (code, parent) => {\n        try {\n            const result = await kernel.execute(code, parent);\n            return result;\n        }\n        catch (error) {\n            console.error(\"[WORKER] Execute error:\", error);\n            // Check if this is a KeyboardInterrupt and handle it specially\n            if (isKeyboardInterrupt(error)) {\n                console.log(\"[WORKER] KeyboardInterrupt caught in execute method\");\n                return createKeyboardInterruptResult();\n            }\n            // Handle other errors normally\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error)),\n                result: {\n                    payload: [],\n                    status: \"error\",\n                    ename: error instanceof Error ? error.constructor.name : \"Error\",\n                    evalue: error instanceof Error ? error.message : String(error),\n                    traceback: error instanceof Error && error.stack ? error.stack.split('\\n') : [String(error)]\n                }\n            };\n        }\n    },\n    isInitialized: () => {\n        try {\n            const result = kernel.isInitialized();\n            return result;\n        }\n        catch (error) {\n            console.error(\"[WORKER] IsInitialized error:\", error);\n            return false;\n        }\n    },\n    inputReply: async (content) => {\n        try {\n            await kernel.inputReply(content);\n        }\n        catch (error) {\n            console.error(\"[WORKER] InputReply error:\", error);\n            throw error;\n        }\n    },\n    // Async method for status\n    getStatus: async () => {\n        try {\n            const status = await kernel.getStatus();\n            return status;\n        }\n        catch (error) {\n            console.error(\"[WORKER] getStatus error:\", error);\n            return \"unknown\";\n        }\n    },\n    // Interrupt functionality\n    interrupt: async () => {\n        try {\n            if (typeof kernel.interrupt === 'function') {\n                const result = await kernel.interrupt();\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support interrupt method\");\n                return false;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] Interrupt error:\", error);\n            // Don't let interrupt errors crash the worker\n            return false;\n        }\n    },\n    setInterruptBuffer: (buffer) => {\n        try {\n            if (typeof kernel.setInterruptBuffer === 'function') {\n                kernel.setInterruptBuffer(buffer);\n                return true;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support setInterruptBuffer method\");\n                return false;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] setInterruptBuffer error:\", error);\n            return false;\n        }\n    },\n    // Completion methods\n    complete: async (code, cursor_pos, parent) => {\n        try {\n            if (typeof kernel.complete === 'function') {\n                const result = await kernel.complete(code, cursor_pos, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support complete method\");\n                return { status: 'error', error: 'Completion not supported' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] Complete error:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    },\n    inspect: async (code, cursor_pos, detail_level, parent) => {\n        try {\n            if (typeof kernel.inspect === 'function') {\n                const result = await kernel.inspect(code, cursor_pos, detail_level, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support inspect method\");\n                return { status: 'error', error: 'Inspection not supported' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] Inspect error:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    },\n    isComplete: async (code, parent) => {\n        try {\n            if (typeof kernel.isComplete === 'function') {\n                const result = await kernel.isComplete(code, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support isComplete method\");\n                return { status: 'unknown' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] IsComplete error:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    },\n    // Native filesystem mounting\n    mountFS: async (mountPath, dirHandle, permission) => {\n        try {\n            if (typeof kernel.mountFS === 'function') {\n                // In worker context, dirHandle must be provided - we cannot show directory picker\n                if (!dirHandle) {\n                    throw new Error(\"Cannot show directory picker in worker context. Please provide a dirHandle parameter when calling mountFS on a worker kernel.\");\n                }\n                const result = await kernel.mountFS(mountPath, dirHandle, permission);\n                // Wrap the result with Comlink.proxy so the syncfs function can be called across worker boundary\n                return comlink__WEBPACK_IMPORTED_MODULE_0__.proxy(result);\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support mountFS method\");\n                throw new Error(\"mountFS is not supported by this kernel\");\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] MountFS error:\", error);\n            throw error;\n        }\n    },\n    getMountedFileSystems: async () => {\n        try {\n            if (typeof kernel.getMountedFileSystems === 'function') {\n                const result = kernel.getMountedFileSystems();\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support getMountedFileSystems method\");\n                return [];\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] getMountedFileSystems error:\", error);\n            return [];\n        }\n    },\n    syncFileSystem: async (mountPath) => {\n        try {\n            if (typeof kernel.syncFileSystem === 'function') {\n                const result = await kernel.syncFileSystem(mountPath);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support syncFileSystem method\");\n                return { success: false, error: 'syncFileSystem is not supported by this kernel' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] syncFileSystem error:\", error);\n            return { success: false, error: error instanceof Error ? error.message : String(error) };\n        }\n    },\n    upgradeFileSystemPermission: async (mountPath) => {\n        try {\n            if (typeof kernel.upgradeFileSystemPermission === 'function') {\n                const result = await kernel.upgradeFileSystemPermission(mountPath);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support upgradeFileSystemPermission method\");\n                return { success: false, error: 'upgradeFileSystemPermission is not supported by this kernel' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] upgradeFileSystemPermission error:\", error);\n            return { success: false, error: error instanceof Error ? error.message : String(error) };\n        }\n    },\n    // Comm methods\n    commInfo: async (target_name, parent) => {\n        try {\n            if (typeof kernel.commInfo === 'function') {\n                const result = await kernel.commInfo(target_name, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support commInfo method\");\n                return { comms: {}, status: 'ok' };\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] CommInfo error:\", error);\n            return { comms: {}, status: 'error', error: String(error) };\n        }\n    },\n    commOpen: async (content, parent) => {\n        try {\n            if (typeof kernel.commOpen === 'function') {\n                const result = await kernel.commOpen(content, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support commOpen method\");\n                return undefined;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] CommOpen error:\", error);\n            return undefined;\n        }\n    },\n    commMsg: async (content, parent) => {\n        try {\n            if (typeof kernel.commMsg === 'function') {\n                const result = await kernel.commMsg(content, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support commMsg method\");\n                return undefined;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] CommMsg error:\", error);\n            return undefined;\n        }\n    },\n    commClose: async (content, parent) => {\n        try {\n            if (typeof kernel.commClose === 'function') {\n                const result = await kernel.commClose(content, parent);\n                return result;\n            }\n            else {\n                console.warn(\"[WORKER] Kernel does not support commClose method\");\n                return undefined;\n            }\n        }\n        catch (error) {\n            console.error(\"[WORKER] CommClose error:\", error);\n            return undefined;\n        }\n    }\n};\n// Expose the proxy through Comlink\ntry {\n    comlink__WEBPACK_IMPORTED_MODULE_0__.expose(simpleProxy);\n}\ncatch (error) {\n    console.error(\"Error exposing proxy:\", error);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aURBQWlELENBQUMsQ0FBQztnQkFDaEUsT0FBTyxTQUFTLENBQUM7WUFDbkIsQ0FBQztRQUNILENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsT0FBTyxDQUFDLEtBQUssQ0FBQyx5QkFBeUIsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUNoRCxPQUFPLFNBQVMsQ0FBQztRQUNuQixDQUFDO0lBQ0gsQ0FBQztJQUVELFNBQVMsRUFBRSxLQUFLLEVBQUUsT0FBWSxFQUFFLE1BQVksRUFBRSxFQUFFO1FBQzlDLElBQUksQ0FBQztZQUNILElBQUksT0FBTyxNQUFNLENBQUMsU0FBUyxLQUFLLFVBQVUsRUFBRSxDQUFDO2dCQUMzQyxNQUFNLE1BQU0sR0FBRyxNQUFNLE1BQU0sQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUN2RCxPQUFPLE1BQU0sQ0FBQztZQUNoQixDQUFDO2lCQUFNLENBQUM7Z0JBQ04sT0FBTyxDQUFDLElBQUksQ0FBQyxtREFBbUQsQ0FBQyxDQUFDO2dCQUNsRSxPQUFPLFNBQVMsQ0FBQztZQUNuQixDQUFDO1FBQ0gsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLDJCQUEyQixFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ2xELE9BQU8sU0FBUyxDQUFDO1FBQ25CLENBQUM7SUFDSCxDQUFDO0NBQ0YsQ0FBQztBQUVGLG1DQUFtQztBQUNuQyxJQUFJLENBQUM7SUFDSCwyQ0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzlCLENBQUM7QUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO0lBQ2YsT0FBTyxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUNoRCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLXB5dGhvbi1rZXJuZWwvLi9zcmMva2VybmVsLndvcmtlci50cz80ZTcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlYiBXb3JrZXIgZmlsZSBmb3IgcnVubmluZyB0aGUgS2VybmVsIGluIGEgc2VwYXJhdGUgdGhyZWFkXG4vLyBJbXBvcnQgbmVjZXNzYXJ5IG1vZHVsZXNcbmltcG9ydCAqIGFzIENvbWxpbmsgZnJvbSBcImNvbWxpbmtcIjtcbmltcG9ydCB7IEtlcm5lbEV2ZW50cywgSUtlcm5lbE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgS2VybmVsIH0gZnJvbSBcIi4vaW5kZXhcIjtcblxuLy8gVXNlIGEgYnJvd3Nlci1jb21wYXRpYmxlIEV2ZW50RW1pdHRlclxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgcHVibGljIGV2ZW50czogeyBba2V5OiBzdHJpbmddOiBGdW5jdGlvbltdIH0gPSB7fTtcblxuICBvbihldmVudE5hbWU6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gW107XG4gICAgfVxuICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICBvZmYoZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikge1xuICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkgcmV0dXJuO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIGVtaXQoZXZlbnROYW1lOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSByZXR1cm47XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKC4uLmFyZ3MpKTtcbiAgfVxufVxuXG5cbi8vIENyZWF0ZSBhIG5ldyBrZXJuZWwgaW5zdGFuY2VcbmNvbnN0IGtlcm5lbCA9IG5ldyBLZXJuZWwoKTtcblxuLy8gVmFyaWFibGUgdG8gc3RvcmUgdGhlIGV2ZW50IHBvcnRcbmxldCBldmVudFBvcnQ6IE1lc3NhZ2VQb3J0IHwgbnVsbCA9IG51bGw7XG5cbi8vIFN0b3JlIGtlcm5lbCBpbml0aWFsaXphdGlvbiBvcHRpb25zXG5sZXQga2VybmVsT3B0aW9uczogSUtlcm5lbE9wdGlvbnMgPSB7fTtcblxuLy8gVHJhY2sgY3VycmVudCBldmVudCBsaXN0ZW5lcnMgZm9yIGNsZWFudXBcbmxldCBjdXJyZW50RXZlbnRMaXN0ZW5lcnM6IE1hcDxzdHJpbmcsIChkYXRhOiBhbnkpID0+IHZvaWQ+ID0gbmV3IE1hcCgpO1xuXG4vLyBJbnRlcnJ1cHQgaGFuZGxpbmcgZm9yIHdvcmtlclxubGV0IGludGVycnVwdEJ1ZmZlcjogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYW4gZXJyb3IgaXMgYSBLZXlib2FyZEludGVycnVwdFxuZnVuY3Rpb24gaXNLZXlib2FyZEludGVycnVwdChlcnJvcjogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiBlcnJvciAmJiBcbiAgICAgICAgIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgXG4gICAgICAgICAoZXJyb3IudHlwZSA9PT0gXCJLZXlib2FyZEludGVycnVwdFwiIHx8IFxuICAgICAgICAgIChlcnJvci5tZXNzYWdlICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJLZXlib2FyZEludGVycnVwdFwiKSkpO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIEtleWJvYXJkSW50ZXJydXB0IGVycm9yIHJlc3VsdFxuZnVuY3Rpb24gY3JlYXRlS2V5Ym9hcmRJbnRlcnJ1cHRSZXN1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogZmFsc2UsXG4gICAgZXJyb3I6IG5ldyBFcnJvcihcIktleWJvYXJkSW50ZXJydXB0OiBFeGVjdXRpb24gaW50ZXJydXB0ZWQgYnkgdXNlclwiKSxcbiAgICByZXN1bHQ6IHtcbiAgICAgIHBheWxvYWQ6IFtdLFxuICAgICAgc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICBlbmFtZTogXCJLZXlib2FyZEludGVycnVwdFwiLFxuICAgICAgZXZhbHVlOiBcIkV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCIsXG4gICAgICB0cmFjZWJhY2s6IFtcIktleWJvYXJkSW50ZXJydXB0OiBFeGVjdXRpb24gaW50ZXJydXB0ZWQgYnkgdXNlclwiXVxuICAgIH1cbiAgfTtcbn1cblxuLy8gR2xvYmFsIGVycm9yIGhhbmRsZXJzIHRvIHByZXZlbnQgd29ya2VyIGNyYXNoZXNcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChldmVudCkgPT4ge1xuICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gR2xvYmFsIGVycm9yIGNhdWdodDpcIiwgZXZlbnQuZXJyb3IpO1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufSk7XG5cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcInVuaGFuZGxlZHJlamVjdGlvblwiLCAoZXZlbnQpID0+IHtcbiAgaWYgKGlzS2V5Ym9hcmRJbnRlcnJ1cHQoZXZlbnQucmVhc29uKSkge1xuICAgIGNvbnNvbGUubG9nKFwiW1dPUktFUl0gS2V5Ym9hcmRJbnRlcnJ1cHQgY2F1Z2h0IGluIHVuaGFuZGxlZCByZWplY3Rpb24gaGFuZGxlciAtIHRoaXMgaXMgZXhwZWN0ZWQgZHVyaW5nIGludGVycnVwdHNcIik7XG4gICAgXG4gICAgLy8gU2VuZCBpbnRlcnJ1cHQgYWNrbm93bGVkZ21lbnQgaWYgd2UgaGF2ZSBhbiBldmVudCBwb3J0XG4gICAgaWYgKGV2ZW50UG9ydCkge1xuICAgICAgZXZlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBlbmFtZTogXCJLZXlib2FyZEludGVycnVwdFwiLFxuICAgICAgICAgIGV2YWx1ZTogXCJFeGVjdXRpb24gaW50ZXJydXB0ZWQgYnkgdXNlclwiLFxuICAgICAgICAgIHRyYWNlYmFjazogW1wiS2V5Ym9hcmRJbnRlcnJ1cHQ6IEV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCJdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uOlwiLCBldmVudC5yZWFzb24pO1xuICB9XG4gIFxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufSk7XG5cbi8vIExpc3RlbiBmb3IgbWVzc2FnZXMgdG8gc2V0IHVwIHRoZSBldmVudCBwb3J0IGFuZCBpbml0aWFsaXplIGtlcm5lbFxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IFwiU0VUX0VWRU5UX1BPUlRcIiAmJiBldmVudC5kYXRhPy5wb3J0KSB7XG4gICAgLy8gQ2xlYW4gdXAgb2xkIGV2ZW50IGxpc3RlbmVycyBhbmQgcG9ydCBiZWZvcmUgc2V0dGluZyB1cCBuZXcgb25lc1xuICAgIGNsZWFudXBFdmVudEZvcndhcmRpbmcoKTtcbiAgICBcbiAgICAvLyBTZXQgdGhlIG5ldyBwb3J0XG4gICAgZXZlbnRQb3J0ID0gZXZlbnQuZGF0YS5wb3J0O1xuICAgIFxuICAgIC8vIElmIHRoZSBrZXJuZWwgaXMgYWxyZWFkeSBpbml0aWFsaXplZCwgc2V0IHVwIGV2ZW50IGZvcndhcmRpbmcgaW1tZWRpYXRlbHlcbiAgICBpZiAoa2VybmVsLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgc2V0dXBFdmVudEZvcndhcmRpbmcoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJJTklUSUFMSVpFX0tFUk5FTFwiKSB7XG4gICAgLy8gU2F2ZSB0aGUgb3B0aW9ucyBmb3Iga2VybmVsIGluaXRpYWxpemF0aW9uXG4gICAga2VybmVsT3B0aW9ucyA9IGV2ZW50LmRhdGEub3B0aW9ucyB8fCB7fTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHRoZSBrZXJuZWwgd2l0aCB0aGUgcHJvdmlkZWQgb3B0aW9uc1xuICAgIGluaXRpYWxpemVLZXJuZWwoa2VybmVsT3B0aW9ucykuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIEVycm9yIGluaXRpYWxpemluZyBrZXJuZWwgaW4gd29ya2VyOlwiLCBlcnJvcik7XG4gICAgICBpZiAoZXZlbnRQb3J0KSB7XG4gICAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgdHlwZTogS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZW5hbWU6IFwiV29ya2VySW5pdEVycm9yXCIsXG4gICAgICAgICAgICBldmFsdWU6IGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBrZXJuZWw6ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgdHJhY2ViYWNrOiBbZXJyb3Iuc3RhY2sgfHwgXCJcIl1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IFwiU0VUX0lOVEVSUlVQVF9CVUZGRVJcIikge1xuICAgIC8vIEhhbmRsZSBpbnRlcnJ1cHQgYnVmZmVyIHNldHVwXG4gICAgaW50ZXJydXB0QnVmZmVyID0gZXZlbnQuZGF0YS5idWZmZXI7XG4gICAgXG4gICAgLy8gU2V0IHRoZSBpbnRlcnJ1cHQgYnVmZmVyIGluIHRoZSBrZXJuZWwgaWYgaXQncyBpbml0aWFsaXplZFxuICAgIGlmIChrZXJuZWwuaXNJbml0aWFsaXplZCgpICYmIGludGVycnVwdEJ1ZmZlciAmJiB0eXBlb2Yga2VybmVsLnNldEludGVycnVwdEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAga2VybmVsLnNldEludGVycnVwdEJ1ZmZlcihpbnRlcnJ1cHRCdWZmZXIpO1xuICAgICAgY29uc29sZS5sb2coXCJbV09SS0VSXSBJbnRlcnJ1cHQgYnVmZmVyIHNldCBpbiBweW9kaWRlIGtlcm5lbFwiKTtcbiAgICB9IGVsc2UgaWYgKGludGVycnVwdEJ1ZmZlcikge1xuICAgICAgY29uc29sZS5sb2coXCJbV09SS0VSXSBJbnRlcnJ1cHQgYnVmZmVyIHN0b3JlZCwgd2lsbCBiZSBzZXQgd2hlbiBrZXJuZWwgaW5pdGlhbGl6ZXNcIik7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZSA9IHtcbiAgICAgIHR5cGU6IFwiSU5URVJSVVBUX0JVRkZFUl9TRVRcIixcbiAgICAgIGRhdGE6IHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBTZW5kIHJlc3BvbnNlIG9uIGJvdGggY2hhbm5lbHMgdG8gZW5zdXJlIGl0J3MgcmVjZWl2ZWRcbiAgICBpZiAoZXZlbnRQb3J0KSB7XG4gICAgICBldmVudFBvcnQucG9zdE1lc3NhZ2UocmVzcG9uc2VNZXNzYWdlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWxzbyBzZW5kIG9uIG1haW4gd29ya2VyIGNoYW5uZWwgaW4gY2FzZSBldmVudFBvcnQgaXNuJ3Qgc2V0IHVwIHlldFxuICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzcG9uc2VNZXNzYWdlKTtcbiAgICBcbiAgfSBlbHNlIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIklOVEVSUlVQVF9LRVJORUxcIikge1xuICAgIC8vIEhhbmRsZSBpbnRlcnJ1cHQgcmVxdWVzdFxuICAgIFxuICAgIGlmIChpbnRlcnJ1cHRCdWZmZXIpIHtcbiAgICAgIC8vIFNldCBpbnRlcnJ1cHQgc2lnbmFsICgyID0gU0lHSU5UKVxuICAgICAgaW50ZXJydXB0QnVmZmVyWzBdID0gMjtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgICB0eXBlOiBcIklOVEVSUlVQVF9UUklHR0VSRURcIixcbiAgICAgICAgZGF0YTogeyBzdWNjZXNzOiB0cnVlLCBtZXRob2Q6IFwiYnVmZmVyXCIgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gU2VuZCByZXNwb25zZSBvbiBib3RoIGNoYW5uZWxzXG4gICAgICBpZiAoZXZlbnRQb3J0KSB7XG4gICAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZShyZXNwb25zZU1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgc2VsZi5wb3N0TWVzc2FnZShyZXNwb25zZU1lc3NhZ2UpO1xuICAgICAgXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW1dPUktFUl0gTm8gaW50ZXJydXB0IGJ1ZmZlciBhdmFpbGFibGUsIHRyeWluZyBrZXJuZWwuaW50ZXJydXB0KClcIik7XG4gICAgICBcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGtlcm5lbCBpbnRlcnJ1cHQgbWV0aG9kXG4gICAgICBpZiAodHlwZW9mIGtlcm5lbC5pbnRlcnJ1cHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAga2VybmVsLmludGVycnVwdCgpLnRoZW4oc3VjY2VzcyA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgICAgICAgdHlwZTogXCJJTlRFUlJVUFRfVFJJR0dFUkVEXCIsXG4gICAgICAgICAgICBkYXRhOiB7IHN1Y2Nlc3MsIG1ldGhvZDogXCJrZXJuZWxcIiB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZXZlbnRQb3J0KSB7XG4gICAgICAgICAgICBldmVudFBvcnQucG9zdE1lc3NhZ2UocmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShyZXNwb25zZU1lc3NhZ2UpO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIEVycm9yIGR1cmluZyBrZXJuZWwgaW50ZXJydXB0OlwiLCBlcnJvcik7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgICAgICAgdHlwZTogXCJJTlRFUlJVUFRfVFJJR0dFUkVEXCIsXG4gICAgICAgICAgICBkYXRhOiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSwgbWV0aG9kOiBcImtlcm5lbFwiIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgICAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZShyZXNwb25zZU1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gTm8gaW50ZXJydXB0IG1ldGhvZCBhdmFpbGFibGVcIik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZSA9IHtcbiAgICAgICAgICB0eXBlOiBcIklOVEVSUlVQVF9UUklHR0VSRURcIixcbiAgICAgICAgICBkYXRhOiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJObyBpbnRlcnJ1cHQgbWV0aG9kIGF2YWlsYWJsZVwiLCBtZXRob2Q6IFwibm9uZVwiIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGlmIChldmVudFBvcnQpIHtcbiAgICAgICAgICBldmVudFBvcnQucG9zdE1lc3NhZ2UocmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUga2VybmVsIHdpdGggcHJvdmlkZWQgb3B0aW9uc1xuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZUtlcm5lbChvcHRpb25zOiBJS2VybmVsT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGF3YWl0IGtlcm5lbC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIFxuICAgIC8vIFNldCB1cCB0aGUgaW50ZXJydXB0IGJ1ZmZlciBpZiBpdCdzIGF2YWlsYWJsZSBhbmQgdGhlIGtlcm5lbCBzdXBwb3J0cyBpdFxuICAgIGlmIChpbnRlcnJ1cHRCdWZmZXIgJiYgdHlwZW9mIGtlcm5lbC5zZXRJbnRlcnJ1cHRCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGtlcm5lbC5zZXRJbnRlcnJ1cHRCdWZmZXIoaW50ZXJydXB0QnVmZmVyKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0IHVwIGV2ZW50IGZvcndhcmRpbmcgQUZURVIga2VybmVsIGlzIGluaXRpYWxpemVkXG4gICAgc2V0dXBFdmVudEZvcndhcmRpbmcoKTtcbiAgICBcbiAgICBpZiAoZXZlbnRQb3J0KSB7XG4gICAgICBldmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcIktFUk5FTF9JTklUSUFMSVpFRFwiLFxuICAgICAgICBkYXRhOiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJLZXJuZWwgaW5pdGlhbGl6YXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLy8gQ2xlYW4gdXAgb2xkIGV2ZW50IGxpc3RlbmVycyBhbmQgcG9ydFxuZnVuY3Rpb24gY2xlYW51cEV2ZW50Rm9yd2FyZGluZygpIHtcbiAgaWYgKGN1cnJlbnRFdmVudExpc3RlbmVycy5zaXplID4gMCkge1xuICAgIC8vIFJlbW92ZSBhbGwgY3VycmVudCBldmVudCBsaXN0ZW5lcnNcbiAgICBmb3IgKGNvbnN0IFtldmVudFR5cGUsIGxpc3RlbmVyXSBvZiBjdXJyZW50RXZlbnRMaXN0ZW5lcnMuZW50cmllcygpKSB7XG4gICAgICAoa2VybmVsIGFzIHVua25vd24gYXMgRXZlbnRFbWl0dGVyKS5vZmYoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFyIHRoZSBsaXN0ZW5lcnMgbWFwXG4gICAgY3VycmVudEV2ZW50TGlzdGVuZXJzLmNsZWFyKCk7XG4gIH1cbiAgXG4gIC8vIENsb3NlIHRoZSBvbGQgcG9ydCBpZiBpdCBleGlzdHNcbiAgaWYgKGV2ZW50UG9ydCkge1xuICAgIGV2ZW50UG9ydC5jbG9zZSgpO1xuICAgIGV2ZW50UG9ydCA9IG51bGw7XG4gIH1cbn1cblxuLy8gU2V0IHVwIGV2ZW50IGZvcndhcmRpbmcgZnJvbSBrZXJuZWwgdG8gbWFpbiB0aHJlYWRcbmZ1bmN0aW9uIHNldHVwRXZlbnRGb3J3YXJkaW5nKCkge1xuICBpZiAoIWV2ZW50UG9ydCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBDYW5ub3Qgc2V0IHVwIGV2ZW50IGZvcndhcmRpbmc6IG5vIGV2ZW50IHBvcnQgYXZhaWxhYmxlXCIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcndhcmQgYWxsIGtlcm5lbCBldmVudHMgdG8gdGhlIG1haW4gdGhyZWFkXG4gIE9iamVjdC52YWx1ZXMoS2VybmVsRXZlbnRzKS5mb3JFYWNoKChldmVudFR5cGUpID0+IHtcbiAgICAvLyBDcmVhdGUgYSBsaXN0ZW5lciBmdW5jdGlvbiBmb3IgdGhpcyBldmVudCB0eXBlXG4gICAgY29uc3QgbGlzdGVuZXIgPSAoZGF0YTogYW55KSA9PiB7XG4gICAgICBpZiAoZXZlbnRQb3J0KSB7XG4gICAgICAgIC8vIFNlbmQganVzdCB0aGUgZXZlbnQgdHlwZSBhbmQgcmF3IGRhdGFcbiAgICAgICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgdXNlZCBpbiBtYWluIHRocmVhZCBtb2RlXG4gICAgICAgIGV2ZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgdHlwZTogZXZlbnRUeXBlLFxuICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBTdG9yZSB0aGUgbGlzdGVuZXIgZm9yIGxhdGVyIGNsZWFudXBcbiAgICBjdXJyZW50RXZlbnRMaXN0ZW5lcnMuc2V0KGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIFxuICAgIC8vIEFkZCB0aGUgbGlzdGVuZXIgdG8gdGhlIGtlcm5lbFxuICAgIChrZXJuZWwgYXMgdW5rbm93biBhcyBFdmVudEVtaXR0ZXIpLm9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICB9KTtcbn1cblxuLy8gSGFuZGxlIGNsZWFudXAgd2hlbiB3b3JrZXIgaXMgdGVybWluYXRlZFxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGFzeW5jICgpID0+IHtcbiAgLy8gQ2xvc2UgYW55IHJlc291cmNlcyBvciBjb25uZWN0aW9uc1xuICB0cnkge1xuICAgIC8vIFNlbmQgYSBmaW5hbCBtZXNzYWdlIGJlZm9yZSB0ZXJtaW5hdGlvbiBpZiBuZWVkZWRcbiAgICBpZiAoZXZlbnRQb3J0KSB7XG4gICAgICBldmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcIldPUktFUl9URVJNSU5BVElOR1wiLFxuICAgICAgICBkYXRhOiB7IG1lc3NhZ2U6IFwiV29ya2VyIGlzIHNodXR0aW5nIGRvd25cIiB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyB3b3JrZXIgY2xlYW51cDpcIiwgZXJyb3IpO1xuICB9XG59KTtcblxuLy8gTG9nIGF2YWlsYWJsZSBtZXRob2RzIGZvciBkZWJ1Z2dpbmdcblxuLy8gQ3JlYXRlIGEgc2ltcGxpZmllZCBwcm94eSB0aGF0IG9ubHkgZXhwb3NlcyB0aGUgbWV0aG9kcyB3ZSBuZWVkXG4vLyBXZSdyZSBub3QgdHJ5aW5nIHRvIGltcGxlbWVudCB0aGUgZnVsbCBFdmVudEVtaXR0ZXIgaW50ZXJmYWNlXG5jb25zdCBzaW1wbGVQcm94eSA9IHtcbiAgLy8gUmVxdWlyZWQgbWV0aG9kcyBmcm9tIElLZXJuZWwgaW50ZXJmYWNlXG4gIGluaXRpYWxpemU6IGFzeW5jIChvcHRpb25zPzogSUtlcm5lbE9wdGlvbnMpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQga2VybmVsLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gSW5pdGlhbGl6ZSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuICBcbiAgZXhlY3V0ZTogYXN5bmMgKGNvZGU6IHN0cmluZywgcGFyZW50PzogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGtlcm5lbC5leGVjdXRlKGNvZGUsIHBhcmVudCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gRXhlY3V0ZSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgS2V5Ym9hcmRJbnRlcnJ1cHQgYW5kIGhhbmRsZSBpdCBzcGVjaWFsbHlcbiAgICAgIGlmIChpc0tleWJvYXJkSW50ZXJydXB0KGVycm9yKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltXT1JLRVJdIEtleWJvYXJkSW50ZXJydXB0IGNhdWdodCBpbiBleGVjdXRlIG1ldGhvZFwiKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUtleWJvYXJkSW50ZXJydXB0UmVzdWx0KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBvdGhlciBlcnJvcnMgbm9ybWFsbHlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpLFxuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICBwYXlsb2FkOiBbXSxcbiAgICAgICAgICBzdGF0dXM6IFwiZXJyb3JcIixcbiAgICAgICAgICBlbmFtZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLmNvbnN0cnVjdG9yLm5hbWUgOiBcIkVycm9yXCIsXG4gICAgICAgICAgZXZhbHVlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgdHJhY2ViYWNrOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLnN0YWNrID8gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpIDogW1N0cmluZyhlcnJvcildXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBcbiAgaXNJbml0aWFsaXplZDogKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwuaXNJbml0aWFsaXplZCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIElzSW5pdGlhbGl6ZWQgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIFxuICBpbnB1dFJlcGx5OiBhc3luYyAoY29udGVudDogeyB2YWx1ZTogc3RyaW5nIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQga2VybmVsLmlucHV0UmVwbHkoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBJbnB1dFJlcGx5IGVycm9yOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG4gIFxuICAvLyBBc3luYyBtZXRob2QgZm9yIHN0YXR1c1xuICBnZXRTdGF0dXM6IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQga2VybmVsLmdldFN0YXR1cygpO1xuICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIGdldFN0YXR1cyBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8vIEludGVycnVwdCBmdW5jdGlvbmFsaXR5XG4gIGludGVycnVwdDogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGtlcm5lbC5pbnRlcnJ1cHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga2VybmVsLmludGVycnVwdCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gS2VybmVsIGRvZXMgbm90IHN1cHBvcnQgaW50ZXJydXB0IG1ldGhvZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gSW50ZXJydXB0IGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAvLyBEb24ndCBsZXQgaW50ZXJydXB0IGVycm9ycyBjcmFzaCB0aGUgd29ya2VyXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuICBcbiAgc2V0SW50ZXJydXB0QnVmZmVyOiAoYnVmZmVyOiBVaW50OEFycmF5KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLnNldEludGVycnVwdEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBrZXJuZWwuc2V0SW50ZXJydXB0QnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gS2VybmVsIGRvZXMgbm90IHN1cHBvcnQgc2V0SW50ZXJydXB0QnVmZmVyIG1ldGhvZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gc2V0SW50ZXJydXB0QnVmZmVyIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuICBcbiAgLy8gQ29tcGxldGlvbiBtZXRob2RzXG4gIGNvbXBsZXRlOiBhc3luYyAoY29kZTogc3RyaW5nLCBjdXJzb3JfcG9zOiBudW1iZXIsIHBhcmVudD86IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGtlcm5lbC5jb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBrZXJuZWwuY29tcGxldGUoY29kZSwgY3Vyc29yX3BvcywgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltXT1JLRVJdIEtlcm5lbCBkb2VzIG5vdCBzdXBwb3J0IGNvbXBsZXRlIG1ldGhvZFwiKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogJ0NvbXBsZXRpb24gbm90IHN1cHBvcnRlZCcgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIENvbXBsZXRlIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiBTdHJpbmcoZXJyb3IpIH07XG4gICAgfVxuICB9LFxuICBcbiAgaW5zcGVjdDogYXN5bmMgKGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBkZXRhaWxfbGV2ZWw6IDAgfCAxLCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBrZXJuZWwuaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBrZXJuZWwuaW5zcGVjdChjb2RlLCBjdXJzb3JfcG9zLCBkZXRhaWxfbGV2ZWwsIHBhcmVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV09SS0VSXSBLZXJuZWwgZG9lcyBub3Qgc3VwcG9ydCBpbnNwZWN0IG1ldGhvZFwiKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogJ0luc3BlY3Rpb24gbm90IHN1cHBvcnRlZCcgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIEluc3BlY3QgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICB9XG4gIH0sXG4gIFxuICBpc0NvbXBsZXRlOiBhc3luYyAoY29kZTogc3RyaW5nLCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBrZXJuZWwuaXNDb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBrZXJuZWwuaXNDb21wbGV0ZShjb2RlLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gS2VybmVsIGRvZXMgbm90IHN1cHBvcnQgaXNDb21wbGV0ZSBtZXRob2RcIik7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogJ3Vua25vd24nIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBJc0NvbXBsZXRlIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiBTdHJpbmcoZXJyb3IpIH07XG4gICAgfVxuICB9LFxuXG4gIC8vIE5hdGl2ZSBmaWxlc3lzdGVtIG1vdW50aW5nXG4gIG1vdW50RlM6IGFzeW5jIChtb3VudFBhdGg6IHN0cmluZywgZGlySGFuZGxlPzogRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSB8IG51bGwsIHBlcm1pc3Npb24/OiAncmVhZCcgfCAncmVhZHdyaXRlJykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGtlcm5lbC5tb3VudEZTID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEluIHdvcmtlciBjb250ZXh0LCBkaXJIYW5kbGUgbXVzdCBiZSBwcm92aWRlZCAtIHdlIGNhbm5vdCBzaG93IGRpcmVjdG9yeSBwaWNrZXJcbiAgICAgICAgaWYgKCFkaXJIYW5kbGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2hvdyBkaXJlY3RvcnkgcGlja2VyIGluIHdvcmtlciBjb250ZXh0LiBQbGVhc2UgcHJvdmlkZSBhIGRpckhhbmRsZSBwYXJhbWV0ZXIgd2hlbiBjYWxsaW5nIG1vdW50RlMgb24gYSB3b3JrZXIga2VybmVsLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBrZXJuZWwubW91bnRGUyhtb3VudFBhdGgsIGRpckhhbmRsZSwgcGVybWlzc2lvbik7XG4gICAgICAgIC8vIFdyYXAgdGhlIHJlc3VsdCB3aXRoIENvbWxpbmsucHJveHkgc28gdGhlIHN5bmNmcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIGFjcm9zcyB3b3JrZXIgYm91bmRhcnlcbiAgICAgICAgcmV0dXJuIENvbWxpbmsucHJveHkocmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltXT1JLRVJdIEtlcm5lbCBkb2VzIG5vdCBzdXBwb3J0IG1vdW50RlMgbWV0aG9kXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb3VudEZTIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBrZXJuZWxcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBNb3VudEZTIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0TW91bnRlZEZpbGVTeXN0ZW1zOiBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmdldE1vdW50ZWRGaWxlU3lzdGVtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwuZ2V0TW91bnRlZEZpbGVTeXN0ZW1zKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV09SS0VSXSBLZXJuZWwgZG9lcyBub3Qgc3VwcG9ydCBnZXRNb3VudGVkRmlsZVN5c3RlbXMgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBnZXRNb3VudGVkRmlsZVN5c3RlbXMgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0sXG5cbiAgc3luY0ZpbGVTeXN0ZW06IGFzeW5jIChtb3VudFBhdGg6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGtlcm5lbC5zeW5jRmlsZVN5c3RlbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBrZXJuZWwuc3luY0ZpbGVTeXN0ZW0obW91bnRQYXRoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltXT1JLRVJdIEtlcm5lbCBkb2VzIG5vdCBzdXBwb3J0IHN5bmNGaWxlU3lzdGVtIG1ldGhvZFwiKTtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnc3luY0ZpbGVTeXN0ZW0gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGtlcm5lbCcgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXT1JLRVJdIHN5bmNGaWxlU3lzdGVtIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSB9O1xuICAgIH1cbiAgfSxcblxuICB1cGdyYWRlRmlsZVN5c3RlbVBlcm1pc3Npb246IGFzeW5jIChtb3VudFBhdGg6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGtlcm5lbC51cGdyYWRlRmlsZVN5c3RlbVBlcm1pc3Npb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga2VybmVsLnVwZ3JhZGVGaWxlU3lzdGVtUGVybWlzc2lvbihtb3VudFBhdGgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gS2VybmVsIGRvZXMgbm90IHN1cHBvcnQgdXBncmFkZUZpbGVTeXN0ZW1QZXJtaXNzaW9uIG1ldGhvZFwiKTtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAndXBncmFkZUZpbGVTeXN0ZW1QZXJtaXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBrZXJuZWwnIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSB1cGdyYWRlRmlsZVN5c3RlbVBlcm1pc3Npb24gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpIH07XG4gICAgfVxuICB9LFxuXG4gIC8vIENvbW0gbWV0aG9kc1xuICBjb21tSW5mbzogYXN5bmMgKHRhcmdldF9uYW1lOiBzdHJpbmcgfCBudWxsLCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBrZXJuZWwuY29tbUluZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga2VybmVsLmNvbW1JbmZvKHRhcmdldF9uYW1lLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gS2VybmVsIGRvZXMgbm90IHN1cHBvcnQgY29tbUluZm8gbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4geyBjb21tczoge30sIHN0YXR1czogJ29rJyB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gQ29tbUluZm8gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IGNvbW1zOiB7fSwgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogU3RyaW5nKGVycm9yKSB9O1xuICAgIH1cbiAgfSxcbiAgXG4gIGNvbW1PcGVuOiBhc3luYyAoY29udGVudDogYW55LCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBrZXJuZWwuY29tbU9wZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga2VybmVsLmNvbW1PcGVuKGNvbnRlbnQsIHBhcmVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV09SS0VSXSBLZXJuZWwgZG9lcyBub3Qgc3VwcG9ydCBjb21tT3BlbiBtZXRob2RcIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBDb21tT3BlbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIFxuICBjb21tTXNnOiBhc3luYyAoY29udGVudDogYW55LCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBrZXJuZWwuY29tbU1zZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBrZXJuZWwuY29tbU1zZyhjb250ZW50LCBwYXJlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dPUktFUl0gS2VybmVsIGRvZXMgbm90IHN1cHBvcnQgY29tbU1zZyBtZXRob2RcIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbV09SS0VSXSBDb21tTXNnIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgXG4gIGNvbW1DbG9zZTogYXN5bmMgKGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Yga2VybmVsLmNvbW1DbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBrZXJuZWwuY29tbUNsb3NlKGNvbnRlbnQsIHBhcmVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV09SS0VSXSBLZXJuZWwgZG9lcyBub3Qgc3VwcG9ydCBjb21tQ2xvc2UgbWV0aG9kXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1dPUktFUl0gQ29tbUNsb3NlIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRXhwb3NlIHRoZSBwcm94eSB0aHJvdWdoIENvbWxpbmtcbnRyeSB7XG4gIENvbWxpbmsuZXhwb3NlKHNpbXBsZVByb3h5KTtcbn0gY2F0Y2ggKGVycm9yKSB7XG4gIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBleHBvc2luZyBwcm94eTpcIiwgZXJyb3IpO1xufSAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/kernel.worker.ts\n\n}");

/***/ }),

/***/ "./src/manager.ts":
/*!************************!*\
  !*** ./src/manager.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* unused harmony exports KernelMode, KernelLanguage, KernelManager */\n/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! comlink */ \"./node_modules/comlink/dist/esm/comlink.mjs\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ \"./src/index.ts\");\n// Kernel Manager for Deno App Engine\n// This file manages kernel instances in either main thread or worker mode\n\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    }\n    off(eventName, listener) {\n        if (!this.events[eventName])\n            return;\n        const index = this.events[eventName].indexOf(listener);\n        if (index > -1) {\n            this.events[eventName].splice(index, 1);\n        }\n    }\n    removeListener(eventName, listener) {\n        this.off(eventName, listener);\n    }\n    emit(eventName, ...args) {\n        if (!this.events[eventName])\n            return;\n        this.events[eventName].forEach(listener => listener(...args));\n    }\n    setMaxListeners(n) {\n        // No-op for browser compatibility\n    }\n}\n\n\n// Re-export KernelEvents for test usage\n\n// Execution mode enum\nvar KernelMode;\n(function (KernelMode) {\n    KernelMode[\"MAIN_THREAD\"] = \"main_thread\";\n    KernelMode[\"WORKER\"] = \"worker\";\n})(KernelMode || (KernelMode = {}));\n// Kernel language enum\nvar KernelLanguage;\n(function (KernelLanguage) {\n    KernelLanguage[\"PYTHON\"] = \"python\";\n})(KernelLanguage || (KernelLanguage = {}));\n/**\n * KernelManager class manages multiple kernel instances\n * in either main thread or worker mode\n */\nclass KernelManager extends EventEmitter {\n    /**\n     * Resolve the worker URL based on the current environment\n     * @private\n     * @returns The resolved worker URL\n     */\n    resolveWorkerUrl() {\n        // If a custom worker URL is provided, use it\n        if (this.workerUrl) {\n            return this.workerUrl;\n        }\n        // Try to detect the current script location and derive the worker URL\n        if (typeof window !== 'undefined' && window.location) {\n            // Browser environment\n            const currentScript = document.currentScript ||\n                Array.from(document.getElementsByTagName('script')).pop();\n            if (currentScript && currentScript.src) {\n                // Get the base URL from the current script\n                const scriptUrl = new URL(currentScript.src);\n                const baseUrl = scriptUrl.href.substring(0, scriptUrl.href.lastIndexOf('/'));\n                // Check if we're loading from a CDN (jsdelivr, unpkg, etc.)\n                if (scriptUrl.hostname.includes('jsdelivr.net') ||\n                    scriptUrl.hostname.includes('unpkg.com') ||\n                    scriptUrl.hostname.includes('cdnjs.cloudflare.com')) {\n                    // For CDN, the worker should be at the same path\n                    return `${baseUrl}/kernel.worker.js`;\n                }\n                // For local development or custom deployments\n                return `${baseUrl}/kernel.worker.js`;\n            }\n            // Fallback to relative path from current location\n            const baseUrl = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));\n            return `${baseUrl}/dist/kernel.worker.js`;\n        }\n        // Node.js or unknown environment - use relative path\n        // This may not work in Node.js but is provided as a fallback\n        return './kernel.worker.js';\n    }\n    /**\n     * Helper function to check if an error is a KeyboardInterrupt\n     * @private\n     */\n    isKeyboardInterrupt(error) {\n        return error &&\n            typeof error === 'object' &&\n            (('type' in error && error.type === \"KeyboardInterrupt\") ||\n                ('message' in error && typeof error.message === 'string' && error.message.includes(\"KeyboardInterrupt\")));\n    }\n    /**\n     * Helper function to create a standardized KeyboardInterrupt error result\n     * @private\n     */\n    createKeyboardInterruptResult() {\n        return {\n            success: false,\n            error: new Error(\"KeyboardInterrupt: Execution interrupted by user\"),\n            result: {\n                status: \"error\",\n                ename: \"KeyboardInterrupt\",\n                evalue: \"Execution interrupted by user\",\n                traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n            }\n        };\n    }\n    /**\n     * Store an AbortController for a specific kernel execution\n     * @private\n     */\n    storeAbortController(kernelId, executionId, controller) {\n        if (!this.abortControllers.has(kernelId)) {\n            this.abortControllers.set(kernelId, new Map());\n        }\n        this.abortControllers.get(kernelId).set(executionId, controller);\n    }\n    /**\n     * Remove and return an AbortController for a specific kernel execution\n     * @private\n     */\n    removeAbortController(kernelId, executionId) {\n        const kernelControllers = this.abortControllers.get(kernelId);\n        if (!kernelControllers)\n            return undefined;\n        const controller = kernelControllers.get(executionId);\n        if (controller) {\n            kernelControllers.delete(executionId);\n            if (kernelControllers.size === 0) {\n                this.abortControllers.delete(kernelId);\n            }\n        }\n        return controller;\n    }\n    /**\n     * Abort all ongoing operations for a specific kernel\n     * @private\n     */\n    abortAllKernelOperations(kernelId) {\n        const kernelControllers = this.abortControllers.get(kernelId);\n        if (!kernelControllers)\n            return;\n        for (const [executionId, controller] of kernelControllers) {\n            try {\n                controller.abort();\n                console.log(`ðŸš« Aborted execution ${executionId} for kernel ${kernelId}`);\n            }\n            catch (error) {\n                console.warn(`âš ï¸ Error aborting execution ${executionId}:`, error);\n            }\n        }\n        // Clear all controllers for this kernel\n        this.abortControllers.delete(kernelId);\n    }\n    constructor(options = {}) {\n        super();\n        this.kernels = new Map();\n        // Track listeners for each kernel to enable individual removal\n        this.listenerWrappers = new Map();\n        // Track last activity time for each kernel\n        this.lastActivityTime = new Map();\n        // Store inactivity timers for each kernel\n        this.inactivityTimers = new Map();\n        // Track ongoing executions for each kernel\n        this.ongoingExecutions = new Map();\n        // Track execution timeouts for detecting stuck/dead kernels\n        this.executionTimeouts = new Map();\n        // Track execution start times for accurate duration calculation\n        this.executionStartTimes = new Map();\n        // Track execution metadata for better monitoring\n        this.executionMetadata = new Map();\n        // Track AbortControllers for each kernel's ongoing operations\n        this.abortControllers = new Map();\n        // Pool management - now using promises for immediate response\n        this.pool = new Map();\n        this.isPreloading = false;\n        // Track which pool keys are currently being prefilled to prevent duplicates\n        this.prefillingInProgress = new Map();\n        // Interrupt buffers for worker kernels (using SharedArrayBuffer)\n        this.interruptBuffers = new Map();\n        super.setMaxListeners(100); // Allow many listeners for kernel events\n        // Set interruption mode (default to 'auto')\n        this.interruptionMode = options.interruptionMode || 'auto';\n        // Set worker URL if provided\n        this.workerUrl = options.workerUrl;\n        // Set default allowed kernel types (worker mode only for security)\n        this.allowedKernelTypes = options.allowedKernelTypes || [\n            { mode: KernelMode.WORKER, language: KernelLanguage.PYTHON }\n        ];\n        // Initialize pool configuration with defaults based on allowed types\n        const defaultPreloadConfigs = this.allowedKernelTypes.filter(type => type.language === KernelLanguage.PYTHON // Only preload Python kernels by default\n        );\n        this.poolConfig = {\n            enabled: false,\n            poolSize: 2,\n            autoRefill: true,\n            preloadConfigs: defaultPreloadConfigs,\n            ...options.pool\n        };\n        // Validate that pool preload configs are within allowed types\n        if (this.poolConfig.preloadConfigs) {\n            this.poolConfig.preloadConfigs = this.poolConfig.preloadConfigs.filter(config => {\n                const isAllowed = this.isKernelTypeAllowed(config.mode, config.language);\n                if (!isAllowed) {\n                    console.warn(`Pool preload config ${config.mode}-${config.language} is not in allowedKernelTypes, skipping`);\n                }\n                return isAllowed;\n            });\n        }\n        // Start preloading if pool is enabled\n        if (this.poolConfig.enabled) {\n            this.preloadPool().catch(error => {\n                console.error(\"Error preloading kernel pool:\", error);\n            });\n        }\n    }\n    /**\n     * Generate a pool key for a given mode and language combination\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Pool key string\n     * @private\n     */\n    getPoolKey(mode, language) {\n        return `${mode}-${language}`;\n    }\n    /**\n     * Get a kernel promise from the pool if available\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Kernel promise or null if none available\n     * @private\n     */\n    getFromPool(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return null;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        const poolPromises = this.pool.get(poolKey);\n        if (!poolPromises || poolPromises.length === 0) {\n            return null;\n        }\n        // Remove and return the first promise from the pool (FIFO)\n        const kernelPromise = poolPromises.shift();\n        // Immediately trigger background refill to add one promise back\n        if (this.poolConfig.autoRefill) {\n            setTimeout(() => {\n                this.refillPoolSingle(mode, language).catch(error => {\n                    console.error(`Error refilling single kernel for ${poolKey}:`, error);\n                });\n            }, 0);\n        }\n        return kernelPromise;\n    }\n    /**\n     * Add a kernel promise to the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @param kernelPromise Kernel promise\n     * @private\n     */\n    addToPool(mode, language, kernelPromise) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        if (!this.pool.has(poolKey)) {\n            this.pool.set(poolKey, []);\n        }\n        const poolPromises = this.pool.get(poolKey);\n        // Only add if we haven't reached the pool size limit\n        if (poolPromises.length < this.poolConfig.poolSize) {\n            poolPromises.push(kernelPromise);\n            // Handle promise rejection to prevent unhandled rejections\n            kernelPromise.catch(error => {\n                console.error(`Pool kernel promise rejected for ${poolKey}:`, error);\n                // Remove the failed promise from the pool\n                const index = poolPromises.indexOf(kernelPromise);\n                if (index !== -1) {\n                    poolPromises.splice(index, 1);\n                }\n            });\n        }\n        else {\n            // Pool is full, let the excess promise resolve and then destroy the kernel\n            kernelPromise.then(kernel => {\n                kernel.destroy().catch(error => {\n                    console.error(\"Error destroying excess pool kernel:\", error);\n                });\n            }).catch(error => {\n                console.error(\"Excess pool kernel promise rejected:\", error);\n            });\n        }\n    }\n    /**\n     * Refill the pool with a single kernel promise\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @private\n     */\n    async refillPoolSingle(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        const poolPromises = this.pool.get(poolKey) || [];\n        // Only add one if we're below the pool size\n        if (poolPromises.length < this.poolConfig.poolSize) {\n            const kernelPromise = this.createPoolKernelPromise(mode, language);\n            this.addToPool(mode, language, kernelPromise);\n        }\n    }\n    /**\n     * Refill the pool for a specific configuration with parallel creation\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @private\n     */\n    async refillPool(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        // Check if already prefilling this pool key to prevent duplicates\n        if (this.prefillingInProgress.get(poolKey)) {\n            return;\n        }\n        // Set prefilling flag\n        this.prefillingInProgress.set(poolKey, true);\n        try {\n            const poolPromises = this.pool.get(poolKey) || [];\n            const needed = this.poolConfig.poolSize - poolPromises.length;\n            if (needed <= 0) {\n                return;\n            }\n            // Create all needed kernel promises in parallel\n            const newPromises = Array.from({ length: needed }, () => this.createPoolKernelPromise(mode, language));\n            // Add all promises to the pool\n            for (const kernelPromise of newPromises) {\n                this.addToPool(mode, language, kernelPromise);\n            }\n        }\n        catch (error) {\n            console.error(`Error refilling pool for ${poolKey}:`, error);\n        }\n        finally {\n            // Always clear the prefilling flag\n            this.prefillingInProgress.set(poolKey, false);\n        }\n    }\n    /**\n     * Create a kernel promise for the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Promise that resolves to a kernel instance\n     * @private\n     */\n    createPoolKernelPromise(mode, language) {\n        return new Promise(async (resolve, reject) => {\n            try {\n                const kernel = await this.createPoolKernel(mode, language);\n                // Mark as taken from pool\n                kernel.isFromPool = true;\n                resolve(kernel);\n            }\n            catch (error) {\n                console.error(`Error creating pool kernel for ${mode}-${language}:`, error);\n                reject(error);\n            }\n        });\n    }\n    /**\n     * Create a kernel specifically for the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Kernel instance\n     * @private\n     */\n    async createPoolKernel(mode, language) {\n        // Generate a temporary ID for the pool kernel\n        const tempId = `pool-${crypto.randomUUID()}`;\n        // Create kernel with minimal configuration\n        const options = {\n            mode,\n            lang: language\n        };\n        // Store options temporarily - but don't store incomplete instance in kernels map\n        // Instead, we'll pass the options directly to the creation methods\n        let instance;\n        try {\n            if (mode === KernelMode.MAIN_THREAD) {\n                // For main thread, we need to temporarily store the instance for createMainThreadKernel\n                const tempInstance = {\n                    id: tempId,\n                    options,\n                    mode,\n                    language\n                };\n                this.kernels.set(tempId, tempInstance);\n                try {\n                    instance = await this.createMainThreadKernel(tempId);\n                }\n                finally {\n                    // Always clean up the temporary instance\n                    this.kernels.delete(tempId);\n                }\n            }\n            else {\n                // For worker mode, we need to temporarily store the instance for createWorkerKernel\n                const tempInstance = {\n                    id: tempId,\n                    options,\n                    mode,\n                    language\n                };\n                this.kernels.set(tempId, tempInstance);\n                try {\n                    instance = await this.createWorkerKernel(tempId);\n                }\n                finally {\n                    // Always clean up the temporary instance\n                    this.kernels.delete(tempId);\n                }\n            }\n        }\n        catch (error) {\n            // Ensure cleanup on any error\n            this.kernels.delete(tempId);\n            throw error;\n        }\n        return instance;\n    }\n    /**\n     * Preload the kernel pool with configured kernel types\n     * @private\n     */\n    async preloadPool() {\n        if (!this.poolConfig.enabled || this.isPreloading) {\n            return;\n        }\n        this.isPreloading = true;\n        try {\n            // Preload kernels for each configured type\n            for (const config of this.poolConfig.preloadConfigs) {\n                try {\n                    await this.refillPool(config.mode, config.language);\n                }\n                catch (error) {\n                    console.error(`Error preloading ${config.mode}-${config.language}:`, error);\n                    // Continue with other configurations\n                }\n            }\n        }\n        catch (error) {\n            console.error(\"Error during kernel pool preloading:\", error);\n        }\n        finally {\n            this.isPreloading = false;\n        }\n    }\n    /**\n     * Check if a kernel request can use the pool\n     * @param options Kernel creation options\n     * @returns True if the request can use pool\n     * @private\n     */\n    canUsePool(options) {\n        // Don't use pool if it's disabled\n        if (!this.poolConfig.enabled) {\n            return false;\n        }\n        // Don't use pool if custom filesystem or permissions are specified\n        if (options.filesystem || options.deno?.permissions) {\n            return false;\n        }\n        // Don't use pool if custom timeouts are specified\n        if (options.inactivityTimeout !== undefined || options.maxExecutionTime !== undefined) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Reassign a pool kernel with new ID and options\n     * @param poolKernel Kernel from pool\n     * @param newId New kernel ID\n     * @param options Kernel options\n     * @returns Updated kernel instance\n     * @private\n     */\n    reassignPoolKernel(poolKernel, newId, options) {\n        // Create a new instance object explicitly to avoid spread operator issues\n        const updatedInstance = {\n            id: newId,\n            kernel: poolKernel.kernel,\n            mode: poolKernel.mode,\n            language: poolKernel.language,\n            worker: poolKernel.worker,\n            created: new Date().toISOString(), // Update creation time\n            options: { ...poolKernel.options, ...options },\n            isFromPool: true,\n            destroy: poolKernel.destroy // Preserve the original destroy function\n        };\n        // Verify the destroy function is properly set\n        if (typeof updatedInstance.destroy !== 'function') {\n            console.error('Failed to preserve destroy function during pool kernel reassignment');\n            console.error('poolKernel.destroy type:', typeof poolKernel.destroy);\n            console.error('updatedInstance.destroy type:', typeof updatedInstance.destroy);\n            throw new Error(`Failed to preserve destroy function during pool kernel reassignment`);\n        }\n        return updatedInstance;\n    }\n    /**\n     * Get pool statistics for debugging/monitoring\n     * @returns Pool statistics\n     */\n    getPoolStats() {\n        const stats = {};\n        for (const [poolKey, promises] of this.pool.entries()) {\n            stats[poolKey] = {\n                available: promises.length,\n                total: this.poolConfig.poolSize\n            };\n        }\n        return stats;\n    }\n    /**\n     * Get pool configuration information\n     * @returns Pool configuration details\n     */\n    getPoolConfig() {\n        return {\n            enabled: this.poolConfig.enabled,\n            poolSize: this.poolConfig.poolSize,\n            autoRefill: this.poolConfig.autoRefill,\n            preloadConfigs: [...this.poolConfig.preloadConfigs], // Return a copy to prevent modification\n            isPreloading: this.isPreloading\n        };\n    }\n    /**\n     * Get the current worker URL configuration\n     * @returns The worker URL or undefined if using auto-detection\n     */\n    getWorkerUrl() {\n        return this.workerUrl;\n    }\n    /**\n     * Set a custom worker URL for kernel workers\n     * @param url The URL to the kernel.worker.js file\n     * @example\n     * // For CDN usage:\n     * manager.setWorkerUrl('https://cdn.jsdelivr.net/npm/web-python-kernel@latest/dist/kernel.worker.js');\n     * // For local development:\n     * manager.setWorkerUrl('/dist/kernel.worker.js');\n     */\n    setWorkerUrl(url) {\n        this.workerUrl = url;\n    }\n    /**\n     * Create a new kernel instance\n     * @param options Options for creating the kernel\n     * @param options.id Optional custom ID for the kernel\n     * @param options.mode Optional kernel mode (main_thread or worker)\n     * @param options.lang Optional kernel language (python or typescript)\n     * @param options.namespace Optional namespace prefix for the kernel ID\n     * @param options.deno.permissions Optional Deno permissions for worker mode\n     * @param options.filesystem Optional filesystem mounting options\n     * @param options.inactivityTimeout Optional timeout in ms after which an inactive kernel will be shut down\n     * @param options.maxExecutionTime Optional maximum time in ms an execution can run before considered stuck\n     * @returns Promise resolving to the kernel instance ID\n     */\n    async createKernel(options = {}) {\n        // make sure the options.id does not contain colons because it will be used as a namespace prefix\n        if (options.id && options.id.includes(':')) {\n            throw new Error('Kernel ID cannot contain colons');\n        }\n        const baseId = options.id || crypto.randomUUID();\n        const mode = options.mode || KernelMode.WORKER;\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Check if the requested kernel type is allowed\n        if (!this.isKernelTypeAllowed(mode, language)) {\n            throw new Error(`Kernel type ${mode}-${language} is not allowed. Allowed types: ${this.allowedKernelTypes.map(t => `${t.mode}-${t.language}`).join(', ')}`);\n        }\n        // Apply namespace prefix if provided\n        const id = options.namespace ? `${options.namespace}:${baseId}` : baseId;\n        // Check if kernel with this ID already exists\n        if (this.kernels.has(id)) {\n            throw new Error(`Kernel with ID ${id} already exists`);\n        }\n        // Try to get from pool if possible\n        if (this.canUsePool(options)) {\n            const poolKey = this.getPoolKey(mode, language);\n            // Check if this kernel type is configured for pooling\n            const isPooledType = this.poolConfig.preloadConfigs.some(config => config.mode === mode && config.language === language);\n            if (isPooledType) {\n                // First try to get from existing pool\n                let poolKernelPromise = this.getFromPool(mode, language);\n                if (poolKernelPromise) {\n                    return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n                }\n                // Pool is empty, but this type should be pooled\n                // Create a new promise immediately and trigger background refill\n                try {\n                    // Create a new kernel promise specifically for this request\n                    const newKernelPromise = this.createPoolKernelPromise(mode, language);\n                    // Trigger background refill to replenish the pool for future requests\n                    if (this.poolConfig.autoRefill) {\n                        setTimeout(() => {\n                            this.refillPool(mode, language).catch(error => {\n                                console.error(`Error refilling exhausted pool for ${poolKey}:`, error);\n                            });\n                        }, 0);\n                    }\n                    return await this.setupPoolKernelFromPromise(newKernelPromise, id, options);\n                }\n                catch (error) {\n                    console.error(`Failed to create kernel promise for exhausted pool: ${error}`);\n                    // Fall through to on-demand creation as last resort\n                }\n            }\n            else {\n                // This kernel type is not configured for pooling, try to get from pool anyway\n                // in case there are kernels available from previous configurations\n                const poolKernelPromise = this.getFromPool(mode, language);\n                if (poolKernelPromise) {\n                    return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n                }\n            }\n        }\n        // Fall back to creating a new kernel on-demand\n        return this.createOnDemandKernel(id, mode, language, options);\n    }\n    /**\n     * Setup a pool kernel from a promise with new ID and options\n     * @param poolKernelPromise Kernel promise from pool\n     * @param id New kernel ID\n     * @param options Kernel options\n     * @returns Kernel ID (returned after kernel is ready)\n     * @private\n     */\n    async setupPoolKernelFromPromise(poolKernelPromise, id, options) {\n        try {\n            // Wait for the pool kernel to be ready\n            const poolKernel = await poolKernelPromise;\n            // Reassign the pool kernel with the new ID and options\n            const instance = this.reassignPoolKernel(poolKernel, id, options);\n            // For worker kernels, we need to recreate the event handler with the new ID\n            if (instance.mode === KernelMode.WORKER && instance.worker) {\n                // Get the worker and create new message channel\n                const worker = instance.worker;\n                // Create a new message channel for the reassigned kernel\n                const { port1, port2 } = new MessageChannel();\n                // Send the new event port to the worker\n                worker.postMessage({\n                    type: \"SET_EVENT_PORT\",\n                    port: port2\n                }, [port2]);\n                // Create a new event handler with the correct kernel ID\n                const eventHandler = (event) => {\n                    if (event.data && event.data.type) {\n                        // Emit the event from the manager with kernel ID\n                        // This structure matches the setupEventForwarding method for main thread kernels\n                        super.emit(event.data.type, {\n                            kernelId: id,\n                            data: event.data.data\n                        });\n                    }\n                };\n                // Listen for events from the worker with the new handler\n                port1.addEventListener('message', eventHandler);\n                port1.start();\n                // Update the destroy function to clean up the new event handler\n                const originalDestroy = instance.destroy;\n                instance.destroy = async () => {\n                    port1.removeEventListener('message', eventHandler);\n                    port1.close();\n                    return originalDestroy();\n                };\n            }\n            // Store the kernel instance\n            this.kernels.set(id, instance);\n            // Forward kernel events to manager (for main thread kernels)\n            this.setupEventForwarding(instance);\n            // Initialize activity tracking\n            this.updateKernelActivity(id);\n            // Set up inactivity timeout if specified and greater than 0\n            if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n                this.setupInactivityTimeout(id, options.inactivityTimeout);\n            }\n            // Setup handlers for stalled executions if maxExecutionTime is specified\n            if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n                this.setupStalledExecutionHandler(id);\n            }\n            return id;\n        }\n        catch (error) {\n            console.error(`Error setting up pool kernel ${id}:`, error);\n            // Emit an error event for this kernel\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: id,\n                data: {\n                    ename: \"KernelSetupError\",\n                    evalue: `Failed to setup kernel: ${error instanceof Error ? error.message : String(error)}`,\n                    traceback: [error instanceof Error ? (error.stack || error.message) : String(error)]\n                }\n            });\n            throw error; // Re-throw to let the caller handle it\n        }\n    }\n    /**\n     * Setup a pool kernel with new ID and options (for already resolved kernels)\n     * @param poolKernel Kernel from pool\n     * @param id New kernel ID\n     * @param options Kernel options\n     * @returns Kernel ID\n     * @private\n     */\n    setupPoolKernel(poolKernel, id, options) {\n        // Reassign the pool kernel with the new ID and options\n        const instance = this.reassignPoolKernel(poolKernel, id, options);\n        // For worker kernels, we need to recreate the event handler with the new ID\n        if (instance.mode === KernelMode.WORKER && instance.worker) {\n            // Get the worker and create new message channel\n            const worker = instance.worker;\n            // Create a new message channel for the reassigned kernel\n            const { port1, port2 } = new MessageChannel();\n            // Send the new event port to the worker\n            worker.postMessage({\n                type: \"SET_EVENT_PORT\",\n                port: port2\n            }, [port2]);\n            // Create a new event handler with the correct kernel ID\n            const eventHandler = (event) => {\n                if (event.data && event.data.type) {\n                    // Emit the event from the manager with kernel ID\n                    // This structure matches the setupEventForwarding method for main thread kernels\n                    super.emit(event.data.type, {\n                        kernelId: id,\n                        data: event.data.data\n                    });\n                }\n            };\n            // Listen for events from the worker with the new handler\n            port1.addEventListener('message', eventHandler);\n            port1.start();\n            // Update the destroy function to clean up the new event handler\n            const originalDestroy = instance.destroy;\n            instance.destroy = async () => {\n                port1.removeEventListener('message', eventHandler);\n                port1.close();\n                return originalDestroy();\n            };\n        }\n        // Store the kernel instance\n        this.kernels.set(id, instance);\n        // Forward kernel events to manager (for main thread kernels)\n        this.setupEventForwarding(instance);\n        // Initialize activity tracking\n        this.updateKernelActivity(id);\n        // Set up inactivity timeout if specified and greater than 0\n        if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n            this.setupInactivityTimeout(id, options.inactivityTimeout);\n        }\n        // Setup handlers for stalled executions if maxExecutionTime is specified\n        if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n            this.setupStalledExecutionHandler(id);\n        }\n        return id;\n    }\n    /**\n     * Create a kernel on-demand (not from pool)\n     * @param id Kernel ID\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @param options Kernel options\n     * @returns Kernel ID\n     * @private\n     */\n    async createOnDemandKernel(id, mode, language, options) {\n        // Store options temporarily to be used in createWorkerKernel\n        const tempInstance = {\n            id,\n            options: { ...options, lang: language },\n            mode,\n            language\n        };\n        this.kernels.set(id, tempInstance);\n        // Create the appropriate kernel instance\n        let instance;\n        if (mode === KernelMode.MAIN_THREAD) {\n            instance = await this.createMainThreadKernel(id);\n        }\n        else {\n            instance = await this.createWorkerKernel(id);\n        }\n        // Store the kernel instance\n        this.kernels.set(id, instance);\n        // Forward kernel events to manager\n        this.setupEventForwarding(instance);\n        // Initialize activity tracking\n        this.updateKernelActivity(id);\n        // Set up inactivity timeout if specified and greater than 0\n        if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n            this.setupInactivityTimeout(id, options.inactivityTimeout);\n        }\n        // Setup handlers for stalled executions if maxExecutionTime is specified\n        if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n            this.setupStalledExecutionHandler(id);\n        }\n        return id;\n    }\n    /**\n     * Create a kernel instance running in the main thread\n     * @param id Kernel ID\n     * @returns Kernel instance\n     */\n    async createMainThreadKernel(id) {\n        // Get options from the temporary instance\n        const options = this.kernels.get(id)?.options || {};\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Create the Python kernel\n        const kernel = new _index__WEBPACK_IMPORTED_MODULE_2__.Kernel();\n        // Create the kernel instance\n        const instance = {\n            id,\n            kernel,\n            mode: KernelMode.MAIN_THREAD,\n            language,\n            created: new Date().toISOString(),\n            options,\n            destroy: async () => {\n                // Nothing special to do for main thread kernel\n                return Promise.resolve();\n            }\n        };\n        // Initialize the kernel with filesystem options\n        const kernelOptions = {};\n        // Add filesystem options if provided\n        if (options.filesystem) {\n            kernelOptions.filesystem = options.filesystem;\n        }\n        // Add environment variables if provided\n        if (options.env) {\n            kernelOptions.env = options.env;\n        }\n        // Add lockFileURL if provided\n        if (options.lockFileURL) {\n            kernelOptions.lockFileURL = options.lockFileURL;\n        }\n        // Add autoSyncFs if provided\n        if (options.autoSyncFs !== undefined) {\n            kernelOptions.autoSyncFs = options.autoSyncFs;\n        }\n        // Initialize the kernel\n        await kernel.initialize(kernelOptions);\n        return instance;\n    }\n    /**\n     * Create a kernel instance running in a worker\n     * @param id Kernel ID\n     * @returns Kernel instance\n     */\n    async createWorkerKernel(id) {\n        // Get permissions from options when creating the kernel\n        const options = this.kernels.get(id)?.options || {};\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Create a new worker with optional permissions\n        const workerOptions = {\n            type: \"module\",\n        };\n        // If Deno permissions are provided, use them.\n        // Otherwise don't specify Deno permissions at all to inherit from host script\n        if (options.deno?.permissions) {\n            workerOptions.deno = {\n                permissions: options.deno.permissions\n            };\n        }\n        // Determine the worker URL based on the environment\n        const workerUrl = this.resolveWorkerUrl();\n        const worker = new Worker(workerUrl, { type: 'classic' });\n        // Create a message channel for events\n        const { port1, port2 } = new MessageChannel();\n        // Create a promise that will resolve when the kernel is initialized\n        const initPromise = new Promise((resolve, reject) => {\n            const initHandler = (event) => {\n                if (event.data?.type === \"KERNEL_INITIALIZED\") {\n                    if (event.data.data.success) {\n                        port1.removeEventListener('message', initHandler);\n                        resolve();\n                    }\n                    else {\n                        port1.removeEventListener('message', initHandler);\n                        reject(new Error(\"Kernel initialization failed\"));\n                    }\n                }\n            };\n            port1.addEventListener('message', initHandler);\n        });\n        // Send the port to the worker\n        worker.postMessage({ type: \"SET_EVENT_PORT\", port: port2 }, [port2]);\n        // Create a proxy to the worker using Comlink\n        const kernelProxy = comlink__WEBPACK_IMPORTED_MODULE_0__.wrap(worker);\n        // Add a local event handler to bridge the worker events\n        // This works around the limitation that Comlink doesn't proxy event emitters\n        const eventHandler = (event) => {\n            if (event.data && event.data.type) {\n                // Emit the event from the manager with kernel ID\n                // This structure matches the setupEventForwarding method for main thread kernels\n                super.emit(event.data.type, {\n                    kernelId: id,\n                    data: event.data.data\n                });\n            }\n        };\n        // Listen for events from the worker\n        port1.addEventListener('message', eventHandler);\n        port1.start();\n        // Initialize the kernel with filesystem options\n        // We need to pass these options to the worker\n        worker.postMessage({\n            type: \"INITIALIZE_KERNEL\",\n            options: {\n                filesystem: options.filesystem,\n                env: options.env,\n                lockFileURL: options.lockFileURL,\n                autoSyncFs: options.autoSyncFs,\n                lang: language\n            }\n        });\n        // Wait for kernel initialization\n        await initPromise;\n        // Set up interrupt buffer automatically for worker kernels\n        await this.setupWorkerInterruptBuffer(id, worker);\n        // Create the kernel instance\n        const instance = {\n            id,\n            kernel: {\n                // Map methods from the Comlink proxy to the IKernel interface\n                initialize: async (options) => {\n                    return kernelProxy.initialize(options);\n                },\n                execute: async (code, parent) => {\n                    const result = await kernelProxy.execute(code, parent);\n                    // Handle Python worker results (no special display reconstruction needed)\n                    return result;\n                },\n                isInitialized: () => {\n                    return kernelProxy.isInitialized();\n                },\n                inputReply: async (content) => {\n                    return kernelProxy.inputReply(content);\n                },\n                // Map async getStatus method\n                getStatus: async () => {\n                    try {\n                        if (typeof kernelProxy.getStatus === 'function') {\n                            return await kernelProxy.getStatus();\n                        }\n                        else {\n                            return \"unknown\";\n                        }\n                    }\n                    catch (error) {\n                        return \"unknown\";\n                    }\n                },\n                // Map completion methods\n                complete: async (code, cursor_pos, parent) => {\n                    try {\n                        if (typeof kernelProxy.complete === 'function') {\n                            return await kernelProxy.complete(code, cursor_pos, parent);\n                        }\n                        else {\n                            return { status: 'error', error: 'Completion not supported' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                inspect: async (code, cursor_pos, detail_level, parent) => {\n                    try {\n                        if (typeof kernelProxy.inspect === 'function') {\n                            return await kernelProxy.inspect(code, cursor_pos, detail_level, parent);\n                        }\n                        else {\n                            return { status: 'error', error: 'Inspection not supported' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                isComplete: async (code, parent) => {\n                    try {\n                        if (typeof kernelProxy.isComplete === 'function') {\n                            return await kernelProxy.isComplete(code, parent);\n                        }\n                        else {\n                            return { status: 'unknown' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                // Map interrupt methods\n                interrupt: async () => {\n                    try {\n                        if (typeof kernelProxy.interrupt === 'function') {\n                            return await kernelProxy.interrupt();\n                        }\n                        else {\n                            return false;\n                        }\n                    }\n                    catch (error) {\n                        return false;\n                    }\n                },\n                setInterruptBuffer: (buffer) => {\n                    try {\n                        if (typeof kernelProxy.setInterruptBuffer === 'function') {\n                            kernelProxy.setInterruptBuffer(buffer);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to set interrupt buffer:', error);\n                    }\n                },\n                // Map mountFS method\n                mountFS: async (mountPath, dirHandle, permission) => {\n                    try {\n                        if (typeof kernelProxy.mountFS === 'function') {\n                            return await kernelProxy.mountFS(mountPath, dirHandle, permission);\n                        }\n                        else {\n                            throw new Error('mountFS is not supported by this kernel');\n                        }\n                    }\n                    catch (error) {\n                        throw error;\n                    }\n                },\n                // Map filesystem sync methods\n                getMountedFileSystems: () => {\n                    try {\n                        if (typeof kernelProxy.getMountedFileSystems === 'function') {\n                            return kernelProxy.getMountedFileSystems();\n                        }\n                        else {\n                            return [];\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to get mounted filesystems:', error);\n                        return [];\n                    }\n                },\n                syncFileSystem: async (mountPath) => {\n                    try {\n                        if (typeof kernelProxy.syncFileSystem === 'function') {\n                            return await kernelProxy.syncFileSystem(mountPath);\n                        }\n                        else {\n                            return { success: false, error: 'syncFileSystem is not supported by this kernel' };\n                        }\n                    }\n                    catch (error) {\n                        return { success: false, error: error instanceof Error ? error.message : String(error) };\n                    }\n                },\n                upgradeFileSystemPermission: async (mountPath) => {\n                    try {\n                        if (typeof kernelProxy.upgradeFileSystemPermission === 'function') {\n                            return await kernelProxy.upgradeFileSystemPermission(mountPath);\n                        }\n                        else {\n                            return { success: false, error: 'upgradeFileSystemPermission is not supported by this kernel' };\n                        }\n                    }\n                    catch (error) {\n                        return { success: false, error: error instanceof Error ? error.message : String(error) };\n                    }\n                },\n                // Map comm methods\n                commInfo: async (target_name, parent) => {\n                    try {\n                        if (typeof kernelProxy.commInfo === 'function') {\n                            return await kernelProxy.commInfo(target_name, parent);\n                        }\n                        else {\n                            return { comms: {}, status: 'ok' };\n                        }\n                    }\n                    catch (error) {\n                        return { comms: {}, status: 'error', error: String(error) };\n                    }\n                },\n                commOpen: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commOpen === 'function') {\n                            return await kernelProxy.commOpen(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to open comm:', error);\n                    }\n                },\n                commMsg: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commMsg === 'function') {\n                            return await kernelProxy.commMsg(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to send comm message:', error);\n                    }\n                },\n                commClose: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commClose === 'function') {\n                            return await kernelProxy.commClose(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to close comm:', error);\n                    }\n                }\n            },\n            mode: KernelMode.WORKER,\n            language,\n            worker,\n            created: new Date().toISOString(),\n            options, // Store the options for reference\n            destroy: async () => {\n                // Clean up the worker and event listeners\n                port1.removeEventListener('message', eventHandler);\n                port1.close();\n                worker.terminate();\n                return Promise.resolve();\n            }\n        };\n        return instance;\n    }\n    /**\n     * Setup event forwarding from kernel to manager\n     * @param instance Kernel instance\n     */\n    setupEventForwarding(instance) {\n        // Only needed for main thread kernels as worker events are handled directly\n        if (instance.mode === KernelMode.MAIN_THREAD) {\n            // Forward all kernel events to the manager with kernel ID\n            Object.values(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents).forEach((eventType) => {\n                // Access the kernel as a Kernel instance which extends EventEmitter\n                const kernelEmitter = instance.kernel;\n                // Add event listener to forward events\n                kernelEmitter.on(eventType, (data) => {\n                    super.emit(eventType, {\n                        kernelId: instance.id,\n                        data\n                    });\n                });\n            });\n        }\n    }\n    /**\n     * Get a kernel instance by ID\n     * @param id Kernel ID\n     * @returns Kernel instance or undefined if not found\n     */\n    getKernel(id) {\n        return this.kernels.get(id);\n    }\n    /**\n     * Get a list of all kernel IDs\n     * @returns Array of kernel IDs\n     */\n    getKernelIds() {\n        return Array.from(this.kernels.keys());\n    }\n    /**\n     * Get a list of all kernels with their details\n     * @param namespace Optional namespace to filter kernels by\n     * @returns Array of kernel information objects\n     */\n    async listKernels(namespace) {\n        const filteredKernels = Array.from(this.kernels.entries())\n            .filter(([id]) => {\n            // Filter out pool kernels (temporary kernels with IDs starting with \"pool-\")\n            if (id.startsWith(\"pool-\"))\n                return false;\n            if (!namespace)\n                return true;\n            return id.startsWith(`${namespace}:`);\n        });\n        // Use Promise.all to get all statuses concurrently\n        const kernelInfos = await Promise.all(filteredKernels.map(async ([id, instance]) => {\n            // Extract namespace from id if present\n            const namespaceMatch = id.match(/^([^:]+):/);\n            const extractedNamespace = namespaceMatch ? namespaceMatch[1] : undefined;\n            // Get status using async getStatus method\n            let status = \"unknown\";\n            try {\n                if (instance && instance.kernel && typeof instance.kernel.getStatus === 'function') {\n                    status = await instance.kernel.getStatus();\n                }\n            }\n            catch (error) {\n                console.warn(`Error getting status for kernel ${id}:`, error);\n                status = \"unknown\";\n            }\n            return {\n                id,\n                mode: instance.mode,\n                language: instance.language,\n                status,\n                created: instance.created || new Date().toISOString(),\n                namespace: extractedNamespace,\n                deno: instance.options?.deno\n            };\n        }));\n        return kernelInfos;\n    }\n    /**\n     * Destroy a kernel instance\n     * @param id Kernel ID\n     * @returns Promise resolving when kernel is destroyed\n     */\n    async destroyKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            // Handle gracefully - kernel may already be destroyed\n            return;\n        }\n        // Verify the destroy function exists\n        if (typeof instance.destroy !== 'function') {\n            throw new Error(`Kernel ${id} is missing destroy function (type: ${typeof instance.destroy})`);\n        }\n        // Abort all ongoing operations for this kernel first\n        this.abortAllKernelOperations(id);\n        // Clear any inactivity timer\n        this.clearInactivityTimeout(id);\n        // Clean up execution timeouts\n        if (this.executionTimeouts.has(id)) {\n            const timeouts = this.executionTimeouts.get(id);\n            for (const timeoutId of timeouts.values()) {\n                clearTimeout(timeoutId);\n            }\n            this.executionTimeouts.delete(id);\n        }\n        // Clean up execution start times\n        if (this.executionStartTimes.has(id)) {\n            this.executionStartTimes.delete(id);\n        }\n        // Clean up execution metadata\n        if (this.executionMetadata.has(id)) {\n            this.executionMetadata.delete(id);\n        }\n        // Clean up interrupt buffers\n        if (this.interruptBuffers.has(id)) {\n            this.interruptBuffers.delete(id);\n        }\n        // Clean up ongoing executions tracking\n        this.ongoingExecutions.delete(id);\n        // Clean up activity tracking\n        this.lastActivityTime.delete(id);\n        // Remove all event listeners for this kernel\n        this.removeAllKernelListeners(id);\n        // Destroy the kernel instance\n        await instance.destroy();\n        // Remove the kernel from the map\n        this.kernels.delete(id);\n    }\n    /**\n     * Destroy all kernel instances\n     * @param namespace Optional namespace to filter kernels to destroy\n     * @returns Promise resolving when all kernels are destroyed\n     */\n    async destroyAll(namespace) {\n        const ids = Array.from(this.kernels.keys())\n            .filter(id => {\n            if (!namespace)\n                return true;\n            return id.startsWith(`${namespace}:`);\n        });\n        // Destroy all kernels, but skip incomplete instances\n        const destroyPromises = ids.map(async (id) => {\n            const instance = this.kernels.get(id);\n            if (!instance || typeof instance.destroy !== 'function') {\n                console.warn(`Skipping incomplete kernel instance ${id} during destroyAll`);\n                // Just remove it from the map\n                this.kernels.delete(id);\n                return;\n            }\n            return this.destroyKernel(id);\n        });\n        await Promise.all(destroyPromises);\n        // If no namespace specified, also clean up the pool\n        if (!namespace) {\n            await this.destroyPool();\n        }\n    }\n    /**\n     * Destroy all kernels in the pool\n     * @private\n     */\n    async destroyPool() {\n        const destroyPromises = [];\n        for (const [poolKey, promises] of this.pool.entries()) {\n            for (const kernelPromise of promises) {\n                // Handle each promise - if it resolves, destroy the kernel\n                const destroyPromise = kernelPromise.then(kernel => {\n                    return kernel.destroy();\n                }).catch(error => {\n                    console.error(`Error destroying pool kernel from promise:`, error);\n                    // Don't re-throw to avoid unhandled rejections\n                });\n                destroyPromises.push(destroyPromise);\n            }\n        }\n        // Wait for all pool kernels to be destroyed\n        await Promise.all(destroyPromises);\n        // Clear the pool and prefilling flags\n        this.pool.clear();\n        this.prefillingInProgress.clear();\n    }\n    /**\n     * Register an event listener for a specific kernel's events\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @param listener Event listener\n     */\n    onKernelEvent(kernelId, eventType, listener) {\n        // Check if kernel exists\n        if (!this.kernels.has(kernelId)) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        // Create wrapper that filters events for this specific kernel\n        const wrapper = {\n            original: listener,\n            wrapped: (event) => {\n                if (event.kernelId === kernelId) {\n                    // Pass just the data to the listener\n                    // The data structure is consistent across main thread and worker modes\n                    listener(event.data);\n                }\n            }\n        };\n        // Store the wrapper for later removal\n        this.storeListener(kernelId, eventType, listener, wrapper);\n        // Add the wrapped listener to the manager\n        super.on(eventType, wrapper.wrapped);\n    }\n    /**\n     * Remove an event listener for a specific kernel\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @param listener Event listener\n     */\n    offKernelEvent(kernelId, eventType, listener) {\n        const wrapper = this.getListener(kernelId, eventType, listener);\n        if (wrapper) {\n            // Remove the wrapped listener from the manager\n            super.removeListener(eventType, wrapper.wrapped);\n            // Remove the wrapper from our tracking map\n            this.removeStoredListener(kernelId, eventType, listener);\n        }\n    }\n    /**\n     * Store a listener wrapper for later removal\n     */\n    storeListener(kernelId, eventType, original, wrapper) {\n        // Get or create kernel map\n        if (!this.listenerWrappers.has(kernelId)) {\n            this.listenerWrappers.set(kernelId, new Map());\n        }\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        // Get or create event type map\n        if (!kernelMap.has(eventType)) {\n            kernelMap.set(eventType, new Map());\n        }\n        const eventMap = kernelMap.get(eventType);\n        // Store the wrapper\n        eventMap.set(original, wrapper);\n    }\n    /**\n     * Get a stored listener wrapper\n     */\n    getListener(kernelId, eventType, original) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return undefined;\n        const eventMap = kernelMap.get(eventType);\n        if (!eventMap)\n            return undefined;\n        return eventMap.get(original);\n    }\n    /**\n     * Remove a stored listener wrapper\n     */\n    removeStoredListener(kernelId, eventType, original) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return;\n        const eventMap = kernelMap.get(eventType);\n        if (!eventMap)\n            return;\n        // Remove the listener\n        eventMap.delete(original);\n        // Clean up empty maps\n        if (eventMap.size === 0) {\n            kernelMap.delete(eventType);\n        }\n        if (kernelMap.size === 0) {\n            this.listenerWrappers.delete(kernelId);\n        }\n    }\n    /**\n     * Remove all listeners for a specific kernel\n     */\n    removeAllKernelListeners(kernelId) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return;\n        // For each event type\n        for (const [eventType, eventMap] of kernelMap.entries()) {\n            // For each original listener\n            for (const wrapper of eventMap.values()) {\n                // Remove the wrapped listener from the manager\n                super.removeListener(eventType, wrapper.wrapped);\n            }\n        }\n        // Clear the kernel's listener map\n        this.listenerWrappers.delete(kernelId);\n    }\n    /**\n     * Get all listeners for a specific kernel and event type\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @returns Array of listeners\n     */\n    getListeners(kernelId, eventType) {\n        const kernelListeners = this.listenerWrappers.get(kernelId);\n        if (!kernelListeners) {\n            return [];\n        }\n        const eventListeners = kernelListeners.get(eventType);\n        if (!eventListeners) {\n            return [];\n        }\n        return Array.from(eventListeners.keys());\n    }\n    /**\n     * Execute Python code with streaming output\n     * This method works in both main thread and worker modes\n     * @param kernelId ID of the kernel to use\n     * @param code The Python code to execute\n     * @param parent Optional parent message header\n     * @returns AsyncGenerator yielding intermediate outputs\n     */\n    async *executeStream(kernelId, code, parent = {}) {\n        const instance = this.getKernel(kernelId);\n        if (!instance) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        // Update kernel activity\n        this.updateKernelActivity(kernelId);\n        // Track this execution with the code for better monitoring\n        const executionId = this.trackExecution(kernelId, code);\n        // Create AbortController for this execution to enable cancellation\n        const abortController = new AbortController();\n        this.storeAbortController(kernelId, executionId, abortController);\n        try {\n            // For main thread kernels, we can use the executeStream method directly\n            if (instance.mode === KernelMode.MAIN_THREAD) {\n                const kernel = instance.kernel;\n                // Forward to the kernel's executeStream method\n                if (typeof kernel.executeStream === 'function') {\n                    try {\n                        yield* kernel.executeStream(code, parent);\n                        // Update activity after execution completes\n                        this.updateKernelActivity(kernelId);\n                        // Complete execution tracking\n                        this.completeExecution(kernelId, executionId);\n                        return { success: true };\n                    }\n                    catch (error) {\n                        console.error(`Error in main thread executeStream:`, error);\n                        // Update activity even if there's an error\n                        this.updateKernelActivity(kernelId);\n                        // Complete execution tracking even on error\n                        this.completeExecution(kernelId, executionId);\n                        return {\n                            success: false,\n                            error: error instanceof Error ? error : new Error(String(error))\n                        };\n                    }\n                }\n            }\n            // For worker mode, we need to implement streaming via events with proper isolation\n            try {\n                // Event-based approach for worker kernels or main thread kernels without executeStream\n                const streamQueue = [];\n                let executionComplete = false;\n                let executionResult = { success: true };\n                // Store handler references for guaranteed cleanup\n                const eventHandlers = new Map();\n                // Helper function to clean up all event handlers\n                const cleanupHandlers = () => {\n                    for (const [eventType, handler] of eventHandlers.entries()) {\n                        super.off(eventType, handler);\n                    }\n                    eventHandlers.clear();\n                };\n                // Create execution-specific event handlers that include executionId check\n                const createHandler = (eventType) => {\n                    const handler = (event) => {\n                        // Only process events for this specific kernel and while this execution is active\n                        if (event.kernelId === kernelId && !executionComplete) {\n                            streamQueue.push({\n                                type: eventType,\n                                data: event.data,\n                                executionId // Include execution ID for debugging\n                            });\n                            // Events also count as activity\n                            this.updateKernelActivity(kernelId);\n                        }\n                    };\n                    eventHandlers.set(eventType, handler);\n                    return handler;\n                };\n                // Create and register all event handlers\n                const handleStreamEvent = createHandler('stream');\n                const handleDisplayEvent = createHandler('display_data');\n                const handleUpdateDisplayEvent = createHandler('update_display_data');\n                const handleResultEvent = createHandler('execute_result');\n                const handleErrorEvent = createHandler('execute_error');\n                // Register handlers\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.STREAM, handleStreamEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.DISPLAY_DATA, handleDisplayEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.UPDATE_DISPLAY_DATA, handleUpdateDisplayEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_RESULT, handleResultEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, handleErrorEvent);\n                // Create a promise that will resolve when execution is complete\n                const executionPromise = new Promise((resolve, reject) => {\n                    // Set up a handler for execution errors specifically\n                    const handleExecutionError = (event) => {\n                        if (event.kernelId === kernelId && !executionComplete) {\n                            // Mark execution as complete to stop processing more events\n                            executionComplete = true;\n                            // Store the error for the final result\n                            executionResult = {\n                                success: false,\n                                error: new Error(`${event.data.ename}: ${event.data.evalue}`),\n                                result: event.data\n                            };\n                            // Update activity\n                            this.updateKernelActivity(kernelId);\n                            resolve(executionResult);\n                        }\n                    };\n                    // Add error handler to our cleanup list\n                    eventHandlers.set('execute_error_completion', handleExecutionError);\n                    super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, handleExecutionError);\n                    // Check if already aborted\n                    if (abortController.signal.aborted) {\n                        executionComplete = true;\n                        resolve({\n                            success: false,\n                            error: new Error('Execution was aborted')\n                        });\n                        return;\n                    }\n                    // Set up abort handler\n                    const abortHandler = () => {\n                        if (!executionComplete) {\n                            console.log(`ðŸš« Execution ${executionId} aborted`);\n                            executionComplete = true;\n                            resolve({\n                                success: false,\n                                error: new Error('Execution was aborted')\n                            });\n                        }\n                    };\n                    abortController.signal.addEventListener('abort', abortHandler);\n                    // Execute the code\n                    // We know the execute method is available directly on the kernel object\n                    try {\n                        const executePromise = instance.kernel.execute(code, parent);\n                        executePromise.then((result) => {\n                            // Only process if execution hasn't been marked complete already\n                            if (!executionComplete) {\n                                // Check if the execution result indicates an error (for Python kernels)\n                                if (result.success && result.result && result.result.status === \"error\") {\n                                    // Handle as error\n                                    const errorData = {\n                                        status: result.result.status,\n                                        ename: result.result.ename,\n                                        evalue: result.result.evalue,\n                                        traceback: result.result.traceback\n                                    };\n                                    // Push error to stream queue directly \n                                    streamQueue.push({\n                                        type: 'error',\n                                        data: errorData,\n                                        executionId\n                                    });\n                                    // Update execution result to reflect the error\n                                    executionResult = {\n                                        success: false,\n                                        error: new Error(`${result.result.ename}: ${result.result.evalue}`),\n                                        result: result.result\n                                    };\n                                }\n                                else {\n                                    executionResult = result;\n                                }\n                                executionComplete = true;\n                                // Update activity when execution completes\n                                this.updateKernelActivity(kernelId);\n                                resolve(executionResult);\n                            }\n                        }).catch((error) => {\n                            // Only process if execution hasn't been marked complete already\n                            if (!executionComplete) {\n                                console.error(`Error in execute for kernel ${kernelId}:`, error);\n                                // Check if this is a KeyboardInterrupt and handle it specially\n                                let errorResult;\n                                if (this.isKeyboardInterrupt(error)) {\n                                    console.log(`KeyboardInterrupt caught in executeStream for kernel ${kernelId}`);\n                                    errorResult = this.createKeyboardInterruptResult();\n                                    // Also push to stream queue for immediate feedback\n                                    streamQueue.push({\n                                        type: 'error',\n                                        data: errorResult.result,\n                                        executionId\n                                    });\n                                }\n                                else {\n                                    // Handle other errors normally\n                                    errorResult = {\n                                        success: false,\n                                        error: error instanceof Error ? error : new Error(String(error))\n                                    };\n                                }\n                                executionComplete = true;\n                                executionResult = errorResult;\n                                // Update activity even on error\n                                this.updateKernelActivity(kernelId);\n                                resolve(errorResult);\n                            }\n                        });\n                    }\n                    catch (error) {\n                        // Only process if execution hasn't been marked complete already\n                        if (!executionComplete) {\n                            console.error(`Error calling execute for kernel ${kernelId}:`, error);\n                            // Simple error handling\n                            const errorResult = {\n                                success: false,\n                                error: error instanceof Error ? error : new Error(String(error))\n                            };\n                            executionComplete = true;\n                            executionResult = errorResult;\n                            // Update activity even on direct error\n                            this.updateKernelActivity(kernelId);\n                            resolve(errorResult);\n                        }\n                    }\n                });\n                // Use try/finally to guarantee cleanup\n                try {\n                    // Monitor the stream queue and yield results\n                    // Continue until execution is complete AND all queued events have been yielded\n                    while ((!executionComplete || streamQueue.length > 0) && !abortController.signal.aborted) {\n                        // If there are items in the queue, yield them\n                        if (streamQueue.length > 0) {\n                            const event = streamQueue.shift();\n                            yield event;\n                            continue;\n                        }\n                        // If no more events but execution is not complete, wait a little\n                        if (!executionComplete) {\n                            // Use abort signal to cancel the wait\n                            try {\n                                await new Promise((resolve, reject) => {\n                                    const timeoutId = setTimeout(resolve, 10);\n                                    abortController.signal.addEventListener('abort', () => {\n                                        clearTimeout(timeoutId);\n                                        reject(new Error('Aborted'));\n                                    });\n                                });\n                            }\n                            catch (error) {\n                                // If aborted, break out of loop\n                                if (abortController.signal.aborted) {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    // Check if execution was aborted during stream monitoring\n                    if (abortController.signal.aborted && !executionComplete) {\n                        throw new Error('Execution was aborted during stream monitoring');\n                    }\n                    // Wait for the final result\n                    const result = await executionPromise;\n                    return result;\n                }\n                finally {\n                    // ALWAYS clean up event handlers regardless of how execution ends\n                    cleanupHandlers();\n                    // Remove AbortController to prevent memory leaks\n                    this.removeAbortController(kernelId, executionId);\n                    // Complete execution tracking\n                    this.completeExecution(kernelId, executionId);\n                }\n            }\n            catch (error) {\n                // Complete execution tracking on any outer error\n                this.completeExecution(kernelId, executionId);\n                console.error(`Unexpected error in executeStream:`, error);\n                return {\n                    success: false,\n                    error: error instanceof Error ? error : new Error(String(error))\n                };\n            }\n        }\n        catch (error) {\n            // Complete execution tracking on any outer error\n            this.completeExecution(kernelId, executionId);\n            console.error(`Unexpected error in executeStream:`, error);\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    /**\n     * Track a new execution task for a kernel\n     * @param kernelId Kernel ID\n     * @param code Optional code being executed for metadata\n     * @returns Unique execution ID\n     * @private\n     */\n    trackExecution(kernelId, code) {\n        // Create a unique execution ID\n        const executionId = `exec-${crypto.randomUUID()}`;\n        const startTime = Date.now();\n        // Reset interrupt buffer for worker kernels before each new execution\n        // This ensures the kernel can be interrupted multiple times\n        const instance = this.kernels.get(kernelId);\n        if (instance && instance.mode === KernelMode.WORKER && this.interruptBuffers.has(kernelId)) {\n            const interruptBuffer = this.interruptBuffers.get(kernelId);\n            // Reset buffer to 0 (no interrupt signal) to ensure clean state\n            interruptBuffer[0] = 0;\n        }\n        // Get or create the set of ongoing executions for this kernel\n        if (!this.ongoingExecutions.has(kernelId)) {\n            this.ongoingExecutions.set(kernelId, new Set());\n        }\n        // Add this execution to the set\n        this.ongoingExecutions.get(kernelId).add(executionId);\n        // Track execution start time\n        if (!this.executionStartTimes.has(kernelId)) {\n            this.executionStartTimes.set(kernelId, new Map());\n        }\n        this.executionStartTimes.get(kernelId).set(executionId, startTime);\n        // Track execution metadata\n        if (!this.executionMetadata.has(kernelId)) {\n            this.executionMetadata.set(kernelId, new Map());\n        }\n        // Update activity timestamp\n        this.updateKernelActivity(kernelId);\n        // If maxExecutionTime is set, create a timeout to detect stuck/dead kernels\n        if (instance && instance.options.maxExecutionTime && instance.options.maxExecutionTime > 0) {\n            // Get or create the map of execution timeouts for this kernel\n            if (!this.executionTimeouts.has(kernelId)) {\n                this.executionTimeouts.set(kernelId, new Map());\n            }\n            // Set a timeout for this execution with enhanced handling\n            const timeoutId = setTimeout(() => {\n                console.warn(`Execution ${executionId} on kernel ${kernelId} has been running for ${instance.options.maxExecutionTime}ms and may be stuck/dead.`);\n                // Get execution metadata for better error reporting\n                const metadata = this.executionMetadata.get(kernelId)?.get(executionId);\n                const actualRuntime = Date.now() - (metadata?.startTime || startTime);\n                // Emit a stalled execution event with enhanced information\n                super.emit('execution_stalled', {\n                    kernelId,\n                    executionId,\n                    maxExecutionTime: instance.options.maxExecutionTime,\n                    actualRuntime,\n                    code: metadata?.code || code,\n                    startTime: metadata?.startTime || startTime\n                });\n                // Auto-handle stuck execution if configured\n                this.handleStuckExecution(kernelId, executionId, actualRuntime, metadata?.code || code);\n            }, instance.options.maxExecutionTime);\n            // Store the timeout ID\n            this.executionTimeouts.get(kernelId).set(executionId, timeoutId);\n            // Store metadata including timeout ID\n            this.executionMetadata.get(kernelId).set(executionId, {\n                startTime,\n                code,\n                timeoutId\n            });\n        }\n        else {\n            // Store metadata without timeout ID\n            this.executionMetadata.get(kernelId).set(executionId, {\n                startTime,\n                code\n            });\n        }\n        return executionId;\n    }\n    /**\n     * Complete tracking for an execution\n     * @param kernelId Kernel ID\n     * @param executionId Execution ID\n     * @private\n     */\n    completeExecution(kernelId, executionId) {\n        // Clear any execution timeout\n        if (this.executionTimeouts.has(kernelId)) {\n            const timeouts = this.executionTimeouts.get(kernelId);\n            if (timeouts.has(executionId)) {\n                clearTimeout(timeouts.get(executionId));\n                timeouts.delete(executionId);\n            }\n            // Clean up empty maps\n            if (timeouts.size === 0) {\n                this.executionTimeouts.delete(kernelId);\n            }\n        }\n        // Clean up execution start times\n        if (this.executionStartTimes.has(kernelId)) {\n            const startTimes = this.executionStartTimes.get(kernelId);\n            startTimes.delete(executionId);\n            // Clean up empty maps\n            if (startTimes.size === 0) {\n                this.executionStartTimes.delete(kernelId);\n            }\n        }\n        // Clean up execution metadata\n        if (this.executionMetadata.has(kernelId)) {\n            const metadata = this.executionMetadata.get(kernelId);\n            metadata.delete(executionId);\n            // Clean up empty maps\n            if (metadata.size === 0) {\n                this.executionMetadata.delete(kernelId);\n            }\n        }\n        // Remove from ongoing executions\n        if (this.ongoingExecutions.has(kernelId)) {\n            const executions = this.ongoingExecutions.get(kernelId);\n            executions.delete(executionId);\n            // Clean up empty sets\n            if (executions.size === 0) {\n                this.ongoingExecutions.delete(kernelId);\n                // Update activity timestamp for completed execution\n                this.updateKernelActivity(kernelId);\n            }\n        }\n    }\n    /**\n     * Check if a kernel has any ongoing executions\n     * @param kernelId Kernel ID\n     * @returns True if the kernel has ongoing executions\n     * @private\n     */\n    hasOngoingExecutions(kernelId) {\n        return this.ongoingExecutions.has(kernelId) &&\n            this.ongoingExecutions.get(kernelId).size > 0;\n    }\n    /**\n     * Get the count of ongoing executions for a kernel\n     * @param id Kernel ID\n     * @returns Number of ongoing executions\n     */\n    getOngoingExecutionCount(id) {\n        if (!this.ongoingExecutions.has(id)) {\n            return 0;\n        }\n        return this.ongoingExecutions.get(id).size;\n    }\n    /**\n     * Set up an inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @param timeout Timeout in milliseconds\n     * @private\n     */\n    setupInactivityTimeout(id, timeout) {\n        // Don't set up a timer if timeout is 0 or negative\n        if (timeout <= 0) {\n            return;\n        }\n        // Always clear any existing timer first\n        this.clearInactivityTimeout(id);\n        // Calculate remaining time based on last activity\n        const lastActivity = this.lastActivityTime.get(id) || Date.now();\n        const elapsed = Date.now() - lastActivity;\n        const remainingTime = Math.max(0, timeout - elapsed);\n        // If no time remaining, destroy immediately\n        if (remainingTime === 0) {\n            // Check if the kernel has ongoing executions before shutting down\n            if (this.hasOngoingExecutions(id)) {\n                // Reset the timer to check again later\n                this.setupInactivityTimeout(id, timeout);\n                return;\n            }\n            // Destroy immediately\n            this.destroyKernel(id).catch(error => {\n                console.error(`Error destroying inactive kernel ${id}:`, error);\n            });\n            return;\n        }\n        // Create a timer to destroy the kernel after the remaining timeout\n        const timer = setTimeout(() => {\n            // Check if the kernel has ongoing executions before shutting down\n            if (this.hasOngoingExecutions(id)) {\n                // Reset the timer to check again later\n                this.setupInactivityTimeout(id, timeout);\n                return;\n            }\n            this.destroyKernel(id).catch(error => {\n                console.error(`Error destroying inactive kernel ${id}:`, error);\n            });\n        }, remainingTime);\n        // Store the timer ID\n        this.inactivityTimers.set(id, timer);\n    }\n    /**\n     * Clear any existing inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @private\n     */\n    clearInactivityTimeout(id) {\n        if (this.inactivityTimers.has(id)) {\n            const timerId = this.inactivityTimers.get(id);\n            clearTimeout(timerId);\n            this.inactivityTimers.delete(id);\n        }\n    }\n    /**\n     * Update activity timestamp for a kernel and reset inactivity timer if present\n     * @param id Kernel ID\n     * @private\n     */\n    updateKernelActivity(id) {\n        // Update the last activity time\n        this.lastActivityTime.set(id, Date.now());\n        // Get the kernel options\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return;\n        const timeout = instance.options.inactivityTimeout;\n        // Reset the inactivity timer if timeout is enabled (greater than 0)\n        if (timeout && timeout > 0) {\n            this.setupInactivityTimeout(id, timeout);\n        }\n    }\n    /**\n     * Get the last activity time for a kernel\n     * @param id Kernel ID\n     * @returns Last activity time in milliseconds since epoch, or undefined if not found\n     */\n    getLastActivityTime(id) {\n        return this.lastActivityTime.get(id);\n    }\n    /**\n     * Get the inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @returns Inactivity timeout in milliseconds, or undefined if not set\n     */\n    getInactivityTimeout(id) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return undefined;\n        return instance.options.inactivityTimeout;\n    }\n    /**\n     * Set or update the inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @param timeout Timeout in milliseconds, or 0 to disable\n     * @returns True if the timeout was set, false if the kernel was not found\n     */\n    setInactivityTimeout(id, timeout) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return false;\n        // Update the timeout in the options\n        instance.options.inactivityTimeout = timeout;\n        // Clear any existing timer\n        this.clearInactivityTimeout(id);\n        // If timeout is greater than 0, set up a new timer\n        if (timeout > 0) {\n            this.setupInactivityTimeout(id, timeout);\n        }\n        return true;\n    }\n    /**\n     * Get time until auto-shutdown for a kernel\n     * @param id Kernel ID\n     * @returns Time in milliseconds until auto-shutdown, or undefined if no timeout is set\n     */\n    getTimeUntilShutdown(id) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return undefined;\n        const timeout = instance.options.inactivityTimeout;\n        if (!timeout || timeout <= 0)\n            return undefined;\n        const lastActivity = this.lastActivityTime.get(id);\n        if (!lastActivity)\n            return undefined;\n        const elapsedTime = Date.now() - lastActivity;\n        const remainingTime = timeout - elapsedTime;\n        return Math.max(0, remainingTime);\n    }\n    /**\n     * Get the map of inactivity timers (for debugging/testing only)\n     * @returns Object with kernel IDs as keys and timer IDs as values\n     */\n    getInactivityTimers() {\n        // Convert Map to Object for easier inspection\n        const timers = {};\n        this.inactivityTimers.forEach((value, key) => {\n            timers[key] = value;\n        });\n        return timers;\n    }\n    /**\n     * Set up a handler for stalled executions\n     * @param id Kernel ID\n     * @private\n     */\n    setupStalledExecutionHandler(id) {\n        // Listen for stalled execution events\n        super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTION_STALLED, (event) => {\n            if (event.kernelId === id) {\n                console.warn(`Handling stalled execution ${event.executionId} on kernel ${id} (running longer than ${event.maxExecutionTime}ms)`);\n                // Emit an event for clients to handle\n                const instance = this.kernels.get(id);\n                if (instance) {\n                    super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                        kernelId: id,\n                        data: {\n                            ename: \"ExecutionStalledError\",\n                            evalue: `Execution stalled or potentially deadlocked (running > ${event.maxExecutionTime}ms)`,\n                            traceback: [\"Execution may be stuck in an infinite loop or deadlocked.\"]\n                        }\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * Force terminate a potentially stuck kernel\n     * @param id Kernel ID\n     * @param reason Optional reason for termination\n     * @returns Promise resolving to true if the kernel was terminated\n     */\n    async forceTerminateKernel(id, reason = \"Force terminated due to stalled execution\") {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return false;\n        }\n        try {\n            // Log the forced termination\n            console.warn(`Force terminating kernel ${id}: ${reason}`);\n            // Emit an error event to notify clients\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: id,\n                data: {\n                    ename: \"KernelForcedTermination\",\n                    evalue: reason,\n                    traceback: [\"Kernel was forcefully terminated by the system.\"]\n                }\n            });\n            // Destroy the kernel\n            await this.destroyKernel(id);\n            return true;\n        }\n        catch (error) {\n            console.error(`Error during forced termination of kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Get information about ongoing executions for a kernel\n     * @param id Kernel ID\n     * @returns Information about ongoing executions with accurate timing\n     */\n    getExecutionInfo(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return { count: 0, isStuck: false, executionIds: [], executions: [] };\n        }\n        // Handle partially initialized kernels where options may not be fully set\n        if (!instance.options) {\n            return { count: 0, isStuck: false, executionIds: [], executions: [] };\n        }\n        const executionIds = this.ongoingExecutions.get(id)\n            ? Array.from(this.ongoingExecutions.get(id))\n            : [];\n        const count = executionIds.length;\n        const currentTime = Date.now();\n        const maxExecutionTime = instance.options.maxExecutionTime;\n        // Build detailed execution information\n        const executions = [];\n        let longestRunningTime = undefined;\n        let anyStuck = false;\n        // Get execution start times and metadata\n        const startTimes = this.executionStartTimes.get(id);\n        const metadata = this.executionMetadata.get(id);\n        for (const executionId of executionIds) {\n            const startTime = startTimes?.get(executionId);\n            const execMetadata = metadata?.get(executionId);\n            if (startTime !== undefined) {\n                const runtime = currentTime - startTime;\n                const isStuck = maxExecutionTime !== undefined && runtime > maxExecutionTime;\n                executions.push({\n                    id: executionId,\n                    startTime,\n                    runtime,\n                    code: execMetadata?.code,\n                    isStuck\n                });\n                // Track longest running time\n                if (longestRunningTime === undefined || runtime > longestRunningTime) {\n                    longestRunningTime = runtime;\n                }\n                // Track if any execution is stuck\n                if (isStuck) {\n                    anyStuck = true;\n                }\n            }\n            else {\n                // Fallback for executions without start time tracking\n                console.warn(`No start time found for execution ${executionId} on kernel ${id}`);\n                executions.push({\n                    id: executionId,\n                    startTime: 0,\n                    runtime: 0,\n                    code: execMetadata?.code,\n                    isStuck: false\n                });\n            }\n        }\n        // Sort executions by start time (oldest first)\n        executions.sort((a, b) => a.startTime - b.startTime);\n        return {\n            count,\n            isStuck: anyStuck,\n            executionIds,\n            longestRunningTime,\n            executions\n        };\n    }\n    /**\n     * Execute Python code in a kernel\n     * Uses executeStream to collect all outputs and return them\n     * @param kernelId ID of the kernel to use\n     * @param code Python code to execute\n     * @param parent Optional parent message header\n     * @returns Promise resolving to execution result with collected outputs\n     */\n    async execute(kernelId, code, parent = {}) {\n        const instance = this.getKernel(kernelId);\n        if (!instance) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        return await instance.kernel.execute(code, parent);\n    }\n    /**\n     * Check if a kernel type is allowed\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns True if the kernel type is allowed\n     * @private\n     */\n    isKernelTypeAllowed(mode, language) {\n        return this.allowedKernelTypes.some(type => type.mode === mode && type.language === language);\n    }\n    /**\n     * Get the list of allowed kernel types\n     * @returns Array of allowed kernel type configurations\n     */\n    getAllowedKernelTypes() {\n        return [...this.allowedKernelTypes]; // Return a copy to prevent modification\n    }\n    /**\n     * Ping a kernel to reset its activity timer and extend the deadline\n     * @param id Kernel ID\n     * @returns True if the kernel was pinged successfully, false if not found\n     */\n    pingKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return false;\n        }\n        // Update kernel activity (this will reset the inactivity timer)\n        this.updateKernelActivity(id);\n        return true;\n    }\n    /**\n     * Restart a kernel by destroying it and creating a new one with the same ID and configuration\n     * @param id Kernel ID\n     * @returns Promise resolving to true if the kernel was restarted successfully, false if not found\n     */\n    async restartKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            console.warn(`Cannot restart kernel ${id}: kernel not found`);\n            return false;\n        }\n        try {\n            // Store the current configuration\n            const currentConfig = {\n                mode: instance.mode,\n                language: instance.language,\n                options: { ...instance.options }\n            };\n            // Extract namespace from ID if present\n            let namespace;\n            let baseId;\n            if (id.includes(':')) {\n                const parts = id.split(':');\n                namespace = parts[0];\n                baseId = parts[1];\n            }\n            else {\n                baseId = id;\n            }\n            // Destroy the existing kernel\n            await this.destroyKernel(id);\n            // Create a new kernel with the same configuration\n            const restartOptions = {\n                id: baseId,\n                mode: currentConfig.mode,\n                lang: currentConfig.language,\n                namespace,\n                deno: currentConfig.options.deno,\n                filesystem: currentConfig.options.filesystem,\n                inactivityTimeout: currentConfig.options.inactivityTimeout,\n                maxExecutionTime: currentConfig.options.maxExecutionTime\n            };\n            // Create the new kernel\n            const newKernelId = await this.createKernel(restartOptions);\n            // Verify the new kernel has the same ID\n            if (newKernelId !== id) {\n                console.error(`Kernel restart failed: expected ID ${id}, got ${newKernelId}`);\n                return false;\n            }\n            return true;\n        }\n        catch (error) {\n            console.error(`Error restarting kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Interrupt a running kernel execution\n     * @param id Kernel ID\n     * @returns Promise resolving to true if the interrupt was successful, false if not found or failed\n     */\n    async interruptKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            console.warn(`Cannot interrupt kernel ${id}: kernel not found`);\n            return false;\n        }\n        try {\n            if (instance.mode === KernelMode.WORKER && instance.worker) {\n                // For worker kernels, use SharedArrayBuffer interrupt method\n                return await this.interruptWorkerKernel(id, instance);\n            }\n            else {\n                // For main thread kernels, try to interrupt (will throw error if not supported)\n                return await this.interruptMainThreadKernel(id, instance);\n            }\n        }\n        catch (error) {\n            console.error(`Error interrupting kernel ${id}:`, error instanceof Error ? error.message : String(error));\n            return false;\n        }\n    }\n    /**\n     * Interrupt a main thread kernel\n     * @param id Kernel ID\n     * @param instance Kernel instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptMainThreadKernel(id, instance) {\n        // Main thread kernels don't support proper interruption like worker kernels do\n        // Even if they have an interrupt method, it's limited and unreliable\n        throw new Error(`Main thread kernel ${id} does not support reliable interruption. Use worker kernels for interruptible execution.`);\n    }\n    /**\n     * Interrupt a worker kernel using SharedArrayBuffer according to Pyodide documentation\n     * @param id Kernel ID\n     * @param instance Kernel instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptWorkerKernel(id, instance) {\n        try {\n            const worker = instance.worker;\n            if (!worker) {\n                console.error(`Worker not found for kernel ${id}`);\n                return false;\n            }\n            // If interruption mode is 'kernel-interrupt', use fallback directly\n            if (this.interruptionMode === 'kernel-interrupt') {\n                return await this.interruptWorkerKernelFallback(id, worker);\n            }\n            // Check if we already have an interrupt buffer for this kernel\n            let interruptBuffer = this.interruptBuffers.get(id);\n            if (!interruptBuffer) {\n                // Create a new SharedArrayBuffer for interrupt control\n                try {\n                    // Try to create SharedArrayBuffer (requires specific security headers)\n                    const sharedBuffer = new SharedArrayBuffer(1);\n                    interruptBuffer = new Uint8Array(sharedBuffer);\n                    // Initialize buffer to 0 (no interrupt signal)\n                    interruptBuffer[0] = 0;\n                    // Store the buffer for future use\n                    this.interruptBuffers.set(id, interruptBuffer);\n                    // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n                    worker.postMessage({\n                        type: \"SET_INTERRUPT_BUFFER\",\n                        buffer: interruptBuffer\n                    });\n                    // Wait for the worker to confirm buffer setup\n                    await new Promise((resolve, reject) => {\n                        const timeout = setTimeout(() => {\n                            reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n                        }, 2000);\n                        const handler = (event) => {\n                            if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n                                worker.removeEventListener(\"message\", handler);\n                                clearTimeout(timeout);\n                                resolve();\n                            }\n                        };\n                        worker.addEventListener(\"message\", handler);\n                    });\n                    console.log(`Interrupt buffer set up for kernel ${id}`);\n                }\n                catch (error) {\n                    // Handle based on interruption mode\n                    if (this.interruptionMode === 'shared-array-buffer') {\n                        // If explicitly set to shared-array-buffer, this is an error\n                        console.error(`âŒ Cannot create SharedArrayBuffer for interrupt handling in kernel ${id}`);\n                        throw new Error(`SharedArrayBuffer is required for interruption mode 'shared-array-buffer' but is not available.\n\nTo fix this issue, either:\n1. Configure your web server with these headers:\n   - Cross-Origin-Opener-Policy: same-origin\n   - Cross-Origin-Embedder-Policy: require-corp\n\n2. Or change the interruption mode when creating KernelManager:\n   new KernelManager({ interruptionMode: 'auto' })`);\n                    }\n                    else {\n                        // Auto mode: fall back to kernel.interrupt()\n                        console.info(`â„¹ï¸ Using message-based interrupt for kernel ${id} (SharedArrayBuffer not available)`);\n                        // Fallback: use message-based interrupt\n                        return await this.interruptWorkerKernelFallback(id, worker);\n                    }\n                }\n            }\n            // According to Pyodide docs: Set interrupt signal (2 = SIGINT)\n            console.log(`Setting interrupt signal for kernel ${id}...`);\n            interruptBuffer[0] = 2;\n            // Wait for Pyodide to process the interrupt\n            // Pyodide will reset the buffer to 0 when it processes the interrupt\n            let attempts = 0;\n            const maxAttempts = 50; // Check for up to 5 seconds (50 * 100ms)\n            while (attempts < maxAttempts && interruptBuffer[0] !== 0) {\n                await new Promise(resolve => setTimeout(resolve, 100));\n                attempts++;\n            }\n            if (interruptBuffer[0] === 0) {\n                console.log(`Interrupt processed successfully for kernel ${id} after ${attempts * 100}ms`);\n                return true;\n            }\n            else {\n                console.warn(`Interrupt signal not processed for kernel ${id} after ${maxAttempts * 100}ms`);\n                // Still return true as we set the signal - the interrupt may be processed later\n                return true;\n            }\n        }\n        catch (error) {\n            console.error(`Error interrupting worker kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Fallback interrupt method for worker kernels when SharedArrayBuffer is not available\n     * @param id Kernel ID\n     * @param worker Worker instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptWorkerKernelFallback(id, worker) {\n        return new Promise((resolve) => {\n            // Set up a listener for the interrupt response\n            const responseHandler = (event) => {\n                if (event.data?.type === \"INTERRUPT_TRIGGERED\") {\n                    worker.removeEventListener(\"message\", responseHandler);\n                    const success = event.data.data?.success || false;\n                    resolve(success);\n                }\n            };\n            // Listen for the response\n            worker.addEventListener(\"message\", responseHandler);\n            // Send the interrupt message\n            worker.postMessage({\n                type: \"INTERRUPT_KERNEL\"\n            });\n            // Set a timeout in case we don't get a response\n            setTimeout(() => {\n                worker.removeEventListener(\"message\", responseHandler);\n                console.warn(`â±ï¸ Interrupt request timed out for kernel ${id} after 5 seconds.\nThis may happen if:\n- The kernel is running code that cannot be interrupted\n- The kernel is in an unresponsive state\nYou may need to restart the kernel if it remains unresponsive.`);\n                resolve(false);\n            }, 5000); // 5 second timeout\n        });\n    }\n    /**\n     * Handle a stuck execution with configurable strategies\n     * @param kernelId Kernel ID\n     * @param executionId Execution ID that's stuck\n     * @param actualRuntime How long the execution has been running\n     * @param code The code that was being executed\n     * @private\n     */\n    async handleStuckExecution(kernelId, executionId, actualRuntime, code) {\n        const instance = this.kernels.get(kernelId);\n        if (!instance) {\n            return;\n        }\n        console.warn(`Handling stuck execution ${executionId} on kernel ${kernelId} (runtime: ${actualRuntime}ms)`);\n        // Strategy 1: Try to interrupt the kernel first\n        const interruptSuccess = await this.interruptKernel(kernelId);\n        if (interruptSuccess) {\n            console.log(`Successfully interrupted kernel ${kernelId}`);\n            // Emit an execution error to notify clients\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: kernelId,\n                data: {\n                    ename: \"ExecutionInterrupted\",\n                    evalue: `Execution automatically interrupted after ${actualRuntime}ms (exceeded maxExecutionTime)`,\n                    traceback: [\n                        `Execution was automatically interrupted due to timeout.`,\n                        `Runtime: ${actualRuntime}ms`,\n                        `Max allowed: ${instance.options.maxExecutionTime}ms`,\n                        code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n                    ]\n                }\n            });\n            return;\n        }\n        // Strategy 2: If interrupt failed, try restarting the kernel\n        console.warn(`Interrupt failed for kernel ${kernelId}, attempting restart...`);\n        const restartSuccess = await this.restartKernel(kernelId);\n        if (restartSuccess) {\n            console.log(`Successfully restarted kernel ${kernelId}`);\n            // Emit a restart notification\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: kernelId,\n                data: {\n                    ename: \"KernelRestarted\",\n                    evalue: `Kernel automatically restarted due to stuck execution (runtime: ${actualRuntime}ms)`,\n                    traceback: [\n                        `Kernel was automatically restarted due to stuck execution.`,\n                        `Runtime: ${actualRuntime}ms`,\n                        `Max allowed: ${instance.options.maxExecutionTime}ms`,\n                        `Interrupt attempt failed, kernel was restarted instead.`,\n                        code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n                    ]\n                }\n            });\n            return;\n        }\n        // Strategy 3: If restart failed, force terminate the kernel\n        console.error(`Restart failed for kernel ${kernelId}, force terminating...`);\n        const terminateSuccess = await this.forceTerminateKernel(kernelId, `Stuck execution could not be interrupted or restarted (runtime: ${actualRuntime}ms)`);\n        if (terminateSuccess) {\n            console.log(`Successfully terminated kernel ${kernelId}`);\n        }\n        else {\n            console.error(`Failed to terminate kernel ${kernelId} - manual intervention may be required`);\n            // Emit a critical error\n            super.emit('kernel_unrecoverable', {\n                kernelId: kernelId,\n                executionId: executionId,\n                actualRuntime: actualRuntime,\n                code: code,\n                message: 'Kernel is stuck and could not be recovered through interrupt, restart, or termination'\n            });\n        }\n    }\n    /**\n     * Get detailed information about stuck executions across all kernels\n     * @returns Array of stuck execution details\n     */\n    getStuckExecutions() {\n        const stuckExecutions = [];\n        const currentTime = Date.now();\n        for (const [kernelId, instance] of this.kernels.entries()) {\n            // Skip pool kernels\n            if (kernelId.startsWith(\"pool-\"))\n                continue;\n            // Skip kernels without maxExecutionTime configured\n            if (!instance.options?.maxExecutionTime || instance.options.maxExecutionTime <= 0) {\n                continue;\n            }\n            const maxExecutionTime = instance.options.maxExecutionTime;\n            const startTimes = this.executionStartTimes.get(kernelId);\n            const metadata = this.executionMetadata.get(kernelId);\n            const ongoingExecs = this.ongoingExecutions.get(kernelId);\n            if (!ongoingExecs || ongoingExecs.size === 0) {\n                continue;\n            }\n            for (const executionId of ongoingExecs) {\n                const startTime = startTimes?.get(executionId);\n                if (startTime === undefined)\n                    continue;\n                const runtime = currentTime - startTime;\n                // Check if this execution is stuck\n                if (runtime > maxExecutionTime) {\n                    const execMetadata = metadata?.get(executionId);\n                    stuckExecutions.push({\n                        kernelId,\n                        executionId,\n                        startTime,\n                        runtime,\n                        maxAllowed: maxExecutionTime,\n                        code: execMetadata?.code,\n                        kernelMode: instance.mode,\n                        kernelLanguage: instance.language\n                    });\n                }\n            }\n        }\n        // Sort by runtime (longest running first)\n        stuckExecutions.sort((a, b) => b.runtime - a.runtime);\n        return stuckExecutions;\n    }\n    /**\n     * Force interrupt all stuck executions across all kernels\n     * @returns Promise resolving to array of intervention results\n     */\n    async handleAllStuckExecutions() {\n        const stuckExecutions = this.getStuckExecutions();\n        const results = [];\n        console.log(`Found ${stuckExecutions.length} stuck executions to handle`);\n        // Group by kernel to avoid multiple interventions on the same kernel\n        const kernelGroups = new Map();\n        for (const exec of stuckExecutions) {\n            if (!kernelGroups.has(exec.kernelId)) {\n                kernelGroups.set(exec.kernelId, []);\n            }\n            kernelGroups.get(exec.kernelId).push(exec);\n        }\n        // Handle each kernel's stuck executions\n        for (const [kernelId, executions] of kernelGroups) {\n            try {\n                // Pick the longest running execution as the primary one\n                const primaryExec = executions[0]; // Already sorted by runtime desc\n                console.log(`Handling stuck kernel ${kernelId} with ${executions.length} stuck executions (primary: ${primaryExec.runtime}ms)`);\n                // Use the automated handling system\n                await this.handleStuckExecution(kernelId, primaryExec.executionId, primaryExec.runtime, primaryExec.code);\n                // Mark all executions for this kernel as handled\n                for (const exec of executions) {\n                    results.push({\n                        kernelId: exec.kernelId,\n                        executionId: exec.executionId,\n                        action: 'interrupted', // We don't know the exact action, but it was handled\n                        success: true\n                    });\n                }\n            }\n            catch (error) {\n                console.error(`Error handling stuck executions for kernel ${kernelId}:`, error);\n                // Mark all executions for this kernel as failed\n                for (const exec of executions) {\n                    results.push({\n                        kernelId: exec.kernelId,\n                        executionId: exec.executionId,\n                        action: 'failed',\n                        success: false,\n                        error: error instanceof Error ? error.message : String(error)\n                    });\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * Set up interrupt buffer for a worker kernel during creation\n     * @param id Kernel ID\n     * @param worker Worker instance\n     * @private\n     */\n    async setupWorkerInterruptBuffer(id, worker) {\n        // Skip SharedArrayBuffer setup if mode is 'kernel-interrupt'\n        if (this.interruptionMode === 'kernel-interrupt') {\n            console.log(`Skipping SharedArrayBuffer setup for kernel ${id} - using kernel.interrupt() mode`);\n            return;\n        }\n        try {\n            // Python kernels support interrupt buffers\n            // For Python kernels, create actual SharedArrayBuffer\n            const sharedBuffer = new SharedArrayBuffer(1);\n            const interruptBuffer = new Uint8Array(sharedBuffer);\n            // Initialize buffer to 0 (no interrupt signal)\n            interruptBuffer[0] = 0;\n            // Store the buffer for future use\n            this.interruptBuffers.set(id, interruptBuffer);\n            // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n            worker.postMessage({\n                type: \"SET_INTERRUPT_BUFFER\",\n                buffer: interruptBuffer\n            });\n            // Wait for the worker to confirm buffer setup\n            await new Promise((resolve, reject) => {\n                const timeout = setTimeout(() => {\n                    reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n                }, 5000);\n                const handler = (event) => {\n                    if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n                        worker.removeEventListener(\"message\", handler);\n                        clearTimeout(timeout);\n                        resolve();\n                    }\n                };\n                worker.addEventListener(\"message\", handler);\n            });\n        }\n        catch (error) {\n            // Handle based on interruption mode\n            if (this.interruptionMode === 'shared-array-buffer') {\n                // If explicitly set to shared-array-buffer, this is an error\n                console.error(`âŒ SharedArrayBuffer required but not available for kernel ${id}`);\n                throw new Error(`SharedArrayBuffer is required but not available. To enable SharedArrayBuffer, your server must set these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nAlternatively, use interruptionMode: 'kernel-interrupt' or 'auto' in KernelManager options.`);\n            }\n            else {\n                // Auto mode: fall back to kernel.interrupt()\n                console.info(`â„¹ï¸ SharedArrayBuffer not available for kernel ${id}. Using alternative interrupt method.\n\nTo enable faster interrupts, configure your server with these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nNote: Some development servers (e.g., Vite, webpack-dev-server) can be configured to add these headers.\nThe alternative interrupt method will still work but may be less responsive for long-running code.`);\n                // Don't throw - kernel can still work without interrupt buffer\n            }\n        }\n    }\n    /**\n     * Get information about mounted filesystems for a specific kernel\n     * @param id Kernel ID\n     * @returns Promise resolving to array of mounted filesystem info\n     */\n    async getMountedFileSystems(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            throw new Error(`Kernel ${id} not found`);\n        }\n        try {\n            if (typeof instance.kernel.getMountedFileSystems === 'function') {\n                return instance.kernel.getMountedFileSystems();\n            }\n            else {\n                console.warn(`Kernel ${id} does not support getMountedFileSystems method`);\n                return [];\n            }\n        }\n        catch (error) {\n            console.error(`Error getting mounted filesystems for kernel ${id}:`, error);\n            throw error;\n        }\n    }\n    /**\n     * Manually sync a specific mounted filesystem for a kernel\n     * @param id Kernel ID\n     * @param mountPath The path of the mounted filesystem to sync\n     * @returns Promise resolving to sync result\n     */\n    async syncFileSystem(id, mountPath) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            throw new Error(`Kernel ${id} not found`);\n        }\n        try {\n            if (typeof instance.kernel.syncFileSystem === 'function') {\n                return await instance.kernel.syncFileSystem(mountPath);\n            }\n            else {\n                console.warn(`Kernel ${id} does not support syncFileSystem method`);\n                return {\n                    success: false,\n                    error: 'syncFileSystem is not supported by this kernel'\n                };\n            }\n        }\n        catch (error) {\n            console.error(`Error syncing filesystem for kernel ${id}:`, error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    }\n    /**\n     * Upgrade a mounted filesystem from read-only to read-write permission\n     * @param id Kernel ID\n     * @param mountPath The path of the mounted filesystem to upgrade\n     * @returns Promise resolving to upgrade result\n     */\n    async upgradeFileSystemPermission(id, mountPath) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            throw new Error(`Kernel ${id} not found`);\n        }\n        try {\n            if (typeof instance.kernel.upgradeFileSystemPermission === 'function') {\n                return await instance.kernel.upgradeFileSystemPermission(mountPath);\n            }\n            else {\n                console.warn(`Kernel ${id} does not support upgradeFileSystemPermission method`);\n                return {\n                    success: false,\n                    error: 'upgradeFileSystemPermission is not supported by this kernel'\n                };\n            }\n        }\n        catch (error) {\n            console.error(`Error upgrading filesystem permission for kernel ${id}:`, error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEtlcm5lbCBNYW5hZ2VyIGZvciBEZW5vIEFwcCBFbmdpbmVcbi8vIFRoaXMgZmlsZSBtYW5hZ2VzIGtlcm5lbCBpbnN0YW5jZXMgaW4gZWl0aGVyIG1haW4gdGhyZWFkIG9yIHdvcmtlciBtb2RlXG5cbmltcG9ydCAqIGFzIENvbWxpbmsgZnJvbSBcImNvbWxpbmtcIjtcbi8vIEB0cy1pZ25vcmUgSW1wb3J0aW5nIGZyb20gbnBtXG4vLyBVc2UgYSBicm93c2VyLWNvbXBhdGlibGUgRXZlbnRFbWl0dGVyXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGV2ZW50czogeyBba2V5OiBzdHJpbmddOiBGdW5jdGlvbltdIH0gPSB7fTtcblxuICBvbihldmVudE5hbWU6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gW107XG4gICAgfVxuICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICBvZmYoZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikge1xuICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkgcmV0dXJuO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogRnVuY3Rpb24pIHtcbiAgICB0aGlzLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIGVtaXQoZXZlbnROYW1lOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSByZXR1cm47XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKC4uLmFyZ3MpKTtcbiAgfVxuXG4gIHNldE1heExpc3RlbmVycyhuOiBudW1iZXIpIHtcbiAgICAvLyBOby1vcCBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4gIH1cbn1cbmltcG9ydCB7IEtlcm5lbEV2ZW50cywgSUtlcm5lbCwgSUtlcm5lbE9wdGlvbnMsIElGaWxlU3lzdGVtTW91bnRPcHRpb25zIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IEtlcm5lbCB9IGZyb20gXCIuL2luZGV4XCI7XG5cbi8vIFJlLWV4cG9ydCBLZXJuZWxFdmVudHMgZm9yIHRlc3QgdXNhZ2VcbmV4cG9ydCB7IEtlcm5lbEV2ZW50cyB9O1xuXG4vLyBFeGVjdXRpb24gbW9kZSBlbnVtXG5leHBvcnQgZW51bSBLZXJuZWxNb2RlIHtcbiAgTUFJTl9USFJFQUQgPSBcIm1haW5fdGhyZWFkXCIsXG4gIFdPUktFUiA9IFwid29ya2VyXCJcbn1cblxuLy8gS2VybmVsIGxhbmd1YWdlIGVudW1cbmV4cG9ydCBlbnVtIEtlcm5lbExhbmd1YWdlIHtcbiAgUFlUSE9OID0gXCJweXRob25cIlxufVxuXG4vLyBFeHRlbmRlZCBXb3JrZXJPcHRpb25zIGludGVyZmFjZSB0byBpbmNsdWRlIERlbm8gcGVybWlzc2lvbnNcbmludGVyZmFjZSBXb3JrZXJPcHRpb25zIHtcbiAgdHlwZT86IFwiY2xhc3NpY1wiIHwgXCJtb2R1bGVcIjtcbiAgbmFtZT86IHN0cmluZztcbiAgZGVubz86IHtcbiAgICBwZXJtaXNzaW9ucz86IElEZW5vUGVybWlzc2lvbnM7XG4gIH07XG59XG5cbi8vIEludGVyZmFjZSBmb3Iga2VybmVsIHBvb2wgY29uZmlndXJhdGlvblxuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsUG9vbENvbmZpZyB7XG4gIGVuYWJsZWQ6IGJvb2xlYW47XG4gIHBvb2xTaXplOiBudW1iZXI7IC8vIE51bWJlciBvZiBrZXJuZWxzIHRvIGtlZXAgcmVhZHkgcGVyIGNvbmZpZ3VyYXRpb25cbiAgYXV0b1JlZmlsbDogYm9vbGVhbjsgLy8gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IHJlZmlsbCB0aGUgcG9vbCB3aGVuIGtlcm5lbHMgYXJlIHRha2VuXG4gIHByZWxvYWRDb25maWdzOiBBcnJheTx7XG4gICAgbW9kZTogS2VybmVsTW9kZTtcbiAgICBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gIH0+OyAvLyBDb25maWd1cmF0aW9ucyB0byBwcmVsb2FkIGluIHRoZSBwb29sXG59XG5cbi8vIEludGVyZmFjZSBmb3Iga2VybmVsIG1hbmFnZXIgb3B0aW9uc1xuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsTWFuYWdlck9wdGlvbnMge1xuICBwb29sPzogSUtlcm5lbFBvb2xDb25maWc7XG4gIGFsbG93ZWRLZXJuZWxUeXBlcz86IEFycmF5PHtcbiAgICBtb2RlOiBLZXJuZWxNb2RlO1xuICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgfT47IC8vIFJlc3RyaWN0IHdoaWNoIGtlcm5lbCB0eXBlcyBjYW4gYmUgY3JlYXRlZFxuICBpbnRlcnJ1cHRpb25Nb2RlPzogJ3NoYXJlZC1hcnJheS1idWZmZXInIHwgJ2tlcm5lbC1pbnRlcnJ1cHQnIHwgJ2F1dG8nOyAvLyBEZWZhdWx0OiAnYXV0bydcbiAgd29ya2VyVXJsPzogc3RyaW5nOyAvLyBPcHRpb25hbCBjdXN0b20gVVJMIGZvciB0aGUgd29ya2VyIHNjcmlwdFxufVxuXG4vLyBJbnRlcmZhY2UgZm9yIGtlcm5lbCBpbnN0YW5jZVxuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsSW5zdGFuY2Uge1xuICBpZDogc3RyaW5nO1xuICBrZXJuZWw6IElLZXJuZWw7XG4gIG1vZGU6IEtlcm5lbE1vZGU7XG4gIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgd29ya2VyPzogV29ya2VyO1xuICBjcmVhdGVkOiBzdHJpbmc7XG4gIG9wdGlvbnM6IElNYW5hZ2VyS2VybmVsT3B0aW9ucztcbiAgaXNGcm9tUG9vbD86IGJvb2xlYW47IC8vIFRyYWNrIGlmIHRoaXMga2VybmVsIGNhbWUgZnJvbSB0aGUgcG9vbFxuICBkZXN0cm95KCk6IFByb21pc2U8dm9pZD47XG59XG5cbi8vIEludGVyZmFjZSBmb3IgRGVubyB3b3JrZXIgcGVybWlzc2lvbnNcbmV4cG9ydCBpbnRlcmZhY2UgSURlbm9QZXJtaXNzaW9ucyB7XG4gIHJlYWQ/OiAoc3RyaW5nIHwgVVJMKVtdO1xuICB3cml0ZT86IChzdHJpbmcgfCBVUkwpW107XG4gIG5ldD86IHN0cmluZ1tdO1xuICBlbnY/OiBzdHJpbmdbXTtcbiAgcnVuPzogc3RyaW5nW107XG4gIGZmaT86IHN0cmluZ1tdO1xuICBocnRpbWU/OiBib29sZWFuO1xufVxuXG4vLyBJbnRlcmZhY2UgZm9yIGtlcm5lbCBjcmVhdGlvbiBvcHRpb25zXG5leHBvcnQgaW50ZXJmYWNlIElNYW5hZ2VyS2VybmVsT3B0aW9ucyB7XG4gIGlkPzogc3RyaW5nO1xuICBtb2RlPzogS2VybmVsTW9kZTtcbiAgbGFuZz86IEtlcm5lbExhbmd1YWdlO1xuICBuYW1lc3BhY2U/OiBzdHJpbmc7XG4gIGRlbm8/OiB7XG4gICAgcGVybWlzc2lvbnM/OiBJRGVub1Blcm1pc3Npb25zO1xuICB9O1xuICBmaWxlc3lzdGVtPzogSUZpbGVTeXN0ZW1Nb3VudE9wdGlvbnM7XG4gIGVudj86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47IC8vIEVudmlyb25tZW50IHZhcmlhYmxlcyB0byBzZXQgaW4gdGhlIGtlcm5lbFxuICBsb2NrRmlsZVVSTD86IHN0cmluZzsgLy8gVVJMIHRvIHB5b2RpZGUtbG9jay5qc29uIGZpbGUgZm9yIGZhc3RlciBsb2FkaW5nXG4gIGF1dG9TeW5jRnM/OiBib29sZWFuOyAvLyBBdXRvbWF0aWNhbGx5IHN5bmMgbmF0aXZlIGZpbGVzeXN0ZW0gYWZ0ZXIgY29kZSBleGVjdXRpb24gKGRlZmF1bHQ6IGZhbHNlKVxuICBpbmFjdGl2aXR5VGltZW91dD86IG51bWJlcjsgLy8gVGltZSBpbiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggYW4gaW5hY3RpdmUga2VybmVsIHdpbGwgYmUgc2h1dCBkb3duXG4gIG1heEV4ZWN1dGlvblRpbWU/OiBudW1iZXI7IC8vIE1heGltdW0gdGltZSBpbiBtaWxsaXNlY29uZHMgYSBzaW5nbGUgZXhlY3V0aW9uIGNhbiBydW4gYmVmb3JlIGNvbnNpZGVyZWQgc3R1Y2svZGVhZFxufVxuXG4vLyBIZWxwZXIgdHlwZSBmb3IgbGlzdGVuZXIgbWFuYWdlbWVudFxudHlwZSBMaXN0ZW5lcldyYXBwZXIgPSB7XG4gIG9yaWdpbmFsOiAoZGF0YTogYW55KSA9PiB2b2lkO1xuICB3cmFwcGVkOiAoZXZlbnQ6IHsga2VybmVsSWQ6IHN0cmluZywgZGF0YTogYW55IH0pID0+IHZvaWQ7XG59O1xuXG4vKipcbiAqIEtlcm5lbE1hbmFnZXIgY2xhc3MgbWFuYWdlcyBtdWx0aXBsZSBrZXJuZWwgaW5zdGFuY2VzIFxuICogaW4gZWl0aGVyIG1haW4gdGhyZWFkIG9yIHdvcmtlciBtb2RlXG4gKi9cbmV4cG9ydCBjbGFzcyBLZXJuZWxNYW5hZ2VyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSBrZXJuZWxzOiBNYXA8c3RyaW5nLCBJS2VybmVsSW5zdGFuY2U+ID0gbmV3IE1hcCgpO1xuICAvLyBUcmFjayBsaXN0ZW5lcnMgZm9yIGVhY2gga2VybmVsIHRvIGVuYWJsZSBpbmRpdmlkdWFsIHJlbW92YWxcbiAgcHJpdmF0ZSBsaXN0ZW5lcldyYXBwZXJzOiBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBNYXA8RnVuY3Rpb24sIExpc3RlbmVyV3JhcHBlcj4+PiA9IG5ldyBNYXAoKTtcbiAgLy8gVHJhY2sgbGFzdCBhY3Rpdml0eSB0aW1lIGZvciBlYWNoIGtlcm5lbFxuICBwcml2YXRlIGxhc3RBY3Rpdml0eVRpbWU6IE1hcDxzdHJpbmcsIG51bWJlcj4gPSBuZXcgTWFwKCk7XG4gIC8vIFN0b3JlIGluYWN0aXZpdHkgdGltZXJzIGZvciBlYWNoIGtlcm5lbFxuICBwcml2YXRlIGluYWN0aXZpdHlUaW1lcnM6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwKCk7XG4gIC8vIFRyYWNrIG9uZ29pbmcgZXhlY3V0aW9ucyBmb3IgZWFjaCBrZXJuZWxcbiAgcHJpdmF0ZSBvbmdvaW5nRXhlY3V0aW9uczogTWFwPHN0cmluZywgU2V0PHN0cmluZz4+ID0gbmV3IE1hcCgpO1xuICAvLyBUcmFjayBleGVjdXRpb24gdGltZW91dHMgZm9yIGRldGVjdGluZyBzdHVjay9kZWFkIGtlcm5lbHNcbiAgcHJpdmF0ZSBleGVjdXRpb25UaW1lb3V0czogTWFwPHN0cmluZywgTWFwPHN0cmluZywgYW55Pj4gPSBuZXcgTWFwKCk7XG4gIC8vIFRyYWNrIGV4ZWN1dGlvbiBzdGFydCB0aW1lcyBmb3IgYWNjdXJhdGUgZHVyYXRpb24gY2FsY3VsYXRpb25cbiAgcHJpdmF0ZSBleGVjdXRpb25TdGFydFRpbWVzOiBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBudW1iZXI+PiA9IG5ldyBNYXAoKTtcbiAgLy8gVHJhY2sgZXhlY3V0aW9uIG1ldGFkYXRhIGZvciBiZXR0ZXIgbW9uaXRvcmluZ1xuICBwcml2YXRlIGV4ZWN1dGlvbk1ldGFkYXRhOiBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCB7IHN0YXJ0VGltZTogbnVtYmVyOyBjb2RlPzogc3RyaW5nOyB0aW1lb3V0SWQ/OiBhbnkgfT4+ID0gbmV3IE1hcCgpO1xuICBcbiAgLy8gVHJhY2sgQWJvcnRDb250cm9sbGVycyBmb3IgZWFjaCBrZXJuZWwncyBvbmdvaW5nIG9wZXJhdGlvbnNcbiAgcHJpdmF0ZSBhYm9ydENvbnRyb2xsZXJzOiBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBBYm9ydENvbnRyb2xsZXI+PiA9IG5ldyBNYXAoKTtcbiAgXG4gIC8vIFBvb2wgbWFuYWdlbWVudCAtIG5vdyB1c2luZyBwcm9taXNlcyBmb3IgaW1tZWRpYXRlIHJlc3BvbnNlXG4gIHByaXZhdGUgcG9vbDogTWFwPHN0cmluZywgUHJvbWlzZTxJS2VybmVsSW5zdGFuY2U+W10+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHBvb2xDb25maWc6IElLZXJuZWxQb29sQ29uZmlnO1xuICBwcml2YXRlIGlzUHJlbG9hZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAvLyBUcmFjayB3aGljaCBwb29sIGtleXMgYXJlIGN1cnJlbnRseSBiZWluZyBwcmVmaWxsZWQgdG8gcHJldmVudCBkdXBsaWNhdGVzXG4gIHByaXZhdGUgcHJlZmlsbGluZ0luUHJvZ3Jlc3M6IE1hcDxzdHJpbmcsIGJvb2xlYW4+ID0gbmV3IE1hcCgpO1xuICBcbiAgLy8gQWxsb3dlZCBrZXJuZWwgdHlwZXMgY29uZmlndXJhdGlvblxuICBwcml2YXRlIGFsbG93ZWRLZXJuZWxUeXBlczogQXJyYXk8e1xuICAgIG1vZGU6IEtlcm5lbE1vZGU7XG4gICAgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlO1xuICB9PjtcbiAgXG4gIC8vIEludGVycnVwdCBidWZmZXJzIGZvciB3b3JrZXIga2VybmVscyAodXNpbmcgU2hhcmVkQXJyYXlCdWZmZXIpXG4gIHByaXZhdGUgaW50ZXJydXB0QnVmZmVyczogTWFwPHN0cmluZywgVWludDhBcnJheT4gPSBuZXcgTWFwKCk7XG4gIFxuICAvLyBJbnRlcnJ1cHRpb24gbW9kZSBjb25maWd1cmF0aW9uXG4gIHByaXZhdGUgaW50ZXJydXB0aW9uTW9kZTogJ3NoYXJlZC1hcnJheS1idWZmZXInIHwgJ2tlcm5lbC1pbnRlcnJ1cHQnIHwgJ2F1dG8nO1xuICBcbiAgLy8gV29ya2VyIFVSTCBjb25maWd1cmF0aW9uXG4gIHByaXZhdGUgd29ya2VyVXJsOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIFxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgd29ya2VyIFVSTCBiYXNlZCBvbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyBUaGUgcmVzb2x2ZWQgd29ya2VyIFVSTFxuICAgKi9cbiAgcHJpdmF0ZSByZXNvbHZlV29ya2VyVXJsKCk6IHN0cmluZyB7XG4gICAgLy8gSWYgYSBjdXN0b20gd29ya2VyIFVSTCBpcyBwcm92aWRlZCwgdXNlIGl0XG4gICAgaWYgKHRoaXMud29ya2VyVXJsKSB7XG4gICAgICByZXR1cm4gdGhpcy53b3JrZXJVcmw7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSB0byBkZXRlY3QgdGhlIGN1cnJlbnQgc2NyaXB0IGxvY2F0aW9uIGFuZCBkZXJpdmUgdGhlIHdvcmtlciBVUkxcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uKSB7XG4gICAgICAvLyBCcm93c2VyIGVudmlyb25tZW50XG4gICAgICBjb25zdCBjdXJyZW50U2NyaXB0ID0gKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JykpLnBvcCgpO1xuICAgICAgXG4gICAgICBpZiAoY3VycmVudFNjcmlwdCAmJiBjdXJyZW50U2NyaXB0LnNyYykge1xuICAgICAgICAvLyBHZXQgdGhlIGJhc2UgVVJMIGZyb20gdGhlIGN1cnJlbnQgc2NyaXB0XG4gICAgICAgIGNvbnN0IHNjcmlwdFVybCA9IG5ldyBVUkwoY3VycmVudFNjcmlwdC5zcmMpO1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gc2NyaXB0VXJsLmhyZWYuc3Vic3RyaW5nKDAsIHNjcmlwdFVybC5ocmVmLmxhc3RJbmRleE9mKCcvJykpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgbG9hZGluZyBmcm9tIGEgQ0ROIChqc2RlbGl2ciwgdW5wa2csIGV0Yy4pXG4gICAgICAgIGlmIChzY3JpcHRVcmwuaG9zdG5hbWUuaW5jbHVkZXMoJ2pzZGVsaXZyLm5ldCcpIHx8IFxuICAgICAgICAgICAgc2NyaXB0VXJsLmhvc3RuYW1lLmluY2x1ZGVzKCd1bnBrZy5jb20nKSB8fFxuICAgICAgICAgICAgc2NyaXB0VXJsLmhvc3RuYW1lLmluY2x1ZGVzKCdjZG5qcy5jbG91ZGZsYXJlLmNvbScpKSB7XG4gICAgICAgICAgLy8gRm9yIENETiwgdGhlIHdvcmtlciBzaG91bGQgYmUgYXQgdGhlIHNhbWUgcGF0aFxuICAgICAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9rZXJuZWwud29ya2VyLmpzYDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRm9yIGxvY2FsIGRldmVsb3BtZW50IG9yIGN1c3RvbSBkZXBsb3ltZW50c1xuICAgICAgICByZXR1cm4gYCR7YmFzZVVybH0va2VybmVsLndvcmtlci5qc2A7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZhbGxiYWNrIHRvIHJlbGF0aXZlIHBhdGggZnJvbSBjdXJyZW50IGxvY2F0aW9uXG4gICAgICBjb25zdCBiYXNlVXJsID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5zdWJzdHJpbmcoMCwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLmxhc3RJbmRleE9mKCcvJykpO1xuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2Rpc3Qva2VybmVsLndvcmtlci5qc2A7XG4gICAgfVxuICAgIFxuICAgIC8vIE5vZGUuanMgb3IgdW5rbm93biBlbnZpcm9ubWVudCAtIHVzZSByZWxhdGl2ZSBwYXRoXG4gICAgLy8gVGhpcyBtYXkgbm90IHdvcmsgaW4gTm9kZS5qcyBidXQgaXMgcHJvdmlkZWQgYXMgYSBmYWxsYmFja1xuICAgIHJldHVybiAnLi9rZXJuZWwud29ya2VyLmpzJztcbiAgfVxuICBcbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBhbiBlcnJvciBpcyBhIEtleWJvYXJkSW50ZXJydXB0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGlzS2V5Ym9hcmRJbnRlcnJ1cHQoZXJyb3I6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBlcnJvciAmJiBcbiAgICAgICAgICAgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBcbiAgICAgICAgICAgKCgndHlwZScgaW4gZXJyb3IgJiYgZXJyb3IudHlwZSA9PT0gXCJLZXlib2FyZEludGVycnVwdFwiKSB8fFxuICAgICAgICAgICAgKCdtZXNzYWdlJyBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIktleWJvYXJkSW50ZXJydXB0XCIpKSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc3RhbmRhcmRpemVkIEtleWJvYXJkSW50ZXJydXB0IGVycm9yIHJlc3VsdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVLZXlib2FyZEludGVycnVwdFJlc3VsdCgpOiB7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yOiBFcnJvcjsgcmVzdWx0OiBhbnkgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIktleWJvYXJkSW50ZXJydXB0OiBFeGVjdXRpb24gaW50ZXJydXB0ZWQgYnkgdXNlclwiKSxcbiAgICAgIHJlc3VsdDoge1xuICAgICAgICBzdGF0dXM6IFwiZXJyb3JcIixcbiAgICAgICAgZW5hbWU6IFwiS2V5Ym9hcmRJbnRlcnJ1cHRcIixcbiAgICAgICAgZXZhbHVlOiBcIkV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCIsXG4gICAgICAgIHRyYWNlYmFjazogW1wiS2V5Ym9hcmRJbnRlcnJ1cHQ6IEV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCJdXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFN0b3JlIGFuIEFib3J0Q29udHJvbGxlciBmb3IgYSBzcGVjaWZpYyBrZXJuZWwgZXhlY3V0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHN0b3JlQWJvcnRDb250cm9sbGVyKGtlcm5lbElkOiBzdHJpbmcsIGV4ZWN1dGlvbklkOiBzdHJpbmcsIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5hYm9ydENvbnRyb2xsZXJzLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVycy5zZXQoa2VybmVsSWQsIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIHRoaXMuYWJvcnRDb250cm9sbGVycy5nZXQoa2VybmVsSWQpIS5zZXQoZXhlY3V0aW9uSWQsIGNvbnRyb2xsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbmQgcmV0dXJuIGFuIEFib3J0Q29udHJvbGxlciBmb3IgYSBzcGVjaWZpYyBrZXJuZWwgZXhlY3V0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHJlbW92ZUFib3J0Q29udHJvbGxlcihrZXJuZWxJZDogc3RyaW5nLCBleGVjdXRpb25JZDogc3RyaW5nKTogQWJvcnRDb250cm9sbGVyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBrZXJuZWxDb250cm9sbGVycyA9IHRoaXMuYWJvcnRDb250cm9sbGVycy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsQ29udHJvbGxlcnMpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgY29uc3QgY29udHJvbGxlciA9IGtlcm5lbENvbnRyb2xsZXJzLmdldChleGVjdXRpb25JZCk7XG4gICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgIGtlcm5lbENvbnRyb2xsZXJzLmRlbGV0ZShleGVjdXRpb25JZCk7XG4gICAgICBpZiAoa2VybmVsQ29udHJvbGxlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlcnMuZGVsZXRlKGtlcm5lbElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gIH1cblxuICAvKipcbiAgICogQWJvcnQgYWxsIG9uZ29pbmcgb3BlcmF0aW9ucyBmb3IgYSBzcGVjaWZpYyBrZXJuZWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYWJvcnRBbGxLZXJuZWxPcGVyYXRpb25zKGtlcm5lbElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBrZXJuZWxDb250cm9sbGVycyA9IHRoaXMuYWJvcnRDb250cm9sbGVycy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsQ29udHJvbGxlcnMpIHJldHVybjtcblxuICAgIGZvciAoY29uc3QgW2V4ZWN1dGlvbklkLCBjb250cm9sbGVyXSBvZiBrZXJuZWxDb250cm9sbGVycykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+aqyBBYm9ydGVkIGV4ZWN1dGlvbiAke2V4ZWN1dGlvbklkfSBmb3Iga2VybmVsICR7a2VybmVsSWR9YCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBFcnJvciBhYm9ydGluZyBleGVjdXRpb24gJHtleGVjdXRpb25JZH06YCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhciBhbGwgY29udHJvbGxlcnMgZm9yIHRoaXMga2VybmVsXG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXJzLmRlbGV0ZShrZXJuZWxJZCk7XG4gIH1cbiAgXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IElLZXJuZWxNYW5hZ2VyT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBzdXBlci5zZXRNYXhMaXN0ZW5lcnMoMTAwKTsgLy8gQWxsb3cgbWFueSBsaXN0ZW5lcnMgZm9yIGtlcm5lbCBldmVudHNcbiAgICBcbiAgICAvLyBTZXQgaW50ZXJydXB0aW9uIG1vZGUgKGRlZmF1bHQgdG8gJ2F1dG8nKVxuICAgIHRoaXMuaW50ZXJydXB0aW9uTW9kZSA9IG9wdGlvbnMuaW50ZXJydXB0aW9uTW9kZSB8fCAnYXV0byc7XG4gICAgXG4gICAgLy8gU2V0IHdvcmtlciBVUkwgaWYgcHJvdmlkZWRcbiAgICB0aGlzLndvcmtlclVybCA9IG9wdGlvbnMud29ya2VyVXJsO1xuICAgIFxuICAgIC8vIFNldCBkZWZhdWx0IGFsbG93ZWQga2VybmVsIHR5cGVzICh3b3JrZXIgbW9kZSBvbmx5IGZvciBzZWN1cml0eSlcbiAgICB0aGlzLmFsbG93ZWRLZXJuZWxUeXBlcyA9IG9wdGlvbnMuYWxsb3dlZEtlcm5lbFR5cGVzIHx8IFtcbiAgICAgIHsgbW9kZTogS2VybmVsTW9kZS5XT1JLRVIsIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZS5QWVRIT04gfVxuICAgIF07XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBwb29sIGNvbmZpZ3VyYXRpb24gd2l0aCBkZWZhdWx0cyBiYXNlZCBvbiBhbGxvd2VkIHR5cGVzXG4gICAgY29uc3QgZGVmYXVsdFByZWxvYWRDb25maWdzID0gdGhpcy5hbGxvd2VkS2VybmVsVHlwZXMuZmlsdGVyKHR5cGUgPT4gXG4gICAgICB0eXBlLmxhbmd1YWdlID09PSBLZXJuZWxMYW5ndWFnZS5QWVRIT04gLy8gT25seSBwcmVsb2FkIFB5dGhvbiBrZXJuZWxzIGJ5IGRlZmF1bHRcbiAgICApO1xuICAgIFxuICAgIHRoaXMucG9vbENvbmZpZyA9IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgcG9vbFNpemU6IDIsXG4gICAgICBhdXRvUmVmaWxsOiB0cnVlLFxuICAgICAgcHJlbG9hZENvbmZpZ3M6IGRlZmF1bHRQcmVsb2FkQ29uZmlncyxcbiAgICAgIC4uLm9wdGlvbnMucG9vbFxuICAgIH07XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdGhhdCBwb29sIHByZWxvYWQgY29uZmlncyBhcmUgd2l0aGluIGFsbG93ZWQgdHlwZXNcbiAgICBpZiAodGhpcy5wb29sQ29uZmlnLnByZWxvYWRDb25maWdzKSB7XG4gICAgICB0aGlzLnBvb2xDb25maWcucHJlbG9hZENvbmZpZ3MgPSB0aGlzLnBvb2xDb25maWcucHJlbG9hZENvbmZpZ3MuZmlsdGVyKGNvbmZpZyA9PiB7XG4gICAgICAgIGNvbnN0IGlzQWxsb3dlZCA9IHRoaXMuaXNLZXJuZWxUeXBlQWxsb3dlZChjb25maWcubW9kZSwgY29uZmlnLmxhbmd1YWdlKTtcbiAgICAgICAgaWYgKCFpc0FsbG93ZWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFBvb2wgcHJlbG9hZCBjb25maWcgJHtjb25maWcubW9kZX0tJHtjb25maWcubGFuZ3VhZ2V9IGlzIG5vdCBpbiBhbGxvd2VkS2VybmVsVHlwZXMsIHNraXBwaW5nYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQWxsb3dlZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdGFydCBwcmVsb2FkaW5nIGlmIHBvb2wgaXMgZW5hYmxlZFxuICAgIGlmICh0aGlzLnBvb2xDb25maWcuZW5hYmxlZCkge1xuICAgICAgdGhpcy5wcmVsb2FkUG9vbCgpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHByZWxvYWRpbmcga2VybmVsIHBvb2w6XCIsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHBvb2wga2V5IGZvciBhIGdpdmVuIG1vZGUgYW5kIGxhbmd1YWdlIGNvbWJpbmF0aW9uXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHJldHVybnMgUG9vbCBrZXkgc3RyaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGdldFBvb2xLZXkobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7bW9kZX0tJHtsYW5ndWFnZX1gO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IGEga2VybmVsIHByb21pc2UgZnJvbSB0aGUgcG9vbCBpZiBhdmFpbGFibGVcbiAgICogQHBhcmFtIG1vZGUgS2VybmVsIG1vZGVcbiAgICogQHBhcmFtIGxhbmd1YWdlIEtlcm5lbCBsYW5ndWFnZVxuICAgKiBAcmV0dXJucyBLZXJuZWwgcHJvbWlzZSBvciBudWxsIGlmIG5vbmUgYXZhaWxhYmxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGdldEZyb21Qb29sKG1vZGU6IEtlcm5lbE1vZGUsIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSk6IFByb21pc2U8SUtlcm5lbEluc3RhbmNlPiB8IG51bGwge1xuICAgIGlmICghdGhpcy5wb29sQ29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBwb29sS2V5ID0gdGhpcy5nZXRQb29sS2V5KG1vZGUsIGxhbmd1YWdlKTtcbiAgICBjb25zdCBwb29sUHJvbWlzZXMgPSB0aGlzLnBvb2wuZ2V0KHBvb2xLZXkpO1xuICAgIFxuICAgIGlmICghcG9vbFByb21pc2VzIHx8IHBvb2xQcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZW1vdmUgYW5kIHJldHVybiB0aGUgZmlyc3QgcHJvbWlzZSBmcm9tIHRoZSBwb29sIChGSUZPKVxuICAgIGNvbnN0IGtlcm5lbFByb21pc2UgPSBwb29sUHJvbWlzZXMuc2hpZnQoKSE7XG4gICAgXG4gICAgLy8gSW1tZWRpYXRlbHkgdHJpZ2dlciBiYWNrZ3JvdW5kIHJlZmlsbCB0byBhZGQgb25lIHByb21pc2UgYmFja1xuICAgIGlmICh0aGlzLnBvb2xDb25maWcuYXV0b1JlZmlsbCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMucmVmaWxsUG9vbFNpbmdsZShtb2RlLCBsYW5ndWFnZSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlZmlsbGluZyBzaW5nbGUga2VybmVsIGZvciAke3Bvb2xLZXl9OmAsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGtlcm5lbFByb21pc2U7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBBZGQgYSBrZXJuZWwgcHJvbWlzZSB0byB0aGUgcG9vbFxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEBwYXJhbSBrZXJuZWxQcm9taXNlIEtlcm5lbCBwcm9taXNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFkZFRvUG9vbChtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UsIGtlcm5lbFByb21pc2U6IFByb21pc2U8SUtlcm5lbEluc3RhbmNlPik6IHZvaWQge1xuICAgIGlmICghdGhpcy5wb29sQ29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcG9vbEtleSA9IHRoaXMuZ2V0UG9vbEtleShtb2RlLCBsYW5ndWFnZSk7XG4gICAgXG4gICAgaWYgKCF0aGlzLnBvb2wuaGFzKHBvb2xLZXkpKSB7XG4gICAgICB0aGlzLnBvb2wuc2V0KHBvb2xLZXksIFtdKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcG9vbFByb21pc2VzID0gdGhpcy5wb29sLmdldChwb29sS2V5KSE7XG4gICAgXG4gICAgLy8gT25seSBhZGQgaWYgd2UgaGF2ZW4ndCByZWFjaGVkIHRoZSBwb29sIHNpemUgbGltaXRcbiAgICBpZiAocG9vbFByb21pc2VzLmxlbmd0aCA8IHRoaXMucG9vbENvbmZpZy5wb29sU2l6ZSkge1xuICAgICAgcG9vbFByb21pc2VzLnB1c2goa2VybmVsUHJvbWlzZSk7XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBwcm9taXNlIHJlamVjdGlvbiB0byBwcmV2ZW50IHVuaGFuZGxlZCByZWplY3Rpb25zXG4gICAgICBrZXJuZWxQcm9taXNlLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgUG9vbCBrZXJuZWwgcHJvbWlzZSByZWplY3RlZCBmb3IgJHtwb29sS2V5fTpgLCBlcnJvcik7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZmFpbGVkIHByb21pc2UgZnJvbSB0aGUgcG9vbFxuICAgICAgICBjb25zdCBpbmRleCA9IHBvb2xQcm9taXNlcy5pbmRleE9mKGtlcm5lbFByb21pc2UpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcG9vbFByb21pc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQb29sIGlzIGZ1bGwsIGxldCB0aGUgZXhjZXNzIHByb21pc2UgcmVzb2x2ZSBhbmQgdGhlbiBkZXN0cm95IHRoZSBrZXJuZWxcbiAgICAgIGtlcm5lbFByb21pc2UudGhlbihrZXJuZWwgPT4ge1xuICAgICAgICBrZXJuZWwuZGVzdHJveSgpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVzdHJveWluZyBleGNlc3MgcG9vbCBrZXJuZWw6XCIsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFeGNlc3MgcG9vbCBrZXJuZWwgcHJvbWlzZSByZWplY3RlZDpcIiwgZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogUmVmaWxsIHRoZSBwb29sIHdpdGggYSBzaW5nbGUga2VybmVsIHByb21pc2VcbiAgICogQHBhcmFtIG1vZGUgS2VybmVsIG1vZGVcbiAgICogQHBhcmFtIGxhbmd1YWdlIEtlcm5lbCBsYW5ndWFnZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZWZpbGxQb29sU2luZ2xlKG1vZGU6IEtlcm5lbE1vZGUsIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5wb29sQ29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcG9vbEtleSA9IHRoaXMuZ2V0UG9vbEtleShtb2RlLCBsYW5ndWFnZSk7XG4gICAgY29uc3QgcG9vbFByb21pc2VzID0gdGhpcy5wb29sLmdldChwb29sS2V5KSB8fCBbXTtcbiAgICBcbiAgICAvLyBPbmx5IGFkZCBvbmUgaWYgd2UncmUgYmVsb3cgdGhlIHBvb2wgc2l6ZVxuICAgIGlmIChwb29sUHJvbWlzZXMubGVuZ3RoIDwgdGhpcy5wb29sQ29uZmlnLnBvb2xTaXplKSB7XG4gICAgICBjb25zdCBrZXJuZWxQcm9taXNlID0gdGhpcy5jcmVhdGVQb29sS2VybmVsUHJvbWlzZShtb2RlLCBsYW5ndWFnZSk7XG4gICAgICB0aGlzLmFkZFRvUG9vbChtb2RlLCBsYW5ndWFnZSwga2VybmVsUHJvbWlzZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZmlsbCB0aGUgcG9vbCBmb3IgYSBzcGVjaWZpYyBjb25maWd1cmF0aW9uIHdpdGggcGFyYWxsZWwgY3JlYXRpb25cbiAgICogQHBhcmFtIG1vZGUgS2VybmVsIG1vZGVcbiAgICogQHBhcmFtIGxhbmd1YWdlIEtlcm5lbCBsYW5ndWFnZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZWZpbGxQb29sKG1vZGU6IEtlcm5lbE1vZGUsIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5wb29sQ29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcG9vbEtleSA9IHRoaXMuZ2V0UG9vbEtleShtb2RlLCBsYW5ndWFnZSk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBwcmVmaWxsaW5nIHRoaXMgcG9vbCBrZXkgdG8gcHJldmVudCBkdXBsaWNhdGVzXG4gICAgaWYgKHRoaXMucHJlZmlsbGluZ0luUHJvZ3Jlc3MuZ2V0KHBvb2xLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFNldCBwcmVmaWxsaW5nIGZsYWdcbiAgICB0aGlzLnByZWZpbGxpbmdJblByb2dyZXNzLnNldChwb29sS2V5LCB0cnVlKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcG9vbFByb21pc2VzID0gdGhpcy5wb29sLmdldChwb29sS2V5KSB8fCBbXTtcbiAgICAgIGNvbnN0IG5lZWRlZCA9IHRoaXMucG9vbENvbmZpZy5wb29sU2l6ZSAtIHBvb2xQcm9taXNlcy5sZW5ndGg7XG4gICAgICBcbiAgICAgIGlmIChuZWVkZWQgPD0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhbGwgbmVlZGVkIGtlcm5lbCBwcm9taXNlcyBpbiBwYXJhbGxlbFxuICAgICAgY29uc3QgbmV3UHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuZWVkZWQgfSwgKCkgPT4gXG4gICAgICAgIHRoaXMuY3JlYXRlUG9vbEtlcm5lbFByb21pc2UobW9kZSwgbGFuZ3VhZ2UpXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBBZGQgYWxsIHByb21pc2VzIHRvIHRoZSBwb29sXG4gICAgICBmb3IgKGNvbnN0IGtlcm5lbFByb21pc2Ugb2YgbmV3UHJvbWlzZXMpIHtcbiAgICAgICAgdGhpcy5hZGRUb1Bvb2wobW9kZSwgbGFuZ3VhZ2UsIGtlcm5lbFByb21pc2UpO1xuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlZmlsbGluZyBwb29sIGZvciAke3Bvb2xLZXl9OmAsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gQWx3YXlzIGNsZWFyIHRoZSBwcmVmaWxsaW5nIGZsYWdcbiAgICAgIHRoaXMucHJlZmlsbGluZ0luUHJvZ3Jlc3Muc2V0KHBvb2xLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBrZXJuZWwgcHJvbWlzZSBmb3IgdGhlIHBvb2xcbiAgICogQHBhcmFtIG1vZGUgS2VybmVsIG1vZGVcbiAgICogQHBhcmFtIGxhbmd1YWdlIEtlcm5lbCBsYW5ndWFnZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBrZXJuZWwgaW5zdGFuY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlUG9vbEtlcm5lbFByb21pc2UobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlKTogUHJvbWlzZTxJS2VybmVsSW5zdGFuY2U+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qga2VybmVsID0gYXdhaXQgdGhpcy5jcmVhdGVQb29sS2VybmVsKG1vZGUsIGxhbmd1YWdlKTtcbiAgICAgICAgLy8gTWFyayBhcyB0YWtlbiBmcm9tIHBvb2xcbiAgICAgICAga2VybmVsLmlzRnJvbVBvb2wgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKGtlcm5lbCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjcmVhdGluZyBwb29sIGtlcm5lbCBmb3IgJHttb2RlfS0ke2xhbmd1YWdlfTpgLCBlcnJvcik7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEga2VybmVsIHNwZWNpZmljYWxseSBmb3IgdGhlIHBvb2xcbiAgICogQHBhcmFtIG1vZGUgS2VybmVsIG1vZGVcbiAgICogQHBhcmFtIGxhbmd1YWdlIEtlcm5lbCBsYW5ndWFnZVxuICAgKiBAcmV0dXJucyBLZXJuZWwgaW5zdGFuY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlUG9vbEtlcm5lbChtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UpOiBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT4ge1xuICAgIC8vIEdlbmVyYXRlIGEgdGVtcG9yYXJ5IElEIGZvciB0aGUgcG9vbCBrZXJuZWxcbiAgICBjb25zdCB0ZW1wSWQgPSBgcG9vbC0ke2NyeXB0by5yYW5kb21VVUlEKCl9YDtcbiAgICBcbiAgICAvLyBDcmVhdGUga2VybmVsIHdpdGggbWluaW1hbCBjb25maWd1cmF0aW9uXG4gICAgY29uc3Qgb3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zID0ge1xuICAgICAgbW9kZSxcbiAgICAgIGxhbmc6IGxhbmd1YWdlXG4gICAgfTtcbiAgICBcbiAgICAvLyBTdG9yZSBvcHRpb25zIHRlbXBvcmFyaWx5IC0gYnV0IGRvbid0IHN0b3JlIGluY29tcGxldGUgaW5zdGFuY2UgaW4ga2VybmVscyBtYXBcbiAgICAvLyBJbnN0ZWFkLCB3ZSdsbCBwYXNzIHRoZSBvcHRpb25zIGRpcmVjdGx5IHRvIHRoZSBjcmVhdGlvbiBtZXRob2RzXG4gICAgbGV0IGluc3RhbmNlOiBJS2VybmVsSW5zdGFuY2U7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGlmIChtb2RlID09PSBLZXJuZWxNb2RlLk1BSU5fVEhSRUFEKSB7XG4gICAgICAgIC8vIEZvciBtYWluIHRocmVhZCwgd2UgbmVlZCB0byB0ZW1wb3JhcmlseSBzdG9yZSB0aGUgaW5zdGFuY2UgZm9yIGNyZWF0ZU1haW5UaHJlYWRLZXJuZWxcbiAgICAgICAgY29uc3QgdGVtcEluc3RhbmNlID0ge1xuICAgICAgICAgIGlkOiB0ZW1wSWQsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIGxhbmd1YWdlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMua2VybmVscy5zZXQodGVtcElkLCB0ZW1wSW5zdGFuY2UgYXMgdW5rbm93biBhcyBJS2VybmVsSW5zdGFuY2UpO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbnN0YW5jZSA9IGF3YWl0IHRoaXMuY3JlYXRlTWFpblRocmVhZEtlcm5lbCh0ZW1wSWQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIC8vIEFsd2F5cyBjbGVhbiB1cCB0aGUgdGVtcG9yYXJ5IGluc3RhbmNlXG4gICAgICAgICAgdGhpcy5rZXJuZWxzLmRlbGV0ZSh0ZW1wSWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igd29ya2VyIG1vZGUsIHdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgc3RvcmUgdGhlIGluc3RhbmNlIGZvciBjcmVhdGVXb3JrZXJLZXJuZWxcbiAgICAgICAgY29uc3QgdGVtcEluc3RhbmNlID0ge1xuICAgICAgICAgIGlkOiB0ZW1wSWQsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIGxhbmd1YWdlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMua2VybmVscy5zZXQodGVtcElkLCB0ZW1wSW5zdGFuY2UgYXMgdW5rbm93biBhcyBJS2VybmVsSW5zdGFuY2UpO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbnN0YW5jZSA9IGF3YWl0IHRoaXMuY3JlYXRlV29ya2VyS2VybmVsKHRlbXBJZCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gQWx3YXlzIGNsZWFuIHVwIHRoZSB0ZW1wb3JhcnkgaW5zdGFuY2VcbiAgICAgICAgICB0aGlzLmtlcm5lbHMuZGVsZXRlKHRlbXBJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gRW5zdXJlIGNsZWFudXAgb24gYW55IGVycm9yXG4gICAgICB0aGlzLmtlcm5lbHMuZGVsZXRlKHRlbXBJZCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIFxuICAvKipcbiAgICogUHJlbG9hZCB0aGUga2VybmVsIHBvb2wgd2l0aCBjb25maWd1cmVkIGtlcm5lbCB0eXBlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwcmVsb2FkUG9vbCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMucG9vbENvbmZpZy5lbmFibGVkIHx8IHRoaXMuaXNQcmVsb2FkaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHRoaXMuaXNQcmVsb2FkaW5nID0gdHJ1ZTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gUHJlbG9hZCBrZXJuZWxzIGZvciBlYWNoIGNvbmZpZ3VyZWQgdHlwZVxuICAgICAgZm9yIChjb25zdCBjb25maWcgb2YgdGhpcy5wb29sQ29uZmlnLnByZWxvYWRDb25maWdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5yZWZpbGxQb29sKGNvbmZpZy5tb2RlLCBjb25maWcubGFuZ3VhZ2UpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByZWxvYWRpbmcgJHtjb25maWcubW9kZX0tJHtjb25maWcubGFuZ3VhZ2V9OmAsIGVycm9yKTtcbiAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIG90aGVyIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyBrZXJuZWwgcG9vbCBwcmVsb2FkaW5nOlwiLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaXNQcmVsb2FkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBrZXJuZWwgcmVxdWVzdCBjYW4gdXNlIHRoZSBwb29sXG4gICAqIEBwYXJhbSBvcHRpb25zIEtlcm5lbCBjcmVhdGlvbiBvcHRpb25zXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHJlcXVlc3QgY2FuIHVzZSBwb29sXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGNhblVzZVBvb2wob3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgLy8gRG9uJ3QgdXNlIHBvb2wgaWYgaXQncyBkaXNhYmxlZFxuICAgIGlmICghdGhpcy5wb29sQ29uZmlnLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gRG9uJ3QgdXNlIHBvb2wgaWYgY3VzdG9tIGZpbGVzeXN0ZW0gb3IgcGVybWlzc2lvbnMgYXJlIHNwZWNpZmllZFxuICAgIGlmIChvcHRpb25zLmZpbGVzeXN0ZW0gfHwgb3B0aW9ucy5kZW5vPy5wZXJtaXNzaW9ucykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBEb24ndCB1c2UgcG9vbCBpZiBjdXN0b20gdGltZW91dHMgYXJlIHNwZWNpZmllZFxuICAgIGlmIChvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0ICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZWFzc2lnbiBhIHBvb2wga2VybmVsIHdpdGggbmV3IElEIGFuZCBvcHRpb25zXG4gICAqIEBwYXJhbSBwb29sS2VybmVsIEtlcm5lbCBmcm9tIHBvb2xcbiAgICogQHBhcmFtIG5ld0lkIE5ldyBrZXJuZWwgSURcbiAgICogQHBhcmFtIG9wdGlvbnMgS2VybmVsIG9wdGlvbnNcbiAgICogQHJldHVybnMgVXBkYXRlZCBrZXJuZWwgaW5zdGFuY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcmVhc3NpZ25Qb29sS2VybmVsKFxuICAgIHBvb2xLZXJuZWw6IElLZXJuZWxJbnN0YW5jZSwgXG4gICAgbmV3SWQ6IHN0cmluZywgXG4gICAgb3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zXG4gICk6IElLZXJuZWxJbnN0YW5jZSB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9iamVjdCBleHBsaWNpdGx5IHRvIGF2b2lkIHNwcmVhZCBvcGVyYXRvciBpc3N1ZXNcbiAgICBjb25zdCB1cGRhdGVkSW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZSA9IHtcbiAgICAgIGlkOiBuZXdJZCxcbiAgICAgIGtlcm5lbDogcG9vbEtlcm5lbC5rZXJuZWwsXG4gICAgICBtb2RlOiBwb29sS2VybmVsLm1vZGUsXG4gICAgICBsYW5ndWFnZTogcG9vbEtlcm5lbC5sYW5ndWFnZSxcbiAgICAgIHdvcmtlcjogcG9vbEtlcm5lbC53b3JrZXIsXG4gICAgICBjcmVhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksIC8vIFVwZGF0ZSBjcmVhdGlvbiB0aW1lXG4gICAgICBvcHRpb25zOiB7IC4uLnBvb2xLZXJuZWwub3B0aW9ucywgLi4ub3B0aW9ucyB9LFxuICAgICAgaXNGcm9tUG9vbDogdHJ1ZSxcbiAgICAgIGRlc3Ryb3k6IHBvb2xLZXJuZWwuZGVzdHJveSAvLyBQcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgZGVzdHJveSBmdW5jdGlvblxuICAgIH07XG4gICAgXG4gICAgLy8gVmVyaWZ5IHRoZSBkZXN0cm95IGZ1bmN0aW9uIGlzIHByb3Blcmx5IHNldFxuICAgIGlmICh0eXBlb2YgdXBkYXRlZEluc3RhbmNlLmRlc3Ryb3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwcmVzZXJ2ZSBkZXN0cm95IGZ1bmN0aW9uIGR1cmluZyBwb29sIGtlcm5lbCByZWFzc2lnbm1lbnQnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3Bvb2xLZXJuZWwuZGVzdHJveSB0eXBlOicsIHR5cGVvZiBwb29sS2VybmVsLmRlc3Ryb3kpO1xuICAgICAgY29uc29sZS5lcnJvcigndXBkYXRlZEluc3RhbmNlLmRlc3Ryb3kgdHlwZTonLCB0eXBlb2YgdXBkYXRlZEluc3RhbmNlLmRlc3Ryb3kpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcHJlc2VydmUgZGVzdHJveSBmdW5jdGlvbiBkdXJpbmcgcG9vbCBrZXJuZWwgcmVhc3NpZ25tZW50YCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB1cGRhdGVkSW5zdGFuY2U7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgcG9vbCBzdGF0aXN0aWNzIGZvciBkZWJ1Z2dpbmcvbW9uaXRvcmluZ1xuICAgKiBAcmV0dXJucyBQb29sIHN0YXRpc3RpY3NcbiAgICovXG4gIHB1YmxpYyBnZXRQb29sU3RhdHMoKTogUmVjb3JkPHN0cmluZywgeyBhdmFpbGFibGU6IG51bWJlcjsgdG90YWw6IG51bWJlciB9PiB7XG4gICAgY29uc3Qgc3RhdHM6IFJlY29yZDxzdHJpbmcsIHsgYXZhaWxhYmxlOiBudW1iZXI7IHRvdGFsOiBudW1iZXIgfT4gPSB7fTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IFtwb29sS2V5LCBwcm9taXNlc10gb2YgdGhpcy5wb29sLmVudHJpZXMoKSkge1xuICAgICAgc3RhdHNbcG9vbEtleV0gPSB7XG4gICAgICAgIGF2YWlsYWJsZTogcHJvbWlzZXMubGVuZ3RoLFxuICAgICAgICB0b3RhbDogdGhpcy5wb29sQ29uZmlnLnBvb2xTaXplXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgcG9vbCBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm5zIFBvb2wgY29uZmlndXJhdGlvbiBkZXRhaWxzXG4gICAqL1xuICBwdWJsaWMgZ2V0UG9vbENvbmZpZygpOiB7XG4gICAgZW5hYmxlZDogYm9vbGVhbjtcbiAgICBwb29sU2l6ZTogbnVtYmVyO1xuICAgIGF1dG9SZWZpbGw6IGJvb2xlYW47XG4gICAgcHJlbG9hZENvbmZpZ3M6IEFycmF5PHtcbiAgICAgIG1vZGU6IEtlcm5lbE1vZGU7XG4gICAgICBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gICAgfT47XG4gICAgaXNQcmVsb2FkaW5nOiBib29sZWFuO1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgZW5hYmxlZDogdGhpcy5wb29sQ29uZmlnLmVuYWJsZWQsXG4gICAgICBwb29sU2l6ZTogdGhpcy5wb29sQ29uZmlnLnBvb2xTaXplLFxuICAgICAgYXV0b1JlZmlsbDogdGhpcy5wb29sQ29uZmlnLmF1dG9SZWZpbGwsXG4gICAgICBwcmVsb2FkQ29uZmlnczogWy4uLnRoaXMucG9vbENvbmZpZy5wcmVsb2FkQ29uZmlnc10sIC8vIFJldHVybiBhIGNvcHkgdG8gcHJldmVudCBtb2RpZmljYXRpb25cbiAgICAgIGlzUHJlbG9hZGluZzogdGhpcy5pc1ByZWxvYWRpbmdcbiAgICB9O1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHdvcmtlciBVUkwgY29uZmlndXJhdGlvblxuICAgKiBAcmV0dXJucyBUaGUgd29ya2VyIFVSTCBvciB1bmRlZmluZWQgaWYgdXNpbmcgYXV0by1kZXRlY3Rpb25cbiAgICovXG4gIHB1YmxpYyBnZXRXb3JrZXJVcmwoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy53b3JrZXJVcmw7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZXQgYSBjdXN0b20gd29ya2VyIFVSTCBmb3Iga2VybmVsIHdvcmtlcnNcbiAgICogQHBhcmFtIHVybCBUaGUgVVJMIHRvIHRoZSBrZXJuZWwud29ya2VyLmpzIGZpbGVcbiAgICogQGV4YW1wbGVcbiAgICogLy8gRm9yIENETiB1c2FnZTpcbiAgICogbWFuYWdlci5zZXRXb3JrZXJVcmwoJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vd2ViLXB5dGhvbi1rZXJuZWxAbGF0ZXN0L2Rpc3Qva2VybmVsLndvcmtlci5qcycpO1xuICAgKiAvLyBGb3IgbG9jYWwgZGV2ZWxvcG1lbnQ6XG4gICAqIG1hbmFnZXIuc2V0V29ya2VyVXJsKCcvZGlzdC9rZXJuZWwud29ya2VyLmpzJyk7XG4gICAqL1xuICBwdWJsaWMgc2V0V29ya2VyVXJsKHVybDogc3RyaW5nIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgdGhpcy53b3JrZXJVcmwgPSB1cmw7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcga2VybmVsIGluc3RhbmNlXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBrZXJuZWxcbiAgICogQHBhcmFtIG9wdGlvbnMuaWQgT3B0aW9uYWwgY3VzdG9tIElEIGZvciB0aGUga2VybmVsXG4gICAqIEBwYXJhbSBvcHRpb25zLm1vZGUgT3B0aW9uYWwga2VybmVsIG1vZGUgKG1haW5fdGhyZWFkIG9yIHdvcmtlcilcbiAgICogQHBhcmFtIG9wdGlvbnMubGFuZyBPcHRpb25hbCBrZXJuZWwgbGFuZ3VhZ2UgKHB5dGhvbiBvciB0eXBlc2NyaXB0KVxuICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lc3BhY2UgT3B0aW9uYWwgbmFtZXNwYWNlIHByZWZpeCBmb3IgdGhlIGtlcm5lbCBJRFxuICAgKiBAcGFyYW0gb3B0aW9ucy5kZW5vLnBlcm1pc3Npb25zIE9wdGlvbmFsIERlbm8gcGVybWlzc2lvbnMgZm9yIHdvcmtlciBtb2RlXG4gICAqIEBwYXJhbSBvcHRpb25zLmZpbGVzeXN0ZW0gT3B0aW9uYWwgZmlsZXN5c3RlbSBtb3VudGluZyBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0IE9wdGlvbmFsIHRpbWVvdXQgaW4gbXMgYWZ0ZXIgd2hpY2ggYW4gaW5hY3RpdmUga2VybmVsIHdpbGwgYmUgc2h1dCBkb3duXG4gICAqIEBwYXJhbSBvcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgT3B0aW9uYWwgbWF4aW11bSB0aW1lIGluIG1zIGFuIGV4ZWN1dGlvbiBjYW4gcnVuIGJlZm9yZSBjb25zaWRlcmVkIHN0dWNrXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBrZXJuZWwgaW5zdGFuY2UgSURcbiAgICovXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVLZXJuZWwob3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zID0ge30pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIC8vIG1ha2Ugc3VyZSB0aGUgb3B0aW9ucy5pZCBkb2VzIG5vdCBjb250YWluIGNvbG9ucyBiZWNhdXNlIGl0IHdpbGwgYmUgdXNlZCBhcyBhIG5hbWVzcGFjZSBwcmVmaXhcbiAgICBpZiAob3B0aW9ucy5pZCAmJiBvcHRpb25zLmlkLmluY2x1ZGVzKCc6JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignS2VybmVsIElEIGNhbm5vdCBjb250YWluIGNvbG9ucycpO1xuICAgIH1cbiAgICBjb25zdCBiYXNlSWQgPSBvcHRpb25zLmlkIHx8IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCBLZXJuZWxNb2RlLldPUktFUjtcbiAgICBjb25zdCBsYW5ndWFnZSA9IG9wdGlvbnMubGFuZyB8fCBLZXJuZWxMYW5ndWFnZS5QWVRIT047XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJlcXVlc3RlZCBrZXJuZWwgdHlwZSBpcyBhbGxvd2VkXG4gICAgaWYgKCF0aGlzLmlzS2VybmVsVHlwZUFsbG93ZWQobW9kZSwgbGFuZ3VhZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCB0eXBlICR7bW9kZX0tJHtsYW5ndWFnZX0gaXMgbm90IGFsbG93ZWQuIEFsbG93ZWQgdHlwZXM6ICR7XG4gICAgICAgIHRoaXMuYWxsb3dlZEtlcm5lbFR5cGVzLm1hcCh0ID0+IGAke3QubW9kZX0tJHt0Lmxhbmd1YWdlfWApLmpvaW4oJywgJylcbiAgICAgIH1gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQXBwbHkgbmFtZXNwYWNlIHByZWZpeCBpZiBwcm92aWRlZFxuICAgIGNvbnN0IGlkID0gb3B0aW9ucy5uYW1lc3BhY2UgPyBgJHtvcHRpb25zLm5hbWVzcGFjZX06JHtiYXNlSWR9YCA6IGJhc2VJZDtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBrZXJuZWwgd2l0aCB0aGlzIElEIGFscmVhZHkgZXhpc3RzXG4gICAgaWYgKHRoaXMua2VybmVscy5oYXMoaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCB3aXRoIElEICR7aWR9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSB0byBnZXQgZnJvbSBwb29sIGlmIHBvc3NpYmxlXG4gICAgaWYgKHRoaXMuY2FuVXNlUG9vbChvcHRpb25zKSkge1xuICAgICAgY29uc3QgcG9vbEtleSA9IHRoaXMuZ2V0UG9vbEtleShtb2RlLCBsYW5ndWFnZSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMga2VybmVsIHR5cGUgaXMgY29uZmlndXJlZCBmb3IgcG9vbGluZ1xuICAgICAgY29uc3QgaXNQb29sZWRUeXBlID0gdGhpcy5wb29sQ29uZmlnLnByZWxvYWRDb25maWdzLnNvbWUoY29uZmlnID0+IFxuICAgICAgICBjb25maWcubW9kZSA9PT0gbW9kZSAmJiBjb25maWcubGFuZ3VhZ2UgPT09IGxhbmd1YWdlXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAoaXNQb29sZWRUeXBlKSB7XG4gICAgICAgIC8vIEZpcnN0IHRyeSB0byBnZXQgZnJvbSBleGlzdGluZyBwb29sXG4gICAgICAgIGxldCBwb29sS2VybmVsUHJvbWlzZSA9IHRoaXMuZ2V0RnJvbVBvb2wobW9kZSwgbGFuZ3VhZ2UpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHBvb2xLZXJuZWxQcm9taXNlKSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0dXBQb29sS2VybmVsRnJvbVByb21pc2UocG9vbEtlcm5lbFByb21pc2UsIGlkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUG9vbCBpcyBlbXB0eSwgYnV0IHRoaXMgdHlwZSBzaG91bGQgYmUgcG9vbGVkXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwcm9taXNlIGltbWVkaWF0ZWx5IGFuZCB0cmlnZ2VyIGJhY2tncm91bmQgcmVmaWxsXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGtlcm5lbCBwcm9taXNlIHNwZWNpZmljYWxseSBmb3IgdGhpcyByZXF1ZXN0XG4gICAgICAgICAgY29uc3QgbmV3S2VybmVsUHJvbWlzZSA9IHRoaXMuY3JlYXRlUG9vbEtlcm5lbFByb21pc2UobW9kZSwgbGFuZ3VhZ2UpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyaWdnZXIgYmFja2dyb3VuZCByZWZpbGwgdG8gcmVwbGVuaXNoIHRoZSBwb29sIGZvciBmdXR1cmUgcmVxdWVzdHNcbiAgICAgICAgICBpZiAodGhpcy5wb29sQ29uZmlnLmF1dG9SZWZpbGwpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlZmlsbFBvb2wobW9kZSwgbGFuZ3VhZ2UpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZWZpbGxpbmcgZXhoYXVzdGVkIHBvb2wgZm9yICR7cG9vbEtleX06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXR1cFBvb2xLZXJuZWxGcm9tUHJvbWlzZShuZXdLZXJuZWxQcm9taXNlLCBpZCwgb3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBrZXJuZWwgcHJvbWlzZSBmb3IgZXhoYXVzdGVkIHBvb2w6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgLy8gRmFsbCB0aHJvdWdoIHRvIG9uLWRlbWFuZCBjcmVhdGlvbiBhcyBsYXN0IHJlc29ydFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGtlcm5lbCB0eXBlIGlzIG5vdCBjb25maWd1cmVkIGZvciBwb29saW5nLCB0cnkgdG8gZ2V0IGZyb20gcG9vbCBhbnl3YXlcbiAgICAgICAgLy8gaW4gY2FzZSB0aGVyZSBhcmUga2VybmVscyBhdmFpbGFibGUgZnJvbSBwcmV2aW91cyBjb25maWd1cmF0aW9uc1xuICAgICAgICBjb25zdCBwb29sS2VybmVsUHJvbWlzZSA9IHRoaXMuZ2V0RnJvbVBvb2wobW9kZSwgbGFuZ3VhZ2UpO1xuICAgICAgICBpZiAocG9vbEtlcm5lbFByb21pc2UpIHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXR1cFBvb2xLZXJuZWxGcm9tUHJvbWlzZShwb29sS2VybmVsUHJvbWlzZSwgaWQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGwgYmFjayB0byBjcmVhdGluZyBhIG5ldyBrZXJuZWwgb24tZGVtYW5kXG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlT25EZW1hbmRLZXJuZWwoaWQsIG1vZGUsIGxhbmd1YWdlLCBvcHRpb25zKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNldHVwIGEgcG9vbCBrZXJuZWwgZnJvbSBhIHByb21pc2Ugd2l0aCBuZXcgSUQgYW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHBvb2xLZXJuZWxQcm9taXNlIEtlcm5lbCBwcm9taXNlIGZyb20gcG9vbFxuICAgKiBAcGFyYW0gaWQgTmV3IGtlcm5lbCBJRFxuICAgKiBAcGFyYW0gb3B0aW9ucyBLZXJuZWwgb3B0aW9uc1xuICAgKiBAcmV0dXJucyBLZXJuZWwgSUQgKHJldHVybmVkIGFmdGVyIGtlcm5lbCBpcyByZWFkeSlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc2V0dXBQb29sS2VybmVsRnJvbVByb21pc2UoXG4gICAgcG9vbEtlcm5lbFByb21pc2U6IFByb21pc2U8SUtlcm5lbEluc3RhbmNlPiwgXG4gICAgaWQ6IHN0cmluZywgXG4gICAgb3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBwb29sIGtlcm5lbCB0byBiZSByZWFkeVxuICAgICAgY29uc3QgcG9vbEtlcm5lbCA9IGF3YWl0IHBvb2xLZXJuZWxQcm9taXNlO1xuICAgICAgXG4gICAgICAvLyBSZWFzc2lnbiB0aGUgcG9vbCBrZXJuZWwgd2l0aCB0aGUgbmV3IElEIGFuZCBvcHRpb25zXG4gICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMucmVhc3NpZ25Qb29sS2VybmVsKHBvb2xLZXJuZWwsIGlkLCBvcHRpb25zKTtcbiAgICAgIFxuICAgICAgLy8gRm9yIHdvcmtlciBrZXJuZWxzLCB3ZSBuZWVkIHRvIHJlY3JlYXRlIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIG5ldyBJRFxuICAgICAgaWYgKGluc3RhbmNlLm1vZGUgPT09IEtlcm5lbE1vZGUuV09SS0VSICYmIGluc3RhbmNlLndvcmtlcikge1xuICAgICAgICAvLyBHZXQgdGhlIHdvcmtlciBhbmQgY3JlYXRlIG5ldyBtZXNzYWdlIGNoYW5uZWxcbiAgICAgICAgY29uc3Qgd29ya2VyID0gaW5zdGFuY2Uud29ya2VyO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG1lc3NhZ2UgY2hhbm5lbCBmb3IgdGhlIHJlYXNzaWduZWQga2VybmVsXG4gICAgICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNlbmQgdGhlIG5ldyBldmVudCBwb3J0IHRvIHRoZSB3b3JrZXJcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICB0eXBlOiBcIlNFVF9FVkVOVF9QT1JUXCIsXG4gICAgICAgICAgcG9ydDogcG9ydDJcbiAgICAgICAgfSwgW3BvcnQyXSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgZXZlbnQgaGFuZGxlciB3aXRoIHRoZSBjb3JyZWN0IGtlcm5lbCBJRFxuICAgICAgICBjb25zdCBldmVudEhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEudHlwZSkge1xuICAgICAgICAgICAgLy8gRW1pdCB0aGUgZXZlbnQgZnJvbSB0aGUgbWFuYWdlciB3aXRoIGtlcm5lbCBJRFxuICAgICAgICAgICAgLy8gVGhpcyBzdHJ1Y3R1cmUgbWF0Y2hlcyB0aGUgc2V0dXBFdmVudEZvcndhcmRpbmcgbWV0aG9kIGZvciBtYWluIHRocmVhZCBrZXJuZWxzXG4gICAgICAgICAgICBzdXBlci5lbWl0KGV2ZW50LmRhdGEudHlwZSwge1xuICAgICAgICAgICAgICBrZXJuZWxJZDogaWQsXG4gICAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEuZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gTGlzdGVuIGZvciBldmVudHMgZnJvbSB0aGUgd29ya2VyIHdpdGggdGhlIG5ldyBoYW5kbGVyXG4gICAgICAgIHBvcnQxLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudEhhbmRsZXIpO1xuICAgICAgICBwb3J0MS5zdGFydCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBkZXN0cm95IGZ1bmN0aW9uIHRvIGNsZWFuIHVwIHRoZSBuZXcgZXZlbnQgaGFuZGxlclxuICAgICAgICBjb25zdCBvcmlnaW5hbERlc3Ryb3kgPSBpbnN0YW5jZS5kZXN0cm95O1xuICAgICAgICBpbnN0YW5jZS5kZXN0cm95ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudEhhbmRsZXIpO1xuICAgICAgICAgIHBvcnQxLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsRGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTdG9yZSB0aGUga2VybmVsIGluc3RhbmNlXG4gICAgICB0aGlzLmtlcm5lbHMuc2V0KGlkLCBpbnN0YW5jZSk7XG4gICAgICBcbiAgICAgIC8vIEZvcndhcmQga2VybmVsIGV2ZW50cyB0byBtYW5hZ2VyIChmb3IgbWFpbiB0aHJlYWQga2VybmVscylcbiAgICAgIHRoaXMuc2V0dXBFdmVudEZvcndhcmRpbmcoaW5zdGFuY2UpO1xuICAgICAgXG4gICAgICAvLyBJbml0aWFsaXplIGFjdGl2aXR5IHRyYWNraW5nXG4gICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGlkKTtcbiAgICAgIFxuICAgICAgLy8gU2V0IHVwIGluYWN0aXZpdHkgdGltZW91dCBpZiBzcGVjaWZpZWQgYW5kIGdyZWF0ZXIgdGhhbiAwXG4gICAgICBpZiAob3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCAmJiBvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0ID4gMCkge1xuICAgICAgICB0aGlzLnNldHVwSW5hY3Rpdml0eVRpbWVvdXQoaWQsIG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZXR1cCBoYW5kbGVycyBmb3Igc3RhbGxlZCBleGVjdXRpb25zIGlmIG1heEV4ZWN1dGlvblRpbWUgaXMgc3BlY2lmaWVkXG4gICAgICBpZiAob3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lICYmIG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSA+IDApIHtcbiAgICAgICAgdGhpcy5zZXR1cFN0YWxsZWRFeGVjdXRpb25IYW5kbGVyKGlkKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGlkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzZXR0aW5nIHVwIHBvb2wga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIC8vIEVtaXQgYW4gZXJyb3IgZXZlbnQgZm9yIHRoaXMga2VybmVsXG4gICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCB7XG4gICAgICAgIGtlcm5lbElkOiBpZCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGVuYW1lOiBcIktlcm5lbFNldHVwRXJyb3JcIixcbiAgICAgICAgICBldmFsdWU6IGBGYWlsZWQgdG8gc2V0dXAga2VybmVsOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gLFxuICAgICAgICAgIHRyYWNlYmFjazogW2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAoZXJyb3Iuc3RhY2sgfHwgZXJyb3IubWVzc2FnZSkgOiBTdHJpbmcoZXJyb3IpXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yOyAvLyBSZS10aHJvdyB0byBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgYSBwb29sIGtlcm5lbCB3aXRoIG5ldyBJRCBhbmQgb3B0aW9ucyAoZm9yIGFscmVhZHkgcmVzb2x2ZWQga2VybmVscylcbiAgICogQHBhcmFtIHBvb2xLZXJuZWwgS2VybmVsIGZyb20gcG9vbFxuICAgKiBAcGFyYW0gaWQgTmV3IGtlcm5lbCBJRFxuICAgKiBAcGFyYW0gb3B0aW9ucyBLZXJuZWwgb3B0aW9uc1xuICAgKiBAcmV0dXJucyBLZXJuZWwgSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc2V0dXBQb29sS2VybmVsKFxuICAgIHBvb2xLZXJuZWw6IElLZXJuZWxJbnN0YW5jZSwgXG4gICAgaWQ6IHN0cmluZywgXG4gICAgb3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zXG4gICk6IHN0cmluZyB7XG4gICAgLy8gUmVhc3NpZ24gdGhlIHBvb2wga2VybmVsIHdpdGggdGhlIG5ldyBJRCBhbmQgb3B0aW9uc1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5yZWFzc2lnblBvb2xLZXJuZWwocG9vbEtlcm5lbCwgaWQsIG9wdGlvbnMpO1xuICAgIFxuICAgIC8vIEZvciB3b3JrZXIga2VybmVscywgd2UgbmVlZCB0byByZWNyZWF0ZSB0aGUgZXZlbnQgaGFuZGxlciB3aXRoIHRoZSBuZXcgSURcbiAgICBpZiAoaW5zdGFuY2UubW9kZSA9PT0gS2VybmVsTW9kZS5XT1JLRVIgJiYgaW5zdGFuY2Uud29ya2VyKSB7XG4gICAgICAvLyBHZXQgdGhlIHdvcmtlciBhbmQgY3JlYXRlIG5ldyBtZXNzYWdlIGNoYW5uZWxcbiAgICAgIGNvbnN0IHdvcmtlciA9IGluc3RhbmNlLndvcmtlcjtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IG1lc3NhZ2UgY2hhbm5lbCBmb3IgdGhlIHJlYXNzaWduZWQga2VybmVsXG4gICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICBcbiAgICAgIC8vIFNlbmQgdGhlIG5ldyBldmVudCBwb3J0IHRvIHRoZSB3b3JrZXJcbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiU0VUX0VWRU5UX1BPUlRcIixcbiAgICAgICAgcG9ydDogcG9ydDJcbiAgICAgIH0sIFtwb3J0Ml0pO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgZXZlbnQgaGFuZGxlciB3aXRoIHRoZSBjb3JyZWN0IGtlcm5lbCBJRFxuICAgICAgY29uc3QgZXZlbnRIYW5kbGVyID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS50eXBlKSB7XG4gICAgICAgICAgLy8gRW1pdCB0aGUgZXZlbnQgZnJvbSB0aGUgbWFuYWdlciB3aXRoIGtlcm5lbCBJRFxuICAgICAgICAgIC8vIFRoaXMgc3RydWN0dXJlIG1hdGNoZXMgdGhlIHNldHVwRXZlbnRGb3J3YXJkaW5nIG1ldGhvZCBmb3IgbWFpbiB0aHJlYWQga2VybmVsc1xuICAgICAgICAgIHN1cGVyLmVtaXQoZXZlbnQuZGF0YS50eXBlLCB7XG4gICAgICAgICAgICBrZXJuZWxJZDogaWQsXG4gICAgICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gTGlzdGVuIGZvciBldmVudHMgZnJvbSB0aGUgd29ya2VyIHdpdGggdGhlIG5ldyBoYW5kbGVyXG4gICAgICBwb3J0MS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRIYW5kbGVyKTtcbiAgICAgIHBvcnQxLnN0YXJ0KCk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGVzdHJveSBmdW5jdGlvbiB0byBjbGVhbiB1cCB0aGUgbmV3IGV2ZW50IGhhbmRsZXJcbiAgICAgIGNvbnN0IG9yaWdpbmFsRGVzdHJveSA9IGluc3RhbmNlLmRlc3Ryb3k7XG4gICAgICBpbnN0YW5jZS5kZXN0cm95ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBwb3J0MS5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgcG9ydDEuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsRGVzdHJveSgpO1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RvcmUgdGhlIGtlcm5lbCBpbnN0YW5jZVxuICAgIHRoaXMua2VybmVscy5zZXQoaWQsIGluc3RhbmNlKTtcbiAgICBcbiAgICAvLyBGb3J3YXJkIGtlcm5lbCBldmVudHMgdG8gbWFuYWdlciAoZm9yIG1haW4gdGhyZWFkIGtlcm5lbHMpXG4gICAgdGhpcy5zZXR1cEV2ZW50Rm9yd2FyZGluZyhpbnN0YW5jZSk7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBhY3Rpdml0eSB0cmFja2luZ1xuICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoaWQpO1xuICAgIFxuICAgIC8vIFNldCB1cCBpbmFjdGl2aXR5IHRpbWVvdXQgaWYgc3BlY2lmaWVkIGFuZCBncmVhdGVyIHRoYW4gMFxuICAgIGlmIChvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0ICYmIG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgPiAwKSB7XG4gICAgICB0aGlzLnNldHVwSW5hY3Rpdml0eVRpbWVvdXQoaWQsIG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTZXR1cCBoYW5kbGVycyBmb3Igc3RhbGxlZCBleGVjdXRpb25zIGlmIG1heEV4ZWN1dGlvblRpbWUgaXMgc3BlY2lmaWVkXG4gICAgaWYgKG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSAmJiBvcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgPiAwKSB7XG4gICAgICB0aGlzLnNldHVwU3RhbGxlZEV4ZWN1dGlvbkhhbmRsZXIoaWQpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBrZXJuZWwgb24tZGVtYW5kIChub3QgZnJvbSBwb29sKVxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHBhcmFtIG9wdGlvbnMgS2VybmVsIG9wdGlvbnNcbiAgICogQHJldHVybnMgS2VybmVsIElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNyZWF0ZU9uRGVtYW5kS2VybmVsKFxuICAgIGlkOiBzdHJpbmcsIFxuICAgIG1vZGU6IEtlcm5lbE1vZGUsIFxuICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSwgXG4gICAgb3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgLy8gU3RvcmUgb3B0aW9ucyB0ZW1wb3JhcmlseSB0byBiZSB1c2VkIGluIGNyZWF0ZVdvcmtlcktlcm5lbFxuICAgIGNvbnN0IHRlbXBJbnN0YW5jZSA9IHtcbiAgICAgIGlkLFxuICAgICAgb3B0aW9uczogeyAuLi5vcHRpb25zLCBsYW5nOiBsYW5ndWFnZSB9LFxuICAgICAgbW9kZSxcbiAgICAgIGxhbmd1YWdlXG4gICAgfTtcbiAgICB0aGlzLmtlcm5lbHMuc2V0KGlkLCB0ZW1wSW5zdGFuY2UgYXMgdW5rbm93biBhcyBJS2VybmVsSW5zdGFuY2UpO1xuICAgIFxuICAgIC8vIENyZWF0ZSB0aGUgYXBwcm9wcmlhdGUga2VybmVsIGluc3RhbmNlXG4gICAgbGV0IGluc3RhbmNlOiBJS2VybmVsSW5zdGFuY2U7XG4gICAgXG4gICAgaWYgKG1vZGUgPT09IEtlcm5lbE1vZGUuTUFJTl9USFJFQUQpIHtcbiAgICAgIGluc3RhbmNlID0gYXdhaXQgdGhpcy5jcmVhdGVNYWluVGhyZWFkS2VybmVsKGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UgPSBhd2FpdCB0aGlzLmNyZWF0ZVdvcmtlcktlcm5lbChpZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0b3JlIHRoZSBrZXJuZWwgaW5zdGFuY2VcbiAgICB0aGlzLmtlcm5lbHMuc2V0KGlkLCBpbnN0YW5jZSk7XG4gICAgXG4gICAgLy8gRm9yd2FyZCBrZXJuZWwgZXZlbnRzIHRvIG1hbmFnZXJcbiAgICB0aGlzLnNldHVwRXZlbnRGb3J3YXJkaW5nKGluc3RhbmNlKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIGFjdGl2aXR5IHRyYWNraW5nXG4gICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShpZCk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGluYWN0aXZpdHkgdGltZW91dCBpZiBzcGVjaWZpZWQgYW5kIGdyZWF0ZXIgdGhhbiAwXG4gICAgaWYgKG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgJiYgb3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCA+IDApIHtcbiAgICAgIHRoaXMuc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZCwgb3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFNldHVwIGhhbmRsZXJzIGZvciBzdGFsbGVkIGV4ZWN1dGlvbnMgaWYgbWF4RXhlY3V0aW9uVGltZSBpcyBzcGVjaWZpZWRcbiAgICBpZiAob3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lICYmIG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSA+IDApIHtcbiAgICAgIHRoaXMuc2V0dXBTdGFsbGVkRXhlY3V0aW9uSGFuZGxlcihpZCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBpZDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGtlcm5lbCBpbnN0YW5jZSBydW5uaW5nIGluIHRoZSBtYWluIHRocmVhZFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIEtlcm5lbCBpbnN0YW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVNYWluVGhyZWFkS2VybmVsKGlkOiBzdHJpbmcpOiBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT4ge1xuICAgIC8vIEdldCBvcHRpb25zIGZyb20gdGhlIHRlbXBvcmFyeSBpbnN0YW5jZVxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKT8ub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBsYW5ndWFnZSA9IG9wdGlvbnMubGFuZyB8fCBLZXJuZWxMYW5ndWFnZS5QWVRIT047XG4gICAgXG4gICAgLy8gQ3JlYXRlIHRoZSBQeXRob24ga2VybmVsXG4gICAgY29uc3Qga2VybmVsID0gbmV3IEtlcm5lbCgpO1xuICAgIFxuICAgIC8vIENyZWF0ZSB0aGUga2VybmVsIGluc3RhbmNlXG4gICAgY29uc3QgaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZSA9IHtcbiAgICAgIGlkLFxuICAgICAga2VybmVsLFxuICAgICAgbW9kZTogS2VybmVsTW9kZS5NQUlOX1RIUkVBRCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgY3JlYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGRlc3Ryb3k6IGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gTm90aGluZyBzcGVjaWFsIHRvIGRvIGZvciBtYWluIHRocmVhZCBrZXJuZWxcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUga2VybmVsIHdpdGggZmlsZXN5c3RlbSBvcHRpb25zXG4gICAgY29uc3Qga2VybmVsT3B0aW9uczogSUtlcm5lbE9wdGlvbnMgPSB7fTtcblxuICAgIC8vIEFkZCBmaWxlc3lzdGVtIG9wdGlvbnMgaWYgcHJvdmlkZWRcbiAgICBpZiAob3B0aW9ucy5maWxlc3lzdGVtKSB7XG4gICAgICBrZXJuZWxPcHRpb25zLmZpbGVzeXN0ZW0gPSBvcHRpb25zLmZpbGVzeXN0ZW07XG4gICAgfVxuXG4gICAgLy8gQWRkIGVudmlyb25tZW50IHZhcmlhYmxlcyBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zLmVudikge1xuICAgICAga2VybmVsT3B0aW9ucy5lbnYgPSBvcHRpb25zLmVudjtcbiAgICB9XG5cbiAgICAvLyBBZGQgbG9ja0ZpbGVVUkwgaWYgcHJvdmlkZWRcbiAgICBpZiAob3B0aW9ucy5sb2NrRmlsZVVSTCkge1xuICAgICAga2VybmVsT3B0aW9ucy5sb2NrRmlsZVVSTCA9IG9wdGlvbnMubG9ja0ZpbGVVUkw7XG4gICAgfVxuXG4gICAgLy8gQWRkIGF1dG9TeW5jRnMgaWYgcHJvdmlkZWRcbiAgICBpZiAob3B0aW9ucy5hdXRvU3luY0ZzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtlcm5lbE9wdGlvbnMuYXV0b1N5bmNGcyA9IG9wdGlvbnMuYXV0b1N5bmNGcztcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBrZXJuZWxcbiAgICBhd2FpdCBrZXJuZWwuaW5pdGlhbGl6ZShrZXJuZWxPcHRpb25zKTtcbiAgICBcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBrZXJuZWwgaW5zdGFuY2UgcnVubmluZyBpbiBhIHdvcmtlclxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIEtlcm5lbCBpbnN0YW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVXb3JrZXJLZXJuZWwoaWQ6IHN0cmluZyk6IFByb21pc2U8SUtlcm5lbEluc3RhbmNlPiB7XG4gICAgLy8gR2V0IHBlcm1pc3Npb25zIGZyb20gb3B0aW9ucyB3aGVuIGNyZWF0aW5nIHRoZSBrZXJuZWxcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5rZXJuZWxzLmdldChpZCk/Lm9wdGlvbnMgfHwge307XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBvcHRpb25zLmxhbmcgfHwgS2VybmVsTGFuZ3VhZ2UuUFlUSE9OO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIG5ldyB3b3JrZXIgd2l0aCBvcHRpb25hbCBwZXJtaXNzaW9uc1xuICAgIGNvbnN0IHdvcmtlck9wdGlvbnM6IFdvcmtlck9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiBcIm1vZHVsZVwiLFxuICAgIH07XG4gICAgXG4gICAgLy8gSWYgRGVubyBwZXJtaXNzaW9ucyBhcmUgcHJvdmlkZWQsIHVzZSB0aGVtLlxuICAgIC8vIE90aGVyd2lzZSBkb24ndCBzcGVjaWZ5IERlbm8gcGVybWlzc2lvbnMgYXQgYWxsIHRvIGluaGVyaXQgZnJvbSBob3N0IHNjcmlwdFxuICAgIGlmIChvcHRpb25zLmRlbm8/LnBlcm1pc3Npb25zKSB7XG4gICAgICB3b3JrZXJPcHRpb25zLmRlbm8gPSB7XG4gICAgICAgIHBlcm1pc3Npb25zOiBvcHRpb25zLmRlbm8ucGVybWlzc2lvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIERldGVybWluZSB0aGUgd29ya2VyIFVSTCBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnRcbiAgICBjb25zdCB3b3JrZXJVcmwgPSB0aGlzLnJlc29sdmVXb3JrZXJVcmwoKTtcbiAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVybCwgeyB0eXBlOiAnY2xhc3NpYycgfSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgbWVzc2FnZSBjaGFubmVsIGZvciBldmVudHNcbiAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBrZXJuZWwgaXMgaW5pdGlhbGl6ZWRcbiAgICBjb25zdCBpbml0UHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGluaXRIYW5kbGVyID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IFwiS0VSTkVMX0lOSVRJQUxJWkVEXCIpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5kYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBpbml0SGFuZGxlcik7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBpbml0SGFuZGxlcik7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiS2VybmVsIGluaXRpYWxpemF0aW9uIGZhaWxlZFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcG9ydDEuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGluaXRIYW5kbGVyKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTZW5kIHRoZSBwb3J0IHRvIHRoZSB3b3JrZXJcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyB0eXBlOiBcIlNFVF9FVkVOVF9QT1JUXCIsIHBvcnQ6IHBvcnQyIH0sIFtwb3J0Ml0pO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHByb3h5IHRvIHRoZSB3b3JrZXIgdXNpbmcgQ29tbGlua1xuICAgIGNvbnN0IGtlcm5lbFByb3h5ID0gQ29tbGluay53cmFwPElLZXJuZWw+KHdvcmtlcik7XG4gICAgXG4gICAgLy8gQWRkIGEgbG9jYWwgZXZlbnQgaGFuZGxlciB0byBicmlkZ2UgdGhlIHdvcmtlciBldmVudHNcbiAgICAvLyBUaGlzIHdvcmtzIGFyb3VuZCB0aGUgbGltaXRhdGlvbiB0aGF0IENvbWxpbmsgZG9lc24ndCBwcm94eSBldmVudCBlbWl0dGVyc1xuICAgIGNvbnN0IGV2ZW50SGFuZGxlciA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnR5cGUpIHtcbiAgICAgICAgLy8gRW1pdCB0aGUgZXZlbnQgZnJvbSB0aGUgbWFuYWdlciB3aXRoIGtlcm5lbCBJRFxuICAgICAgICAvLyBUaGlzIHN0cnVjdHVyZSBtYXRjaGVzIHRoZSBzZXR1cEV2ZW50Rm9yd2FyZGluZyBtZXRob2QgZm9yIG1haW4gdGhyZWFkIGtlcm5lbHNcbiAgICAgICAgc3VwZXIuZW1pdChldmVudC5kYXRhLnR5cGUsIHtcbiAgICAgICAgICBrZXJuZWxJZDogaWQsXG4gICAgICAgICAgZGF0YTogZXZlbnQuZGF0YS5kYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gTGlzdGVuIGZvciBldmVudHMgZnJvbSB0aGUgd29ya2VyXG4gICAgcG9ydDEuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50SGFuZGxlcik7XG4gICAgcG9ydDEuc3RhcnQoKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHRoZSBrZXJuZWwgd2l0aCBmaWxlc3lzdGVtIG9wdGlvbnNcbiAgICAvLyBXZSBuZWVkIHRvIHBhc3MgdGhlc2Ugb3B0aW9ucyB0byB0aGUgd29ya2VyXG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwiSU5JVElBTElaRV9LRVJORUxcIixcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgZmlsZXN5c3RlbTogb3B0aW9ucy5maWxlc3lzdGVtLFxuICAgICAgICBlbnY6IG9wdGlvbnMuZW52LFxuICAgICAgICBsb2NrRmlsZVVSTDogb3B0aW9ucy5sb2NrRmlsZVVSTCxcbiAgICAgICAgYXV0b1N5bmNGczogb3B0aW9ucy5hdXRvU3luY0ZzLFxuICAgICAgICBsYW5nOiBsYW5ndWFnZVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFdhaXQgZm9yIGtlcm5lbCBpbml0aWFsaXphdGlvblxuICAgIGF3YWl0IGluaXRQcm9taXNlO1xuICAgIFxuICAgIC8vIFNldCB1cCBpbnRlcnJ1cHQgYnVmZmVyIGF1dG9tYXRpY2FsbHkgZm9yIHdvcmtlciBrZXJuZWxzXG4gICAgYXdhaXQgdGhpcy5zZXR1cFdvcmtlckludGVycnVwdEJ1ZmZlcihpZCwgd29ya2VyKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgdGhlIGtlcm5lbCBpbnN0YW5jZVxuICAgIGNvbnN0IGluc3RhbmNlOiBJS2VybmVsSW5zdGFuY2UgPSB7XG4gICAgICBpZCxcbiAgICAgIGtlcm5lbDoge1xuICAgICAgICAvLyBNYXAgbWV0aG9kcyBmcm9tIHRoZSBDb21saW5rIHByb3h5IHRvIHRoZSBJS2VybmVsIGludGVyZmFjZVxuICAgICAgICBpbml0aWFsaXplOiBhc3luYyAob3B0aW9ucz86IElLZXJuZWxPcHRpb25zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGtlcm5lbFByb3h5LmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGV4ZWN1dGU6IGFzeW5jIChjb2RlOiBzdHJpbmcsIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGtlcm5lbFByb3h5LmV4ZWN1dGUoY29kZSwgcGFyZW50KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBIYW5kbGUgUHl0aG9uIHdvcmtlciByZXN1bHRzIChubyBzcGVjaWFsIGRpc3BsYXkgcmVjb25zdHJ1Y3Rpb24gbmVlZGVkKVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGlzSW5pdGlhbGl6ZWQ6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4ga2VybmVsUHJveHkuaXNJbml0aWFsaXplZCgpO1xuICAgICAgICB9LFxuICAgICAgICBpbnB1dFJlcGx5OiBhc3luYyAoY29udGVudDogeyB2YWx1ZTogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4ga2VybmVsUHJveHkuaW5wdXRSZXBseShjb250ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWFwIGFzeW5jIGdldFN0YXR1cyBtZXRob2RcbiAgICAgICAgZ2V0U3RhdHVzOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuZ2V0U3RhdHVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5nZXRTdGF0dXMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBcInVua25vd25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWFwIGNvbXBsZXRpb24gbWV0aG9kc1xuICAgICAgICBjb21wbGV0ZTogYXN5bmMgKGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5jb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuY29tcGxldGUoY29kZSwgY3Vyc29yX3BvcywgcGFyZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6ICdDb21wbGV0aW9uIG5vdCBzdXBwb3J0ZWQnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluc3BlY3Q6IGFzeW5jIChjb2RlOiBzdHJpbmcsIGN1cnNvcl9wb3M6IG51bWJlciwgZGV0YWlsX2xldmVsOiAwIHwgMSwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuaW5zcGVjdChjb2RlLCBjdXJzb3JfcG9zLCBkZXRhaWxfbGV2ZWwsIHBhcmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiAnSW5zcGVjdGlvbiBub3Qgc3VwcG9ydGVkJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiBTdHJpbmcoZXJyb3IpIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc0NvbXBsZXRlOiBhc3luYyAoY29kZTogc3RyaW5nLCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5pc0NvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5pc0NvbXBsZXRlKGNvZGUsIHBhcmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6ICd1bmtub3duJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiBTdHJpbmcoZXJyb3IpIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBNYXAgaW50ZXJydXB0IG1ldGhvZHNcbiAgICAgICAgaW50ZXJydXB0OiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuaW50ZXJydXB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5pbnRlcnJ1cHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW50ZXJydXB0QnVmZmVyOiAoYnVmZmVyOiBVaW50OEFycmF5KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuc2V0SW50ZXJydXB0QnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGtlcm5lbFByb3h5LnNldEludGVycnVwdEJ1ZmZlcihidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBzZXQgaW50ZXJydXB0IGJ1ZmZlcjonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBNYXAgbW91bnRGUyBtZXRob2RcbiAgICAgICAgbW91bnRGUzogYXN5bmMgKG1vdW50UGF0aDogc3RyaW5nLCBkaXJIYW5kbGU/OiBGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHwgbnVsbCwgcGVybWlzc2lvbj86ICdyZWFkJyB8ICdyZWFkd3JpdGUnKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkubW91bnRGUyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkubW91bnRGUyhtb3VudFBhdGgsIGRpckhhbmRsZSwgcGVybWlzc2lvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vdW50RlMgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGtlcm5lbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1hcCBmaWxlc3lzdGVtIHN5bmMgbWV0aG9kc1xuICAgICAgICBnZXRNb3VudGVkRmlsZVN5c3RlbXM6ICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5nZXRNb3VudGVkRmlsZVN5c3RlbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGtlcm5lbFByb3h5LmdldE1vdW50ZWRGaWxlU3lzdGVtcygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBnZXQgbW91bnRlZCBmaWxlc3lzdGVtczonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzeW5jRmlsZVN5c3RlbTogYXN5bmMgKG1vdW50UGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuc3luY0ZpbGVTeXN0ZW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LnN5bmNGaWxlU3lzdGVtKG1vdW50UGF0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdzeW5jRmlsZVN5c3RlbSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMga2VybmVsJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXBncmFkZUZpbGVTeXN0ZW1QZXJtaXNzaW9uOiBhc3luYyAobW91bnRQYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS51cGdyYWRlRmlsZVN5c3RlbVBlcm1pc3Npb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LnVwZ3JhZGVGaWxlU3lzdGVtUGVybWlzc2lvbihtb3VudFBhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAndXBncmFkZUZpbGVTeXN0ZW1QZXJtaXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBrZXJuZWwnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBNYXAgY29tbSBtZXRob2RzXG4gICAgICAgIGNvbW1JbmZvOiBhc3luYyAodGFyZ2V0X25hbWU6IHN0cmluZyB8IG51bGwsIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmNvbW1JbmZvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5jb21tSW5mbyh0YXJnZXRfbmFtZSwgcGFyZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGNvbW1zOiB7fSwgc3RhdHVzOiAnb2snIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbW1zOiB7fSwgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogU3RyaW5nKGVycm9yKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tbU9wZW46IGFzeW5jIChjb250ZW50OiBhbnksIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmNvbW1PcGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5jb21tT3Blbihjb250ZW50LCBwYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBvcGVuIGNvbW06JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tbU1zZzogYXN5bmMgKGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VybmVsUHJveHkuY29tbU1zZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuY29tbU1zZyhjb250ZW50LCBwYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBzZW5kIGNvbW0gbWVzc2FnZTonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21tQ2xvc2U6IGFzeW5jIChjb250ZW50OiBhbnksIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmNvbW1DbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuY29tbUNsb3NlKGNvbnRlbnQsIHBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGNsb3NlIGNvbW06JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIElLZXJuZWwsXG4gICAgICBtb2RlOiBLZXJuZWxNb2RlLldPUktFUixcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgd29ya2VyLFxuICAgICAgY3JlYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgb3B0aW9ucywgLy8gU3RvcmUgdGhlIG9wdGlvbnMgZm9yIHJlZmVyZW5jZVxuICAgICAgZGVzdHJveTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBDbGVhbiB1cCB0aGUgd29ya2VyIGFuZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgcG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgIHBvcnQxLmNsb3NlKCk7XG4gICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIFxuICAvKipcbiAgICogU2V0dXAgZXZlbnQgZm9yd2FyZGluZyBmcm9tIGtlcm5lbCB0byBtYW5hZ2VyXG4gICAqIEBwYXJhbSBpbnN0YW5jZSBLZXJuZWwgaW5zdGFuY2VcbiAgICovXG4gIHByaXZhdGUgc2V0dXBFdmVudEZvcndhcmRpbmcoaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZSk6IHZvaWQge1xuICAgIC8vIE9ubHkgbmVlZGVkIGZvciBtYWluIHRocmVhZCBrZXJuZWxzIGFzIHdvcmtlciBldmVudHMgYXJlIGhhbmRsZWQgZGlyZWN0bHlcbiAgICBpZiAoaW5zdGFuY2UubW9kZSA9PT0gS2VybmVsTW9kZS5NQUlOX1RIUkVBRCkge1xuICAgICAgLy8gRm9yd2FyZCBhbGwga2VybmVsIGV2ZW50cyB0byB0aGUgbWFuYWdlciB3aXRoIGtlcm5lbCBJRFxuICAgICAgT2JqZWN0LnZhbHVlcyhLZXJuZWxFdmVudHMpLmZvckVhY2goKGV2ZW50VHlwZSkgPT4ge1xuICAgICAgICAvLyBBY2Nlc3MgdGhlIGtlcm5lbCBhcyBhIEtlcm5lbCBpbnN0YW5jZSB3aGljaCBleHRlbmRzIEV2ZW50RW1pdHRlclxuICAgICAgICBjb25zdCBrZXJuZWxFbWl0dGVyID0gaW5zdGFuY2Uua2VybmVsIGFzIHVua25vd24gYXMgRXZlbnRFbWl0dGVyO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyIHRvIGZvcndhcmQgZXZlbnRzXG4gICAgICAgIGtlcm5lbEVtaXR0ZXIub24oZXZlbnRUeXBlLCAoZGF0YTogYW55KSA9PiB7XG4gICAgICAgICAgc3VwZXIuZW1pdChldmVudFR5cGUsIHtcbiAgICAgICAgICAgIGtlcm5lbElkOiBpbnN0YW5jZS5pZCxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBrZXJuZWwgaW5zdGFuY2UgYnkgSURcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBLZXJuZWwgaW5zdGFuY2Ugb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgcHVibGljIGdldEtlcm5lbChpZDogc3RyaW5nKTogSUtlcm5lbEluc3RhbmNlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGFsbCBrZXJuZWwgSURzXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGtlcm5lbCBJRHNcbiAgICovXG4gIHB1YmxpYyBnZXRLZXJuZWxJZHMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua2VybmVscy5rZXlzKCkpO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBhbGwga2VybmVscyB3aXRoIHRoZWlyIGRldGFpbHNcbiAgICogQHBhcmFtIG5hbWVzcGFjZSBPcHRpb25hbCBuYW1lc3BhY2UgdG8gZmlsdGVyIGtlcm5lbHMgYnlcbiAgICogQHJldHVybnMgQXJyYXkgb2Yga2VybmVsIGluZm9ybWF0aW9uIG9iamVjdHNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0S2VybmVscyhuYW1lc3BhY2U/OiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG1vZGU6IEtlcm5lbE1vZGU7XG4gICAgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlO1xuICAgIHN0YXR1czogXCJhY3RpdmVcIiB8IFwiYnVzeVwiIHwgXCJ1bmtub3duXCI7XG4gICAgY3JlYXRlZDogc3RyaW5nO1xuICAgIG5hbWVzcGFjZT86IHN0cmluZztcbiAgICBkZW5vPzoge1xuICAgICAgcGVybWlzc2lvbnM/OiBJRGVub1Blcm1pc3Npb25zO1xuICAgIH07XG4gIH0+PiB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRLZXJuZWxzID0gQXJyYXkuZnJvbSh0aGlzLmtlcm5lbHMuZW50cmllcygpKVxuICAgICAgICAuZmlsdGVyKChbaWRdKSA9PiB7XG4gICAgICAgICAgLy8gRmlsdGVyIG91dCBwb29sIGtlcm5lbHMgKHRlbXBvcmFyeSBrZXJuZWxzIHdpdGggSURzIHN0YXJ0aW5nIHdpdGggXCJwb29sLVwiKVxuICAgICAgICAgIGlmIChpZC5zdGFydHNXaXRoKFwicG9vbC1cIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIW5hbWVzcGFjZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoYCR7bmFtZXNwYWNlfTpgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIFVzZSBQcm9taXNlLmFsbCB0byBnZXQgYWxsIHN0YXR1c2VzIGNvbmN1cnJlbnRseVxuICAgICAgY29uc3Qga2VybmVsSW5mb3MgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgZmlsdGVyZWRLZXJuZWxzLm1hcChhc3luYyAoW2lkLCBpbnN0YW5jZV0pID0+IHtcbiAgICAgICAgICAvLyBFeHRyYWN0IG5hbWVzcGFjZSBmcm9tIGlkIGlmIHByZXNlbnRcbiAgICAgICAgICBjb25zdCBuYW1lc3BhY2VNYXRjaCA9IGlkLm1hdGNoKC9eKFteOl0rKTovKTtcbiAgICAgICAgICBjb25zdCBleHRyYWN0ZWROYW1lc3BhY2UgPSBuYW1lc3BhY2VNYXRjaCA/IG5hbWVzcGFjZU1hdGNoWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCBzdGF0dXMgdXNpbmcgYXN5bmMgZ2V0U3RhdHVzIG1ldGhvZFxuICAgICAgICAgIGxldCBzdGF0dXM6IFwiYWN0aXZlXCIgfCBcImJ1c3lcIiB8IFwidW5rbm93blwiID0gXCJ1bmtub3duXCI7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5rZXJuZWwgJiYgdHlwZW9mIGluc3RhbmNlLmtlcm5lbC5nZXRTdGF0dXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgc3RhdHVzID0gYXdhaXQgaW5zdGFuY2Uua2VybmVsLmdldFN0YXR1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIGdldHRpbmcgc3RhdHVzIGZvciBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgc3RhdHVzID0gXCJ1bmtub3duXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG1vZGU6IGluc3RhbmNlLm1vZGUsXG4gICAgICAgICAgICBsYW5ndWFnZTogaW5zdGFuY2UubGFuZ3VhZ2UsXG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBjcmVhdGVkOiBpbnN0YW5jZS5jcmVhdGVkIHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogZXh0cmFjdGVkTmFtZXNwYWNlLFxuICAgICAgICAgICAgZGVubzogaW5zdGFuY2Uub3B0aW9ucz8uZGVub1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ga2VybmVsSW5mb3M7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBEZXN0cm95IGEga2VybmVsIGluc3RhbmNlXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiBrZXJuZWwgaXMgZGVzdHJveWVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVzdHJveUtlcm5lbChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAvLyBIYW5kbGUgZ3JhY2VmdWxseSAtIGtlcm5lbCBtYXkgYWxyZWFkeSBiZSBkZXN0cm95ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gVmVyaWZ5IHRoZSBkZXN0cm95IGZ1bmN0aW9uIGV4aXN0c1xuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgJHtpZH0gaXMgbWlzc2luZyBkZXN0cm95IGZ1bmN0aW9uICh0eXBlOiAke3R5cGVvZiBpbnN0YW5jZS5kZXN0cm95fSlgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWJvcnQgYWxsIG9uZ29pbmcgb3BlcmF0aW9ucyBmb3IgdGhpcyBrZXJuZWwgZmlyc3RcbiAgICB0aGlzLmFib3J0QWxsS2VybmVsT3BlcmF0aW9ucyhpZCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgYW55IGluYWN0aXZpdHkgdGltZXJcbiAgICB0aGlzLmNsZWFySW5hY3Rpdml0eVRpbWVvdXQoaWQpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGV4ZWN1dGlvbiB0aW1lb3V0c1xuICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVvdXRzLmhhcyhpZCkpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXRzID0gdGhpcy5leGVjdXRpb25UaW1lb3V0cy5nZXQoaWQpITtcbiAgICAgIGZvciAoY29uc3QgdGltZW91dElkIG9mIHRpbWVvdXRzLnZhbHVlcygpKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5leGVjdXRpb25UaW1lb3V0cy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBleGVjdXRpb24gc3RhcnQgdGltZXNcbiAgICBpZiAodGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmhhcyhpZCkpIHtcbiAgICAgIHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBleGVjdXRpb24gbWV0YWRhdGFcbiAgICBpZiAodGhpcy5leGVjdXRpb25NZXRhZGF0YS5oYXMoaWQpKSB7XG4gICAgICB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIGludGVycnVwdCBidWZmZXJzXG4gICAgaWYgKHRoaXMuaW50ZXJydXB0QnVmZmVycy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLmludGVycnVwdEJ1ZmZlcnMuZGVsZXRlKGlkKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgb25nb2luZyBleGVjdXRpb25zIHRyYWNraW5nXG4gICAgdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5kZWxldGUoaWQpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGFjdGl2aXR5IHRyYWNraW5nXG4gICAgdGhpcy5sYXN0QWN0aXZpdHlUaW1lLmRlbGV0ZShpZCk7XG4gICAgXG4gICAgLy8gUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMgZm9yIHRoaXMga2VybmVsXG4gICAgdGhpcy5yZW1vdmVBbGxLZXJuZWxMaXN0ZW5lcnMoaWQpO1xuICAgIFxuICAgIC8vIERlc3Ryb3kgdGhlIGtlcm5lbCBpbnN0YW5jZVxuICAgIGF3YWl0IGluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICBcbiAgICAvLyBSZW1vdmUgdGhlIGtlcm5lbCBmcm9tIHRoZSBtYXBcbiAgICB0aGlzLmtlcm5lbHMuZGVsZXRlKGlkKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIERlc3Ryb3kgYWxsIGtlcm5lbCBpbnN0YW5jZXNcbiAgICogQHBhcmFtIG5hbWVzcGFjZSBPcHRpb25hbCBuYW1lc3BhY2UgdG8gZmlsdGVyIGtlcm5lbHMgdG8gZGVzdHJveVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIGFsbCBrZXJuZWxzIGFyZSBkZXN0cm95ZWRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZXN0cm95QWxsKG5hbWVzcGFjZT86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGlkcyA9IEFycmF5LmZyb20odGhpcy5rZXJuZWxzLmtleXMoKSlcbiAgICAgIC5maWx0ZXIoaWQgPT4ge1xuICAgICAgICBpZiAoIW5hbWVzcGFjZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBpZC5zdGFydHNXaXRoKGAke25hbWVzcGFjZX06YCk7XG4gICAgICB9KTtcbiAgICBcbiAgICAvLyBEZXN0cm95IGFsbCBrZXJuZWxzLCBidXQgc2tpcCBpbmNvbXBsZXRlIGluc3RhbmNlc1xuICAgIGNvbnN0IGRlc3Ryb3lQcm9taXNlcyA9IGlkcy5tYXAoYXN5bmMgKGlkKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgICAgaWYgKCFpbnN0YW5jZSB8fCB0eXBlb2YgaW5zdGFuY2UuZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFNraXBwaW5nIGluY29tcGxldGUga2VybmVsIGluc3RhbmNlICR7aWR9IGR1cmluZyBkZXN0cm95QWxsYCk7XG4gICAgICAgIC8vIEp1c3QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcFxuICAgICAgICB0aGlzLmtlcm5lbHMuZGVsZXRlKGlkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveUtlcm5lbChpZCk7XG4gICAgfSk7XG4gICAgXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoZGVzdHJveVByb21pc2VzKTtcbiAgICBcbiAgICAvLyBJZiBubyBuYW1lc3BhY2Ugc3BlY2lmaWVkLCBhbHNvIGNsZWFuIHVwIHRoZSBwb29sXG4gICAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVzdHJveVBvb2woKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBEZXN0cm95IGFsbCBrZXJuZWxzIGluIHRoZSBwb29sXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGRlc3Ryb3lQb29sKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIFxuICAgIGNvbnN0IGRlc3Ryb3lQcm9taXNlczogUHJvbWlzZTx2b2lkPltdID0gW107XG4gICAgXG4gICAgZm9yIChjb25zdCBbcG9vbEtleSwgcHJvbWlzZXNdIG9mIHRoaXMucG9vbC5lbnRyaWVzKCkpIHtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBrZXJuZWxQcm9taXNlIG9mIHByb21pc2VzKSB7XG4gICAgICAgIC8vIEhhbmRsZSBlYWNoIHByb21pc2UgLSBpZiBpdCByZXNvbHZlcywgZGVzdHJveSB0aGUga2VybmVsXG4gICAgICAgIGNvbnN0IGRlc3Ryb3lQcm9taXNlID0ga2VybmVsUHJvbWlzZS50aGVuKGtlcm5lbCA9PiB7XG4gICAgICAgICAgcmV0dXJuIGtlcm5lbC5kZXN0cm95KCk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZXN0cm95aW5nIHBvb2wga2VybmVsIGZyb20gcHJvbWlzZTpgLCBlcnJvcik7XG4gICAgICAgICAgLy8gRG9uJ3QgcmUtdGhyb3cgdG8gYXZvaWQgdW5oYW5kbGVkIHJlamVjdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBkZXN0cm95UHJvbWlzZXMucHVzaChkZXN0cm95UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFdhaXQgZm9yIGFsbCBwb29sIGtlcm5lbHMgdG8gYmUgZGVzdHJveWVkXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoZGVzdHJveVByb21pc2VzKTtcbiAgICBcbiAgICAvLyBDbGVhciB0aGUgcG9vbCBhbmQgcHJlZmlsbGluZyBmbGFnc1xuICAgIHRoaXMucG9vbC5jbGVhcigpO1xuICAgIHRoaXMucHJlZmlsbGluZ0luUHJvZ3Jlc3MuY2xlYXIoKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBhIHNwZWNpZmljIGtlcm5lbCdzIGV2ZW50c1xuICAgKiBAcGFyYW0ga2VybmVsSWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBldmVudFR5cGUgRXZlbnQgdHlwZVxuICAgKiBAcGFyYW0gbGlzdGVuZXIgRXZlbnQgbGlzdGVuZXJcbiAgICovXG4gIHB1YmxpYyBvbktlcm5lbEV2ZW50KGtlcm5lbElkOiBzdHJpbmcsIGV2ZW50VHlwZTogS2VybmVsRXZlbnRzLCBsaXN0ZW5lcjogKGRhdGE6IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgIC8vIENoZWNrIGlmIGtlcm5lbCBleGlzdHNcbiAgICBpZiAoIXRoaXMua2VybmVscy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCB3aXRoIElEICR7a2VybmVsSWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgd3JhcHBlciB0aGF0IGZpbHRlcnMgZXZlbnRzIGZvciB0aGlzIHNwZWNpZmljIGtlcm5lbFxuICAgIGNvbnN0IHdyYXBwZXI6IExpc3RlbmVyV3JhcHBlciA9IHtcbiAgICAgIG9yaWdpbmFsOiBsaXN0ZW5lcixcbiAgICAgIHdyYXBwZWQ6IChldmVudDogeyBrZXJuZWxJZDogc3RyaW5nLCBkYXRhOiBhbnkgfSkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQua2VybmVsSWQgPT09IGtlcm5lbElkKSB7XG4gICAgICAgICAgLy8gUGFzcyBqdXN0IHRoZSBkYXRhIHRvIHRoZSBsaXN0ZW5lclxuICAgICAgICAgIC8vIFRoZSBkYXRhIHN0cnVjdHVyZSBpcyBjb25zaXN0ZW50IGFjcm9zcyBtYWluIHRocmVhZCBhbmQgd29ya2VyIG1vZGVzXG4gICAgICAgICAgbGlzdGVuZXIoZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIFN0b3JlIHRoZSB3cmFwcGVyIGZvciBsYXRlciByZW1vdmFsXG4gICAgdGhpcy5zdG9yZUxpc3RlbmVyKGtlcm5lbElkLCBldmVudFR5cGUsIGxpc3RlbmVyLCB3cmFwcGVyKTtcbiAgICBcbiAgICAvLyBBZGQgdGhlIHdyYXBwZWQgbGlzdGVuZXIgdG8gdGhlIG1hbmFnZXJcbiAgICBzdXBlci5vbihldmVudFR5cGUsIHdyYXBwZXIud3JhcHBlZCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWMga2VybmVsXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIGV2ZW50VHlwZSBFdmVudCB0eXBlXG4gICAqIEBwYXJhbSBsaXN0ZW5lciBFdmVudCBsaXN0ZW5lclxuICAgKi9cbiAgcHVibGljIG9mZktlcm5lbEV2ZW50KGtlcm5lbElkOiBzdHJpbmcsIGV2ZW50VHlwZTogS2VybmVsRXZlbnRzLCBsaXN0ZW5lcjogKGRhdGE6IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLmdldExpc3RlbmVyKGtlcm5lbElkLCBldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICBcbiAgICBpZiAod3JhcHBlcikge1xuICAgICAgLy8gUmVtb3ZlIHRoZSB3cmFwcGVkIGxpc3RlbmVyIGZyb20gdGhlIG1hbmFnZXJcbiAgICAgIHN1cGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50VHlwZSwgd3JhcHBlci53cmFwcGVkKTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIHRoZSB3cmFwcGVyIGZyb20gb3VyIHRyYWNraW5nIG1hcFxuICAgICAgdGhpcy5yZW1vdmVTdG9yZWRMaXN0ZW5lcihrZXJuZWxJZCwgZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogU3RvcmUgYSBsaXN0ZW5lciB3cmFwcGVyIGZvciBsYXRlciByZW1vdmFsXG4gICAqL1xuICBwcml2YXRlIHN0b3JlTGlzdGVuZXIoXG4gICAga2VybmVsSWQ6IHN0cmluZywgXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsIFxuICAgIG9yaWdpbmFsOiBGdW5jdGlvbiwgXG4gICAgd3JhcHBlcjogTGlzdGVuZXJXcmFwcGVyXG4gICk6IHZvaWQge1xuICAgIC8vIEdldCBvciBjcmVhdGUga2VybmVsIG1hcFxuICAgIGlmICghdGhpcy5saXN0ZW5lcldyYXBwZXJzLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJXcmFwcGVycy5zZXQoa2VybmVsSWQsIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbE1hcCA9IHRoaXMubGlzdGVuZXJXcmFwcGVycy5nZXQoa2VybmVsSWQpITtcbiAgICBcbiAgICAvLyBHZXQgb3IgY3JlYXRlIGV2ZW50IHR5cGUgbWFwXG4gICAgaWYgKCFrZXJuZWxNYXAuaGFzKGV2ZW50VHlwZSkpIHtcbiAgICAgIGtlcm5lbE1hcC5zZXQoZXZlbnRUeXBlLCBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBjb25zdCBldmVudE1hcCA9IGtlcm5lbE1hcC5nZXQoZXZlbnRUeXBlKSE7XG4gICAgXG4gICAgLy8gU3RvcmUgdGhlIHdyYXBwZXJcbiAgICBldmVudE1hcC5zZXQob3JpZ2luYWwsIHdyYXBwZXIpO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IGEgc3RvcmVkIGxpc3RlbmVyIHdyYXBwZXJcbiAgICovXG4gIHByaXZhdGUgZ2V0TGlzdGVuZXIoXG4gICAga2VybmVsSWQ6IHN0cmluZywgXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsIFxuICAgIG9yaWdpbmFsOiBGdW5jdGlvblxuICApOiBMaXN0ZW5lcldyYXBwZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGtlcm5lbE1hcCA9IHRoaXMubGlzdGVuZXJXcmFwcGVycy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsTWFwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIGNvbnN0IGV2ZW50TWFwID0ga2VybmVsTWFwLmdldChldmVudFR5cGUpO1xuICAgIGlmICghZXZlbnRNYXApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgcmV0dXJuIGV2ZW50TWFwLmdldChvcmlnaW5hbCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBzdG9yZWQgbGlzdGVuZXIgd3JhcHBlclxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVTdG9yZWRMaXN0ZW5lcihcbiAgICBrZXJuZWxJZDogc3RyaW5nLCBcbiAgICBldmVudFR5cGU6IHN0cmluZywgXG4gICAgb3JpZ2luYWw6IEZ1bmN0aW9uXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGtlcm5lbE1hcCA9IHRoaXMubGlzdGVuZXJXcmFwcGVycy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsTWFwKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZXZlbnRNYXAgPSBrZXJuZWxNYXAuZ2V0KGV2ZW50VHlwZSk7XG4gICAgaWYgKCFldmVudE1hcCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIFJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICBldmVudE1hcC5kZWxldGUob3JpZ2luYWwpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGVtcHR5IG1hcHNcbiAgICBpZiAoZXZlbnRNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAga2VybmVsTWFwLmRlbGV0ZShldmVudFR5cGUpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoa2VybmVsTWFwLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMubGlzdGVuZXJXcmFwcGVycy5kZWxldGUoa2VybmVsSWQpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIGtlcm5lbFxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVBbGxLZXJuZWxMaXN0ZW5lcnMoa2VybmVsSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGtlcm5lbE1hcCA9IHRoaXMubGlzdGVuZXJXcmFwcGVycy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsTWFwKSByZXR1cm47XG4gICAgXG4gICAgLy8gRm9yIGVhY2ggZXZlbnQgdHlwZVxuICAgIGZvciAoY29uc3QgW2V2ZW50VHlwZSwgZXZlbnRNYXBdIG9mIGtlcm5lbE1hcC5lbnRyaWVzKCkpIHtcbiAgICAgIC8vIEZvciBlYWNoIG9yaWdpbmFsIGxpc3RlbmVyXG4gICAgICBmb3IgKGNvbnN0IHdyYXBwZXIgb2YgZXZlbnRNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB3cmFwcGVkIGxpc3RlbmVyIGZyb20gdGhlIG1hbmFnZXJcbiAgICAgICAgc3VwZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnRUeXBlLCB3cmFwcGVyLndyYXBwZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhciB0aGUga2VybmVsJ3MgbGlzdGVuZXIgbWFwXG4gICAgdGhpcy5saXN0ZW5lcldyYXBwZXJzLmRlbGV0ZShrZXJuZWxJZCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYWxsIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBrZXJuZWwgYW5kIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIGtlcm5lbElkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gZXZlbnRUeXBlIEV2ZW50IHR5cGVcbiAgICogQHJldHVybnMgQXJyYXkgb2YgbGlzdGVuZXJzXG4gICAqL1xuICBwdWJsaWMgZ2V0TGlzdGVuZXJzKGtlcm5lbElkOiBzdHJpbmcsIGV2ZW50VHlwZTogS2VybmVsRXZlbnRzKTogKChkYXRhOiBhbnkpID0+IHZvaWQpW10ge1xuICAgIGNvbnN0IGtlcm5lbExpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJXcmFwcGVycy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsTGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0ga2VybmVsTGlzdGVuZXJzLmdldChldmVudFR5cGUpO1xuICAgIGlmICghZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZXZlbnRMaXN0ZW5lcnMua2V5cygpKSBhcyAoKGRhdGE6IGFueSkgPT4gdm9pZClbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIFB5dGhvbiBjb2RlIHdpdGggc3RyZWFtaW5nIG91dHB1dFxuICAgKiBUaGlzIG1ldGhvZCB3b3JrcyBpbiBib3RoIG1haW4gdGhyZWFkIGFuZCB3b3JrZXIgbW9kZXNcbiAgICogQHBhcmFtIGtlcm5lbElkIElEIG9mIHRoZSBrZXJuZWwgdG8gdXNlXG4gICAqIEBwYXJhbSBjb2RlIFRoZSBQeXRob24gY29kZSB0byBleGVjdXRlXG4gICAqIEBwYXJhbSBwYXJlbnQgT3B0aW9uYWwgcGFyZW50IG1lc3NhZ2UgaGVhZGVyXG4gICAqIEByZXR1cm5zIEFzeW5jR2VuZXJhdG9yIHlpZWxkaW5nIGludGVybWVkaWF0ZSBvdXRwdXRzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMqIGV4ZWN1dGVTdHJlYW0oXG4gICAga2VybmVsSWQ6IHN0cmluZywgXG4gICAgY29kZTogc3RyaW5nLCBcbiAgICBwYXJlbnQ6IGFueSA9IHt9XG4gICk6IEFzeW5jR2VuZXJhdG9yPGFueSwgeyBzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ/OiBhbnksIGVycm9yPzogRXJyb3IgfSwgdm9pZD4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRLZXJuZWwoa2VybmVsSWQpO1xuICAgIFxuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsIHdpdGggSUQgJHtrZXJuZWxJZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBrZXJuZWwgYWN0aXZpdHlcbiAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICBcbiAgICAvLyBUcmFjayB0aGlzIGV4ZWN1dGlvbiB3aXRoIHRoZSBjb2RlIGZvciBiZXR0ZXIgbW9uaXRvcmluZ1xuICAgIGNvbnN0IGV4ZWN1dGlvbklkID0gdGhpcy50cmFja0V4ZWN1dGlvbihrZXJuZWxJZCwgY29kZSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIEFib3J0Q29udHJvbGxlciBmb3IgdGhpcyBleGVjdXRpb24gdG8gZW5hYmxlIGNhbmNlbGxhdGlvblxuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLnN0b3JlQWJvcnRDb250cm9sbGVyKGtlcm5lbElkLCBleGVjdXRpb25JZCwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gRm9yIG1haW4gdGhyZWFkIGtlcm5lbHMsIHdlIGNhbiB1c2UgdGhlIGV4ZWN1dGVTdHJlYW0gbWV0aG9kIGRpcmVjdGx5XG4gICAgICBpZiAoaW5zdGFuY2UubW9kZSA9PT0gS2VybmVsTW9kZS5NQUlOX1RIUkVBRCkge1xuICAgICAgICBjb25zdCBrZXJuZWwgPSBpbnN0YW5jZS5rZXJuZWwgYXMgdW5rbm93biBhcyB7IFxuICAgICAgICAgIGV4ZWN1dGVTdHJlYW06IChjb2RlOiBzdHJpbmcsIHBhcmVudDogYW55KSA9PiBBc3luY0dlbmVyYXRvcjxhbnksIGFueSwgdm9pZD4gXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBGb3J3YXJkIHRvIHRoZSBrZXJuZWwncyBleGVjdXRlU3RyZWFtIG1ldGhvZFxuICAgICAgICBpZiAodHlwZW9mIGtlcm5lbC5leGVjdXRlU3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHlpZWxkKiBrZXJuZWwuZXhlY3V0ZVN0cmVhbShjb2RlLCBwYXJlbnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZpdHkgYWZ0ZXIgZXhlY3V0aW9uIGNvbXBsZXRlc1xuICAgICAgICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbXBsZXRlIGV4ZWN1dGlvbiB0cmFja2luZ1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUV4ZWN1dGlvbihrZXJuZWxJZCwgZXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIG1haW4gdGhyZWFkIGV4ZWN1dGVTdHJlYW06YCwgZXJyb3IpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZpdHkgZXZlbiBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ29tcGxldGUgZXhlY3V0aW9uIHRyYWNraW5nIGV2ZW4gb24gZXJyb3JcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVFeGVjdXRpb24oa2VybmVsSWQsIGV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRm9yIHdvcmtlciBtb2RlLCB3ZSBuZWVkIHRvIGltcGxlbWVudCBzdHJlYW1pbmcgdmlhIGV2ZW50cyB3aXRoIHByb3BlciBpc29sYXRpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEV2ZW50LWJhc2VkIGFwcHJvYWNoIGZvciB3b3JrZXIga2VybmVscyBvciBtYWluIHRocmVhZCBrZXJuZWxzIHdpdGhvdXQgZXhlY3V0ZVN0cmVhbVxuICAgICAgICBjb25zdCBzdHJlYW1RdWV1ZTogYW55W10gPSBbXTtcbiAgICAgICAgbGV0IGV4ZWN1dGlvbkNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIGxldCBleGVjdXRpb25SZXN1bHQ6IHsgc3VjY2VzczogYm9vbGVhbiwgcmVzdWx0PzogYW55LCBlcnJvcj86IEVycm9yIH0gPSB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIGhhbmRsZXIgcmVmZXJlbmNlcyBmb3IgZ3VhcmFudGVlZCBjbGVhbnVwXG4gICAgICAgIGNvbnN0IGV2ZW50SGFuZGxlcnMgPSBuZXcgTWFwPHN0cmluZywgKGV2ZW50OiB7IGtlcm5lbElkOiBzdHJpbmcsIGRhdGE6IGFueSB9KSA9PiB2b2lkPigpO1xuICAgICAgICBcbiAgICAgICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNsZWFuIHVwIGFsbCBldmVudCBoYW5kbGVyc1xuICAgICAgICBjb25zdCBjbGVhbnVwSGFuZGxlcnMgPSAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBbZXZlbnRUeXBlLCBoYW5kbGVyXSBvZiBldmVudEhhbmRsZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgc3VwZXIub2ZmKGV2ZW50VHlwZSBhcyBhbnksIGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudEhhbmRsZXJzLmNsZWFyKCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgZXhlY3V0aW9uLXNwZWNpZmljIGV2ZW50IGhhbmRsZXJzIHRoYXQgaW5jbHVkZSBleGVjdXRpb25JZCBjaGVja1xuICAgICAgICBjb25zdCBjcmVhdGVIYW5kbGVyID0gKGV2ZW50VHlwZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IChldmVudDogeyBrZXJuZWxJZDogc3RyaW5nLCBkYXRhOiBhbnkgfSkgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBwcm9jZXNzIGV2ZW50cyBmb3IgdGhpcyBzcGVjaWZpYyBrZXJuZWwgYW5kIHdoaWxlIHRoaXMgZXhlY3V0aW9uIGlzIGFjdGl2ZVxuICAgICAgICAgICAgaWYgKGV2ZW50Lmtlcm5lbElkID09PSBrZXJuZWxJZCAmJiAhZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgc3RyZWFtUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogZXZlbnRUeXBlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uSWQgLy8gSW5jbHVkZSBleGVjdXRpb24gSUQgZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEV2ZW50cyBhbHNvIGNvdW50IGFzIGFjdGl2aXR5XG4gICAgICAgICAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgZXZlbnRIYW5kbGVycy5zZXQoZXZlbnRUeXBlLCBoYW5kbGVyKTtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhbmQgcmVnaXN0ZXIgYWxsIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGNvbnN0IGhhbmRsZVN0cmVhbUV2ZW50ID0gY3JlYXRlSGFuZGxlcignc3RyZWFtJyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZURpc3BsYXlFdmVudCA9IGNyZWF0ZUhhbmRsZXIoJ2Rpc3BsYXlfZGF0YScpO1xuICAgICAgICBjb25zdCBoYW5kbGVVcGRhdGVEaXNwbGF5RXZlbnQgPSBjcmVhdGVIYW5kbGVyKCd1cGRhdGVfZGlzcGxheV9kYXRhJyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc3VsdEV2ZW50ID0gY3JlYXRlSGFuZGxlcignZXhlY3V0ZV9yZXN1bHQnKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRXJyb3JFdmVudCA9IGNyZWF0ZUhhbmRsZXIoJ2V4ZWN1dGVfZXJyb3InKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlZ2lzdGVyIGhhbmRsZXJzXG4gICAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5TVFJFQU0sIGhhbmRsZVN0cmVhbUV2ZW50KTtcbiAgICAgICAgc3VwZXIub24oS2VybmVsRXZlbnRzLkRJU1BMQVlfREFUQSwgaGFuZGxlRGlzcGxheUV2ZW50KTtcbiAgICAgICAgc3VwZXIub24oS2VybmVsRXZlbnRzLlVQREFURV9ESVNQTEFZX0RBVEEsIGhhbmRsZVVwZGF0ZURpc3BsYXlFdmVudCk7XG4gICAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5FWEVDVVRFX1JFU1VMVCwgaGFuZGxlUmVzdWx0RXZlbnQpO1xuICAgICAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwgaGFuZGxlRXJyb3JFdmVudCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvblByb21pc2UgPSBuZXcgUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgLy8gU2V0IHVwIGEgaGFuZGxlciBmb3IgZXhlY3V0aW9uIGVycm9ycyBzcGVjaWZpY2FsbHlcbiAgICAgICAgICBjb25zdCBoYW5kbGVFeGVjdXRpb25FcnJvciA9IChldmVudDogeyBrZXJuZWxJZDogc3RyaW5nLCBkYXRhOiBhbnkgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50Lmtlcm5lbElkID09PSBrZXJuZWxJZCAmJiAhZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgLy8gTWFyayBleGVjdXRpb24gYXMgY29tcGxldGUgdG8gc3RvcCBwcm9jZXNzaW5nIG1vcmUgZXZlbnRzXG4gICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBlcnJvciBmb3IgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgICAgICAgICBleGVjdXRpb25SZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgJHtldmVudC5kYXRhLmVuYW1lfTogJHtldmVudC5kYXRhLmV2YWx1ZX1gKSxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGV2ZW50LmRhdGFcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3Rpdml0eVxuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJlc29sdmUoZXhlY3V0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFkZCBlcnJvciBoYW5kbGVyIHRvIG91ciBjbGVhbnVwIGxpc3RcbiAgICAgICAgICBldmVudEhhbmRsZXJzLnNldCgnZXhlY3V0ZV9lcnJvcl9jb21wbGV0aW9uJywgaGFuZGxlRXhlY3V0aW9uRXJyb3IpO1xuICAgICAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCBoYW5kbGVFeGVjdXRpb25FcnJvcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBhYm9ydGVkXG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZXhlY3V0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdFeGVjdXRpb24gd2FzIGFib3J0ZWQnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNldCB1cCBhYm9ydCBoYW5kbGVyXG4gICAgICAgICAgY29uc3QgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+aqyBFeGVjdXRpb24gJHtleGVjdXRpb25JZH0gYWJvcnRlZGApO1xuICAgICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdFeGVjdXRpb24gd2FzIGFib3J0ZWQnKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNvZGVcbiAgICAgICAgICAvLyBXZSBrbm93IHRoZSBleGVjdXRlIG1ldGhvZCBpcyBhdmFpbGFibGUgZGlyZWN0bHkgb24gdGhlIGtlcm5lbCBvYmplY3RcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZVByb21pc2UgPSBpbnN0YW5jZS5rZXJuZWwuZXhlY3V0ZShjb2RlLCBwYXJlbnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleGVjdXRlUHJvbWlzZS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgLy8gT25seSBwcm9jZXNzIGlmIGV4ZWN1dGlvbiBoYXNuJ3QgYmVlbiBtYXJrZWQgY29tcGxldGUgYWxyZWFkeVxuICAgICAgICAgICAgICBpZiAoIWV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV4ZWN1dGlvbiByZXN1bHQgaW5kaWNhdGVzIGFuIGVycm9yIChmb3IgUHl0aG9uIGtlcm5lbHMpXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5yZXN1bHQgJiYgcmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGFzIGVycm9yXG4gICAgICAgICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzdWx0LnJlc3VsdC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGVuYW1lOiByZXN1bHQucmVzdWx0LmVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBldmFsdWU6IHJlc3VsdC5yZXN1bHQuZXZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZWJhY2s6IHJlc3VsdC5yZXN1bHQudHJhY2ViYWNrXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBQdXNoIGVycm9yIHRvIHN0cmVhbSBxdWV1ZSBkaXJlY3RseSBcbiAgICAgICAgICAgICAgICAgIHN0cmVhbVF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBlcnJvckRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbklkXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4ZWN1dGlvbiByZXN1bHQgdG8gcmVmbGVjdCB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvblJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYCR7cmVzdWx0LnJlc3VsdC5lbmFtZX06ICR7cmVzdWx0LnJlc3VsdC5ldmFsdWV9YCksXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LnJlc3VsdFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZXhlY3V0aW9uUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5IHdoZW4gZXhlY3V0aW9uIGNvbXBsZXRlc1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJlc29sdmUoZXhlY3V0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBpZiBleGVjdXRpb24gaGFzbid0IGJlZW4gbWFya2VkIGNvbXBsZXRlIGFscmVhZHlcbiAgICAgICAgICAgICAgaWYgKCFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGV4ZWN1dGUgZm9yIGtlcm5lbCAke2tlcm5lbElkfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIEtleWJvYXJkSW50ZXJydXB0IGFuZCBoYW5kbGUgaXQgc3BlY2lhbGx5XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzS2V5Ym9hcmRJbnRlcnJ1cHQoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgS2V5Ym9hcmRJbnRlcnJ1cHQgY2F1Z2h0IGluIGV4ZWN1dGVTdHJlYW0gZm9yIGtlcm5lbCAke2tlcm5lbElkfWApO1xuICAgICAgICAgICAgICAgICAgZXJyb3JSZXN1bHQgPSB0aGlzLmNyZWF0ZUtleWJvYXJkSW50ZXJydXB0UmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEFsc28gcHVzaCB0byBzdHJlYW0gcXVldWUgZm9yIGltbWVkaWF0ZSBmZWVkYmFja1xuICAgICAgICAgICAgICAgICAgc3RyZWFtUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGVycm9yUmVzdWx0LnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0aW9uSWRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgb3RoZXIgZXJyb3JzIG5vcm1hbGx5XG4gICAgICAgICAgICAgICAgICBlcnJvclJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleGVjdXRpb25SZXN1bHQgPSBlcnJvclJlc3VsdDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZpdHkgZXZlbiBvbiBlcnJvclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJlc29sdmUoZXJyb3JSZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gT25seSBwcm9jZXNzIGlmIGV4ZWN1dGlvbiBoYXNuJ3QgYmVlbiBtYXJrZWQgY29tcGxldGUgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKCFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjYWxsaW5nIGV4ZWN1dGUgZm9yIGtlcm5lbCAke2tlcm5lbElkfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBTaW1wbGUgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgICAgICAgY29uc3QgZXJyb3JSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZXhlY3V0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICBleGVjdXRpb25SZXN1bHQgPSBlcnJvclJlc3VsdDtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3Rpdml0eSBldmVuIG9uIGRpcmVjdCBlcnJvclxuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJlc29sdmUoZXJyb3JSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVc2UgdHJ5L2ZpbmFsbHkgdG8gZ3VhcmFudGVlIGNsZWFudXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBNb25pdG9yIHRoZSBzdHJlYW0gcXVldWUgYW5kIHlpZWxkIHJlc3VsdHNcbiAgICAgICAgICAvLyBDb250aW51ZSB1bnRpbCBleGVjdXRpb24gaXMgY29tcGxldGUgQU5EIGFsbCBxdWV1ZWQgZXZlbnRzIGhhdmUgYmVlbiB5aWVsZGVkXG4gICAgICAgICAgd2hpbGUgKCghZXhlY3V0aW9uQ29tcGxldGUgfHwgc3RyZWFtUXVldWUubGVuZ3RoID4gMCkgJiYgIWFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGl0ZW1zIGluIHRoZSBxdWV1ZSwgeWllbGQgdGhlbVxuICAgICAgICAgICAgaWYgKHN0cmVhbVF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBzdHJlYW1RdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIG5vIG1vcmUgZXZlbnRzIGJ1dCBleGVjdXRpb24gaXMgbm90IGNvbXBsZXRlLCB3YWl0IGEgbGl0dGxlXG4gICAgICAgICAgICBpZiAoIWV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIC8vIFVzZSBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSB3YWl0XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dChyZXNvbHZlLCAxMCk7XG4gICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQWJvcnRlZCcpKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIGFib3J0ZWQsIGJyZWFrIG91dCBvZiBsb29wXG4gICAgICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIGV4ZWN1dGlvbiB3YXMgYWJvcnRlZCBkdXJpbmcgc3RyZWFtIG1vbml0b3JpbmdcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkICYmICFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGVjdXRpb24gd2FzIGFib3J0ZWQgZHVyaW5nIHN0cmVhbSBtb25pdG9yaW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRpb25Qcm9taXNlO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gQUxXQVlTIGNsZWFuIHVwIGV2ZW50IGhhbmRsZXJzIHJlZ2FyZGxlc3Mgb2YgaG93IGV4ZWN1dGlvbiBlbmRzXG4gICAgICAgICAgY2xlYW51cEhhbmRsZXJzKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIEFib3J0Q29udHJvbGxlciB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWJvcnRDb250cm9sbGVyKGtlcm5lbElkLCBleGVjdXRpb25JZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ29tcGxldGUgZXhlY3V0aW9uIHRyYWNraW5nXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZUV4ZWN1dGlvbihrZXJuZWxJZCwgZXhlY3V0aW9uSWQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBDb21wbGV0ZSBleGVjdXRpb24gdHJhY2tpbmcgb24gYW55IG91dGVyIGVycm9yXG4gICAgICAgIHRoaXMuY29tcGxldGVFeGVjdXRpb24oa2VybmVsSWQsIGV4ZWN1dGlvbklkKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuZXhwZWN0ZWQgZXJyb3IgaW4gZXhlY3V0ZVN0cmVhbTpgLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gQ29tcGxldGUgZXhlY3V0aW9uIHRyYWNraW5nIG9uIGFueSBvdXRlciBlcnJvclxuICAgICAgdGhpcy5jb21wbGV0ZUV4ZWN1dGlvbihrZXJuZWxJZCwgZXhlY3V0aW9uSWQpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmVycm9yKGBVbmV4cGVjdGVkIGVycm9yIGluIGV4ZWN1dGVTdHJlYW06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFjayBhIG5ldyBleGVjdXRpb24gdGFzayBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGtlcm5lbElkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gY29kZSBPcHRpb25hbCBjb2RlIGJlaW5nIGV4ZWN1dGVkIGZvciBtZXRhZGF0YVxuICAgKiBAcmV0dXJucyBVbmlxdWUgZXhlY3V0aW9uIElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHRyYWNrRXhlY3V0aW9uKGtlcm5lbElkOiBzdHJpbmcsIGNvZGU/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBleGVjdXRpb24gSURcbiAgICBjb25zdCBleGVjdXRpb25JZCA9IGBleGVjLSR7Y3J5cHRvLnJhbmRvbVVVSUQoKX1gO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gUmVzZXQgaW50ZXJydXB0IGJ1ZmZlciBmb3Igd29ya2VyIGtlcm5lbHMgYmVmb3JlIGVhY2ggbmV3IGV4ZWN1dGlvblxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGUga2VybmVsIGNhbiBiZSBpbnRlcnJ1cHRlZCBtdWx0aXBsZSB0aW1lc1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLm1vZGUgPT09IEtlcm5lbE1vZGUuV09SS0VSICYmIHRoaXMuaW50ZXJydXB0QnVmZmVycy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICBjb25zdCBpbnRlcnJ1cHRCdWZmZXIgPSB0aGlzLmludGVycnVwdEJ1ZmZlcnMuZ2V0KGtlcm5lbElkKSE7XG4gICAgICAvLyBSZXNldCBidWZmZXIgdG8gMCAobm8gaW50ZXJydXB0IHNpZ25hbCkgdG8gZW5zdXJlIGNsZWFuIHN0YXRlXG4gICAgICBpbnRlcnJ1cHRCdWZmZXJbMF0gPSAwO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBzZXQgb2Ygb25nb2luZyBleGVjdXRpb25zIGZvciB0aGlzIGtlcm5lbFxuICAgIGlmICghdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLnNldChrZXJuZWxJZCwgbmV3IFNldCgpKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHRoaXMgZXhlY3V0aW9uIHRvIHRoZSBzZXRcbiAgICB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChrZXJuZWxJZCkhLmFkZChleGVjdXRpb25JZCk7XG4gICAgXG4gICAgLy8gVHJhY2sgZXhlY3V0aW9uIHN0YXJ0IHRpbWVcbiAgICBpZiAoIXRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICB0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuc2V0KGtlcm5lbElkLCBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICB0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuZ2V0KGtlcm5lbElkKSEuc2V0KGV4ZWN1dGlvbklkLCBzdGFydFRpbWUpO1xuICAgIFxuICAgIC8vIFRyYWNrIGV4ZWN1dGlvbiBtZXRhZGF0YVxuICAgIGlmICghdGhpcy5leGVjdXRpb25NZXRhZGF0YS5oYXMoa2VybmVsSWQpKSB7XG4gICAgICB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLnNldChrZXJuZWxJZCwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIGFjdGl2aXR5IHRpbWVzdGFtcFxuICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgIFxuICAgIC8vIElmIG1heEV4ZWN1dGlvblRpbWUgaXMgc2V0LCBjcmVhdGUgYSB0aW1lb3V0IHRvIGRldGVjdCBzdHVjay9kZWFkIGtlcm5lbHNcbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lICYmIGluc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSA+IDApIHtcbiAgICAgIC8vIEdldCBvciBjcmVhdGUgdGhlIG1hcCBvZiBleGVjdXRpb24gdGltZW91dHMgZm9yIHRoaXMga2VybmVsXG4gICAgICBpZiAoIXRoaXMuZXhlY3V0aW9uVGltZW91dHMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgICB0aGlzLmV4ZWN1dGlvblRpbWVvdXRzLnNldChrZXJuZWxJZCwgbmV3IE1hcCgpKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2V0IGEgdGltZW91dCBmb3IgdGhpcyBleGVjdXRpb24gd2l0aCBlbmhhbmNlZCBoYW5kbGluZ1xuICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRXhlY3V0aW9uICR7ZXhlY3V0aW9uSWR9IG9uIGtlcm5lbCAke2tlcm5lbElkfSBoYXMgYmVlbiBydW5uaW5nIGZvciAke2luc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZX1tcyBhbmQgbWF5IGJlIHN0dWNrL2RlYWQuYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgZXhlY3V0aW9uIG1ldGFkYXRhIGZvciBiZXR0ZXIgZXJyb3IgcmVwb3J0aW5nXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5leGVjdXRpb25NZXRhZGF0YS5nZXQoa2VybmVsSWQpPy5nZXQoZXhlY3V0aW9uSWQpO1xuICAgICAgICBjb25zdCBhY3R1YWxSdW50aW1lID0gRGF0ZS5ub3coKSAtIChtZXRhZGF0YT8uc3RhcnRUaW1lIHx8IHN0YXJ0VGltZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBFbWl0IGEgc3RhbGxlZCBleGVjdXRpb24gZXZlbnQgd2l0aCBlbmhhbmNlZCBpbmZvcm1hdGlvblxuICAgICAgICBzdXBlci5lbWl0KCdleGVjdXRpb25fc3RhbGxlZCcsIHtcbiAgICAgICAgICBrZXJuZWxJZCxcbiAgICAgICAgICBleGVjdXRpb25JZCxcbiAgICAgICAgICBtYXhFeGVjdXRpb25UaW1lOiBpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWUsXG4gICAgICAgICAgYWN0dWFsUnVudGltZSxcbiAgICAgICAgICBjb2RlOiBtZXRhZGF0YT8uY29kZSB8fCBjb2RlLFxuICAgICAgICAgIHN0YXJ0VGltZTogbWV0YWRhdGE/LnN0YXJ0VGltZSB8fCBzdGFydFRpbWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBdXRvLWhhbmRsZSBzdHVjayBleGVjdXRpb24gaWYgY29uZmlndXJlZFxuICAgICAgICB0aGlzLmhhbmRsZVN0dWNrRXhlY3V0aW9uKGtlcm5lbElkLCBleGVjdXRpb25JZCwgYWN0dWFsUnVudGltZSwgbWV0YWRhdGE/LmNvZGUgfHwgY29kZSk7XG4gICAgICB9LCBpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWUpO1xuICAgICAgXG4gICAgICAvLyBTdG9yZSB0aGUgdGltZW91dCBJRFxuICAgICAgdGhpcy5leGVjdXRpb25UaW1lb3V0cy5nZXQoa2VybmVsSWQpIS5zZXQoZXhlY3V0aW9uSWQsIHRpbWVvdXRJZCk7XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIG1ldGFkYXRhIGluY2x1ZGluZyB0aW1lb3V0IElEXG4gICAgICB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmdldChrZXJuZWxJZCkhLnNldChleGVjdXRpb25JZCwge1xuICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHRpbWVvdXRJZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0b3JlIG1ldGFkYXRhIHdpdGhvdXQgdGltZW91dCBJRFxuICAgICAgdGhpcy5leGVjdXRpb25NZXRhZGF0YS5nZXQoa2VybmVsSWQpIS5zZXQoZXhlY3V0aW9uSWQsIHtcbiAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICBjb2RlXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGV4ZWN1dGlvbklkO1xuICB9XG4gIFxuICAvKipcbiAgICogQ29tcGxldGUgdHJhY2tpbmcgZm9yIGFuIGV4ZWN1dGlvblxuICAgKiBAcGFyYW0ga2VybmVsSWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBleGVjdXRpb25JZCBFeGVjdXRpb24gSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgY29tcGxldGVFeGVjdXRpb24oa2VybmVsSWQ6IHN0cmluZywgZXhlY3V0aW9uSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIENsZWFyIGFueSBleGVjdXRpb24gdGltZW91dFxuICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVvdXRzLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXRzID0gdGhpcy5leGVjdXRpb25UaW1lb3V0cy5nZXQoa2VybmVsSWQpITtcbiAgICAgIGlmICh0aW1lb3V0cy5oYXMoZXhlY3V0aW9uSWQpKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0cy5nZXQoZXhlY3V0aW9uSWQpKTtcbiAgICAgICAgdGltZW91dHMuZGVsZXRlKGV4ZWN1dGlvbklkKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXAgZW1wdHkgbWFwc1xuICAgICAgaWYgKHRpbWVvdXRzLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5leGVjdXRpb25UaW1lb3V0cy5kZWxldGUoa2VybmVsSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBleGVjdXRpb24gc3RhcnQgdGltZXNcbiAgICBpZiAodGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZXMgPSB0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuZ2V0KGtlcm5lbElkKSE7XG4gICAgICBzdGFydFRpbWVzLmRlbGV0ZShleGVjdXRpb25JZCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHVwIGVtcHR5IG1hcHNcbiAgICAgIGlmIChzdGFydFRpbWVzLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmRlbGV0ZShrZXJuZWxJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIGV4ZWN1dGlvbiBtZXRhZGF0YVxuICAgIGlmICh0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5leGVjdXRpb25NZXRhZGF0YS5nZXQoa2VybmVsSWQpITtcbiAgICAgIG1ldGFkYXRhLmRlbGV0ZShleGVjdXRpb25JZCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHVwIGVtcHR5IG1hcHNcbiAgICAgIGlmIChtZXRhZGF0YS5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuZGVsZXRlKGtlcm5lbElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gUmVtb3ZlIGZyb20gb25nb2luZyBleGVjdXRpb25zXG4gICAgaWYgKHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgY29uc3QgZXhlY3V0aW9ucyA9IHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZ2V0KGtlcm5lbElkKSE7XG4gICAgICBleGVjdXRpb25zLmRlbGV0ZShleGVjdXRpb25JZCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHVwIGVtcHR5IHNldHNcbiAgICAgIGlmIChleGVjdXRpb25zLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5kZWxldGUoa2VybmVsSWQpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5IHRpbWVzdGFtcCBmb3IgY29tcGxldGVkIGV4ZWN1dGlvblxuICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGtlcm5lbCBoYXMgYW55IG9uZ29pbmcgZXhlY3V0aW9uc1xuICAgKiBAcGFyYW0ga2VybmVsSWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGtlcm5lbCBoYXMgb25nb2luZyBleGVjdXRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGhhc09uZ29pbmdFeGVjdXRpb25zKGtlcm5lbElkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5oYXMoa2VybmVsSWQpICYmIFxuICAgICAgICAgICB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChrZXJuZWxJZCkhLnNpemUgPiAwO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IHRoZSBjb3VudCBvZiBvbmdvaW5nIGV4ZWN1dGlvbnMgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgTnVtYmVyIG9mIG9uZ29pbmcgZXhlY3V0aW9uc1xuICAgKi9cbiAgcHVibGljIGdldE9uZ29pbmdFeGVjdXRpb25Db3VudChpZDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBpZiAoIXRoaXMub25nb2luZ0V4ZWN1dGlvbnMuaGFzKGlkKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChpZCkhLnNpemU7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZXQgdXAgYW4gaW5hY3Rpdml0eSB0aW1lb3V0IGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSB0aW1lb3V0IFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHNldHVwSW5hY3Rpdml0eVRpbWVvdXQoaWQ6IHN0cmluZywgdGltZW91dDogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gRG9uJ3Qgc2V0IHVwIGEgdGltZXIgaWYgdGltZW91dCBpcyAwIG9yIG5lZ2F0aXZlXG4gICAgaWYgKHRpbWVvdXQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBBbHdheXMgY2xlYXIgYW55IGV4aXN0aW5nIHRpbWVyIGZpcnN0XG4gICAgdGhpcy5jbGVhckluYWN0aXZpdHlUaW1lb3V0KGlkKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgcmVtYWluaW5nIHRpbWUgYmFzZWQgb24gbGFzdCBhY3Rpdml0eVxuICAgIGNvbnN0IGxhc3RBY3Rpdml0eSA9IHRoaXMubGFzdEFjdGl2aXR5VGltZS5nZXQoaWQpIHx8IERhdGUubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSBsYXN0QWN0aXZpdHk7XG4gICAgY29uc3QgcmVtYWluaW5nVGltZSA9IE1hdGgubWF4KDAsIHRpbWVvdXQgLSBlbGFwc2VkKTtcbiAgICBcbiAgICAvLyBJZiBubyB0aW1lIHJlbWFpbmluZywgZGVzdHJveSBpbW1lZGlhdGVseVxuICAgIGlmIChyZW1haW5pbmdUaW1lID09PSAwKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUga2VybmVsIGhhcyBvbmdvaW5nIGV4ZWN1dGlvbnMgYmVmb3JlIHNodXR0aW5nIGRvd25cbiAgICAgIGlmICh0aGlzLmhhc09uZ29pbmdFeGVjdXRpb25zKGlkKSkge1xuICAgICAgICAvLyBSZXNldCB0aGUgdGltZXIgdG8gY2hlY2sgYWdhaW4gbGF0ZXJcbiAgICAgICAgdGhpcy5zZXR1cEluYWN0aXZpdHlUaW1lb3V0KGlkLCB0aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZXN0cm95IGltbWVkaWF0ZWx5XG4gICAgICB0aGlzLmRlc3Ryb3lLZXJuZWwoaWQpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVzdHJveWluZyBpbmFjdGl2ZSBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBhIHRpbWVyIHRvIGRlc3Ryb3kgdGhlIGtlcm5lbCBhZnRlciB0aGUgcmVtYWluaW5nIHRpbWVvdXRcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGtlcm5lbCBoYXMgb25nb2luZyBleGVjdXRpb25zIGJlZm9yZSBzaHV0dGluZyBkb3duXG4gICAgICBpZiAodGhpcy5oYXNPbmdvaW5nRXhlY3V0aW9ucyhpZCkpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHRpbWVyIHRvIGNoZWNrIGFnYWluIGxhdGVyXG4gICAgICAgIHRoaXMuc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZCwgdGltZW91dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5kZXN0cm95S2VybmVsKGlkKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlc3Ryb3lpbmcgaW5hY3RpdmUga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0sIHJlbWFpbmluZ1RpbWUpO1xuICAgIFxuICAgIC8vIFN0b3JlIHRoZSB0aW1lciBJRFxuICAgIHRoaXMuaW5hY3Rpdml0eVRpbWVycy5zZXQoaWQsIHRpbWVyKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENsZWFyIGFueSBleGlzdGluZyBpbmFjdGl2aXR5IHRpbWVvdXQgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgY2xlYXJJbmFjdGl2aXR5VGltZW91dChpZDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaW5hY3Rpdml0eVRpbWVycy5oYXMoaWQpKSB7XG4gICAgICBjb25zdCB0aW1lcklkID0gdGhpcy5pbmFjdGl2aXR5VGltZXJzLmdldChpZCk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICB0aGlzLmluYWN0aXZpdHlUaW1lcnMuZGVsZXRlKGlkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGFjdGl2aXR5IHRpbWVzdGFtcCBmb3IgYSBrZXJuZWwgYW5kIHJlc2V0IGluYWN0aXZpdHkgdGltZXIgaWYgcHJlc2VudFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZUtlcm5lbEFjdGl2aXR5KGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgdGhlIGxhc3QgYWN0aXZpdHkgdGltZVxuICAgIHRoaXMubGFzdEFjdGl2aXR5VGltZS5zZXQoaWQsIERhdGUubm93KCkpO1xuICAgIFxuICAgIC8vIEdldCB0aGUga2VybmVsIG9wdGlvbnNcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCB0aW1lb3V0ID0gaW5zdGFuY2Uub3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dDtcbiAgICBcbiAgICAvLyBSZXNldCB0aGUgaW5hY3Rpdml0eSB0aW1lciBpZiB0aW1lb3V0IGlzIGVuYWJsZWQgKGdyZWF0ZXIgdGhhbiAwKVxuICAgIGlmICh0aW1lb3V0ICYmIHRpbWVvdXQgPiAwKSB7XG4gICAgICB0aGlzLnNldHVwSW5hY3Rpdml0eVRpbWVvdXQoaWQsIHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhc3QgYWN0aXZpdHkgdGltZSBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBMYXN0IGFjdGl2aXR5IHRpbWUgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoLCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAqL1xuICBwdWJsaWMgZ2V0TGFzdEFjdGl2aXR5VGltZShpZDogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5sYXN0QWN0aXZpdHlUaW1lLmdldChpZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbmFjdGl2aXR5IHRpbWVvdXQgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgSW5hY3Rpdml0eSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcywgb3IgdW5kZWZpbmVkIGlmIG5vdCBzZXRcbiAgICovXG4gIHB1YmxpYyBnZXRJbmFjdGl2aXR5VGltZW91dChpZDogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgcmV0dXJuIGluc3RhbmNlLm9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IG9yIHVwZGF0ZSB0aGUgaW5hY3Rpdml0eSB0aW1lb3V0IGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSB0aW1lb3V0IFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLCBvciAwIHRvIGRpc2FibGVcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdGltZW91dCB3YXMgc2V0LCBmYWxzZSBpZiB0aGUga2VybmVsIHdhcyBub3QgZm91bmRcbiAgICovXG4gIHB1YmxpYyBzZXRJbmFjdGl2aXR5VGltZW91dChpZDogc3RyaW5nLCB0aW1lb3V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBVcGRhdGUgdGhlIHRpbWVvdXQgaW4gdGhlIG9wdGlvbnNcbiAgICBpbnN0YW5jZS5vcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0ID0gdGltZW91dDtcbiAgICBcbiAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdGltZXJcbiAgICB0aGlzLmNsZWFySW5hY3Rpdml0eVRpbWVvdXQoaWQpO1xuICAgIFxuICAgIC8vIElmIHRpbWVvdXQgaXMgZ3JlYXRlciB0aGFuIDAsIHNldCB1cCBhIG5ldyB0aW1lclxuICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgdGhpcy5zZXR1cEluYWN0aXZpdHlUaW1lb3V0KGlkLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRpbWUgdW50aWwgYXV0by1zaHV0ZG93biBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBUaW1lIGluIG1pbGxpc2Vjb25kcyB1bnRpbCBhdXRvLXNodXRkb3duLCBvciB1bmRlZmluZWQgaWYgbm8gdGltZW91dCBpcyBzZXRcbiAgICovXG4gIHB1YmxpYyBnZXRUaW1lVW50aWxTaHV0ZG93bihpZDogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgY29uc3QgdGltZW91dCA9IGluc3RhbmNlLm9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQ7XG4gICAgaWYgKCF0aW1lb3V0IHx8IHRpbWVvdXQgPD0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBcbiAgICBjb25zdCBsYXN0QWN0aXZpdHkgPSB0aGlzLmxhc3RBY3Rpdml0eVRpbWUuZ2V0KGlkKTtcbiAgICBpZiAoIWxhc3RBY3Rpdml0eSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBcbiAgICBjb25zdCBlbGFwc2VkVGltZSA9IERhdGUubm93KCkgLSBsYXN0QWN0aXZpdHk7XG4gICAgY29uc3QgcmVtYWluaW5nVGltZSA9IHRpbWVvdXQgLSBlbGFwc2VkVGltZTtcbiAgICBcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgcmVtYWluaW5nVGltZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgb2YgaW5hY3Rpdml0eSB0aW1lcnMgKGZvciBkZWJ1Z2dpbmcvdGVzdGluZyBvbmx5KVxuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBrZXJuZWwgSURzIGFzIGtleXMgYW5kIHRpbWVyIElEcyBhcyB2YWx1ZXNcbiAgICovXG4gIHB1YmxpYyBnZXRJbmFjdGl2aXR5VGltZXJzKCk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xuICAgIC8vIENvbnZlcnQgTWFwIHRvIE9iamVjdCBmb3IgZWFzaWVyIGluc3BlY3Rpb25cbiAgICBjb25zdCB0aW1lcnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICB0aGlzLmluYWN0aXZpdHlUaW1lcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGltZXJzW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGltZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCBhIGhhbmRsZXIgZm9yIHN0YWxsZWQgZXhlY3V0aW9uc1xuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHNldHVwU3RhbGxlZEV4ZWN1dGlvbkhhbmRsZXIoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIExpc3RlbiBmb3Igc3RhbGxlZCBleGVjdXRpb24gZXZlbnRzXG4gICAgc3VwZXIub24oS2VybmVsRXZlbnRzLkVYRUNVVElPTl9TVEFMTEVELCAoZXZlbnQ6IHsga2VybmVsSWQ6IHN0cmluZywgZXhlY3V0aW9uSWQ6IHN0cmluZywgbWF4RXhlY3V0aW9uVGltZTogbnVtYmVyIH0pID0+IHtcbiAgICAgIGlmIChldmVudC5rZXJuZWxJZCA9PT0gaWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBIYW5kbGluZyBzdGFsbGVkIGV4ZWN1dGlvbiAke2V2ZW50LmV4ZWN1dGlvbklkfSBvbiBrZXJuZWwgJHtpZH0gKHJ1bm5pbmcgbG9uZ2VyIHRoYW4gJHtldmVudC5tYXhFeGVjdXRpb25UaW1lfW1zKWApO1xuICAgICAgICBcbiAgICAgICAgLy8gRW1pdCBhbiBldmVudCBmb3IgY2xpZW50cyB0byBoYW5kbGVcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwge1xuICAgICAgICAgICAga2VybmVsSWQ6IGlkLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBlbmFtZTogXCJFeGVjdXRpb25TdGFsbGVkRXJyb3JcIixcbiAgICAgICAgICAgICAgZXZhbHVlOiBgRXhlY3V0aW9uIHN0YWxsZWQgb3IgcG90ZW50aWFsbHkgZGVhZGxvY2tlZCAocnVubmluZyA+ICR7ZXZlbnQubWF4RXhlY3V0aW9uVGltZX1tcylgLFxuICAgICAgICAgICAgICB0cmFjZWJhY2s6IFtcIkV4ZWN1dGlvbiBtYXkgYmUgc3R1Y2sgaW4gYW4gaW5maW5pdGUgbG9vcCBvciBkZWFkbG9ja2VkLlwiXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgdGVybWluYXRlIGEgcG90ZW50aWFsbHkgc3R1Y2sga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIHJlYXNvbiBPcHRpb25hbCByZWFzb24gZm9yIHRlcm1pbmF0aW9uXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRydWUgaWYgdGhlIGtlcm5lbCB3YXMgdGVybWluYXRlZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGZvcmNlVGVybWluYXRlS2VybmVsKGlkOiBzdHJpbmcsIHJlYXNvbiA9IFwiRm9yY2UgdGVybWluYXRlZCBkdWUgdG8gc3RhbGxlZCBleGVjdXRpb25cIik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgXG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gTG9nIHRoZSBmb3JjZWQgdGVybWluYXRpb25cbiAgICAgIGNvbnNvbGUud2FybihgRm9yY2UgdGVybWluYXRpbmcga2VybmVsICR7aWR9OiAke3JlYXNvbn1gKTtcbiAgICAgIFxuICAgICAgLy8gRW1pdCBhbiBlcnJvciBldmVudCB0byBub3RpZnkgY2xpZW50c1xuICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwge1xuICAgICAgICBrZXJuZWxJZDogaWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBlbmFtZTogXCJLZXJuZWxGb3JjZWRUZXJtaW5hdGlvblwiLFxuICAgICAgICAgIGV2YWx1ZTogcmVhc29uLFxuICAgICAgICAgIHRyYWNlYmFjazogW1wiS2VybmVsIHdhcyBmb3JjZWZ1bGx5IHRlcm1pbmF0ZWQgYnkgdGhlIHN5c3RlbS5cIl1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIERlc3Ryb3kgdGhlIGtlcm5lbFxuICAgICAgYXdhaXQgdGhpcy5kZXN0cm95S2VybmVsKGlkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkdXJpbmcgZm9yY2VkIHRlcm1pbmF0aW9uIG9mIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBvbmdvaW5nIGV4ZWN1dGlvbnMgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgSW5mb3JtYXRpb24gYWJvdXQgb25nb2luZyBleGVjdXRpb25zIHdpdGggYWNjdXJhdGUgdGltaW5nXG4gICAqL1xuICBwdWJsaWMgZ2V0RXhlY3V0aW9uSW5mbyhpZDogc3RyaW5nKTogeyBcbiAgICBjb3VudDogbnVtYmVyOyBcbiAgICBpc1N0dWNrOiBib29sZWFuOyBcbiAgICBleGVjdXRpb25JZHM6IHN0cmluZ1tdO1xuICAgIGxvbmdlc3RSdW5uaW5nVGltZT86IG51bWJlcjtcbiAgICBleGVjdXRpb25zOiBBcnJheTx7XG4gICAgICBpZDogc3RyaW5nO1xuICAgICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgICBydW50aW1lOiBudW1iZXI7XG4gICAgICBjb2RlPzogc3RyaW5nO1xuICAgICAgaXNTdHVjazogYm9vbGVhbjtcbiAgICB9PjtcbiAgfSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4geyBjb3VudDogMCwgaXNTdHVjazogZmFsc2UsIGV4ZWN1dGlvbklkczogW10sIGV4ZWN1dGlvbnM6IFtdIH07XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBwYXJ0aWFsbHkgaW5pdGlhbGl6ZWQga2VybmVscyB3aGVyZSBvcHRpb25zIG1heSBub3QgYmUgZnVsbHkgc2V0XG4gICAgaWYgKCFpbnN0YW5jZS5vcHRpb25zKSB7XG4gICAgICByZXR1cm4geyBjb3VudDogMCwgaXNTdHVjazogZmFsc2UsIGV4ZWN1dGlvbklkczogW10sIGV4ZWN1dGlvbnM6IFtdIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGV4ZWN1dGlvbklkcyA9IHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZ2V0KGlkKSBcbiAgICAgID8gQXJyYXkuZnJvbSh0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChpZCkhKVxuICAgICAgOiBbXTtcbiAgICBcbiAgICBjb25zdCBjb3VudCA9IGV4ZWN1dGlvbklkcy5sZW5ndGg7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG1heEV4ZWN1dGlvblRpbWUgPSBpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWU7XG4gICAgXG4gICAgLy8gQnVpbGQgZGV0YWlsZWQgZXhlY3V0aW9uIGluZm9ybWF0aW9uXG4gICAgY29uc3QgZXhlY3V0aW9uczogQXJyYXk8e1xuICAgICAgaWQ6IHN0cmluZztcbiAgICAgIHN0YXJ0VGltZTogbnVtYmVyO1xuICAgICAgcnVudGltZTogbnVtYmVyO1xuICAgICAgY29kZT86IHN0cmluZztcbiAgICAgIGlzU3R1Y2s6IGJvb2xlYW47XG4gICAgfT4gPSBbXTtcbiAgICBcbiAgICBsZXQgbG9uZ2VzdFJ1bm5pbmdUaW1lOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IGFueVN0dWNrID0gZmFsc2U7XG4gICAgXG4gICAgLy8gR2V0IGV4ZWN1dGlvbiBzdGFydCB0aW1lcyBhbmQgbWV0YWRhdGFcbiAgICBjb25zdCBzdGFydFRpbWVzID0gdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmdldChpZCk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmdldChpZCk7XG4gICAgXG4gICAgZm9yIChjb25zdCBleGVjdXRpb25JZCBvZiBleGVjdXRpb25JZHMpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHN0YXJ0VGltZXM/LmdldChleGVjdXRpb25JZCk7XG4gICAgICBjb25zdCBleGVjTWV0YWRhdGEgPSBtZXRhZGF0YT8uZ2V0KGV4ZWN1dGlvbklkKTtcbiAgICAgIFxuICAgICAgaWYgKHN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHJ1bnRpbWUgPSBjdXJyZW50VGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgaXNTdHVjayA9IG1heEV4ZWN1dGlvblRpbWUgIT09IHVuZGVmaW5lZCAmJiBydW50aW1lID4gbWF4RXhlY3V0aW9uVGltZTtcbiAgICAgICAgXG4gICAgICAgIGV4ZWN1dGlvbnMucHVzaCh7XG4gICAgICAgICAgaWQ6IGV4ZWN1dGlvbklkLFxuICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICBydW50aW1lLFxuICAgICAgICAgIGNvZGU6IGV4ZWNNZXRhZGF0YT8uY29kZSxcbiAgICAgICAgICBpc1N0dWNrXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJhY2sgbG9uZ2VzdCBydW5uaW5nIHRpbWVcbiAgICAgICAgaWYgKGxvbmdlc3RSdW5uaW5nVGltZSA9PT0gdW5kZWZpbmVkIHx8IHJ1bnRpbWUgPiBsb25nZXN0UnVubmluZ1RpbWUpIHtcbiAgICAgICAgICBsb25nZXN0UnVubmluZ1RpbWUgPSBydW50aW1lO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBUcmFjayBpZiBhbnkgZXhlY3V0aW9uIGlzIHN0dWNrXG4gICAgICAgIGlmIChpc1N0dWNrKSB7XG4gICAgICAgICAgYW55U3R1Y2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayBmb3IgZXhlY3V0aW9ucyB3aXRob3V0IHN0YXJ0IHRpbWUgdHJhY2tpbmdcbiAgICAgICAgY29uc29sZS53YXJuKGBObyBzdGFydCB0aW1lIGZvdW5kIGZvciBleGVjdXRpb24gJHtleGVjdXRpb25JZH0gb24ga2VybmVsICR7aWR9YCk7XG4gICAgICAgIGV4ZWN1dGlvbnMucHVzaCh7XG4gICAgICAgICAgaWQ6IGV4ZWN1dGlvbklkLFxuICAgICAgICAgIHN0YXJ0VGltZTogMCxcbiAgICAgICAgICBydW50aW1lOiAwLFxuICAgICAgICAgIGNvZGU6IGV4ZWNNZXRhZGF0YT8uY29kZSxcbiAgICAgICAgICBpc1N0dWNrOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU29ydCBleGVjdXRpb25zIGJ5IHN0YXJ0IHRpbWUgKG9sZGVzdCBmaXJzdClcbiAgICBleGVjdXRpb25zLnNvcnQoKGEsIGIpID0+IGEuc3RhcnRUaW1lIC0gYi5zdGFydFRpbWUpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBjb3VudCxcbiAgICAgIGlzU3R1Y2s6IGFueVN0dWNrLFxuICAgICAgZXhlY3V0aW9uSWRzLFxuICAgICAgbG9uZ2VzdFJ1bm5pbmdUaW1lLFxuICAgICAgZXhlY3V0aW9uc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBQeXRob24gY29kZSBpbiBhIGtlcm5lbFxuICAgKiBVc2VzIGV4ZWN1dGVTdHJlYW0gdG8gY29sbGVjdCBhbGwgb3V0cHV0cyBhbmQgcmV0dXJuIHRoZW1cbiAgICogQHBhcmFtIGtlcm5lbElkIElEIG9mIHRoZSBrZXJuZWwgdG8gdXNlXG4gICAqIEBwYXJhbSBjb2RlIFB5dGhvbiBjb2RlIHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIHBhcmVudCBPcHRpb25hbCBwYXJlbnQgbWVzc2FnZSBoZWFkZXJcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gZXhlY3V0aW9uIHJlc3VsdCB3aXRoIGNvbGxlY3RlZCBvdXRwdXRzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZXhlY3V0ZShcbiAgICBrZXJuZWxJZDogc3RyaW5nLFxuICAgIGNvZGU6IHN0cmluZyxcbiAgICBwYXJlbnQ6IGFueSA9IHt9XG4gICk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuLCBvdXRwdXRzPzogYW55LCBlcnJvcj86IEVycm9yLCBlbmFtZT86IHN0cmluZywgZXZhbHVlPzogc3RyaW5nLCB0cmFjZWJhY2s/OiBhbnkgfT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRLZXJuZWwoa2VybmVsSWQpO1xuICAgIFxuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsIHdpdGggSUQgJHtrZXJuZWxJZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBpbnN0YW5jZS5rZXJuZWwuZXhlY3V0ZShjb2RlLCBwYXJlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEga2VybmVsIHR5cGUgaXMgYWxsb3dlZFxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGtlcm5lbCB0eXBlIGlzIGFsbG93ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgaXNLZXJuZWxUeXBlQWxsb3dlZChtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd2VkS2VybmVsVHlwZXMuc29tZSh0eXBlID0+IFxuICAgICAgdHlwZS5tb2RlID09PSBtb2RlICYmIHR5cGUubGFuZ3VhZ2UgPT09IGxhbmd1YWdlXG4gICAgKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBvZiBhbGxvd2VkIGtlcm5lbCB0eXBlc1xuICAgKiBAcmV0dXJucyBBcnJheSBvZiBhbGxvd2VkIGtlcm5lbCB0eXBlIGNvbmZpZ3VyYXRpb25zXG4gICAqL1xuICBwdWJsaWMgZ2V0QWxsb3dlZEtlcm5lbFR5cGVzKCk6IEFycmF5PHtcbiAgICBtb2RlOiBLZXJuZWxNb2RlO1xuICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgfT4ge1xuICAgIHJldHVybiBbLi4udGhpcy5hbGxvd2VkS2VybmVsVHlwZXNdOyAvLyBSZXR1cm4gYSBjb3B5IHRvIHByZXZlbnQgbW9kaWZpY2F0aW9uXG4gIH1cblxuICAvKipcbiAgICogUGluZyBhIGtlcm5lbCB0byByZXNldCBpdHMgYWN0aXZpdHkgdGltZXIgYW5kIGV4dGVuZCB0aGUgZGVhZGxpbmVcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBrZXJuZWwgd2FzIHBpbmdlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgcHVibGljIHBpbmdLZXJuZWwoaWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUga2VybmVsIGFjdGl2aXR5ICh0aGlzIHdpbGwgcmVzZXQgdGhlIGluYWN0aXZpdHkgdGltZXIpXG4gICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShpZCk7XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVzdGFydCBhIGtlcm5lbCBieSBkZXN0cm95aW5nIGl0IGFuZCBjcmVhdGluZyBhIG5ldyBvbmUgd2l0aCB0aGUgc2FtZSBJRCBhbmQgY29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRydWUgaWYgdGhlIGtlcm5lbCB3YXMgcmVzdGFydGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgbm90IGZvdW5kXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcmVzdGFydEtlcm5lbChpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENhbm5vdCByZXN0YXJ0IGtlcm5lbCAke2lkfToga2VybmVsIG5vdCBmb3VuZGApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvblxuICAgICAgY29uc3QgY3VycmVudENvbmZpZyA9IHtcbiAgICAgICAgbW9kZTogaW5zdGFuY2UubW9kZSxcbiAgICAgICAgbGFuZ3VhZ2U6IGluc3RhbmNlLmxhbmd1YWdlLFxuICAgICAgICBvcHRpb25zOiB7IC4uLmluc3RhbmNlLm9wdGlvbnMgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gRXh0cmFjdCBuYW1lc3BhY2UgZnJvbSBJRCBpZiBwcmVzZW50XG4gICAgICBsZXQgbmFtZXNwYWNlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICBsZXQgYmFzZUlkOiBzdHJpbmc7XG4gICAgICBcbiAgICAgIGlmIChpZC5pbmNsdWRlcygnOicpKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gaWQuc3BsaXQoJzonKTtcbiAgICAgICAgbmFtZXNwYWNlID0gcGFydHNbMF07XG4gICAgICAgIGJhc2VJZCA9IHBhcnRzWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUlkID0gaWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERlc3Ryb3kgdGhlIGV4aXN0aW5nIGtlcm5lbFxuICAgICAgYXdhaXQgdGhpcy5kZXN0cm95S2VybmVsKGlkKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IGtlcm5lbCB3aXRoIHRoZSBzYW1lIGNvbmZpZ3VyYXRpb25cbiAgICAgIGNvbnN0IHJlc3RhcnRPcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnMgPSB7XG4gICAgICAgIGlkOiBiYXNlSWQsXG4gICAgICAgIG1vZGU6IGN1cnJlbnRDb25maWcubW9kZSxcbiAgICAgICAgbGFuZzogY3VycmVudENvbmZpZy5sYW5ndWFnZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBkZW5vOiBjdXJyZW50Q29uZmlnLm9wdGlvbnMuZGVubyxcbiAgICAgICAgZmlsZXN5c3RlbTogY3VycmVudENvbmZpZy5vcHRpb25zLmZpbGVzeXN0ZW0sXG4gICAgICAgIGluYWN0aXZpdHlUaW1lb3V0OiBjdXJyZW50Q29uZmlnLm9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQsXG4gICAgICAgIG1heEV4ZWN1dGlvblRpbWU6IGN1cnJlbnRDb25maWcub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgdGhlIG5ldyBrZXJuZWxcbiAgICAgIGNvbnN0IG5ld0tlcm5lbElkID0gYXdhaXQgdGhpcy5jcmVhdGVLZXJuZWwocmVzdGFydE9wdGlvbnMpO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgdGhlIG5ldyBrZXJuZWwgaGFzIHRoZSBzYW1lIElEXG4gICAgICBpZiAobmV3S2VybmVsSWQgIT09IGlkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEtlcm5lbCByZXN0YXJ0IGZhaWxlZDogZXhwZWN0ZWQgSUQgJHtpZH0sIGdvdCAke25ld0tlcm5lbElkfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlc3RhcnRpbmcga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJydXB0IGEgcnVubmluZyBrZXJuZWwgZXhlY3V0aW9uXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZSBpZiB0aGUgaW50ZXJydXB0IHdhcyBzdWNjZXNzZnVsLCBmYWxzZSBpZiBub3QgZm91bmQgb3IgZmFpbGVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW50ZXJydXB0S2VybmVsKGlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ2Fubm90IGludGVycnVwdCBrZXJuZWwgJHtpZH06IGtlcm5lbCBub3QgZm91bmRgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGlmIChpbnN0YW5jZS5tb2RlID09PSBLZXJuZWxNb2RlLldPUktFUiAmJiBpbnN0YW5jZS53b3JrZXIpIHtcbiAgICAgICAgLy8gRm9yIHdvcmtlciBrZXJuZWxzLCB1c2UgU2hhcmVkQXJyYXlCdWZmZXIgaW50ZXJydXB0IG1ldGhvZFxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbnRlcnJ1cHRXb3JrZXJLZXJuZWwoaWQsIGluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBtYWluIHRocmVhZCBrZXJuZWxzLCB0cnkgdG8gaW50ZXJydXB0ICh3aWxsIHRocm93IGVycm9yIGlmIG5vdCBzdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmludGVycnVwdE1haW5UaHJlYWRLZXJuZWwoaWQsIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW50ZXJydXB0aW5nIGtlcm5lbCAke2lkfTpgLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcikpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEludGVycnVwdCBhIG1haW4gdGhyZWFkIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBpbnN0YW5jZSBLZXJuZWwgaW5zdGFuY2VcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gaW50ZXJydXB0IHN1Y2Nlc3NcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW50ZXJydXB0TWFpblRocmVhZEtlcm5lbChpZDogc3RyaW5nLCBpbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gTWFpbiB0aHJlYWQga2VybmVscyBkb24ndCBzdXBwb3J0IHByb3BlciBpbnRlcnJ1cHRpb24gbGlrZSB3b3JrZXIga2VybmVscyBkb1xuICAgIC8vIEV2ZW4gaWYgdGhleSBoYXZlIGFuIGludGVycnVwdCBtZXRob2QsIGl0J3MgbGltaXRlZCBhbmQgdW5yZWxpYWJsZVxuICAgIHRocm93IG5ldyBFcnJvcihgTWFpbiB0aHJlYWQga2VybmVsICR7aWR9IGRvZXMgbm90IHN1cHBvcnQgcmVsaWFibGUgaW50ZXJydXB0aW9uLiBVc2Ugd29ya2VyIGtlcm5lbHMgZm9yIGludGVycnVwdGlibGUgZXhlY3V0aW9uLmApO1xuICB9XG4gIFxuICAvKipcbiAgICogSW50ZXJydXB0IGEgd29ya2VyIGtlcm5lbCB1c2luZyBTaGFyZWRBcnJheUJ1ZmZlciBhY2NvcmRpbmcgdG8gUHlvZGlkZSBkb2N1bWVudGF0aW9uXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIGluc3RhbmNlIEtlcm5lbCBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBpbnRlcnJ1cHQgc3VjY2Vzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbnRlcnJ1cHRXb3JrZXJLZXJuZWwoaWQ6IHN0cmluZywgaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB3b3JrZXIgPSBpbnN0YW5jZS53b3JrZXI7XG4gICAgICBpZiAoIXdvcmtlcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXb3JrZXIgbm90IGZvdW5kIGZvciBrZXJuZWwgJHtpZH1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBpbnRlcnJ1cHRpb24gbW9kZSBpcyAna2VybmVsLWludGVycnVwdCcsIHVzZSBmYWxsYmFjayBkaXJlY3RseVxuICAgICAgaWYgKHRoaXMuaW50ZXJydXB0aW9uTW9kZSA9PT0gJ2tlcm5lbC1pbnRlcnJ1cHQnKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmludGVycnVwdFdvcmtlcktlcm5lbEZhbGxiYWNrKGlkLCB3b3JrZXIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgYW4gaW50ZXJydXB0IGJ1ZmZlciBmb3IgdGhpcyBrZXJuZWxcbiAgICAgIGxldCBpbnRlcnJ1cHRCdWZmZXIgPSB0aGlzLmludGVycnVwdEJ1ZmZlcnMuZ2V0KGlkKTtcbiAgICAgIFxuICAgICAgaWYgKCFpbnRlcnJ1cHRCdWZmZXIpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IFNoYXJlZEFycmF5QnVmZmVyIGZvciBpbnRlcnJ1cHQgY29udHJvbFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRyeSB0byBjcmVhdGUgU2hhcmVkQXJyYXlCdWZmZXIgKHJlcXVpcmVzIHNwZWNpZmljIHNlY3VyaXR5IGhlYWRlcnMpXG4gICAgICAgICAgY29uc3Qgc2hhcmVkQnVmZmVyID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpO1xuICAgICAgICAgIGludGVycnVwdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHNoYXJlZEJ1ZmZlcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSBidWZmZXIgdG8gMCAobm8gaW50ZXJydXB0IHNpZ25hbClcbiAgICAgICAgICBpbnRlcnJ1cHRCdWZmZXJbMF0gPSAwO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFN0b3JlIHRoZSBidWZmZXIgZm9yIGZ1dHVyZSB1c2VcbiAgICAgICAgICB0aGlzLmludGVycnVwdEJ1ZmZlcnMuc2V0KGlkLCBpbnRlcnJ1cHRCdWZmZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNlbmQgdGhlIGJ1ZmZlciB0byB0aGUgd29ya2VyIHRvIHNldCB1cCBweW9kaWRlLnNldEludGVycnVwdEJ1ZmZlcigpXG4gICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiU0VUX0lOVEVSUlVQVF9CVUZGRVJcIixcbiAgICAgICAgICAgIGJ1ZmZlcjogaW50ZXJydXB0QnVmZmVyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHdvcmtlciB0byBjb25maXJtIGJ1ZmZlciBzZXR1cFxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVvdXQgd2FpdGluZyBmb3IgaW50ZXJydXB0IGJ1ZmZlciBzZXR1cFwiKSk7XG4gICAgICAgICAgICB9LCAyMDAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIklOVEVSUlVQVF9CVUZGRVJfU0VUXCIpIHtcbiAgICAgICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBJbnRlcnJ1cHQgYnVmZmVyIHNldCB1cCBmb3Iga2VybmVsICR7aWR9YCk7XG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIGJhc2VkIG9uIGludGVycnVwdGlvbiBtb2RlXG4gICAgICAgICAgaWYgKHRoaXMuaW50ZXJydXB0aW9uTW9kZSA9PT0gJ3NoYXJlZC1hcnJheS1idWZmZXInKSB7XG4gICAgICAgICAgICAvLyBJZiBleHBsaWNpdGx5IHNldCB0byBzaGFyZWQtYXJyYXktYnVmZmVyLCB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgQ2Fubm90IGNyZWF0ZSBTaGFyZWRBcnJheUJ1ZmZlciBmb3IgaW50ZXJydXB0IGhhbmRsaW5nIGluIGtlcm5lbCAke2lkfWApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaGFyZWRBcnJheUJ1ZmZlciBpcyByZXF1aXJlZCBmb3IgaW50ZXJydXB0aW9uIG1vZGUgJ3NoYXJlZC1hcnJheS1idWZmZXInIGJ1dCBpcyBub3QgYXZhaWxhYmxlLlxuXG5UbyBmaXggdGhpcyBpc3N1ZSwgZWl0aGVyOlxuMS4gQ29uZmlndXJlIHlvdXIgd2ViIHNlcnZlciB3aXRoIHRoZXNlIGhlYWRlcnM6XG4gICAtIENyb3NzLU9yaWdpbi1PcGVuZXItUG9saWN5OiBzYW1lLW9yaWdpblxuICAgLSBDcm9zcy1PcmlnaW4tRW1iZWRkZXItUG9saWN5OiByZXF1aXJlLWNvcnBcblxuMi4gT3IgY2hhbmdlIHRoZSBpbnRlcnJ1cHRpb24gbW9kZSB3aGVuIGNyZWF0aW5nIEtlcm5lbE1hbmFnZXI6XG4gICBuZXcgS2VybmVsTWFuYWdlcih7IGludGVycnVwdGlvbk1vZGU6ICdhdXRvJyB9KWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBdXRvIG1vZGU6IGZhbGwgYmFjayB0byBrZXJuZWwuaW50ZXJydXB0KClcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhg4oS577iPIFVzaW5nIG1lc3NhZ2UtYmFzZWQgaW50ZXJydXB0IGZvciBrZXJuZWwgJHtpZH0gKFNoYXJlZEFycmF5QnVmZmVyIG5vdCBhdmFpbGFibGUpYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrOiB1c2UgbWVzc2FnZS1iYXNlZCBpbnRlcnJ1cHRcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmludGVycnVwdFdvcmtlcktlcm5lbEZhbGxiYWNrKGlkLCB3b3JrZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBY2NvcmRpbmcgdG8gUHlvZGlkZSBkb2NzOiBTZXQgaW50ZXJydXB0IHNpZ25hbCAoMiA9IFNJR0lOVClcbiAgICAgIGNvbnNvbGUubG9nKGBTZXR0aW5nIGludGVycnVwdCBzaWduYWwgZm9yIGtlcm5lbCAke2lkfS4uLmApO1xuICAgICAgaW50ZXJydXB0QnVmZmVyWzBdID0gMjtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgUHlvZGlkZSB0byBwcm9jZXNzIHRoZSBpbnRlcnJ1cHRcbiAgICAgIC8vIFB5b2RpZGUgd2lsbCByZXNldCB0aGUgYnVmZmVyIHRvIDAgd2hlbiBpdCBwcm9jZXNzZXMgdGhlIGludGVycnVwdFxuICAgICAgbGV0IGF0dGVtcHRzID0gMDtcbiAgICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNTA7IC8vIENoZWNrIGZvciB1cCB0byA1IHNlY29uZHMgKDUwICogMTAwbXMpXG4gICAgICBcbiAgICAgIHdoaWxlIChhdHRlbXB0cyA8IG1heEF0dGVtcHRzICYmIGludGVycnVwdEJ1ZmZlclswXSAhPT0gMCkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICAgIGF0dGVtcHRzKys7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChpbnRlcnJ1cHRCdWZmZXJbMF0gPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYEludGVycnVwdCBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5IGZvciBrZXJuZWwgJHtpZH0gYWZ0ZXIgJHthdHRlbXB0cyAqIDEwMH1tc2ApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW50ZXJydXB0IHNpZ25hbCBub3QgcHJvY2Vzc2VkIGZvciBrZXJuZWwgJHtpZH0gYWZ0ZXIgJHttYXhBdHRlbXB0cyAqIDEwMH1tc2ApO1xuICAgICAgICAvLyBTdGlsbCByZXR1cm4gdHJ1ZSBhcyB3ZSBzZXQgdGhlIHNpZ25hbCAtIHRoZSBpbnRlcnJ1cHQgbWF5IGJlIHByb2Nlc3NlZCBsYXRlclxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbnRlcnJ1cHRpbmcgd29ya2VyIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogRmFsbGJhY2sgaW50ZXJydXB0IG1ldGhvZCBmb3Igd29ya2VyIGtlcm5lbHMgd2hlbiBTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIHdvcmtlciBXb3JrZXIgaW5zdGFuY2VcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gaW50ZXJydXB0IHN1Y2Nlc3NcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW50ZXJydXB0V29ya2VyS2VybmVsRmFsbGJhY2soaWQ6IHN0cmluZywgd29ya2VyOiBXb3JrZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8Ym9vbGVhbj4oKHJlc29sdmUpID0+IHtcbiAgICAgIC8vIFNldCB1cCBhIGxpc3RlbmVyIGZvciB0aGUgaW50ZXJydXB0IHJlc3BvbnNlXG4gICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJJTlRFUlJVUFRfVFJJR0dFUkVEXCIpIHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICAgICAgICBjb25zdCBzdWNjZXNzID0gZXZlbnQuZGF0YS5kYXRhPy5zdWNjZXNzIHx8IGZhbHNlO1xuICAgICAgICAgIHJlc29sdmUoc3VjY2Vzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIExpc3RlbiBmb3IgdGhlIHJlc3BvbnNlXG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICAgIFxuICAgICAgLy8gU2VuZCB0aGUgaW50ZXJydXB0IG1lc3NhZ2VcbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiSU5URVJSVVBUX0tFUk5FTFwiXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2V0IGEgdGltZW91dCBpbiBjYXNlIHdlIGRvbid0IGdldCBhIHJlc3BvbnNlXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgICAgIGNvbnNvbGUud2Fybihg4o+x77iPIEludGVycnVwdCByZXF1ZXN0IHRpbWVkIG91dCBmb3Iga2VybmVsICR7aWR9IGFmdGVyIDUgc2Vjb25kcy5cblRoaXMgbWF5IGhhcHBlbiBpZjpcbi0gVGhlIGtlcm5lbCBpcyBydW5uaW5nIGNvZGUgdGhhdCBjYW5ub3QgYmUgaW50ZXJydXB0ZWRcbi0gVGhlIGtlcm5lbCBpcyBpbiBhbiB1bnJlc3BvbnNpdmUgc3RhdGVcbllvdSBtYXkgbmVlZCB0byByZXN0YXJ0IHRoZSBrZXJuZWwgaWYgaXQgcmVtYWlucyB1bnJlc3BvbnNpdmUuYCk7XG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgfSwgNTAwMCk7IC8vIDUgc2Vjb25kIHRpbWVvdXRcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBzdHVjayBleGVjdXRpb24gd2l0aCBjb25maWd1cmFibGUgc3RyYXRlZ2llc1xuICAgKiBAcGFyYW0ga2VybmVsSWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBleGVjdXRpb25JZCBFeGVjdXRpb24gSUQgdGhhdCdzIHN0dWNrXG4gICAqIEBwYXJhbSBhY3R1YWxSdW50aW1lIEhvdyBsb25nIHRoZSBleGVjdXRpb24gaGFzIGJlZW4gcnVubmluZ1xuICAgKiBAcGFyYW0gY29kZSBUaGUgY29kZSB0aGF0IHdhcyBiZWluZyBleGVjdXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVTdHVja0V4ZWN1dGlvbihrZXJuZWxJZDogc3RyaW5nLCBleGVjdXRpb25JZDogc3RyaW5nLCBhY3R1YWxSdW50aW1lOiBudW1iZXIsIGNvZGU/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS53YXJuKGBIYW5kbGluZyBzdHVjayBleGVjdXRpb24gJHtleGVjdXRpb25JZH0gb24ga2VybmVsICR7a2VybmVsSWR9IChydW50aW1lOiAke2FjdHVhbFJ1bnRpbWV9bXMpYCk7XG4gICAgXG4gICAgLy8gU3RyYXRlZ3kgMTogVHJ5IHRvIGludGVycnVwdCB0aGUga2VybmVsIGZpcnN0XG4gICAgY29uc3QgaW50ZXJydXB0U3VjY2VzcyA9IGF3YWl0IHRoaXMuaW50ZXJydXB0S2VybmVsKGtlcm5lbElkKTtcbiAgICBcbiAgICBpZiAoaW50ZXJydXB0U3VjY2Vzcykge1xuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBpbnRlcnJ1cHRlZCBrZXJuZWwgJHtrZXJuZWxJZH1gKTtcbiAgICAgIFxuICAgICAgLy8gRW1pdCBhbiBleGVjdXRpb24gZXJyb3IgdG8gbm90aWZ5IGNsaWVudHNcbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsIHtcbiAgICAgICAga2VybmVsSWQ6IGtlcm5lbElkLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZW5hbWU6IFwiRXhlY3V0aW9uSW50ZXJydXB0ZWRcIixcbiAgICAgICAgICBldmFsdWU6IGBFeGVjdXRpb24gYXV0b21hdGljYWxseSBpbnRlcnJ1cHRlZCBhZnRlciAke2FjdHVhbFJ1bnRpbWV9bXMgKGV4Y2VlZGVkIG1heEV4ZWN1dGlvblRpbWUpYCxcbiAgICAgICAgICB0cmFjZWJhY2s6IFtcbiAgICAgICAgICAgIGBFeGVjdXRpb24gd2FzIGF1dG9tYXRpY2FsbHkgaW50ZXJydXB0ZWQgZHVlIHRvIHRpbWVvdXQuYCxcbiAgICAgICAgICAgIGBSdW50aW1lOiAke2FjdHVhbFJ1bnRpbWV9bXNgLFxuICAgICAgICAgICAgYE1heCBhbGxvd2VkOiAke2luc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZX1tc2AsXG4gICAgICAgICAgICBjb2RlID8gYENvZGU6ICR7Y29kZS5zdWJzdHJpbmcoMCwgMjAwKX0ke2NvZGUubGVuZ3RoID4gMjAwID8gJy4uLicgOiAnJ31gIDogJ0NvZGU6IDx1bmtub3duPidcbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFN0cmF0ZWd5IDI6IElmIGludGVycnVwdCBmYWlsZWQsIHRyeSByZXN0YXJ0aW5nIHRoZSBrZXJuZWxcbiAgICBjb25zb2xlLndhcm4oYEludGVycnVwdCBmYWlsZWQgZm9yIGtlcm5lbCAke2tlcm5lbElkfSwgYXR0ZW1wdGluZyByZXN0YXJ0Li4uYCk7XG4gICAgY29uc3QgcmVzdGFydFN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnJlc3RhcnRLZXJuZWwoa2VybmVsSWQpO1xuICAgIFxuICAgIGlmIChyZXN0YXJ0U3VjY2Vzcykge1xuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSByZXN0YXJ0ZWQga2VybmVsICR7a2VybmVsSWR9YCk7XG4gICAgICBcbiAgICAgIC8vIEVtaXQgYSByZXN0YXJ0IG5vdGlmaWNhdGlvblxuICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwge1xuICAgICAgICBrZXJuZWxJZDoga2VybmVsSWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBlbmFtZTogXCJLZXJuZWxSZXN0YXJ0ZWRcIixcbiAgICAgICAgICBldmFsdWU6IGBLZXJuZWwgYXV0b21hdGljYWxseSByZXN0YXJ0ZWQgZHVlIHRvIHN0dWNrIGV4ZWN1dGlvbiAocnVudGltZTogJHthY3R1YWxSdW50aW1lfW1zKWAsXG4gICAgICAgICAgdHJhY2ViYWNrOiBbXG4gICAgICAgICAgICBgS2VybmVsIHdhcyBhdXRvbWF0aWNhbGx5IHJlc3RhcnRlZCBkdWUgdG8gc3R1Y2sgZXhlY3V0aW9uLmAsXG4gICAgICAgICAgICBgUnVudGltZTogJHthY3R1YWxSdW50aW1lfW1zYCxcbiAgICAgICAgICAgIGBNYXggYWxsb3dlZDogJHtpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWV9bXNgLFxuICAgICAgICAgICAgYEludGVycnVwdCBhdHRlbXB0IGZhaWxlZCwga2VybmVsIHdhcyByZXN0YXJ0ZWQgaW5zdGVhZC5gLFxuICAgICAgICAgICAgY29kZSA/IGBDb2RlOiAke2NvZGUuc3Vic3RyaW5nKDAsIDIwMCl9JHtjb2RlLmxlbmd0aCA+IDIwMCA/ICcuLi4nIDogJyd9YCA6ICdDb2RlOiA8dW5rbm93bj4nXG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdHJhdGVneSAzOiBJZiByZXN0YXJ0IGZhaWxlZCwgZm9yY2UgdGVybWluYXRlIHRoZSBrZXJuZWxcbiAgICBjb25zb2xlLmVycm9yKGBSZXN0YXJ0IGZhaWxlZCBmb3Iga2VybmVsICR7a2VybmVsSWR9LCBmb3JjZSB0ZXJtaW5hdGluZy4uLmApO1xuICAgIGNvbnN0IHRlcm1pbmF0ZVN1Y2Nlc3MgPSBhd2FpdCB0aGlzLmZvcmNlVGVybWluYXRlS2VybmVsKFxuICAgICAga2VybmVsSWQsIFxuICAgICAgYFN0dWNrIGV4ZWN1dGlvbiBjb3VsZCBub3QgYmUgaW50ZXJydXB0ZWQgb3IgcmVzdGFydGVkIChydW50aW1lOiAke2FjdHVhbFJ1bnRpbWV9bXMpYFxuICAgICk7XG4gICAgXG4gICAgaWYgKHRlcm1pbmF0ZVN1Y2Nlc3MpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgdGVybWluYXRlZCBrZXJuZWwgJHtrZXJuZWxJZH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHRlcm1pbmF0ZSBrZXJuZWwgJHtrZXJuZWxJZH0gLSBtYW51YWwgaW50ZXJ2ZW50aW9uIG1heSBiZSByZXF1aXJlZGApO1xuICAgICAgXG4gICAgICAvLyBFbWl0IGEgY3JpdGljYWwgZXJyb3JcbiAgICAgIHN1cGVyLmVtaXQoJ2tlcm5lbF91bnJlY292ZXJhYmxlJywge1xuICAgICAgICBrZXJuZWxJZDoga2VybmVsSWQsXG4gICAgICAgIGV4ZWN1dGlvbklkOiBleGVjdXRpb25JZCxcbiAgICAgICAgYWN0dWFsUnVudGltZTogYWN0dWFsUnVudGltZSxcbiAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgbWVzc2FnZTogJ0tlcm5lbCBpcyBzdHVjayBhbmQgY291bGQgbm90IGJlIHJlY292ZXJlZCB0aHJvdWdoIGludGVycnVwdCwgcmVzdGFydCwgb3IgdGVybWluYXRpb24nXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IHN0dWNrIGV4ZWN1dGlvbnMgYWNyb3NzIGFsbCBrZXJuZWxzXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIHN0dWNrIGV4ZWN1dGlvbiBkZXRhaWxzXG4gICAqL1xuICBwdWJsaWMgZ2V0U3R1Y2tFeGVjdXRpb25zKCk6IEFycmF5PHtcbiAgICBrZXJuZWxJZDogc3RyaW5nO1xuICAgIGV4ZWN1dGlvbklkOiBzdHJpbmc7XG4gICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgcnVudGltZTogbnVtYmVyO1xuICAgIG1heEFsbG93ZWQ6IG51bWJlcjtcbiAgICBjb2RlPzogc3RyaW5nO1xuICAgIGtlcm5lbE1vZGU6IEtlcm5lbE1vZGU7XG4gICAga2VybmVsTGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlO1xuICB9PiB7XG4gICAgY29uc3Qgc3R1Y2tFeGVjdXRpb25zOiBBcnJheTx7XG4gICAgICBrZXJuZWxJZDogc3RyaW5nO1xuICAgICAgZXhlY3V0aW9uSWQ6IHN0cmluZztcbiAgICAgIHN0YXJ0VGltZTogbnVtYmVyO1xuICAgICAgcnVudGltZTogbnVtYmVyO1xuICAgICAgbWF4QWxsb3dlZDogbnVtYmVyO1xuICAgICAgY29kZT86IHN0cmluZztcbiAgICAgIGtlcm5lbE1vZGU6IEtlcm5lbE1vZGU7XG4gICAgICBrZXJuZWxMYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gICAgfT4gPSBbXTtcbiAgICBcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgZm9yIChjb25zdCBba2VybmVsSWQsIGluc3RhbmNlXSBvZiB0aGlzLmtlcm5lbHMuZW50cmllcygpKSB7XG4gICAgICAvLyBTa2lwIHBvb2wga2VybmVsc1xuICAgICAgaWYgKGtlcm5lbElkLnN0YXJ0c1dpdGgoXCJwb29sLVwiKSkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIFNraXAga2VybmVscyB3aXRob3V0IG1heEV4ZWN1dGlvblRpbWUgY29uZmlndXJlZFxuICAgICAgaWYgKCFpbnN0YW5jZS5vcHRpb25zPy5tYXhFeGVjdXRpb25UaW1lIHx8IGluc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSA8PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBtYXhFeGVjdXRpb25UaW1lID0gaW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lcyA9IHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5nZXQoa2VybmVsSWQpO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmdldChrZXJuZWxJZCk7XG4gICAgICBjb25zdCBvbmdvaW5nRXhlY3MgPSB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChrZXJuZWxJZCk7XG4gICAgICBcbiAgICAgIGlmICghb25nb2luZ0V4ZWNzIHx8IG9uZ29pbmdFeGVjcy5zaXplID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGV4ZWN1dGlvbklkIG9mIG9uZ29pbmdFeGVjcykge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBzdGFydFRpbWVzPy5nZXQoZXhlY3V0aW9uSWQpO1xuICAgICAgICBpZiAoc3RhcnRUaW1lID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcnVudGltZSA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBleGVjdXRpb24gaXMgc3R1Y2tcbiAgICAgICAgaWYgKHJ1bnRpbWUgPiBtYXhFeGVjdXRpb25UaW1lKSB7XG4gICAgICAgICAgY29uc3QgZXhlY01ldGFkYXRhID0gbWV0YWRhdGE/LmdldChleGVjdXRpb25JZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgc3R1Y2tFeGVjdXRpb25zLnB1c2goe1xuICAgICAgICAgICAga2VybmVsSWQsXG4gICAgICAgICAgICBleGVjdXRpb25JZCxcbiAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgIHJ1bnRpbWUsXG4gICAgICAgICAgICBtYXhBbGxvd2VkOiBtYXhFeGVjdXRpb25UaW1lLFxuICAgICAgICAgICAgY29kZTogZXhlY01ldGFkYXRhPy5jb2RlLFxuICAgICAgICAgICAga2VybmVsTW9kZTogaW5zdGFuY2UubW9kZSxcbiAgICAgICAgICAgIGtlcm5lbExhbmd1YWdlOiBpbnN0YW5jZS5sYW5ndWFnZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNvcnQgYnkgcnVudGltZSAobG9uZ2VzdCBydW5uaW5nIGZpcnN0KVxuICAgIHN0dWNrRXhlY3V0aW9ucy5zb3J0KChhLCBiKSA9PiBiLnJ1bnRpbWUgLSBhLnJ1bnRpbWUpO1xuICAgIFxuICAgIHJldHVybiBzdHVja0V4ZWN1dGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgaW50ZXJydXB0IGFsbCBzdHVjayBleGVjdXRpb25zIGFjcm9zcyBhbGwga2VybmVsc1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBpbnRlcnZlbnRpb24gcmVzdWx0c1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGhhbmRsZUFsbFN0dWNrRXhlY3V0aW9ucygpOiBQcm9taXNlPEFycmF5PHtcbiAgICBrZXJuZWxJZDogc3RyaW5nO1xuICAgIGV4ZWN1dGlvbklkOiBzdHJpbmc7XG4gICAgYWN0aW9uOiAnaW50ZXJydXB0ZWQnIHwgJ3Jlc3RhcnRlZCcgfCAndGVybWluYXRlZCcgfCAnZmFpbGVkJztcbiAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgIGVycm9yPzogc3RyaW5nO1xuICB9Pj4ge1xuICAgIGNvbnN0IHN0dWNrRXhlY3V0aW9ucyA9IHRoaXMuZ2V0U3R1Y2tFeGVjdXRpb25zKCk7XG4gICAgY29uc3QgcmVzdWx0czogQXJyYXk8e1xuICAgICAga2VybmVsSWQ6IHN0cmluZztcbiAgICAgIGV4ZWN1dGlvbklkOiBzdHJpbmc7XG4gICAgICBhY3Rpb246ICdpbnRlcnJ1cHRlZCcgfCAncmVzdGFydGVkJyB8ICd0ZXJtaW5hdGVkJyB8ICdmYWlsZWQnO1xuICAgICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICAgIGVycm9yPzogc3RyaW5nO1xuICAgIH0+ID0gW107XG4gICAgXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7c3R1Y2tFeGVjdXRpb25zLmxlbmd0aH0gc3R1Y2sgZXhlY3V0aW9ucyB0byBoYW5kbGVgKTtcbiAgICBcbiAgICAvLyBHcm91cCBieSBrZXJuZWwgdG8gYXZvaWQgbXVsdGlwbGUgaW50ZXJ2ZW50aW9ucyBvbiB0aGUgc2FtZSBrZXJuZWxcbiAgICBjb25zdCBrZXJuZWxHcm91cHMgPSBuZXcgTWFwPHN0cmluZywgdHlwZW9mIHN0dWNrRXhlY3V0aW9ucz4oKTtcbiAgICBmb3IgKGNvbnN0IGV4ZWMgb2Ygc3R1Y2tFeGVjdXRpb25zKSB7XG4gICAgICBpZiAoIWtlcm5lbEdyb3Vwcy5oYXMoZXhlYy5rZXJuZWxJZCkpIHtcbiAgICAgICAga2VybmVsR3JvdXBzLnNldChleGVjLmtlcm5lbElkLCBbXSk7XG4gICAgICB9XG4gICAgICBrZXJuZWxHcm91cHMuZ2V0KGV4ZWMua2VybmVsSWQpIS5wdXNoKGV4ZWMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgZWFjaCBrZXJuZWwncyBzdHVjayBleGVjdXRpb25zXG4gICAgZm9yIChjb25zdCBba2VybmVsSWQsIGV4ZWN1dGlvbnNdIG9mIGtlcm5lbEdyb3Vwcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gUGljayB0aGUgbG9uZ2VzdCBydW5uaW5nIGV4ZWN1dGlvbiBhcyB0aGUgcHJpbWFyeSBvbmVcbiAgICAgICAgY29uc3QgcHJpbWFyeUV4ZWMgPSBleGVjdXRpb25zWzBdOyAvLyBBbHJlYWR5IHNvcnRlZCBieSBydW50aW1lIGRlc2NcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBIYW5kbGluZyBzdHVjayBrZXJuZWwgJHtrZXJuZWxJZH0gd2l0aCAke2V4ZWN1dGlvbnMubGVuZ3RofSBzdHVjayBleGVjdXRpb25zIChwcmltYXJ5OiAke3ByaW1hcnlFeGVjLnJ1bnRpbWV9bXMpYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVc2UgdGhlIGF1dG9tYXRlZCBoYW5kbGluZyBzeXN0ZW1cbiAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVTdHVja0V4ZWN1dGlvbihcbiAgICAgICAgICBrZXJuZWxJZCwgXG4gICAgICAgICAgcHJpbWFyeUV4ZWMuZXhlY3V0aW9uSWQsIFxuICAgICAgICAgIHByaW1hcnlFeGVjLnJ1bnRpbWUsIFxuICAgICAgICAgIHByaW1hcnlFeGVjLmNvZGVcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1hcmsgYWxsIGV4ZWN1dGlvbnMgZm9yIHRoaXMga2VybmVsIGFzIGhhbmRsZWRcbiAgICAgICAgZm9yIChjb25zdCBleGVjIG9mIGV4ZWN1dGlvbnMpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAga2VybmVsSWQ6IGV4ZWMua2VybmVsSWQsXG4gICAgICAgICAgICBleGVjdXRpb25JZDogZXhlYy5leGVjdXRpb25JZCxcbiAgICAgICAgICAgIGFjdGlvbjogJ2ludGVycnVwdGVkJywgLy8gV2UgZG9uJ3Qga25vdyB0aGUgZXhhY3QgYWN0aW9uLCBidXQgaXQgd2FzIGhhbmRsZWRcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGhhbmRsaW5nIHN0dWNrIGV4ZWN1dGlvbnMgZm9yIGtlcm5lbCAke2tlcm5lbElkfTpgLCBlcnJvcik7XG4gICAgICAgIFxuICAgICAgICAvLyBNYXJrIGFsbCBleGVjdXRpb25zIGZvciB0aGlzIGtlcm5lbCBhcyBmYWlsZWRcbiAgICAgICAgZm9yIChjb25zdCBleGVjIG9mIGV4ZWN1dGlvbnMpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAga2VybmVsSWQ6IGV4ZWMua2VybmVsSWQsXG4gICAgICAgICAgICBleGVjdXRpb25JZDogZXhlYy5leGVjdXRpb25JZCxcbiAgICAgICAgICAgIGFjdGlvbjogJ2ZhaWxlZCcsXG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgaW50ZXJydXB0IGJ1ZmZlciBmb3IgYSB3b3JrZXIga2VybmVsIGR1cmluZyBjcmVhdGlvblxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSB3b3JrZXIgV29ya2VyIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNldHVwV29ya2VySW50ZXJydXB0QnVmZmVyKGlkOiBzdHJpbmcsIHdvcmtlcjogV29ya2VyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gU2tpcCBTaGFyZWRBcnJheUJ1ZmZlciBzZXR1cCBpZiBtb2RlIGlzICdrZXJuZWwtaW50ZXJydXB0J1xuICAgIGlmICh0aGlzLmludGVycnVwdGlvbk1vZGUgPT09ICdrZXJuZWwtaW50ZXJydXB0Jykge1xuICAgICAgY29uc29sZS5sb2coYFNraXBwaW5nIFNoYXJlZEFycmF5QnVmZmVyIHNldHVwIGZvciBrZXJuZWwgJHtpZH0gLSB1c2luZyBrZXJuZWwuaW50ZXJydXB0KCkgbW9kZWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gUHl0aG9uIGtlcm5lbHMgc3VwcG9ydCBpbnRlcnJ1cHQgYnVmZmVyc1xuICAgICAgXG4gICAgICAvLyBGb3IgUHl0aG9uIGtlcm5lbHMsIGNyZWF0ZSBhY3R1YWwgU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAgIGNvbnN0IHNoYXJlZEJ1ZmZlciA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKTtcbiAgICAgIGNvbnN0IGludGVycnVwdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHNoYXJlZEJ1ZmZlcik7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgYnVmZmVyIHRvIDAgKG5vIGludGVycnVwdCBzaWduYWwpXG4gICAgICBpbnRlcnJ1cHRCdWZmZXJbMF0gPSAwO1xuICAgICAgXG4gICAgICAvLyBTdG9yZSB0aGUgYnVmZmVyIGZvciBmdXR1cmUgdXNlXG4gICAgICB0aGlzLmludGVycnVwdEJ1ZmZlcnMuc2V0KGlkLCBpbnRlcnJ1cHRCdWZmZXIpO1xuICAgICAgXG4gICAgICAvLyBTZW5kIHRoZSBidWZmZXIgdG8gdGhlIHdvcmtlciB0byBzZXQgdXAgcHlvZGlkZS5zZXRJbnRlcnJ1cHRCdWZmZXIoKVxuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJTRVRfSU5URVJSVVBUX0JVRkZFUlwiLFxuICAgICAgICBidWZmZXI6IGludGVycnVwdEJ1ZmZlclxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSB3b3JrZXIgdG8gY29uZmlybSBidWZmZXIgc2V0dXBcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lb3V0IHdhaXRpbmcgZm9yIGludGVycnVwdCBidWZmZXIgc2V0dXBcIikpO1xuICAgICAgICB9LCA1MDAwKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSBcIklOVEVSUlVQVF9CVUZGRVJfU0VUXCIpIHtcbiAgICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBIYW5kbGUgYmFzZWQgb24gaW50ZXJydXB0aW9uIG1vZGVcbiAgICAgIGlmICh0aGlzLmludGVycnVwdGlvbk1vZGUgPT09ICdzaGFyZWQtYXJyYXktYnVmZmVyJykge1xuICAgICAgICAvLyBJZiBleHBsaWNpdGx5IHNldCB0byBzaGFyZWQtYXJyYXktYnVmZmVyLCB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBTaGFyZWRBcnJheUJ1ZmZlciByZXF1aXJlZCBidXQgbm90IGF2YWlsYWJsZSBmb3Iga2VybmVsICR7aWR9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2hhcmVkQXJyYXlCdWZmZXIgaXMgcmVxdWlyZWQgYnV0IG5vdCBhdmFpbGFibGUuIFRvIGVuYWJsZSBTaGFyZWRBcnJheUJ1ZmZlciwgeW91ciBzZXJ2ZXIgbXVzdCBzZXQgdGhlc2UgaGVhZGVyczpcbi0gQ3Jvc3MtT3JpZ2luLU9wZW5lci1Qb2xpY3k6IHNhbWUtb3JpZ2luXG4tIENyb3NzLU9yaWdpbi1FbWJlZGRlci1Qb2xpY3k6IHJlcXVpcmUtY29ycFxuXG5BbHRlcm5hdGl2ZWx5LCB1c2UgaW50ZXJydXB0aW9uTW9kZTogJ2tlcm5lbC1pbnRlcnJ1cHQnIG9yICdhdXRvJyBpbiBLZXJuZWxNYW5hZ2VyIG9wdGlvbnMuYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdXRvIG1vZGU6IGZhbGwgYmFjayB0byBrZXJuZWwuaW50ZXJydXB0KClcbiAgICAgICAgY29uc29sZS5pbmZvKGDihLnvuI8gU2hhcmVkQXJyYXlCdWZmZXIgbm90IGF2YWlsYWJsZSBmb3Iga2VybmVsICR7aWR9LiBVc2luZyBhbHRlcm5hdGl2ZSBpbnRlcnJ1cHQgbWV0aG9kLlxuXG5UbyBlbmFibGUgZmFzdGVyIGludGVycnVwdHMsIGNvbmZpZ3VyZSB5b3VyIHNlcnZlciB3aXRoIHRoZXNlIGhlYWRlcnM6XG4tIENyb3NzLU9yaWdpbi1PcGVuZXItUG9saWN5OiBzYW1lLW9yaWdpblxuLSBDcm9zcy1PcmlnaW4tRW1iZWRkZXItUG9saWN5OiByZXF1aXJlLWNvcnBcblxuTm90ZTogU29tZSBkZXZlbG9wbWVudCBzZXJ2ZXJzIChlLmcuLCBWaXRlLCB3ZWJwYWNrLWRldi1zZXJ2ZXIpIGNhbiBiZSBjb25maWd1cmVkIHRvIGFkZCB0aGVzZSBoZWFkZXJzLlxuVGhlIGFsdGVybmF0aXZlIGludGVycnVwdCBtZXRob2Qgd2lsbCBzdGlsbCB3b3JrIGJ1dCBtYXkgYmUgbGVzcyByZXNwb25zaXZlIGZvciBsb25nLXJ1bm5pbmcgY29kZS5gKTtcbiAgICAgICAgLy8gRG9uJ3QgdGhyb3cgLSBrZXJuZWwgY2FuIHN0aWxsIHdvcmsgd2l0aG91dCBpbnRlcnJ1cHQgYnVmZmVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBtb3VudGVkIGZpbGVzeXN0ZW1zIGZvciBhIHNwZWNpZmljIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIG1vdW50ZWQgZmlsZXN5c3RlbSBpbmZvXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0TW91bnRlZEZpbGVTeXN0ZW1zKGlkOiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PHtcbiAgICBtb3VudFBhdGg6IHN0cmluZztcbiAgICBwZXJtaXNzaW9uOiAncmVhZCcgfCAncmVhZHdyaXRlJztcbiAgICBjYW5TeW5jOiBib29sZWFuO1xuICB9Pj4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgJHtpZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2Uua2VybmVsLmdldE1vdW50ZWRGaWxlU3lzdGVtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2Uua2VybmVsLmdldE1vdW50ZWRGaWxlU3lzdGVtcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBLZXJuZWwgJHtpZH0gZG9lcyBub3Qgc3VwcG9ydCBnZXRNb3VudGVkRmlsZVN5c3RlbXMgbWV0aG9kYCk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyBtb3VudGVkIGZpbGVzeXN0ZW1zIGZvciBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hbnVhbGx5IHN5bmMgYSBzcGVjaWZpYyBtb3VudGVkIGZpbGVzeXN0ZW0gZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIG1vdW50UGF0aCBUaGUgcGF0aCBvZiB0aGUgbW91bnRlZCBmaWxlc3lzdGVtIHRvIHN5bmNcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gc3luYyByZXN1bHRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBzeW5jRmlsZVN5c3RlbShpZDogc3RyaW5nLCBtb3VudFBhdGg6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCAke2lkfSBub3QgZm91bmRgKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5rZXJuZWwuc3luY0ZpbGVTeXN0ZW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGluc3RhbmNlLmtlcm5lbC5zeW5jRmlsZVN5c3RlbShtb3VudFBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBLZXJuZWwgJHtpZH0gZG9lcyBub3Qgc3VwcG9ydCBzeW5jRmlsZVN5c3RlbSBtZXRob2RgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogJ3N5bmNGaWxlU3lzdGVtIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBrZXJuZWwnXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHN5bmNpbmcgZmlsZXN5c3RlbSBmb3Iga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIGEgbW91bnRlZCBmaWxlc3lzdGVtIGZyb20gcmVhZC1vbmx5IHRvIHJlYWQtd3JpdGUgcGVybWlzc2lvblxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBtb3VudFBhdGggVGhlIHBhdGggb2YgdGhlIG1vdW50ZWQgZmlsZXN5c3RlbSB0byB1cGdyYWRlXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHVwZ3JhZGUgcmVzdWx0XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgdXBncmFkZUZpbGVTeXN0ZW1QZXJtaXNzaW9uKGlkOiBzdHJpbmcsIG1vdW50UGF0aDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsICR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmtlcm5lbC51cGdyYWRlRmlsZVN5c3RlbVBlcm1pc3Npb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGluc3RhbmNlLmtlcm5lbC51cGdyYWRlRmlsZVN5c3RlbVBlcm1pc3Npb24obW91bnRQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgS2VybmVsICR7aWR9IGRvZXMgbm90IHN1cHBvcnQgdXBncmFkZUZpbGVTeXN0ZW1QZXJtaXNzaW9uIG1ldGhvZGApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiAndXBncmFkZUZpbGVTeXN0ZW1QZXJtaXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBrZXJuZWwnXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZ3JhZGluZyBmaWxlc3lzdGVtIHBlcm1pc3Npb24gZm9yIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/manager.ts\n\n}");

/***/ }),

/***/ "./src/pyodide-loader.ts":
/*!*******************************!*\
  !*** ./src/pyodide-loader.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadPyodide: () => (/* binding */ loadPyodide)\n/* harmony export */ });\n/* unused harmony exports isPyodideLoaded, getPyodideCDNUrl, getPyodideIndexUrl */\n/**\n * Pyodide CDN Loader Utility\n * Dynamically loads Pyodide from CDN for both main thread and web workers\n */\nconst PYODIDE_CDN_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js';\nconst PYODIDE_INDEX_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/';\n// Global flag to track if Pyodide is loaded\nlet pyodideLoaded = false;\nlet pyodideLoadPromise = null;\n/**\n * Load Pyodide script dynamically in main thread\n */\nfunction loadPyodideScript() {\n    return new Promise((resolve, reject) => {\n        // Check if script is already loaded\n        if (typeof globalThis.loadPyodide !== 'undefined') {\n            resolve();\n            return;\n        }\n        const script = document.createElement('script');\n        script.src = PYODIDE_CDN_URL;\n        script.onload = () => resolve();\n        script.onerror = () => reject(new Error(`Failed to load Pyodide from ${PYODIDE_CDN_URL}`));\n        document.head.appendChild(script);\n    });\n}\n/**\n * Load Pyodide in web worker using importScripts\n */\nfunction loadPyodideInWorker() {\n    return new Promise((resolve, reject) => {\n        try {\n            // Check if we're in a worker environment\n            if (typeof importScripts === 'undefined') {\n                reject(new Error('importScripts is not available - not in a worker context'));\n                return;\n            }\n            // Check if already loaded\n            if (typeof globalThis.loadPyodide !== 'undefined') {\n                resolve();\n                return;\n            }\n            importScripts(PYODIDE_CDN_URL);\n            resolve();\n        }\n        catch (error) {\n            reject(new Error(`Failed to import Pyodide in worker: ${error}`));\n        }\n    });\n}\n/**\n * Initialize Pyodide with proper configuration\n */\nasync function loadPyodide(config = {}) {\n    // Return existing promise if already loading\n    if (pyodideLoadPromise) {\n        return pyodideLoadPromise;\n    }\n    pyodideLoadPromise = (async () => {\n        try {\n            // Determine if we're in a worker or main thread\n            const isWorker = typeof importScripts !== 'undefined';\n            // Load the Pyodide script\n            if (isWorker) {\n                await loadPyodideInWorker();\n            }\n            else {\n                await loadPyodideScript();\n            }\n            // Get the global loadPyodide function\n            const globalLoadPyodide = globalThis.loadPyodide;\n            if (!globalLoadPyodide) {\n                throw new Error('loadPyodide function not found after script load');\n            }\n            // Configure default options\n            const defaultConfig = {\n                indexURL: PYODIDE_INDEX_URL,\n                ...config\n            };\n            // Initialize Pyodide\n            const pyodide = await globalLoadPyodide(defaultConfig);\n            pyodideLoaded = true;\n            console.log('âœ… Pyodide loaded successfully from CDN');\n            return pyodide;\n        }\n        catch (error) {\n            pyodideLoadPromise = null; // Reset on failure\n            throw error;\n        }\n    })();\n    return pyodideLoadPromise;\n}\n/**\n * Check if Pyodide is already loaded\n */\nfunction isPyodideLoaded() {\n    return pyodideLoaded && typeof globalThis.loadPyodide !== 'undefined';\n}\n/**\n * Get Pyodide CDN URL for external use\n */\nfunction getPyodideCDNUrl() {\n    return PYODIDE_CDN_URL;\n}\n/**\n * Get Pyodide index URL for external use\n */\nfunction getPyodideIndexUrl() {\n    return PYODIDE_INDEX_URL;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFDcEIsUUFBUSxFQUFFLGlCQUFpQjtnQkFDM0IsR0FBRyxNQUFNO2FBQ1YsQ0FBQztZQUVGLHFCQUFxQjtZQUNyQixNQUFNLE9BQU8sR0FBRyxNQUFNLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3ZELGFBQWEsR0FBRyxJQUFJLENBQUM7WUFFckIsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO1lBQ3RELE9BQU8sT0FBTyxDQUFDO1FBQ2pCLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2Ysa0JBQWtCLEdBQUcsSUFBSSxDQUFDLENBQUMsbUJBQW1CO1lBQzlDLE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUMsQ0FBQyxFQUFFLENBQUM7SUFFTCxPQUFPLGtCQUFrQixDQUFDO0FBQzVCLENBQUM7QUFFRDs7R0FFRztBQUNJLFNBQVMsZUFBZTtJQUM3QixPQUFPLGFBQWEsSUFBSSxPQUFRLFVBQWtCLENBQUMsV0FBVyxLQUFLLFdBQVcsQ0FBQztBQUNqRixDQUFDO0FBRUQ7O0dBRUc7QUFDSSxTQUFTLGdCQUFnQjtJQUM5QixPQUFPLGVBQWUsQ0FBQztBQUN6QixDQUFDO0FBRUQ7O0dBRUc7QUFDSSxTQUFTLGtCQUFrQjtJQUNoQyxPQUFPLGlCQUFpQixDQUFDO0FBQzNCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItcHl0aG9uLWtlcm5lbC8uL3NyYy9weW9kaWRlLWxvYWRlci50cz81MDExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUHlvZGlkZSBDRE4gTG9hZGVyIFV0aWxpdHlcbiAqIER5bmFtaWNhbGx5IGxvYWRzIFB5b2RpZGUgZnJvbSBDRE4gZm9yIGJvdGggbWFpbiB0aHJlYWQgYW5kIHdlYiB3b3JrZXJzXG4gKi9cblxuY29uc3QgUFlPRElERV9DRE5fVVJMID0gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9weW9kaWRlL3YwLjI4LjAvZnVsbC9weW9kaWRlLmpzJztcbmNvbnN0IFBZT0RJREVfSU5ERVhfVVJMID0gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9weW9kaWRlL3YwLjI4LjAvZnVsbC8nO1xuXG4vLyBHbG9iYWwgZmxhZyB0byB0cmFjayBpZiBQeW9kaWRlIGlzIGxvYWRlZFxubGV0IHB5b2RpZGVMb2FkZWQgPSBmYWxzZTtcbmxldCBweW9kaWRlTG9hZFByb21pc2U6IFByb21pc2U8YW55PiB8IG51bGwgPSBudWxsO1xuXG4vKipcbiAqIExvYWQgUHlvZGlkZSBzY3JpcHQgZHluYW1pY2FsbHkgaW4gbWFpbiB0aHJlYWRcbiAqL1xuZnVuY3Rpb24gbG9hZFB5b2RpZGVTY3JpcHQoKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgc2NyaXB0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgaWYgKHR5cGVvZiAoZ2xvYmFsVGhpcyBhcyBhbnkpLmxvYWRQeW9kaWRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdC5zcmMgPSBQWU9ESURFX0NETl9VUkw7XG4gICAgc2NyaXB0Lm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcbiAgICBzY3JpcHQub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIFB5b2RpZGUgZnJvbSAke1BZT0RJREVfQ0ROX1VSTH1gKSk7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBMb2FkIFB5b2RpZGUgaW4gd2ViIHdvcmtlciB1c2luZyBpbXBvcnRTY3JpcHRzXG4gKi9cbmZ1bmN0aW9uIGxvYWRQeW9kaWRlSW5Xb3JrZXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIGEgd29ya2VyIGVudmlyb25tZW50XG4gICAgICBpZiAodHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2ltcG9ydFNjcmlwdHMgaXMgbm90IGF2YWlsYWJsZSAtIG5vdCBpbiBhIHdvcmtlciBjb250ZXh0JykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgbG9hZGVkXG4gICAgICBpZiAodHlwZW9mIChnbG9iYWxUaGlzIGFzIGFueSkubG9hZFB5b2RpZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbXBvcnRTY3JpcHRzKFBZT0RJREVfQ0ROX1VSTCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBpbXBvcnQgUHlvZGlkZSBpbiB3b3JrZXI6ICR7ZXJyb3J9YCkpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBQeW9kaWRlIHdpdGggcHJvcGVyIGNvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRQeW9kaWRlKGNvbmZpZzogYW55ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAvLyBSZXR1cm4gZXhpc3RpbmcgcHJvbWlzZSBpZiBhbHJlYWR5IGxvYWRpbmdcbiAgaWYgKHB5b2RpZGVMb2FkUHJvbWlzZSkge1xuICAgIHJldHVybiBweW9kaWRlTG9hZFByb21pc2U7XG4gIH1cblxuICBweW9kaWRlTG9hZFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBEZXRlcm1pbmUgaWYgd2UncmUgaW4gYSB3b3JrZXIgb3IgbWFpbiB0aHJlYWRcbiAgICAgIGNvbnN0IGlzV29ya2VyID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnO1xuICAgICAgXG4gICAgICAvLyBMb2FkIHRoZSBQeW9kaWRlIHNjcmlwdFxuICAgICAgaWYgKGlzV29ya2VyKSB7XG4gICAgICAgIGF3YWl0IGxvYWRQeW9kaWRlSW5Xb3JrZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGxvYWRQeW9kaWRlU2NyaXB0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgZ2xvYmFsIGxvYWRQeW9kaWRlIGZ1bmN0aW9uXG4gICAgICBjb25zdCBnbG9iYWxMb2FkUHlvZGlkZSA9IChnbG9iYWxUaGlzIGFzIGFueSkubG9hZFB5b2RpZGU7XG4gICAgICBpZiAoIWdsb2JhbExvYWRQeW9kaWRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9hZFB5b2RpZGUgZnVuY3Rpb24gbm90IGZvdW5kIGFmdGVyIHNjcmlwdCBsb2FkJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbmZpZ3VyZSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgIGluZGV4VVJMOiBQWU9ESURFX0lOREVYX1VSTCxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIFB5b2RpZGVcbiAgICAgIGNvbnN0IHB5b2RpZGUgPSBhd2FpdCBnbG9iYWxMb2FkUHlvZGlkZShkZWZhdWx0Q29uZmlnKTtcbiAgICAgIHB5b2RpZGVMb2FkZWQgPSB0cnVlO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFB5b2RpZGUgbG9hZGVkIHN1Y2Nlc3NmdWxseSBmcm9tIENETicpO1xuICAgICAgcmV0dXJuIHB5b2RpZGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHB5b2RpZGVMb2FkUHJvbWlzZSA9IG51bGw7IC8vIFJlc2V0IG9uIGZhaWx1cmVcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSkoKTtcblxuICByZXR1cm4gcHlvZGlkZUxvYWRQcm9taXNlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIFB5b2RpZGUgaXMgYWxyZWFkeSBsb2FkZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHlvZGlkZUxvYWRlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIHB5b2RpZGVMb2FkZWQgJiYgdHlwZW9mIChnbG9iYWxUaGlzIGFzIGFueSkubG9hZFB5b2RpZGUgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIEdldCBQeW9kaWRlIENETiBVUkwgZm9yIGV4dGVybmFsIHVzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHlvZGlkZUNETlVybCgpOiBzdHJpbmcge1xuICByZXR1cm4gUFlPRElERV9DRE5fVVJMO1xufVxuXG4vKipcbiAqIEdldCBQeW9kaWRlIGluZGV4IFVSTCBmb3IgZXh0ZXJuYWwgdXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQeW9kaWRlSW5kZXhVcmwoKTogc3RyaW5nIHtcbiAgcmV0dXJuIFBZT0RJREVfSU5ERVhfVVJMO1xufSAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pyodide-loader.ts\n\n}");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KernelEvents: () => (/* binding */ KernelEvents)\n/* harmony export */ });\n// Shared types and interfaces to prevent circular dependencies\n// These are extracted from index.ts to break the circular dependency\n// Events enum\nvar KernelEvents;\n(function (KernelEvents) {\n    // IOPub Channel Messages\n    KernelEvents[\"STREAM\"] = \"stream\";\n    KernelEvents[\"DISPLAY_DATA\"] = \"display_data\";\n    KernelEvents[\"UPDATE_DISPLAY_DATA\"] = \"update_display_data\";\n    KernelEvents[\"EXECUTE_RESULT\"] = \"execute_result\";\n    KernelEvents[\"EXECUTE_ERROR\"] = \"execute_error\";\n    KernelEvents[\"EXECUTE_REQUEST\"] = \"execute_request\";\n    // Input request\n    KernelEvents[\"INPUT_REQUEST\"] = \"input_request\";\n    // Output control\n    KernelEvents[\"CLEAR_OUTPUT\"] = \"clear_output\";\n    // Comm messages\n    KernelEvents[\"COMM_OPEN\"] = \"comm_open\";\n    KernelEvents[\"COMM_MSG\"] = \"comm_msg\";\n    KernelEvents[\"COMM_CLOSE\"] = \"comm_close\";\n    // Internal Events\n    KernelEvents[\"KERNEL_READY\"] = \"kernel_ready\";\n    KernelEvents[\"KERNEL_BUSY\"] = \"kernel_busy\";\n    KernelEvents[\"KERNEL_IDLE\"] = \"kernel_idle\";\n    // Special catchall for internal use\n    KernelEvents[\"ALL\"] = \"*\";\n    // Execution monitoring events\n    KernelEvents[\"EXECUTION_STALLED\"] = \"execution_stalled\";\n    // Enhanced stuck kernel handling events\n    KernelEvents[\"KERNEL_UNRECOVERABLE\"] = \"kernel_unrecoverable\";\n    KernelEvents[\"EXECUTION_INTERRUPTED\"] = \"execution_interrupted\";\n    KernelEvents[\"KERNEL_RESTARTED\"] = \"kernel_restarted\";\n    KernelEvents[\"KERNEL_TERMINATED\"] = \"kernel_terminated\";\n})(KernelEvents || (KernelEvents = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHlwZXMudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEsK0RBQStEO0FBQy9ELHFFQUFxRTtBQUVyRSxjQUFjO0FBQ2QsSUFBWSxZQW9DWDtBQXBDRCxXQUFZLFlBQVk7SUFDdEIseUJBQXlCO0lBQ3pCLGlDQUFpQjtJQUNqQiw2Q0FBNkI7SUFDN0IsMkRBQTJDO0lBQzNDLGlEQUFpQztJQUNqQywrQ0FBK0I7SUFDL0IsbURBQW1DO0lBRW5DLGdCQUFnQjtJQUNoQiwrQ0FBK0I7SUFFL0IsaUJBQWlCO0lBQ2pCLDZDQUE2QjtJQUU3QixnQkFBZ0I7SUFDaEIsdUNBQXVCO0lBQ3ZCLHFDQUFxQjtJQUNyQix5Q0FBeUI7SUFFekIsa0JBQWtCO0lBQ2xCLDZDQUE2QjtJQUM3QiwyQ0FBMkI7SUFDM0IsMkNBQTJCO0lBRTNCLG9DQUFvQztJQUNwQyx5QkFBUztJQUVULDhCQUE4QjtJQUM5Qix1REFBdUM7SUFFdkMsd0NBQXdDO0lBQ3hDLDZEQUE2QztJQUM3QywrREFBK0M7SUFDL0MscURBQXFDO0lBQ3JDLHVEQUF1QztBQUN6QyxDQUFDLEVBcENXLFlBQVksS0FBWixZQUFZLFFBb0N2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1weXRob24ta2VybmVsLy4vc3JjL3R5cGVzLnRzP2E3NmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2hhcmVkIHR5cGVzIGFuZCBpbnRlcmZhY2VzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4vLyBUaGVzZSBhcmUgZXh0cmFjdGVkIGZyb20gaW5kZXgudHMgdG8gYnJlYWsgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3lcblxuLy8gRXZlbnRzIGVudW1cbmV4cG9ydCBlbnVtIEtlcm5lbEV2ZW50cyB7XG4gIC8vIElPUHViIENoYW5uZWwgTWVzc2FnZXNcbiAgU1RSRUFNID0gXCJzdHJlYW1cIixcbiAgRElTUExBWV9EQVRBID0gXCJkaXNwbGF5X2RhdGFcIixcbiAgVVBEQVRFX0RJU1BMQVlfREFUQSA9IFwidXBkYXRlX2Rpc3BsYXlfZGF0YVwiLFxuICBFWEVDVVRFX1JFU1VMVCA9IFwiZXhlY3V0ZV9yZXN1bHRcIixcbiAgRVhFQ1VURV9FUlJPUiA9IFwiZXhlY3V0ZV9lcnJvclwiLFxuICBFWEVDVVRFX1JFUVVFU1QgPSBcImV4ZWN1dGVfcmVxdWVzdFwiLFxuICBcbiAgLy8gSW5wdXQgcmVxdWVzdFxuICBJTlBVVF9SRVFVRVNUID0gXCJpbnB1dF9yZXF1ZXN0XCIsXG4gIFxuICAvLyBPdXRwdXQgY29udHJvbFxuICBDTEVBUl9PVVRQVVQgPSBcImNsZWFyX291dHB1dFwiLFxuICBcbiAgLy8gQ29tbSBtZXNzYWdlc1xuICBDT01NX09QRU4gPSBcImNvbW1fb3BlblwiLFxuICBDT01NX01TRyA9IFwiY29tbV9tc2dcIixcbiAgQ09NTV9DTE9TRSA9IFwiY29tbV9jbG9zZVwiLFxuICBcbiAgLy8gSW50ZXJuYWwgRXZlbnRzXG4gIEtFUk5FTF9SRUFEWSA9IFwia2VybmVsX3JlYWR5XCIsXG4gIEtFUk5FTF9CVVNZID0gXCJrZXJuZWxfYnVzeVwiLFxuICBLRVJORUxfSURMRSA9IFwia2VybmVsX2lkbGVcIixcbiAgXG4gIC8vIFNwZWNpYWwgY2F0Y2hhbGwgZm9yIGludGVybmFsIHVzZVxuICBBTEwgPSBcIipcIiwgLy8gV2lsZGNhcmQgZXZlbnQgdHlwZVxuICBcbiAgLy8gRXhlY3V0aW9uIG1vbml0b3JpbmcgZXZlbnRzXG4gIEVYRUNVVElPTl9TVEFMTEVEID0gXCJleGVjdXRpb25fc3RhbGxlZFwiLFxuICBcbiAgLy8gRW5oYW5jZWQgc3R1Y2sga2VybmVsIGhhbmRsaW5nIGV2ZW50c1xuICBLRVJORUxfVU5SRUNPVkVSQUJMRSA9IFwia2VybmVsX3VucmVjb3ZlcmFibGVcIixcbiAgRVhFQ1VUSU9OX0lOVEVSUlVQVEVEID0gXCJleGVjdXRpb25faW50ZXJydXB0ZWRcIixcbiAgS0VSTkVMX1JFU1RBUlRFRCA9IFwia2VybmVsX3Jlc3RhcnRlZFwiLFxuICBLRVJORUxfVEVSTUlOQVRFRCA9IFwia2VybmVsX3Rlcm1pbmF0ZWRcIlxufVxuXG4vLyBFdmVudEVtaXR0ZXIgaW50ZXJmYWNlIGZvciB0eXBpbmdcbmV4cG9ydCBpbnRlcmZhY2UgSUV2ZW50RW1pdHRlciB7XG4gIG9uKGV2ZW50TmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogRnVuY3Rpb24pOiB2b2lkO1xuICBvZmYoZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbik6IHZvaWQ7XG4gIGVtaXQoZXZlbnROYW1lOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKTogdm9pZDtcbiAgc2V0TWF4TGlzdGVuZXJzKG46IG51bWJlcik6IHZvaWQ7XG59XG5cbi8vIEZpbGVTeXN0ZW0gbW91bnQgb3B0aW9uc1xuZXhwb3J0IGludGVyZmFjZSBJRmlsZVN5c3RlbU1vdW50T3B0aW9ucyB7XG4gIGVuYWJsZWQ/OiBib29sZWFuO1xuICByb290Pzogc3RyaW5nO1xuICBtb3VudFBvaW50Pzogc3RyaW5nO1xufVxuXG4vLyBLZXJuZWwgb3B0aW9ucyBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSUtlcm5lbE9wdGlvbnMge1xuICBmaWxlc3lzdGVtPzogSUZpbGVTeXN0ZW1Nb3VudE9wdGlvbnM7XG4gIGVudj86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47IC8vIEVudmlyb25tZW50IHZhcmlhYmxlcyB0byBzZXQgaW4gdGhlIGtlcm5lbFxuICBsb2NrRmlsZVVSTD86IHN0cmluZzsgLy8gVVJMIHRvIHB5b2RpZGUtbG9jay5qc29uIGZpbGUgZm9yIGZhc3RlciBsb2FkaW5nXG4gIGF1dG9TeW5jRnM/OiBib29sZWFuOyAvLyBBdXRvbWF0aWNhbGx5IHN5bmMgbmF0aXZlIGZpbGVzeXN0ZW0gYWZ0ZXIgY29kZSBleGVjdXRpb24gKGRlZmF1bHQ6IGZhbHNlKVxufVxuXG4vLyBOYXRpdmUgZmlsZXN5c3RlbSBoYW5kbGUgdHlwZVxuZXhwb3J0IGludGVyZmFjZSBJTmF0aXZlRlNIYW5kbGUge1xuICBzeW5jZnMoKTogUHJvbWlzZTx2b2lkPjtcbn1cblxuLy8gS2VybmVsIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsIGV4dGVuZHMgSUV2ZW50RW1pdHRlciB7XG4gIGluaXRpYWxpemUob3B0aW9ucz86IElLZXJuZWxPcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcbiAgZXhlY3V0ZShjb2RlOiBzdHJpbmcsIHBhcmVudD86IGFueSk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ/OiBhbnksIGVycm9yPzogRXJyb3IgfT47XG4gIGV4ZWN1dGVTdHJlYW0/KGNvZGU6IHN0cmluZywgcGFyZW50PzogYW55KTogQXN5bmNHZW5lcmF0b3I8YW55LCB7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9LCB2b2lkPjtcbiAgaXNJbml0aWFsaXplZCgpOiBib29sZWFuO1xuICBpbnB1dFJlcGx5KGNvbnRlbnQ6IHsgdmFsdWU6IHN0cmluZyB9KTogUHJvbWlzZTx2b2lkPjtcbiAgZ2V0U3RhdHVzKCk6IFByb21pc2U8XCJhY3RpdmVcIiB8IFwiYnVzeVwiIHwgXCJ1bmtub3duXCI+O1xuXG4gIC8vIEludGVycnVwdCBmdW5jdGlvbmFsaXR5XG4gIGludGVycnVwdD8oKTogUHJvbWlzZTxib29sZWFuPjtcbiAgc2V0SW50ZXJydXB0QnVmZmVyPyhidWZmZXI6IFVpbnQ4QXJyYXkpOiB2b2lkO1xuXG4gIC8vIE5hdGl2ZSBmaWxlc3lzdGVtIG1vdW50aW5nXG4gIG1vdW50RlM/KG1vdW50UGF0aDogc3RyaW5nLCBkaXJIYW5kbGU/OiBGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHwgbnVsbCwgcGVybWlzc2lvbj86ICdyZWFkJyB8ICdyZWFkd3JpdGUnKTogUHJvbWlzZTxJTmF0aXZlRlNIYW5kbGU+O1xuICBnZXRNb3VudGVkRmlsZVN5c3RlbXM/KCk6IEFycmF5PHsgbW91bnRQYXRoOiBzdHJpbmc7IHBlcm1pc3Npb246ICdyZWFkJyB8ICdyZWFkd3JpdGUnOyBjYW5TeW5jOiBib29sZWFuOyB9PjtcbiAgc3luY0ZpbGVTeXN0ZW0/KG1vdW50UGF0aDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+O1xuICB1cGdyYWRlRmlsZVN5c3RlbVBlcm1pc3Npb24/KG1vdW50UGF0aDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+O1xuXG4gIC8vIE9wdGlvbmFsIG1ldGhvZHNcbiAgY29tcGxldGU/KGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPGFueT47XG4gIGluc3BlY3Q/KGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBkZXRhaWxfbGV2ZWw6IDAgfCAxLCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPGFueT47XG4gIGlzQ29tcGxldGU/KGNvZGU6IHN0cmluZywgcGFyZW50PzogYW55KTogUHJvbWlzZTxhbnk+O1xuICBjb21tSW5mbz8odGFyZ2V0X25hbWU6IHN0cmluZyB8IG51bGwsIHBhcmVudD86IGFueSk6IFByb21pc2U8YW55PjtcbiAgY29tbU9wZW4/KGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KTogUHJvbWlzZTx2b2lkPjtcbiAgY29tbU1zZz8oY29udGVudDogYW55LCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPHZvaWQ+O1xuICBjb21tQ2xvc2U/KGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KTogUHJvbWlzZTx2b2lkPjtcbn1cblxuLy8gRXhlY3V0ZSBvcHRpb25zIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsRXhlY3V0ZU9wdGlvbnMge1xuICBjb2RlOiBzdHJpbmc7XG4gIHNpbGVudD86IGJvb2xlYW47XG4gIHN0b3JlSGlzdG9yeT86IGJvb2xlYW47XG59XG5cbi8vIE1lc3NhZ2UgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIElNZXNzYWdlIHtcbiAgdHlwZTogc3RyaW5nO1xuICBidW5kbGU/OiBhbnk7XG4gIGNvbnRlbnQ/OiBhbnk7XG4gIG1ldGFkYXRhPzogYW55O1xuICBwYXJlbnRIZWFkZXI/OiBhbnk7XG4gIGJ1ZmZlcnM/OiBhbnk7XG4gIGlkZW50PzogYW55O1xufVxuXG4vLyBFdmVudCBkYXRhIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBJRXZlbnREYXRhIHtcbiAgdHlwZTogc3RyaW5nO1xuICBkYXRhOiBhbnk7XG59ICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/types.ts\n\n}");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval-source-map devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/kernel.worker.ts");
/******/ 
