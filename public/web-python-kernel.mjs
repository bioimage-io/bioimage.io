/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./node_modules/comlink/dist/esm/comlink.mjs":
/*!***************************************************!*\
  !*** ./node_modules/comlink/dist/esm/comlink.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* unused harmony exports createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint */\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously Â¯\\_(ãƒ„)_/Â¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didnâ€™t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\n\n//# sourceMappingURL=comlink.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tbGluay9kaXN0L2VzbS9jb21saW5rLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCLGtCQUFrQixVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0EseURBQXlELGdCQUFnQixJQUFJO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix5REFBeUQsZ0JBQWdCLElBQUk7QUFDN0UsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUk7QUFDakkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItcHl0aG9uLWtlcm5lbC8uL25vZGVfbW9kdWxlcy9jb21saW5rL2Rpc3QvZXNtL2NvbWxpbmsubWpzPzI3OTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgcHJveHlNYXJrZXIgPSBTeW1ib2woXCJDb21saW5rLnByb3h5XCIpO1xuY29uc3QgY3JlYXRlRW5kcG9pbnQgPSBTeW1ib2woXCJDb21saW5rLmVuZHBvaW50XCIpO1xuY29uc3QgcmVsZWFzZVByb3h5ID0gU3ltYm9sKFwiQ29tbGluay5yZWxlYXNlUHJveHlcIik7XG5jb25zdCBmaW5hbGl6ZXIgPSBTeW1ib2woXCJDb21saW5rLmZpbmFsaXplclwiKTtcbmNvbnN0IHRocm93TWFya2VyID0gU3ltYm9sKFwiQ29tbGluay50aHJvd25cIik7XG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+ICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkgfHwgdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuLyoqXG4gKiBJbnRlcm5hbCB0cmFuc2ZlciBoYW5kbGUgdG8gaGFuZGxlIG9iamVjdHMgbWFya2VkIHRvIHByb3h5LlxuICovXG5jb25zdCBwcm94eVRyYW5zZmVySGFuZGxlciA9IHtcbiAgICBjYW5IYW5kbGU6ICh2YWwpID0+IGlzT2JqZWN0KHZhbCkgJiYgdmFsW3Byb3h5TWFya2VyXSxcbiAgICBzZXJpYWxpemUob2JqKSB7XG4gICAgICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgZXhwb3NlKG9iaiwgcG9ydDEpO1xuICAgICAgICByZXR1cm4gW3BvcnQyLCBbcG9ydDJdXTtcbiAgICB9LFxuICAgIGRlc2VyaWFsaXplKHBvcnQpIHtcbiAgICAgICAgcG9ydC5zdGFydCgpO1xuICAgICAgICByZXR1cm4gd3JhcChwb3J0KTtcbiAgICB9LFxufTtcbi8qKlxuICogSW50ZXJuYWwgdHJhbnNmZXIgaGFuZGxlciB0byBoYW5kbGUgdGhyb3duIGV4Y2VwdGlvbnMuXG4gKi9cbmNvbnN0IHRocm93VHJhbnNmZXJIYW5kbGVyID0ge1xuICAgIGNhbkhhbmRsZTogKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgdGhyb3dNYXJrZXIgaW4gdmFsdWUsXG4gICAgc2VyaWFsaXplKHsgdmFsdWUgfSkge1xuICAgICAgICBsZXQgc2VyaWFsaXplZDtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSB7XG4gICAgICAgICAgICAgICAgaXNFcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB2YWx1ZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogdmFsdWUuc3RhY2ssXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkID0geyBpc0Vycm9yOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3NlcmlhbGl6ZWQsIFtdXTtcbiAgICB9LFxuICAgIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWQuaXNFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3Ioc2VyaWFsaXplZC52YWx1ZS5tZXNzYWdlKSwgc2VyaWFsaXplZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgc2VyaWFsaXplZC52YWx1ZTtcbiAgICB9LFxufTtcbi8qKlxuICogQWxsb3dzIGN1c3RvbWl6aW5nIHRoZSBzZXJpYWxpemF0aW9uIG9mIGNlcnRhaW4gdmFsdWVzLlxuICovXG5jb25zdCB0cmFuc2ZlckhhbmRsZXJzID0gbmV3IE1hcChbXG4gICAgW1wicHJveHlcIiwgcHJveHlUcmFuc2ZlckhhbmRsZXJdLFxuICAgIFtcInRocm93XCIsIHRocm93VHJhbnNmZXJIYW5kbGVyXSxcbl0pO1xuZnVuY3Rpb24gaXNBbGxvd2VkT3JpZ2luKGFsbG93ZWRPcmlnaW5zLCBvcmlnaW4pIHtcbiAgICBmb3IgKGNvbnN0IGFsbG93ZWRPcmlnaW4gb2YgYWxsb3dlZE9yaWdpbnMpIHtcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gYWxsb3dlZE9yaWdpbiB8fCBhbGxvd2VkT3JpZ2luID09PSBcIipcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93ZWRPcmlnaW4gaW5zdGFuY2VvZiBSZWdFeHAgJiYgYWxsb3dlZE9yaWdpbi50ZXN0KG9yaWdpbikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGV4cG9zZShvYmosIGVwID0gZ2xvYmFsVGhpcywgYWxsb3dlZE9yaWdpbnMgPSBbXCIqXCJdKSB7XG4gICAgZXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gY2FsbGJhY2soZXYpIHtcbiAgICAgICAgaWYgKCFldiB8fCAhZXYuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBbGxvd2VkT3JpZ2luKGFsbG93ZWRPcmlnaW5zLCBldi5vcmlnaW4pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgb3JpZ2luICcke2V2Lm9yaWdpbn0nIGZvciBjb21saW5rIHByb3h5YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpZCwgdHlwZSwgcGF0aCB9ID0gT2JqZWN0LmFzc2lnbih7IHBhdGg6IFtdIH0sIGV2LmRhdGEpO1xuICAgICAgICBjb25zdCBhcmd1bWVudExpc3QgPSAoZXYuZGF0YS5hcmd1bWVudExpc3QgfHwgW10pLm1hcChmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgbGV0IHJldHVyblZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5zbGljZSgwLCAtMSkucmVkdWNlKChvYmosIHByb3ApID0+IG9ialtwcm9wXSwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gcGF0aC5yZWR1Y2UoKG9iaiwgcHJvcCkgPT4gb2JqW3Byb3BdLCBvYmopO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkdFVFwiIC8qIE1lc3NhZ2VUeXBlLkdFVCAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSByYXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiU0VUXCIgLyogTWVzc2FnZVR5cGUuU0VUICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRbcGF0aC5zbGljZSgtMSlbMF1dID0gZnJvbVdpcmVWYWx1ZShldi5kYXRhLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQVBQTFlcIiAvKiBNZXNzYWdlVHlwZS5BUFBMWSAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSByYXdWYWx1ZS5hcHBseShwYXJlbnQsIGFyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkNPTlNUUlVDVFwiIC8qIE1lc3NhZ2VUeXBlLkNPTlNUUlVDVCAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgcmF3VmFsdWUoLi4uYXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gcHJveHkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJFTkRQT0lOVFwiIC8qIE1lc3NhZ2VUeXBlLkVORFBPSU5UICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvc2Uob2JqLCBwb3J0Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRyYW5zZmVyKHBvcnQxLCBbcG9ydDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiUkVMRUFTRVwiIC8qIE1lc3NhZ2VUeXBlLlJFTEVBU0UgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0geyB2YWx1ZSwgW3Rocm93TWFya2VyXTogMCB9O1xuICAgICAgICB9XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSlcbiAgICAgICAgICAgIC5jYXRjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmV0dXJuVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFt3aXJlVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgZXAucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3aXJlVmFsdWUpLCB7IGlkIH0pLCB0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIlJFTEVBU0VcIiAvKiBNZXNzYWdlVHlwZS5SRUxFQVNFICovKSB7XG4gICAgICAgICAgICAgICAgLy8gZGV0YWNoIGFuZCBkZWFjdGl2ZSBhZnRlciBzZW5kaW5nIHJlbGVhc2UgcmVzcG9uc2UgYWJvdmUuXG4gICAgICAgICAgICAgICAgZXAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGNsb3NlRW5kUG9pbnQoZXApO1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbGl6ZXIgaW4gb2JqICYmIHR5cGVvZiBvYmpbZmluYWxpemVyXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtmaW5hbGl6ZXJdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gU2VuZCBTZXJpYWxpemF0aW9uIEVycm9yIFRvIENhbGxlclxuICAgICAgICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBUeXBlRXJyb3IoXCJVbnNlcmlhbGl6YWJsZSByZXR1cm4gdmFsdWVcIiksXG4gICAgICAgICAgICAgICAgW3Rocm93TWFya2VyXTogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXAucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3aXJlVmFsdWUpLCB7IGlkIH0pLCB0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKGVwLnN0YXJ0KSB7XG4gICAgICAgIGVwLnN0YXJ0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNNZXNzYWdlUG9ydChlbmRwb2ludCkge1xuICAgIHJldHVybiBlbmRwb2ludC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIk1lc3NhZ2VQb3J0XCI7XG59XG5mdW5jdGlvbiBjbG9zZUVuZFBvaW50KGVuZHBvaW50KSB7XG4gICAgaWYgKGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpKVxuICAgICAgICBlbmRwb2ludC5jbG9zZSgpO1xufVxuZnVuY3Rpb24gd3JhcChlcCwgdGFyZ2V0KSB7XG4gICAgY29uc3QgcGVuZGluZ0xpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICBlcC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGV2KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gZXY7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5pZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gcGVuZGluZ0xpc3RlbmVycy5nZXQoZGF0YS5pZCk7XG4gICAgICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzb2x2ZXIoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBwZW5kaW5nTGlzdGVuZXJzLmRlbGV0ZShkYXRhLmlkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgW10sIHRhcmdldCk7XG59XG5mdW5jdGlvbiB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1JlbGVhc2VkKSB7XG4gICAgaWYgKGlzUmVsZWFzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJveHkgaGFzIGJlZW4gcmVsZWFzZWQgYW5kIGlzIG5vdCB1c2VhYmxlXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbGVhc2VFbmRwb2ludChlcCkge1xuICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBuZXcgTWFwKCksIHtcbiAgICAgICAgdHlwZTogXCJSRUxFQVNFXCIgLyogTWVzc2FnZVR5cGUuUkVMRUFTRSAqLyxcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgY2xvc2VFbmRQb2ludChlcCk7XG4gICAgfSk7XG59XG5jb25zdCBwcm94eUNvdW50ZXIgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcHJveHlGaW5hbGl6ZXJzID0gXCJGaW5hbGl6YXRpb25SZWdpc3RyeVwiIGluIGdsb2JhbFRoaXMgJiZcbiAgICBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKGVwKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0NvdW50ID0gKHByb3h5Q291bnRlci5nZXQoZXApIHx8IDApIC0gMTtcbiAgICAgICAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpO1xuICAgICAgICBpZiAobmV3Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJlbGVhc2VFbmRwb2ludChlcCk7XG4gICAgICAgIH1cbiAgICB9KTtcbmZ1bmN0aW9uIHJlZ2lzdGVyUHJveHkocHJveHksIGVwKSB7XG4gICAgY29uc3QgbmV3Q291bnQgPSAocHJveHlDb3VudGVyLmdldChlcCkgfHwgMCkgKyAxO1xuICAgIHByb3h5Q291bnRlci5zZXQoZXAsIG5ld0NvdW50KTtcbiAgICBpZiAocHJveHlGaW5hbGl6ZXJzKSB7XG4gICAgICAgIHByb3h5RmluYWxpemVycy5yZWdpc3Rlcihwcm94eSwgZXAsIHByb3h5KTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVyUHJveHkocHJveHkpIHtcbiAgICBpZiAocHJveHlGaW5hbGl6ZXJzKSB7XG4gICAgICAgIHByb3h5RmluYWxpemVycy51bnJlZ2lzdGVyKHByb3h5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgcGF0aCA9IFtdLCB0YXJnZXQgPSBmdW5jdGlvbiAoKSB7IH0pIHtcbiAgICBsZXQgaXNQcm94eVJlbGVhc2VkID0gZmFsc2U7XG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB7XG4gICAgICAgIGdldChfdGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgaWYgKHByb3AgPT09IHJlbGVhc2VQcm94eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJQcm94eShwcm94eSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VFbmRwb2ludChlcCk7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaXNQcm94eVJlbGVhc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgPT09IFwidGhlblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHRoZW46ICgpID0+IHByb3h5IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIgLyogTWVzc2FnZVR5cGUuR0VUICovLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByLnRoZW4uYmluZChyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgWy4uLnBhdGgsIHByb3BdKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KF90YXJnZXQsIHByb3AsIHJhd1ZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgLy8gRklYTUU6IEVTNiBQcm94eSBIYW5kbGVyIGBzZXRgIG1ldGhvZHMgYXJlIHN1cHBvc2VkIHRvIHJldHVybiBhXG4gICAgICAgICAgICAvLyBib29sZWFuLiBUbyBzaG93IGdvb2Qgd2lsbCwgd2UgcmV0dXJuIHRydWUgYXN5bmNocm9ub3VzbHkgwq9cXF8o44OEKV8vwq9cbiAgICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyYXdWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU0VUXCIgLyogTWVzc2FnZVR5cGUuU0VUICovLFxuICAgICAgICAgICAgICAgIHBhdGg6IFsuLi5wYXRoLCBwcm9wXS5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9LCB0cmFuc2ZlcmFibGVzKS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBhcHBseShfdGFyZ2V0LCBfdGhpc0FyZywgcmF3QXJndW1lbnRMaXN0KSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgY29uc3QgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0ID09PSBjcmVhdGVFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiRU5EUE9JTlRcIiAvKiBNZXNzYWdlVHlwZS5FTkRQT0lOVCAqLyxcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UganVzdCBwcmV0ZW5kIHRoYXQgYGJpbmQoKWAgZGlkbuKAmXQgaGFwcGVuLlxuICAgICAgICAgICAgaWYgKGxhc3QgPT09IFwiYmluZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbYXJndW1lbnRMaXN0LCB0cmFuc2ZlcmFibGVzXSA9IHByb2Nlc3NBcmd1bWVudHMocmF3QXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJBUFBMWVwiIC8qIE1lc3NhZ2VUeXBlLkFQUExZICovLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50TGlzdCxcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnN0cnVjdChfdGFyZ2V0LCByYXdBcmd1bWVudExpc3QpIHtcbiAgICAgICAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICAgICAgICBjb25zdCBbYXJndW1lbnRMaXN0LCB0cmFuc2ZlcmFibGVzXSA9IHByb2Nlc3NBcmd1bWVudHMocmF3QXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJDT05TVFJVQ1RcIiAvKiBNZXNzYWdlVHlwZS5DT05TVFJVQ1QgKi8sXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgYXJndW1lbnRMaXN0LFxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZWdpc3RlclByb3h5KHByb3h5LCBlcCk7XG4gICAgcmV0dXJuIHByb3h5O1xufVxuZnVuY3Rpb24gbXlGbGF0KGFycikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0FyZ3VtZW50cyhhcmd1bWVudExpc3QpIHtcbiAgICBjb25zdCBwcm9jZXNzZWQgPSBhcmd1bWVudExpc3QubWFwKHRvV2lyZVZhbHVlKTtcbiAgICByZXR1cm4gW3Byb2Nlc3NlZC5tYXAoKHYpID0+IHZbMF0pLCBteUZsYXQocHJvY2Vzc2VkLm1hcCgodikgPT4gdlsxXSkpXTtcbn1cbmNvbnN0IHRyYW5zZmVyQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gdHJhbnNmZXIob2JqLCB0cmFuc2ZlcnMpIHtcbiAgICB0cmFuc2ZlckNhY2hlLnNldChvYmosIHRyYW5zZmVycyk7XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHByb3h5KG9iaikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgeyBbcHJveHlNYXJrZXJdOiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gd2luZG93RW5kcG9pbnQodywgY29udGV4dCA9IGdsb2JhbFRoaXMsIHRhcmdldE9yaWdpbiA9IFwiKlwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zdE1lc3NhZ2U6IChtc2csIHRyYW5zZmVyYWJsZXMpID0+IHcucG9zdE1lc3NhZ2UobXNnLCB0YXJnZXRPcmlnaW4sIHRyYW5zZmVyYWJsZXMpLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIuYmluZChjb250ZXh0KSxcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogY29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQoY29udGV4dCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvV2lyZVZhbHVlKHZhbHVlKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgaGFuZGxlcl0gb2YgdHJhbnNmZXJIYW5kbGVycykge1xuICAgICAgICBpZiAoaGFuZGxlci5jYW5IYW5kbGUodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBbc2VyaWFsaXplZFZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IGhhbmRsZXIuc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkhBTkRMRVJcIiAvKiBXaXJlVmFsdWVUeXBlLkhBTkRMRVIgKi8sXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzZXJpYWxpemVkVmFsdWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcmFibGVzLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcIlJBV1wiIC8qIFdpcmVWYWx1ZVR5cGUuUkFXICovLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZmVyQ2FjaGUuZ2V0KHZhbHVlKSB8fCBbXSxcbiAgICBdO1xufVxuZnVuY3Rpb24gZnJvbVdpcmVWYWx1ZSh2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICBjYXNlIFwiSEFORExFUlwiIC8qIFdpcmVWYWx1ZVR5cGUuSEFORExFUiAqLzpcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2ZlckhhbmRsZXJzLmdldCh2YWx1ZS5uYW1lKS5kZXNlcmlhbGl6ZSh2YWx1ZS52YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJSQVdcIiAvKiBXaXJlVmFsdWVUeXBlLlJBVyAqLzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBtc2csIHRyYW5zZmVycykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlVVVJRCgpO1xuICAgICAgICBwZW5kaW5nTGlzdGVuZXJzLnNldChpZCwgcmVzb2x2ZSk7XG4gICAgICAgIGlmIChlcC5zdGFydCkge1xuICAgICAgICAgICAgZXAuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKHsgaWQgfSwgbXNnKSwgdHJhbnNmZXJzKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5KDQpXG4gICAgICAgIC5maWxsKDApXG4gICAgICAgIC5tYXAoKCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLnRvU3RyaW5nKDE2KSlcbiAgICAgICAgLmpvaW4oXCItXCIpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVFbmRwb2ludCwgZXhwb3NlLCBmaW5hbGl6ZXIsIHByb3h5LCBwcm94eU1hcmtlciwgcmVsZWFzZVByb3h5LCB0cmFuc2ZlciwgdHJhbnNmZXJIYW5kbGVycywgd2luZG93RW5kcG9pbnQsIHdyYXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWxpbmsubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/comlink/dist/esm/comlink.mjs\n\n}");

/***/ }),

/***/ "./src/_pypi.ts":
/*!**********************!*\
  !*** ./src/_pypi.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allJSONUrl: () => (/* binding */ allJSONUrl),\n/* harmony export */   ipykernelWheelUrl: () => (/* binding */ ipykernelWheelUrl),\n/* harmony export */   pipliteWheelUrl: () => (/* binding */ pipliteWheelUrl),\n/* harmony export */   pyodide_kernelWheelUrl: () => (/* binding */ pyodide_kernelWheelUrl),\n/* harmony export */   widgetsnbextensionWheelUrl: () => (/* binding */ widgetsnbextensionWheelUrl),\n/* harmony export */   widgetsnbextensionWheelUrl1: () => (/* binding */ widgetsnbextensionWheelUrl1)\n/* harmony export */ });\n// this file is autogenerated from the wheels in the pypi directory\nconst allJSONUrl = \"pypi/all.json\";\nconst ipykernelWheelUrl = \"pypi/ipykernel-6.9.2-py3-none-any.whl\";\nconst pipliteWheelUrl = \"pypi/piplite-0.6.0a5-py3-none-any.whl\";\nconst pyodide_kernelWheelUrl = \"pypi/pyodide_kernel-0.6.0a5-py3-none-any.whl\";\nconst widgetsnbextensionWheelUrl = \"pypi/widgetsnbextension-3.6.999-py3-none-any.whl\";\nconst widgetsnbextensionWheelUrl1 = \"pypi/widgetsnbextension-4.0.999-py3-none-any.whl\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvX3B5cGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxtRUFBbUU7QUFDNUQsTUFBTSxVQUFVLEdBQUcsZUFBZSxDQUFDO0FBQ25DLE1BQU0saUJBQWlCLEdBQUcsdUNBQXVDLENBQUM7QUFDbEUsTUFBTSxlQUFlLEdBQUcsdUNBQXVDLENBQUM7QUFDaEUsTUFBTSxzQkFBc0IsR0FBRyw4Q0FBOEMsQ0FBQztBQUM5RSxNQUFNLDBCQUEwQixHQUFHLGtEQUFrRCxDQUFDO0FBQ3RGLE1BQU0sMkJBQTJCLEdBQUcsa0RBQWtELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItcHl0aG9uLWtlcm5lbC8uL3NyYy9fcHlwaS50cz9lODZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRoaXMgZmlsZSBpcyBhdXRvZ2VuZXJhdGVkIGZyb20gdGhlIHdoZWVscyBpbiB0aGUgcHlwaSBkaXJlY3RvcnlcbmV4cG9ydCBjb25zdCBhbGxKU09OVXJsID0gXCJweXBpL2FsbC5qc29uXCI7XG5leHBvcnQgY29uc3QgaXB5a2VybmVsV2hlZWxVcmwgPSBcInB5cGkvaXB5a2VybmVsLTYuOS4yLXB5My1ub25lLWFueS53aGxcIjtcbmV4cG9ydCBjb25zdCBwaXBsaXRlV2hlZWxVcmwgPSBcInB5cGkvcGlwbGl0ZS0wLjYuMGE1LXB5My1ub25lLWFueS53aGxcIjtcbmV4cG9ydCBjb25zdCBweW9kaWRlX2tlcm5lbFdoZWVsVXJsID0gXCJweXBpL3B5b2RpZGVfa2VybmVsLTAuNi4wYTUtcHkzLW5vbmUtYW55LndobFwiO1xuZXhwb3J0IGNvbnN0IHdpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsID0gXCJweXBpL3dpZGdldHNuYmV4dGVuc2lvbi0zLjYuOTk5LXB5My1ub25lLWFueS53aGxcIjtcbmV4cG9ydCBjb25zdCB3aWRnZXRzbmJleHRlbnNpb25XaGVlbFVybDEgPSBcInB5cGkvd2lkZ2V0c25iZXh0ZW5zaW9uLTQuMC45OTktcHkzLW5vbmUtYW55LndobFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/_pypi.ts\n\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Kernel: () => (/* binding */ Kernel),\n/* harmony export */   KernelEvents: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents),\n/* harmony export */   KernelLanguage: () => (/* reexport safe */ _manager__WEBPACK_IMPORTED_MODULE_3__.KernelLanguage),\n/* harmony export */   KernelManager: () => (/* reexport safe */ _manager__WEBPACK_IMPORTED_MODULE_3__.KernelManager),\n/* harmony export */   KernelMode: () => (/* reexport safe */ _manager__WEBPACK_IMPORTED_MODULE_3__.KernelMode)\n/* harmony export */ });\n/* harmony import */ var _pyodide_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pyodide-loader */ \"./src/pyodide-loader.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _pypi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_pypi */ \"./src/_pypi.ts\");\n/* harmony import */ var _manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./manager */ \"./src/manager.ts\");\n// Kernel implementation for Deno using Pyodide directly\n// Based on the PyodideRemoteKernel but adapted for direct execution in main thread\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    }\n    off(eventName, listener) {\n        if (!this.events[eventName])\n            return;\n        const index = this.events[eventName].indexOf(listener);\n        if (index > -1) {\n            this.events[eventName].splice(index, 1);\n        }\n    }\n    emit(eventName, ...args) {\n        if (!this.events[eventName])\n            return;\n        this.events[eventName].forEach(listener => listener(...args));\n    }\n    setMaxListeners(n) {\n        // No-op for browser compatibility\n    }\n}\n// @ts-ignore Importing from npm\n\n// Import types and enums\n\n// Import PyPI URLs\n\n// Event types from JupyterLab\n// Re-export types to maintain backward compatibility\n\n\nclass Kernel extends EventEmitter {\n    constructor() {\n        super();\n        this.initialized = false;\n        this.initPromise = null;\n        // Filesystem options\n        this.filesystemOptions = {\n            enabled: false,\n            root: \".\",\n            mountPoint: \"/home/pyodide\"\n        };\n        // Input handling\n        this._resolveInputReply = null;\n        // Execution state\n        this._parent_header = {};\n        this.executionCount = 0;\n        this._status = \"unknown\";\n        // Interrupt handling\n        this._interruptBuffer = null;\n        this._interruptSupported = false;\n        // Environment variables\n        this.environmentVariables = {};\n        // Native filesystem handles\n        this.nativeFsHandles = new Map();\n        this.autoSyncFs = false;\n        super.setMaxListeners(20);\n        // Generate a unique ID for this kernel instance\n        this.kernelId = `kernel_${Math.random().toString(36).substring(2)}_${Date.now()}`;\n    }\n    // Async method for kernel status\n    async getStatus() {\n        return this._status;\n    }\n    /**\n     * Initialize the kernel with maximum performance optimizations\n     * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n     */\n    async initialize(options) {\n        if (this.initialized) {\n            return;\n        }\n        if (this.initPromise) {\n            return this.initPromise;\n        }\n        // Set filesystem options if provided\n        if (options?.filesystem) {\n            this.filesystemOptions = {\n                ...this.filesystemOptions,\n                ...options.filesystem\n            };\n        }\n        // Set environment variables if provided\n        if (options?.env) {\n            this.environmentVariables = { ...options.env };\n        }\n        // Set lockFileURL if provided\n        if (options?.lockFileURL) {\n            this.lockFileURL = options.lockFileURL;\n        }\n        // Set autoSyncFs if provided\n        if (options?.autoSyncFs !== undefined) {\n            this.autoSyncFs = options.autoSyncFs;\n        }\n        this.initPromise = this._initializeInternal();\n        return this.initPromise;\n    }\n    /**\n     * Initialize the kernel with maximum performance optimizations\n     * OPTIMIZED: Full parallelization with smart caching and performance monitoring\n     */\n    async _initializeInternal() {\n        const startTime = Date.now();\n        console.log(\"ðŸš€ Starting optimized kernel initialization...\");\n        try {\n            // Load Pyodide from CDN\n            const pyodideStartTime = Date.now();\n            // Configure pyodide options\n            const pyodideConfig = {};\n            if (this.lockFileURL) {\n                pyodideConfig.lockFileURL = this.lockFileURL;\n                console.log(`ðŸ”’ Using lockFileURL: ${this.lockFileURL}`);\n            }\n            // Use our CDN loader - it will automatically handle main thread vs worker\n            this.pyodide = await (0,_pyodide_loader__WEBPACK_IMPORTED_MODULE_0__.loadPyodide)(pyodideConfig);\n            const pyodideTime = Date.now() - pyodideStartTime;\n            console.log(`âœ… Pyodide loaded in ${pyodideTime}ms`);\n            // Initialize core components in parallel\n            if (this.lockFileURL) {\n                // When using lockFileURL, packages are pre-installed, skip package installation\n                console.log(\"ðŸš€ Using lock file - skipping package installation\");\n                const [,] = await Promise.all([\n                    // 1. Filesystem mounting (if enabled)\n                    this.filesystemOptions.enabled ? this.mountFilesystem() : Promise.resolve(),\n                    // 2. Environment variables setup\n                    this.setEnvironmentVariables()\n                ]);\n                // Initialize globals directly (packages are already available)\n                await this.initGlobals();\n            }\n            else {\n                // Standard initialization with package installation\n                const [, ,] = await Promise.all([\n                    // 1. Filesystem mounting (if enabled)\n                    this.filesystemOptions.enabled ? this.mountFilesystem() : Promise.resolve(),\n                    // 2. Package manager initialization\n                    this.initPackageManager(),\n                    // 3. Environment variables setup\n                    this.setEnvironmentVariables()\n                ]);\n                // Install packages and initialize globals\n                await this.initKernel();\n                await this.initGlobals();\n            }\n            const totalTime = Date.now() - startTime;\n            console.log(`ðŸŽ¯ KERNEL INITIALIZATION COMPLETE in ${totalTime}ms`);\n            console.log(`âš¡ Performance: Pyodide(${pyodideTime}ms) + Setup(${totalTime - pyodideTime}ms)`);\n            // Mark as initialized\n            this.initialized = true;\n            this._status = \"active\";\n            console.log(\"ðŸŸ¢ Kernel is now ACTIVE and ready for execution!\");\n        }\n        catch (error) {\n            console.error(\"âŒ Kernel initialization failed:\", error);\n            this._status = \"unknown\";\n            throw error;\n        }\n    }\n    /**\n     * Mount the local filesystem to the Pyodide environment\n     */\n    async mountFilesystem() {\n        try {\n            console.log(`Mounting filesystem from ${this.filesystemOptions.root} to ${this.filesystemOptions.mountPoint}`);\n            // Use the same approach as in deno-demo-fs-asgi.js for maximum compatibility\n            // Simple and direct mounting of the filesystem\n            await this.pyodide.FS.mount(this.pyodide.FS.filesystems.NODEFS, { root: this.filesystemOptions.root || \".\" }, this.filesystemOptions.mountPoint || \"/home/pyodide\");\n            console.log(\"Filesystem mounted successfully\");\n            // Verify the mount by listing the directory\n            try {\n                const mountedFiles = this.pyodide.FS.readdir(this.filesystemOptions.mountPoint || \"/home/pyodide\");\n                console.log(`Files in ${this.filesystemOptions.mountPoint} directory: ${mountedFiles.join(\", \")}`);\n            }\n            catch (error) {\n                console.error(`Error listing mounted directory: ${error}`);\n            }\n        }\n        catch (error) {\n            console.error(\"Error mounting filesystem:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Initialize the Pyodide package manager with optimized wheel loading\n     * OPTIMIZED: Smart caching and parallel wheel installation\n     */\n    async initPackageManager() {\n        const startTime = Date.now();\n        console.log(\"âš¡ Initializing optimized package manager...\");\n        try {\n            // Load micropip and packaging in parallel\n            console.log(\"ðŸ“¦ Loading micropip, packaging...\");\n            await this.pyodide.loadPackage(['micropip', 'packaging']);\n            console.log(\"âœ… Loaded micropip, packaging\");\n            // Get the base URL - use window.location for browser or fallback for worker\n            let baseUrl;\n            if (typeof window !== 'undefined' && window.location) {\n                // In main thread - use window.location\n                baseUrl = new URL(\".\", window.location.href).href;\n            }\n            else if (typeof self !== 'undefined' && self.location) {\n                // In web worker - use self.location\n                baseUrl = new URL(\".\", self.location.href).href;\n            }\n            else {\n                // Fallback - assume current origin\n                baseUrl = \"/\";\n            }\n            const allJsonPath = new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.allJSONUrl, baseUrl).href;\n            // Prepare all wheel URLs for parallel loading\n            const wheelFiles = [\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.pipliteWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.pyodide_kernelWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.ipykernelWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.widgetsnbextensionWheelUrl, baseUrl).href,\n                new URL(_pypi__WEBPACK_IMPORTED_MODULE_2__.widgetsnbextensionWheelUrl1, baseUrl).href,\n            ];\n            console.log(`ðŸš€ Installing ${wheelFiles.length} wheel packages in parallel...`);\n            // Install all wheel packages in parallel for maximum speed\n            const wheelPromises = wheelFiles.map(async (wheelUrl, index) => {\n                const wheelStartTime = Date.now();\n                try {\n                    await this.pyodide.runPythonAsync(`\nimport micropip\nawait micropip.install('${wheelUrl}', keep_going=True)\nprint(f\"âœ… Wheel ${index + 1}/${wheelFiles.length} installed\")\n`);\n                    const wheelTime = Date.now() - wheelStartTime;\n                    console.log(`âš¡ Wheel ${index + 1} installed in ${wheelTime}ms`);\n                    return { index, success: true, time: wheelTime };\n                }\n                catch (error) {\n                    const wheelTime = Date.now() - wheelStartTime;\n                    console.warn(`âš ï¸ Wheel ${index + 1} failed after ${wheelTime}ms:`, error);\n                    return { index, success: false, time: wheelTime, error };\n                }\n            });\n            // Wait for all wheel installations\n            const wheelResults = await Promise.all(wheelPromises);\n            const successful = wheelResults.filter(r => r.success);\n            const failed = wheelResults.filter(r => !r.success);\n            console.log(`ðŸ“Š Wheels: ${successful.length}/${wheelFiles.length} successful`);\n            if (failed.length > 0) {\n                console.warn(`âš ï¸ Failed wheels: ${failed.map(f => f.index + 1).join(', ')}`);\n            }\n            // Set up piplite configuration with performance optimizations (if available)\n            try {\n                await this.pyodide.runPythonAsync(`\ntry:\n    import piplite.piplite\n    import json\n\n    # Load package index for faster lookups\n    try:\n        piplite.piplite.PIPLITE_URL = \"${allJsonPath}\"\n        # Pre-load package index for faster installation\n        print(\"ðŸ“‹ Package index configured\")\n    except Exception as e:\n        print(f\"âš ï¸ Package index setup warning: {e}\")\n\n    # Configure piplite for optimal performance\n    piplite.piplite.REPODATA_INFO = {}\n    print(\"âš¡ Piplite optimized for performance\")\nexcept ImportError:\n    print(\"âš ï¸ Piplite not available, continuing without it\")\nexcept Exception as e:\n    print(f\"âš ï¸ Piplite setup failed: {e}\")\n`);\n            }\n            catch (error) {\n                console.warn(\"âš ï¸ Piplite configuration failed, continuing without it:\", error);\n            }\n            const totalTime = Date.now() - startTime;\n            console.log(`ðŸŽ¯ Package manager initialized in ${totalTime}ms`);\n        }\n        catch (error) {\n            console.error(\"âŒ Package manager initialization failed:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Initialize the kernel with required Python packages\n     * OPTIMIZED: Maximum parallelization with intelligent dependency resolution\n     */\n    async initKernel() {\n        const startTime = Date.now();\n        console.log(\"ðŸš€ Initializing kernel packages with maximum optimization...\");\n        // All packages to install with priority and dependency information\n        const packageConfig = [\n            // High priority: CDN packages (fastest)\n            { name: 'pure-eval', priority: 1, source: 'pyodide' },\n            { name: 'stack-data', priority: 1, source: 'pyodide' },\n            { name: 'pygments', priority: 1, source: 'pyodide' },\n            { name: 'ssl', priority: 1, source: 'pyodide' },\n            { name: 'sqlite3', priority: 1, source: 'pyodide' },\n            { name: 'prompt_toolkit', priority: 1, source: 'pyodide' },\n            { name: 'jedi', priority: 1, source: 'pyodide' },\n            { name: 'ipython', priority: 1, source: 'pyodide' },\n            // Medium priority: pip packages\n            { name: 'comm', priority: 2, source: 'pip' },\n            { name: 'hypha-rpc', priority: 2, source: 'pip' },\n            { name: 'nbformat', priority: 2, source: 'pip' },\n            // Lower priority: complex packages\n            { name: 'ipykernel', priority: 3, source: 'pip' },\n            { name: 'pyodide_kernel', priority: 3, source: 'pip' }\n        ];\n        try {\n            console.log(`ðŸ“¦ Installing ${packageConfig.length} packages with intelligent optimization...`);\n            // Install ALL packages in parallel with advanced error handling and caching\n            await this.installPackagesWithIntelligentOptimization(packageConfig);\n            // Import the kernel (must be done after packages are installed)\n            console.log(\"ðŸ“¥ Importing pyodide_kernel...\");\n            const importStartTime = Date.now();\n            await this.pyodide.runPythonAsync('import pyodide_kernel');\n            const importTime = Date.now() - importStartTime;\n            console.log(`âœ… pyodide_kernel imported in ${importTime}ms`);\n            const totalTime = Date.now() - startTime;\n            console.log(`ðŸŽ¯ Kernel packages initialized in ${totalTime}ms`);\n        }\n        catch (error) {\n            console.error(\"âŒ Kernel package initialization failed:\", error);\n            throw error;\n        }\n    }\n    /**\n     * Install packages with intelligent optimization and advanced caching\n     * OPTIMIZED: Smart source selection, parallel installation, and performance monitoring\n     */\n    async installPackagesWithIntelligentOptimization(packageConfig) {\n        console.log(`âš¡ Starting intelligent parallel installation of ${packageConfig.length} packages...`);\n        const installPromises = packageConfig.map(async (pkg) => {\n            const startTime = Date.now();\n            try {\n                console.log(`ðŸ”„ Installing ${pkg.name} (priority: ${pkg.priority}, preferred: ${pkg.source})...`);\n                // Try preferred source first, with intelligent fallback\n                if (pkg.source === 'pyodide') {\n                    try {\n                        await this.pyodide.loadPackage([pkg.name]);\n                        const duration = Date.now() - startTime;\n                        console.log(`âœ… ${pkg.name} loaded from Pyodide CDN (${duration}ms)`);\n                        return { package: pkg.name, method: 'pyodide', duration, success: true, priority: pkg.priority };\n                    }\n                    catch (pyodideError) {\n                        // Fallback to pip with enhanced error handling\n                        console.log(`ðŸ“¦ ${pkg.name} not available on CDN, trying pip...`);\n                        await this.installViaPipWithOptimizations(pkg.name);\n                        const duration = Date.now() - startTime;\n                        console.log(`âœ… ${pkg.name} installed via pip fallback (${duration}ms)`);\n                        return { package: pkg.name, method: 'pip-fallback', duration, success: true, priority: pkg.priority };\n                    }\n                }\n                else {\n                    // Direct pip installation with optimizations\n                    await this.installViaPipWithOptimizations(pkg.name);\n                    const duration = Date.now() - startTime;\n                    console.log(`âœ… ${pkg.name} installed via pip (${duration}ms)`);\n                    return { package: pkg.name, method: 'pip', duration, success: true, priority: pkg.priority };\n                }\n            }\n            catch (error) {\n                const duration = Date.now() - startTime;\n                console.warn(`âŒ Failed to install ${pkg.name} after ${duration}ms:`, error);\n                return { package: pkg.name, method: 'failed', duration, success: false, priority: pkg.priority, error };\n            }\n        });\n        // Wait for all installations with detailed analysis\n        const results = await Promise.all(installPromises);\n        // Comprehensive performance analysis\n        this.analyzeInstallationResults(results);\n    }\n    /**\n     * Install package via pip with performance optimizations\n     */\n    async installViaPipWithOptimizations(packageName) {\n        await this.pyodide.runPythonAsync(`\ntry:\n    # Import piplite first\n    import piplite\n    # Use optimized pip installation with caching\n    await piplite.install('${packageName}', keep_going=True, deps=True)\n    print(\"âœ… Successfully installed ${packageName} via optimized pip\")\nexcept Exception as e:\n    print(\"âš ï¸ Warning: Failed to install ${packageName}:\", str(e))\n    # Try alternative installation method\n    try:\n        import micropip\n        await micropip.install('${packageName}', keep_going=True)\n        print(\"âœ… Successfully installed ${packageName} via micropip fallback\")\n    except Exception as e2:\n        print(\"âŒ Both pip methods failed for ${packageName}:\", str(e2))\n        raise e2\n`);\n    }\n    /**\n     * Analyze installation results and provide performance insights\n     */\n    analyzeInstallationResults(results) {\n        const successful = results.filter(r => r.success);\n        const failed = results.filter(r => !r.success);\n        const pyodideInstalls = successful.filter(r => r.method === 'pyodide');\n        const pipInstalls = successful.filter(r => r.method === 'pip');\n        const fallbackInstalls = successful.filter(r => r.method === 'pip-fallback');\n        const totalDuration = Math.max(...results.map(r => r.duration));\n        const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length;\n        const estimatedSequential = results.reduce((sum, r) => sum + r.duration, 0);\n        console.log(`ðŸŽ¯ INTELLIGENT INSTALLATION COMPLETE!`);\n        console.log(`ðŸ“Š Results: ${successful.length}/${results.length} successful`);\n        console.log(`âš¡ Pyodide CDN: ${pyodideInstalls.length} packages`);\n        console.log(`ðŸ“¦ Direct pip: ${pipInstalls.length} packages`);\n        console.log(`ðŸ”„ Pip fallback: ${fallbackInstalls.length} packages`);\n        console.log(`âŒ Failed: ${failed.length} packages`);\n        console.log(`â±ï¸  Total time: ${totalDuration}ms (vs ~${estimatedSequential}ms sequential)`);\n        console.log(`ðŸš€ Speed improvement: ~${Math.round(estimatedSequential / totalDuration)}x faster`);\n        console.log(`ðŸ“ˆ Average per package: ${Math.round(avgDuration)}ms`);\n        if (failed.length > 0) {\n            console.warn(`âš ï¸  Failed packages: ${failed.map(f => f.package).join(', ')}`);\n            // Log specific failure reasons for debugging\n            failed.forEach(f => {\n                console.warn(`   - ${f.package}: ${f.error?.message || 'Unknown error'}`);\n            });\n        }\n        // Performance insights\n        const fastestInstall = Math.min(...successful.map(r => r.duration));\n        const slowestInstall = Math.max(...successful.map(r => r.duration));\n        console.log(`ðŸ“Š Performance range: ${fastestInstall}ms (fastest) to ${slowestInstall}ms (slowest)`);\n    }\n    /**\n     * Initialize global objects from the pyodide_kernel package\n     * Based on the PyodideRemoteKernel implementation\n     */\n    async initGlobals() {\n        console.log(\"Initializing globals...\");\n        // Get the globals from the Python environment\n        const { globals } = this.pyodide;\n        // Get the kernel instance and related objects\n        this._kernel = globals.get('pyodide_kernel').kernel_instance.copy();\n        this._stdout_stream = globals.get('pyodide_kernel').stdout_stream.copy();\n        this._stderr_stream = globals.get('pyodide_kernel').stderr_stream.copy();\n        this._interpreter = this._kernel.interpreter.copy();\n        // Set up communication handlers\n        this._interpreter.send_comm = this.sendComm.bind(this);\n        // Set up callbacks\n        this.setupCallbacks();\n    }\n    /**\n     * Setup all necessary callbacks for the Python environment\n     */\n    setupCallbacks() {\n        // Execution result callback\n        const publishExecutionResult = (prompt_count, data, metadata) => {\n            const bundle = {\n                execution_count: prompt_count,\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'execute_result',\n            });\n        };\n        // Error callback\n        const publishExecutionError = (ename, evalue, traceback) => {\n            const bundle = {\n                ename: ename,\n                evalue: evalue,\n                traceback: traceback,\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'execute_error',\n            });\n        };\n        // Clear output callback\n        const clearOutputCallback = (wait) => {\n            const bundle = {\n                wait: this.formatResult(wait),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'clear_output',\n            });\n        };\n        // Display data callback\n        const displayDataCallback = (data, metadata, transient) => {\n            const bundle = {\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n                transient: this.formatResult(transient),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'display_data',\n            });\n        };\n        // Update display data callback\n        const updateDisplayDataCallback = (data, metadata, transient) => {\n            const bundle = {\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n                transient: this.formatResult(transient),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'update_display_data',\n            });\n        };\n        // Stream callback\n        const publishStreamCallback = (name, text) => {\n            const bundle = {\n                name: this.formatResult(name),\n                text: this.formatResult(text),\n            };\n            this._sendMessage({\n                parentHeader: this.formatResult(this._parent_header)['header'],\n                bundle,\n                type: 'stream',\n            });\n        };\n        // Assign callbacks to the Python objects\n        this._stdout_stream.publish_stream_callback = publishStreamCallback;\n        this._stderr_stream.publish_stream_callback = publishStreamCallback;\n        this._interpreter.display_pub.clear_output_callback = clearOutputCallback;\n        this._interpreter.display_pub.display_data_callback = displayDataCallback;\n        this._interpreter.display_pub.update_display_data_callback = updateDisplayDataCallback;\n        this._interpreter.displayhook.publish_execution_result = publishExecutionResult;\n        this._interpreter.input = this.input.bind(this);\n        this._interpreter.getpass = this.getpass.bind(this);\n    }\n    /**\n     * Process a message from Python environment\n     */\n    _sendMessage(msg) {\n        this._processMessage(msg);\n    }\n    /**\n     * Process a message by emitting the appropriate event\n     */\n    _processMessage(msg) {\n        if (!msg.type) {\n            return;\n        }\n        let eventData;\n        switch (msg.type) {\n            case 'stream': {\n                const bundle = msg.bundle ?? { name: 'stdout', text: '' };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.STREAM, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'input_request': {\n                const content = msg.content ?? { prompt: '', password: false };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.INPUT_REQUEST, content);\n                eventData = content;\n                break;\n            }\n            case 'display_data': {\n                const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.DISPLAY_DATA, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'update_display_data': {\n                const bundle = msg.bundle ?? { data: {}, metadata: {}, transient: {} };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.UPDATE_DISPLAY_DATA, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'clear_output': {\n                const bundle = msg.bundle ?? { wait: false };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.CLEAR_OUTPUT, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'execute_result': {\n                const bundle = msg.bundle ?? {\n                    execution_count: this.executionCount,\n                    data: {},\n                    metadata: {},\n                };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_RESULT, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'execute_error': {\n                const bundle = msg.bundle ?? { ename: '', evalue: '', traceback: [] };\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, bundle);\n                eventData = bundle;\n                break;\n            }\n            case 'comm_open':\n            case 'comm_msg':\n            case 'comm_close': {\n                const content = msg.content ?? {};\n                super.emit(msg.type, content, msg.metadata, msg.buffers);\n                eventData = {\n                    content,\n                    metadata: msg.metadata,\n                    buffers: msg.buffers\n                };\n                break;\n            }\n        }\n        // Emit the ALL event with standardized format\n        if (eventData) {\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, {\n                type: msg.type,\n                data: eventData\n            });\n        }\n    }\n    /**\n     * Check if the kernel has been initialized\n     */\n    isInitialized() {\n        return this.initialized;\n    }\n    /**\n     * Makes sure pyodide is ready before continuing, and cache the parent message.\n     */\n    async setup(parent) {\n        await this.initialize();\n        this._parent_header = this.pyodide.toPy(parent || {});\n    }\n    /**\n     * Execute code in the kernel with proper message-based completion detection\n     *\n     * @param code The code to execute\n     * @param parent Parent message header\n     * @returns The result of the execution\n     */\n    async execute(code, parent = {}) {\n        // Simple implementation that collects all outputs from executeStream\n        const outputs = [];\n        try {\n            // Use executeStream to get all outputs\n            for await (const output of this.executeStream(code, parent)) {\n                outputs.push(output);\n            }\n            // Process collected outputs to create a comprehensive result\n            const result = {\n                outputs: [],\n                data: {},\n                metadata: {},\n                execution_count: this.executionCount\n            };\n            // Collect all output types\n            for (const output of outputs) {\n                if (output.type === 'stream') {\n                    // Collect stdout/stderr\n                    if (!result.stdout)\n                        result.stdout = '';\n                    if (!result.stderr)\n                        result.stderr = '';\n                    if (output.data.name === 'stdout') {\n                        result.stdout += output.data.text;\n                    }\n                    else if (output.data.name === 'stderr') {\n                        result.stderr += output.data.text;\n                    }\n                    result.outputs.push(output.data);\n                }\n                else if (output.type === 'display_data' || output.type === 'execute_result') {\n                    // Collect display data\n                    if (output.data.data) {\n                        Object.assign(result.data, output.data.data);\n                    }\n                    if (output.data.metadata) {\n                        Object.assign(result.metadata, output.data.metadata);\n                    }\n                    result.outputs.push(output.data);\n                }\n                else if (output.type === 'execute_error' || output.type === 'error') {\n                    // Handle errors\n                    const errorData = output.data;\n                    return {\n                        success: false,\n                        error: new Error(`${errorData.ename}: ${errorData.evalue}`),\n                        ename: errorData.ename,\n                        evalue: errorData.evalue,\n                        traceback: errorData.traceback,\n                        outputs: result.outputs\n                    };\n                }\n                else {\n                    // Store any other output type\n                    result.outputs.push(output);\n                }\n            }\n            // Return collected results\n            result.success = true;\n            // Auto-sync native filesystems if enabled\n            if (this.autoSyncFs) {\n                await this.syncAllNativeFs();\n            }\n            return result;\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Execute error:\", error);\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    /**\n     * Format the result from the Pyodide evaluation\n     * Based on PyodideRemoteKernel implementation\n     */\n    formatResult(res) {\n        if (!(res instanceof this.pyodide.ffi.PyProxy)) {\n            return res;\n        }\n        try {\n            // Convert PyProxy to JS\n            const m = res.toJs();\n            const results = this.mapToObject(m);\n            return results;\n        }\n        catch (error) {\n            console.error(\"Error formatting result:\", error);\n            return { status: 'error', error: String(error) };\n        }\n    }\n    /**\n     * Convert a Map to a JavaScript object recursively\n     * Based on PyodideRemoteKernel implementation\n     */\n    mapToObject(obj) {\n        const out = obj instanceof Array ? [] : {};\n        obj.forEach((value, key) => {\n            out[key] =\n                value instanceof Map || value instanceof Array\n                    ? this.mapToObject(value)\n                    : value;\n        });\n        return out;\n    }\n    /**\n     * Handle input reply from user\n     */\n    async inputReply(content) {\n        if (this._resolveInputReply) {\n            this._resolveInputReply(content);\n            this._resolveInputReply = null;\n        }\n    }\n    /**\n     * Send a input request to the front-end.\n     */\n    async sendInputRequest(prompt, password) {\n        const content = {\n            prompt,\n            password,\n        };\n        this._sendMessage({\n            type: 'input_request',\n            content,\n            parentHeader: this.formatResult(this._parent_header)['header']\n        });\n    }\n    /**\n     * Get password input (with hidden input)\n     */\n    async getpass(prompt) {\n        prompt = typeof prompt === 'undefined' ? '' : prompt;\n        await this.sendInputRequest(prompt, true);\n        const replyPromise = new Promise((resolve) => {\n            this._resolveInputReply = resolve;\n        });\n        const result = await replyPromise;\n        return result.value;\n    }\n    /**\n     * Get text input\n     */\n    async input(prompt) {\n        prompt = typeof prompt === 'undefined' ? '' : prompt;\n        await this.sendInputRequest(prompt, false);\n        const replyPromise = new Promise((resolve) => {\n            this._resolveInputReply = resolve;\n        });\n        const result = await replyPromise;\n        return result.value;\n    }\n    /**\n     * Send a comm message to the front-end.\n     */\n    async sendComm(type, content, metadata, ident, buffers) {\n        this._sendMessage({\n            type: type,\n            content: this.formatResult(content),\n            metadata: this.formatResult(metadata),\n            ident: this.formatResult(ident),\n            buffers: this.formatResult(buffers),\n            parentHeader: this.formatResult(this._parent_header)['header'],\n        });\n    }\n    /**\n     * Complete the code submitted by a user.\n     */\n    async complete(code, cursor_pos, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.complete(code, cursor_pos);\n        return this.formatResult(res);\n    }\n    /**\n     * Inspect the code submitted by a user.\n     */\n    async inspect(code, cursor_pos, detail_level, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.inspect(code, cursor_pos, detail_level);\n        return this.formatResult(res);\n    }\n    /**\n     * Check code for completeness.\n     */\n    async isComplete(code, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.is_complete(code);\n        return this.formatResult(res);\n    }\n    /**\n     * Get information about available comms.\n     */\n    async commInfo(target_name, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_info(target_name);\n        return {\n            comms: this.formatResult(res),\n            status: 'ok',\n        };\n    }\n    /**\n     * Open a COMM\n     */\n    async commOpen(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_open(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Send a message through a COMM\n     */\n    async commMsg(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_msg(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Close a COMM\n     */\n    async commClose(content, parent = {}) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_close(this.pyodide.toPy(null), this.pyodide.toPy(null), this.pyodide.toPy(content));\n        return this.formatResult(res);\n    }\n    /**\n     * Execute Python code with streaming output\n     * @param code The Python code to execute\n     * @param parent Parent message header\n     * @returns AsyncGenerator yielding intermediate outputs and finally the execution result\n     */\n    async *executeStream(code, parent = {}) {\n        if (!this.initialized) {\n            await this.initialize();\n        }\n        try {\n            this._status = \"busy\";\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_BUSY, {});\n            await this.setup(parent);\n            // Create event listeners for streaming\n            const eventQueue = [];\n            let executionComplete = false;\n            let executionResult = null;\n            let executionError = null;\n            const handleAllEvents = (eventData) => {\n                eventQueue.push(eventData);\n            };\n            // Listen for all events BEFORE executing code\n            super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, handleAllEvents);\n            try {\n                // Execute the code directly\n                this._kernel.run(code).then((result) => {\n                    console.log(\"[KERNEL] Python execution finished\");\n                    executionResult = this.formatResult(result);\n                    // Check if the result indicates an error and emit it as an event\n                    if (executionResult && executionResult.status === 'error') {\n                        console.log(\"[KERNEL] Execution completed with error status, emitting execute_error event\");\n                        // Emit the error event so the UI can display it\n                        this._sendMessage({\n                            parentHeader: this.formatResult(this._parent_header)['header'],\n                            bundle: {\n                                ename: executionResult.ename || 'Error',\n                                evalue: executionResult.evalue || 'Unknown error',\n                                traceback: executionResult.traceback || []\n                            },\n                            type: 'execute_error',\n                        });\n                    }\n                    // Wait a small amount of time for any remaining messages to be processed\n                    setTimeout(() => {\n                        executionComplete = true;\n                    }, 100); // 100ms should be enough for message processing\n                }).catch((error) => {\n                    console.error(\"[KERNEL] Python execution error:\", error);\n                    executionError = error instanceof Error ? error : new Error(String(error));\n                    // Still wait for messages to settle before completing\n                    setTimeout(() => {\n                        executionComplete = true;\n                    }, 100);\n                });\n                // Stream events as they arrive\n                while (!executionComplete || eventQueue.length > 0) {\n                    // Yield queued events\n                    if (eventQueue.length > 0) {\n                        const event = eventQueue.shift();\n                        yield event;\n                    }\n                    else if (!executionComplete) {\n                        // Wait a bit for more events\n                        await new Promise(resolve => setTimeout(resolve, 10));\n                    }\n                }\n                // Process final result\n                this._status = \"active\";\n                super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_IDLE, {});\n                if (executionError) {\n                    return {\n                        success: false,\n                        error: executionError,\n                        result: executionResult\n                    };\n                }\n                // Check if result indicates an error\n                if (executionResult && executionResult.status === 'error') {\n                    const errorMsg = `${executionResult.ename || 'Error'}: ${executionResult.evalue || 'Unknown error'}`;\n                    return {\n                        success: false,\n                        error: new Error(errorMsg),\n                        result: executionResult\n                    };\n                }\n                // Auto-sync native filesystems if enabled\n                if (this.autoSyncFs) {\n                    await this.syncAllNativeFs();\n                }\n                return {\n                    success: true,\n                    result: executionResult\n                };\n            }\n            finally {\n                // Clean up listener\n                super.off(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.ALL, handleAllEvents);\n            }\n        }\n        catch (error) {\n            console.error(\"[KERNEL] ExecuteStream error:\", error);\n            this._status = \"active\";\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.KERNEL_IDLE, {});\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    // Interrupt functionality\n    async interrupt() {\n        if (!this.initialized || !this.pyodide) {\n            console.warn(\"[KERNEL] Cannot interrupt: kernel not initialized\");\n            return false;\n        }\n        console.log(\"[KERNEL] Attempting to interrupt execution...\");\n        try {\n            // First priority: Use interrupt buffer if available\n            if (this._interruptBuffer && this._interruptSupported) {\n                console.log(\"[KERNEL] Using interrupt buffer method\");\n                // Set interrupt signal (2 = SIGINT)\n                this._interruptBuffer[0] = 2;\n                // Give the interrupt a moment to be processed\n                await new Promise(resolve => setTimeout(resolve, 100));\n                // Check if the interrupt was processed (buffer should be reset to 0)\n                const wasProcessed = this._interruptBuffer[0] === 0;\n                if (wasProcessed) {\n                    console.log(\"[KERNEL] Interrupt processed successfully via buffer\");\n                    return true;\n                }\n            }\n            // Second priority: Try Python-level interrupt\n            try {\n                console.log(\"[KERNEL] Attempting Python-level interrupt\");\n                // Try to raise KeyboardInterrupt in Python\n                await this.pyodide.runPythonAsync(`\nimport sys\nimport _thread\n# Try to interrupt the main thread\n_thread.interrupt_main()\n`);\n                console.log(\"[KERNEL] Python interrupt signal sent\");\n                return true;\n            }\n            catch (pythonError) {\n                console.log(\"[KERNEL] Python interrupt attempt failed:\", pythonError);\n            }\n            // Third priority: Try interpreter interrupt if available\n            if (this._interpreter && typeof this._interpreter.interrupt === 'function') {\n                console.log(\"[KERNEL] Using interpreter interrupt method\");\n                this._interpreter.interrupt();\n                return true;\n            }\n            // Last resort: Send interrupt messages for UI feedback\n            console.log(\"[KERNEL] Sending interrupt messages for UI feedback\");\n            // Send stderr stream first (for Jupyter notebook UI compatibility)\n            this._sendMessage({\n                type: 'stream',\n                bundle: {\n                    name: 'stderr',\n                    text: 'KeyboardInterrupt: Execution interrupted by user\\n'\n                }\n            });\n            this._sendMessage({\n                type: 'execute_error',\n                bundle: {\n                    ename: 'KeyboardInterrupt',\n                    evalue: 'Execution interrupted by user',\n                    traceback: ['KeyboardInterrupt: Execution interrupted by user']\n                }\n            });\n            // Return false since we couldn't actually interrupt the execution\n            return false;\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Error during interrupt:\", error);\n            return false;\n        }\n    }\n    setInterruptBuffer(buffer) {\n        this._interruptBuffer = buffer;\n        try {\n            if (this.pyodide && typeof this.pyodide.setInterruptBuffer === 'function') {\n                this.pyodide.setInterruptBuffer(buffer);\n                this._interruptSupported = true;\n            }\n            else {\n                console.warn(\"[KERNEL] pyodide.setInterruptBuffer not available, interrupt support limited\");\n                this._interruptSupported = false;\n            }\n        }\n        catch (error) {\n            console.error(\"[KERNEL] Error setting interrupt buffer:\", error);\n            this._interruptSupported = false;\n        }\n    }\n    /**\n     * Verify and request permission for a file system handle\n     * @private\n     */\n    async verifyPermission(fileHandle, permission) {\n        const opts = {};\n        if (permission === 'readwrite') {\n            opts.mode = 'readwrite';\n        }\n        console.log(`[KERNEL] Verifying ${permission} permission for file handle...`);\n        // Check if permission APIs are supported\n        if (typeof fileHandle.queryPermission !== 'function') {\n            console.warn('[KERNEL] queryPermission not supported, assuming permission granted');\n            return true;\n        }\n        try {\n            // Check if we already have permission, if so, return true.\n            const queryResult = await fileHandle.queryPermission(opts);\n            console.log('[KERNEL] Query result:', queryResult);\n            if (queryResult === 'granted') {\n                console.log(`[KERNEL] Permission already granted for ${permission} access`);\n                return true;\n            }\n            // Request permission to the file, if the user grants permission, return true.\n            if (typeof fileHandle.requestPermission === 'function') {\n                console.log(`[KERNEL] Requesting ${permission} permission from user...`);\n                try {\n                    const requestResult = await fileHandle.requestPermission(opts);\n                    console.log('[KERNEL] Request result:', requestResult);\n                    if (requestResult === 'granted') {\n                        console.log(`[KERNEL] Permission granted for ${permission} access`);\n                        return true;\n                    }\n                }\n                catch (requestError) {\n                    console.log('[KERNEL] Permission request failed or was dismissed:', requestError);\n                }\n            }\n            // The user did not grant permission, return false.\n            console.log(`[KERNEL] ${permission} permission not granted`);\n            return false;\n        }\n        catch (error) {\n            console.error('[KERNEL] Error checking permission:', error);\n            // If permission check fails, assume it's granted (more permissive approach)\n            console.warn('[KERNEL] Permission check failed, assuming granted as fallback');\n            return true;\n        }\n    }\n    /**\n     * Mount a native file system directory into the Pyodide filesystem\n     * @param mountPath The path where the directory should be mounted in the Python filesystem\n     * @param dirHandle Optional FileSystemDirectoryHandle. If null/undefined, shows directory picker\n     * @param permission Permission mode:\n     *   - 'read': Read-only access, no syncing capabilities, auto-sync will be skipped (default)\n     *   - 'readwrite': Full read/write access with syncing capabilities\n     * @returns Promise resolving to a handle with syncfs() method for syncing changes\n     * @note syncfs() will throw an error if called on a read-only mounted filesystem\n     * @note Many browsers only offer read permission initially. Explicitly request 'readwrite' if you need write access.\n     */\n    async mountFS(mountPath, dirHandle, permission = 'read') {\n        if (!this.initialized || !this.pyodide) {\n            throw new Error(\"Kernel must be initialized before mounting filesystem\");\n        }\n        // Check if mountNativeFS is available\n        if (typeof this.pyodide.mountNativeFS !== 'function') {\n            throw new Error(\"pyodide.mountNativeFS is not available. Make sure you're using Pyodide 0.23.0 or later.\");\n        }\n        let handle = dirHandle;\n        // If no dirHandle provided, show directory picker\n        if (!handle) {\n            // Check if we're in a worker context\n            if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n                throw new Error(\"Cannot show directory picker in worker context. Please provide a dirHandle parameter.\");\n            }\n            // Check if showDirectoryPicker is available\n            if (typeof window !== 'undefined' && 'showDirectoryPicker' in window) {\n                try {\n                    handle = await window.showDirectoryPicker({\n                        mode: 'readwrite',\n                    });\n                }\n                catch (error) {\n                    throw new Error(`Failed to show directory picker: ${error instanceof Error ? error.message : String(error)}`);\n                }\n            }\n            else {\n                throw new Error(\"showDirectoryPicker is not supported in this browser. Please provide a dirHandle parameter.\");\n            }\n        }\n        if (!handle) {\n            throw new Error(\"No directory handle available\");\n        }\n        // Verify and request permissions before mounting\n        console.log(`[KERNEL] Verifying ${permission} permissions before mounting...`);\n        const hasRequestedPermission = await this.verifyPermission(handle, permission);\n        if (!hasRequestedPermission) {\n            if (permission === 'readwrite') {\n                throw new Error(`Failed to obtain write permission for directory. ` +\n                    `The browser may only be offering read permission. ` +\n                    `Try mounting with permission: 'read' if you only need to read files, ` +\n                    `or ensure the browser supports write access to this directory.`);\n            }\n            else {\n                throw new Error(`Failed to obtain ${permission} permission for directory.`);\n            }\n        }\n        const actualPermission = permission;\n        // Mount the native filesystem\n        try {\n            console.log(`[KERNEL] Mounting native filesystem at ${mountPath} with ${actualPermission} permission`);\n            // Check if the mount point already exists and handle cleanup\n            try {\n                const pathInfo = this.pyodide.FS.analyzePath(mountPath);\n                if (pathInfo.exists) {\n                    console.log(`[KERNEL] Path ${mountPath} exists, checking if it's a mount point`);\n                    // Try to unmount if it's already mounted\n                    try {\n                        await this.pyodide.FS.unmount(mountPath);\n                        console.log(`[KERNEL] Successfully unmounted existing filesystem at ${mountPath}`);\n                    }\n                    catch (unmountError) {\n                        // If unmount fails, it might not be a mount point or might be busy\n                        console.log(`[KERNEL] Unmount failed (this is normal if not mounted): ${unmountError}`);\n                    }\n                    // Remove the directory if it exists but is empty\n                    try {\n                        this.pyodide.FS.rmdir(mountPath);\n                        console.log(`[KERNEL] Removed existing directory at ${mountPath}`);\n                    }\n                    catch (rmdirError) {\n                        // Directory might not be empty or might not exist, that's okay\n                        console.log(`[KERNEL] Could not remove directory (this is normal): ${rmdirError}`);\n                    }\n                }\n            }\n            catch (analyzeError) {\n                // analyzePath might fail, that's okay - the path probably doesn't exist\n                console.log(`[KERNEL] Path analysis failed (path probably doesn't exist): ${analyzeError}`);\n            }\n            // Ensure the parent directory exists\n            const parentPath = mountPath.substring(0, mountPath.lastIndexOf('/')) || '/';\n            try {\n                if (parentPath !== '/' && !this.pyodide.FS.analyzePath(parentPath).exists) {\n                    this.pyodide.FS.mkdir(parentPath);\n                    console.log(`[KERNEL] Created parent directory ${parentPath}`);\n                }\n            }\n            catch (parentError) {\n                console.log(`[KERNEL] Parent directory handling: ${parentError}`);\n            }\n            const nativefs = await this.pyodide.mountNativeFS(mountPath, handle);\n            console.log(`[KERNEL] Successfully mounted native filesystem at ${mountPath} with ${actualPermission} permission`);\n            // Create a handle with syncfs method and permission recovery\n            const fsHandle = {\n                syncfs: async () => {\n                    // Check if filesystem is read-only\n                    if (actualPermission === 'read') {\n                        throw new Error(`Cannot sync read-only filesystem at ${mountPath}. Use upgradeFilesystemPermission() to request write access.`);\n                    }\n                    try {\n                        await nativefs.syncfs();\n                        console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                    }\n                    catch (error) {\n                        throw new Error(`Failed to sync filesystem: ${error instanceof Error ? error.message : String(error)}`);\n                    }\n                },\n                dirHandle: handle,\n                permission: actualPermission,\n                nativefs: nativefs\n            };\n            // Store the handle for auto-sync\n            this.nativeFsHandles.set(mountPath, fsHandle);\n            return { syncfs: fsHandle.syncfs };\n        }\n        catch (error) {\n            throw new Error(`Failed to mount native filesystem: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    /**\n     * Sync all mounted native filesystems with permission recovery\n     * Only syncs filesystems mounted with 'readwrite' permission\n     * @private\n     */\n    async syncAllNativeFs() {\n        if (this.nativeFsHandles.size === 0) {\n            return;\n        }\n        const syncResults = [];\n        for (const [mountPath, fsHandle] of this.nativeFsHandles.entries()) {\n            // Skip read-only filesystems\n            if (fsHandle.permission === 'read') {\n                syncResults.push({ mountPath, success: true, skipped: true });\n                console.log(`[KERNEL] Skipping sync for read-only filesystem at ${mountPath}`);\n                continue;\n            }\n            try {\n                // First, try to sync directly\n                await fsHandle.syncfs();\n                syncResults.push({ mountPath, success: true });\n                console.log(`[KERNEL] Successfully synced filesystem at ${mountPath}`);\n            }\n            catch (error) {\n                // If sync fails, check if it's a permission error\n                const errorMessage = error instanceof Error ? error.message : String(error);\n                if (errorMessage.includes('not allowed by the user agent') ||\n                    errorMessage.includes('getFileHandle') ||\n                    errorMessage.includes('permission')) {\n                    console.warn(`[KERNEL] Permission error syncing ${mountPath}, attempting recovery...`);\n                    try {\n                        // Try to recover by re-verifying permissions\n                        const hasPermission = await this.verifyPermission(fsHandle.dirHandle, fsHandle.permission);\n                        if (hasPermission) {\n                            // Try to remount and sync\n                            console.log(`[KERNEL] Permission recovered for ${mountPath}, attempting remount...`);\n                            const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n                            // Update the stored handle with the new nativefs\n                            fsHandle.nativefs = newNativefs;\n                            fsHandle.syncfs = async () => {\n                                try {\n                                    await newNativefs.syncfs();\n                                    console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                                }\n                                catch (syncError) {\n                                    throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                                }\n                            };\n                            // Try sync again with the new handle\n                            await fsHandle.syncfs();\n                            syncResults.push({ mountPath, success: true });\n                            console.log(`[KERNEL] Successfully recovered and synced filesystem at ${mountPath}`);\n                        }\n                        else {\n                            syncResults.push({\n                                mountPath,\n                                success: false,\n                                error: 'Permission denied by user'\n                            });\n                            console.warn(`[KERNEL] User denied permission for ${mountPath}, skipping sync`);\n                        }\n                    }\n                    catch (recoveryError) {\n                        const recoveryMessage = recoveryError instanceof Error ? recoveryError.message : String(recoveryError);\n                        syncResults.push({\n                            mountPath,\n                            success: false,\n                            error: `Recovery failed: ${recoveryMessage}`\n                        });\n                        console.error(`[KERNEL] Failed to recover permissions for ${mountPath}:`, recoveryError);\n                    }\n                }\n                else {\n                    // Non-permission error\n                    syncResults.push({\n                        mountPath,\n                        success: false,\n                        error: errorMessage\n                    });\n                    console.error(`[KERNEL] Non-permission error syncing ${mountPath}:`, error);\n                }\n            }\n        }\n        // Log summary\n        const successful = syncResults.filter(r => r.success && !r.skipped).length;\n        const skipped = syncResults.filter(r => r.skipped).length;\n        const failed = syncResults.filter(r => !r.success);\n        if (successful > 0 || skipped > 0) {\n            const parts = [];\n            if (successful > 0)\n                parts.push(`${successful} synced`);\n            if (skipped > 0)\n                parts.push(`${skipped} read-only skipped`);\n            console.log(`[KERNEL] Auto-sync completed: ${parts.join(', ')} (${syncResults.length} total filesystems)`);\n        }\n        if (failed.length > 0) {\n            console.warn(`[KERNEL] Auto-sync issues:`, failed.map(f => `${f.mountPath}: ${f.error}`));\n        }\n        // Don't throw - we don't want to fail execution just because sync failed\n    }\n    /**\n     * Get information about mounted native filesystems and their permission status\n     * @returns Array of mounted filesystem information\n     */\n    getMountedFilesystems() {\n        const result = [];\n        for (const [mountPath, fsHandle] of this.nativeFsHandles.entries()) {\n            result.push({\n                mountPath,\n                permission: fsHandle.permission,\n                canSync: fsHandle.permission === 'readwrite'\n            });\n        }\n        return result;\n    }\n    /**\n     * Manually sync a specific mounted filesystem\n     * @param mountPath The path of the mounted filesystem to sync\n     * @returns Promise resolving to success status\n     */\n    async syncFilesystem(mountPath) {\n        const fsHandle = this.nativeFsHandles.get(mountPath);\n        if (!fsHandle) {\n            return {\n                success: false,\n                error: `No filesystem mounted at ${mountPath}`\n            };\n        }\n        // Check if filesystem is read-only\n        if (fsHandle.permission === 'read') {\n            return {\n                success: false,\n                error: `Cannot sync read-only filesystem at ${mountPath}. Mount with 'readwrite' permission to enable syncing.`\n            };\n        }\n        try {\n            await fsHandle.syncfs();\n            return { success: true };\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            // Try permission recovery if it's a permission error\n            if (errorMessage.includes('not allowed by the user agent') ||\n                errorMessage.includes('getFileHandle') ||\n                errorMessage.includes('permission')) {\n                console.log(`[KERNEL] Permission error syncing ${mountPath}, attempting recovery...`);\n                try {\n                    const hasPermission = await this.verifyPermission(fsHandle.dirHandle, fsHandle.permission);\n                    if (hasPermission) {\n                        // Remount and try again\n                        const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n                        fsHandle.nativefs = newNativefs;\n                        fsHandle.syncfs = async () => {\n                            try {\n                                await newNativefs.syncfs();\n                                console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                            }\n                            catch (syncError) {\n                                throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                            }\n                        };\n                        await fsHandle.syncfs();\n                        return { success: true };\n                    }\n                    else {\n                        return {\n                            success: false,\n                            error: 'Permission denied by user'\n                        };\n                    }\n                }\n                catch (recoveryError) {\n                    return {\n                        success: false,\n                        error: `Recovery failed: ${recoveryError instanceof Error ? recoveryError.message : String(recoveryError)}`\n                    };\n                }\n            }\n            return {\n                success: false,\n                error: errorMessage\n            };\n        }\n    }\n    /**\n     * Upgrade a mounted filesystem from read-only to read-write permission\n     * @param mountPath The path of the mounted filesystem to upgrade\n     * @returns Promise resolving to success status\n     */\n    async upgradeFilesystemPermission(mountPath) {\n        const fsHandle = this.nativeFsHandles.get(mountPath);\n        if (!fsHandle) {\n            return {\n                success: false,\n                error: `No filesystem mounted at ${mountPath}`\n            };\n        }\n        if (fsHandle.permission === 'readwrite') {\n            return {\n                success: true,\n                error: `Filesystem at ${mountPath} already has readwrite permission`\n            };\n        }\n        try {\n            console.log(`[KERNEL] Attempting to upgrade ${mountPath} to readwrite permission...`);\n            // Try to get readwrite permission\n            const hasWritePermission = await this.verifyPermission(fsHandle.dirHandle, 'readwrite');\n            if (!hasWritePermission) {\n                return {\n                    success: false,\n                    error: 'User denied write permission or browser does not support write access to this directory'\n                };\n            }\n            // Remount with write permission\n            const newNativefs = await this.pyodide.mountNativeFS(mountPath, fsHandle.dirHandle);\n            // Update the stored handle\n            fsHandle.permission = 'readwrite';\n            fsHandle.nativefs = newNativefs;\n            fsHandle.syncfs = async () => {\n                try {\n                    await newNativefs.syncfs();\n                    console.log(`[KERNEL] Synced changes to native filesystem at ${mountPath}`);\n                }\n                catch (syncError) {\n                    throw new Error(`Failed to sync filesystem: ${syncError instanceof Error ? syncError.message : String(syncError)}`);\n                }\n            };\n            console.log(`[KERNEL] Successfully upgraded ${mountPath} to readwrite permission`);\n            return { success: true };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Failed to upgrade permission: ${error instanceof Error ? error.message : String(error)}`\n            };\n        }\n    }\n    /**\n     * Set environment variables with performance optimization\n     * OPTIMIZED: Parallel variable setting and validation with proper escaping and edge case handling\n     */\n    async setEnvironmentVariables() {\n        if (Object.keys(this.environmentVariables).length === 0) {\n            return; // No variables to set\n        }\n        const startTime = Date.now();\n        console.log(`ðŸŒ Setting ${Object.keys(this.environmentVariables).length} environment variables...`);\n        try {\n            // Set each environment variable individually to avoid escaping issues\n            for (const [key, value] of Object.entries(this.environmentVariables)) {\n                // Handle edge cases: null, undefined, etc.\n                let processedValue;\n                if (value === null) {\n                    processedValue = ''; // Convert null to empty string\n                }\n                else if (value === undefined) {\n                    processedValue = ''; // Convert undefined to empty string\n                }\n                else {\n                    processedValue = String(value); // Convert everything else to string\n                }\n                await this.pyodide.runPythonAsync(`\nimport os\nos.environ[${JSON.stringify(key)}] = ${JSON.stringify(processedValue)}\n`);\n            }\n            const duration = Date.now() - startTime;\n            console.log(`âš¡ Environment variables set in ${duration}ms`);\n        }\n        catch (error) {\n            console.error(\"âŒ Failed to set environment variables:\", error);\n            throw error;\n        }\n    }\n}\n// Only Python kernel is supported\n// Export the manager for advanced usage\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFDM0MsSUFBSSxjQUFzQixDQUFDO2dCQUMzQixJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUUsQ0FBQztvQkFDbkIsY0FBYyxHQUFHLEVBQUUsQ0FBQyxDQUFFLCtCQUErQjtnQkFDdkQsQ0FBQztxQkFBTSxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUUsQ0FBQztvQkFDL0IsY0FBYyxHQUFHLEVBQUUsQ0FBQyxDQUFFLG9DQUFvQztnQkFDNUQsQ0FBQztxQkFBTSxDQUFDO29CQUNOLGNBQWMsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBRSxvQ0FBb0M7Z0JBQ3ZFLENBQUM7Z0JBRUQsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQzs7YUFFN0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQztDQUNwRSxDQUFDLENBQUM7WUFDRyxDQUFDO1lBRUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLFNBQVMsQ0FBQztZQUN4QyxPQUFPLENBQUMsR0FBRyxDQUFDLGtDQUFrQyxRQUFRLElBQUksQ0FBQyxDQUFDO1FBQzlELENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsT0FBTyxDQUFDLEtBQUssQ0FBQyx3Q0FBd0MsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUMvRCxNQUFNLEtBQUssQ0FBQztRQUNkLENBQUM7SUFDSCxDQUFDO0NBQ0Y7QUFFRCxrQ0FBa0M7QUFFbEMsd0NBQXdDO0FBQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItcHl0aG9uLWtlcm5lbC8uL3NyYy9pbmRleC50cz9mZmI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEtlcm5lbCBpbXBsZW1lbnRhdGlvbiBmb3IgRGVubyB1c2luZyBQeW9kaWRlIGRpcmVjdGx5XG4vLyBCYXNlZCBvbiB0aGUgUHlvZGlkZVJlbW90ZUtlcm5lbCBidXQgYWRhcHRlZCBmb3IgZGlyZWN0IGV4ZWN1dGlvbiBpbiBtYWluIHRocmVhZFxuXG4vLyBAdHMtaWdub3JlIEltcG9ydGluZyBmcm9tIG5wbVxuLy8gVXNlIGEgYnJvd3Nlci1jb21wYXRpYmxlIEV2ZW50RW1pdHRlclxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSBldmVudHM6IHsgW2tleTogc3RyaW5nXTogRnVuY3Rpb25bXSB9ID0ge307XG5cbiAgb24oZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikge1xuICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgb2ZmKGV2ZW50TmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogRnVuY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHJldHVybjtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICBlbWl0KGV2ZW50TmFtZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkgcmV0dXJuO1xuICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lciguLi5hcmdzKSk7XG4gIH1cblxuICBzZXRNYXhMaXN0ZW5lcnMobjogbnVtYmVyKSB7XG4gICAgLy8gTm8tb3AgZm9yIGJyb3dzZXIgY29tcGF0aWJpbGl0eVxuICB9XG59XG5cbi8vIEB0cy1pZ25vcmUgSW1wb3J0aW5nIGZyb20gbnBtXG5pbXBvcnQgeyBsb2FkUHlvZGlkZSB9IGZyb20gXCIuL3B5b2RpZGUtbG9hZGVyXCI7XG5cbi8vIEltcG9ydCB0eXBlcyBhbmQgZW51bXNcbmltcG9ydCB7IEtlcm5lbEV2ZW50cywgSUV2ZW50RGF0YSwgSU1lc3NhZ2UsIElLZXJuZWwsIElLZXJuZWxPcHRpb25zLCBJRmlsZXN5c3RlbU1vdW50T3B0aW9ucywgSUtlcm5lbEV4ZWN1dGVPcHRpb25zLCBJRXZlbnRFbWl0dGVyIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuLy8gSW1wb3J0IFB5UEkgVVJMc1xuaW1wb3J0IHtcbiAgcGlwbGl0ZVdoZWVsVXJsLFxuICBweW9kaWRlX2tlcm5lbFdoZWVsVXJsLFxuICBpcHlrZXJuZWxXaGVlbFVybCxcbiAgYWxsSlNPTlVybCxcbiAgd2lkZ2V0c25iZXh0ZW5zaW9uV2hlZWxVcmwsXG4gIHdpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsMVxufSBmcm9tICcuL19weXBpJztcblxuLy8gRXZlbnQgdHlwZXMgZnJvbSBKdXB5dGVyTGFiXG4vLyBSZS1leHBvcnQgdHlwZXMgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuZXhwb3J0IHsgS2VybmVsRXZlbnRzIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmV4cG9ydCB0eXBlIHtcbiAgSUtlcm5lbCxcbiAgSUtlcm5lbE9wdGlvbnMsXG4gIElGaWxlc3lzdGVtTW91bnRPcHRpb25zLFxuICBJS2VybmVsRXhlY3V0ZU9wdGlvbnMsXG4gIElNZXNzYWdlLFxuICBJRXZlbnREYXRhLFxuICBJRXZlbnRFbWl0dGVyLFxuICBJTmF0aXZlRlNIYW5kbGVcbn0gZnJvbSBcIi4vdHlwZXNcIjtcblxuZXhwb3J0IHsgS2VybmVsTW9kZSwgS2VybmVsTGFuZ3VhZ2UgfSBmcm9tIFwiLi9tYW5hZ2VyXCI7XG5cblxuXG5cbmV4cG9ydCBjbGFzcyBLZXJuZWwgZXh0ZW5kcyBFdmVudEVtaXR0ZXIgaW1wbGVtZW50cyBJS2VybmVsIHtcbiAgcHJpdmF0ZSBweW9kaWRlOiBhbnk7XG4gIHByaXZhdGUgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBpbml0UHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gRmlsZXN5c3RlbSBvcHRpb25zXG4gIHByaXZhdGUgZmlsZXN5c3RlbU9wdGlvbnM6IElGaWxlc3lzdGVtTW91bnRPcHRpb25zID0ge1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIHJvb3Q6IFwiLlwiLFxuICAgIG1vdW50UG9pbnQ6IFwiL2hvbWUvcHlvZGlkZVwiXG4gIH07XG4gIFxuICAvLyBLZXJuZWwgb3B0aW9uc1xuICBwcml2YXRlIGxvY2tGaWxlVVJMPzogc3RyaW5nO1xuICBcbiAgLy8gS2VybmVsIGNvbXBvbmVudHNcbiAgcHJpdmF0ZSBfa2VybmVsOiBhbnk7XG4gIHByaXZhdGUgX2ludGVycHJldGVyOiBhbnk7XG4gIHByaXZhdGUgX3N0ZG91dF9zdHJlYW06IGFueTtcbiAgcHJpdmF0ZSBfc3RkZXJyX3N0cmVhbTogYW55O1xuICBcbiAgLy8gSW5wdXQgaGFuZGxpbmdcbiAgcHJpdmF0ZSBfcmVzb2x2ZUlucHV0UmVwbHk6ICgodmFsdWU6IGFueSkgPT4gdm9pZCkgfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIEV4ZWN1dGlvbiBzdGF0ZVxuICBwcml2YXRlIF9wYXJlbnRfaGVhZGVyOiBhbnkgPSB7fTtcbiAgcHJpdmF0ZSBleGVjdXRpb25Db3VudCA9IDA7XG4gIHByaXZhdGUgX3N0YXR1czogXCJhY3RpdmVcIiB8IFwiYnVzeVwiIHwgXCJ1bmtub3duXCIgPSBcInVua25vd25cIjtcbiAgXG4gIC8vIEludGVycnVwdCBoYW5kbGluZ1xuICBwcml2YXRlIF9pbnRlcnJ1cHRCdWZmZXI6IFVpbnQ4QXJyYXkgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfaW50ZXJydXB0U3VwcG9ydGVkID0gZmFsc2U7XG4gIFxuICAvLyBFbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgcHJpdmF0ZSBlbnZpcm9ubWVudFZhcmlhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuXG4gIC8vIE5hdGl2ZSBmaWxlc3lzdGVtIGhhbmRsZXNcbiAgcHJpdmF0ZSBuYXRpdmVGc0hhbmRsZXM6IE1hcDxzdHJpbmcsIHsgXG4gICAgc3luY2ZzOiAoKSA9PiBQcm9taXNlPHZvaWQ+OyBcbiAgICBkaXJIYW5kbGU6IEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGU7XG4gICAgcGVybWlzc2lvbjogJ3JlYWQnIHwgJ3JlYWR3cml0ZSc7XG4gICAgbmF0aXZlZnM6IGFueTtcbiAgfT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgYXV0b1N5bmNGczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8vIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGtlcm5lbCBpbnN0YW5jZVxuICBwcml2YXRlIHJlYWRvbmx5IGtlcm5lbElkOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBzdXBlci5zZXRNYXhMaXN0ZW5lcnMoMjApO1xuICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciB0aGlzIGtlcm5lbCBpbnN0YW5jZVxuICAgIHRoaXMua2VybmVsSWQgPSBga2VybmVsXyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpfV8ke0RhdGUubm93KCl9YDtcbiAgfVxuXG4gIC8vIEFzeW5jIG1ldGhvZCBmb3Iga2VybmVsIHN0YXR1c1xuICBhc3luYyBnZXRTdGF0dXMoKTogUHJvbWlzZTxcImFjdGl2ZVwiIHwgXCJidXN5XCIgfCBcInVua25vd25cIj4ge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUga2VybmVsIHdpdGggbWF4aW11bSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zXG4gICAqIE9QVElNSVpFRDogRnVsbCBwYXJhbGxlbGl6YXRpb24gd2l0aCBzbWFydCBjYWNoaW5nIGFuZCBwZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZShvcHRpb25zPzogSUtlcm5lbE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5pbml0UHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdFByb21pc2U7XG4gICAgfVxuXG4gICAgLy8gU2V0IGZpbGVzeXN0ZW0gb3B0aW9ucyBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zPy5maWxlc3lzdGVtKSB7XG4gICAgICB0aGlzLmZpbGVzeXN0ZW1PcHRpb25zID0ge1xuICAgICAgICAuLi50aGlzLmZpbGVzeXN0ZW1PcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmZpbGVzeXN0ZW1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gU2V0IGVudmlyb25tZW50IHZhcmlhYmxlcyBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zPy5lbnYpIHtcbiAgICAgIHRoaXMuZW52aXJvbm1lbnRWYXJpYWJsZXMgPSB7IC4uLm9wdGlvbnMuZW52IH07XG4gICAgfVxuXG4gICAgLy8gU2V0IGxvY2tGaWxlVVJMIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnM/LmxvY2tGaWxlVVJMKSB7XG4gICAgICB0aGlzLmxvY2tGaWxlVVJMID0gb3B0aW9ucy5sb2NrRmlsZVVSTDtcbiAgICB9XG5cbiAgICAvLyBTZXQgYXV0b1N5bmNGcyBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zPy5hdXRvU3luY0ZzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYXV0b1N5bmNGcyA9IG9wdGlvbnMuYXV0b1N5bmNGcztcbiAgICB9XG5cbiAgICB0aGlzLmluaXRQcm9taXNlID0gdGhpcy5faW5pdGlhbGl6ZUludGVybmFsKCk7XG4gICAgcmV0dXJuIHRoaXMuaW5pdFByb21pc2U7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBrZXJuZWwgd2l0aCBtYXhpbXVtIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnNcbiAgICogT1BUSU1JWkVEOiBGdWxsIHBhcmFsbGVsaXphdGlvbiB3aXRoIHNtYXJ0IGNhY2hpbmcgYW5kIHBlcmZvcm1hbmNlIG1vbml0b3JpbmdcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2luaXRpYWxpemVJbnRlcm5hbCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnNvbGUubG9nKFwi8J+agCBTdGFydGluZyBvcHRpbWl6ZWQga2VybmVsIGluaXRpYWxpemF0aW9uLi4uXCIpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBMb2FkIFB5b2RpZGUgZnJvbSBDRE5cbiAgICAgIGNvbnN0IHB5b2RpZGVTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBDb25maWd1cmUgcHlvZGlkZSBvcHRpb25zXG4gICAgICBjb25zdCBweW9kaWRlQ29uZmlnOiBhbnkgPSB7fTtcbiAgICAgIGlmICh0aGlzLmxvY2tGaWxlVVJMKSB7XG4gICAgICAgIHB5b2RpZGVDb25maWcubG9ja0ZpbGVVUkwgPSB0aGlzLmxvY2tGaWxlVVJMO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UkiBVc2luZyBsb2NrRmlsZVVSTDogJHt0aGlzLmxvY2tGaWxlVVJMfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVc2Ugb3VyIENETiBsb2FkZXIgLSBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgaGFuZGxlIG1haW4gdGhyZWFkIHZzIHdvcmtlclxuICAgICAgdGhpcy5weW9kaWRlID0gYXdhaXQgbG9hZFB5b2RpZGUocHlvZGlkZUNvbmZpZyk7XG4gICAgICBjb25zdCBweW9kaWRlVGltZSA9IERhdGUubm93KCkgLSBweW9kaWRlU3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYOKchSBQeW9kaWRlIGxvYWRlZCBpbiAke3B5b2RpZGVUaW1lfW1zYCk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgY29yZSBjb21wb25lbnRzIGluIHBhcmFsbGVsXG4gICAgICBpZiAodGhpcy5sb2NrRmlsZVVSTCkge1xuICAgICAgICAvLyBXaGVuIHVzaW5nIGxvY2tGaWxlVVJMLCBwYWNrYWdlcyBhcmUgcHJlLWluc3RhbGxlZCwgc2tpcCBwYWNrYWdlIGluc3RhbGxhdGlvblxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfmoAgVXNpbmcgbG9jayBmaWxlIC0gc2tpcHBpbmcgcGFja2FnZSBpbnN0YWxsYXRpb25cIik7XG4gICAgICAgIGNvbnN0IFssXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAvLyAxLiBGaWxlc3lzdGVtIG1vdW50aW5nIChpZiBlbmFibGVkKVxuICAgICAgICAgIHRoaXMuZmlsZXN5c3RlbU9wdGlvbnMuZW5hYmxlZCA/IHRoaXMubW91bnRGaWxlc3lzdGVtKCkgOiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICAgICAgICAvLyAyLiBFbnZpcm9ubWVudCB2YXJpYWJsZXMgc2V0dXBcbiAgICAgICAgICB0aGlzLnNldEVudmlyb25tZW50VmFyaWFibGVzKClcbiAgICAgICAgXSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJbml0aWFsaXplIGdsb2JhbHMgZGlyZWN0bHkgKHBhY2thZ2VzIGFyZSBhbHJlYWR5IGF2YWlsYWJsZSlcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0R2xvYmFscygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3RhbmRhcmQgaW5pdGlhbGl6YXRpb24gd2l0aCBwYWNrYWdlIGluc3RhbGxhdGlvblxuICAgICAgICBjb25zdCBbLCAsXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAvLyAxLiBGaWxlc3lzdGVtIG1vdW50aW5nIChpZiBlbmFibGVkKVxuICAgICAgICAgIHRoaXMuZmlsZXN5c3RlbU9wdGlvbnMuZW5hYmxlZCA/IHRoaXMubW91bnRGaWxlc3lzdGVtKCkgOiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICAgICAgICAvLyAyLiBQYWNrYWdlIG1hbmFnZXIgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICB0aGlzLmluaXRQYWNrYWdlTWFuYWdlcigpLFxuICAgICAgICAgIC8vIDMuIEVudmlyb25tZW50IHZhcmlhYmxlcyBzZXR1cFxuICAgICAgICAgIHRoaXMuc2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKVxuICAgICAgICBdKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEluc3RhbGwgcGFja2FnZXMgYW5kIGluaXRpYWxpemUgZ2xvYmFsc1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRLZXJuZWwoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0R2xvYmFscygpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYPCfjq8gS0VSTkVMIElOSVRJQUxJWkFUSU9OIENPTVBMRVRFIGluICR7dG90YWxUaW1lfW1zYCk7XG4gICAgICBjb25zb2xlLmxvZyhg4pqhIFBlcmZvcm1hbmNlOiBQeW9kaWRlKCR7cHlvZGlkZVRpbWV9bXMpICsgU2V0dXAoJHt0b3RhbFRpbWUgLSBweW9kaWRlVGltZX1tcylgKTtcbiAgICAgIFxuICAgICAgLy8gTWFyayBhcyBpbml0aWFsaXplZFxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLl9zdGF0dXMgPSBcImFjdGl2ZVwiO1xuICAgICAgY29uc29sZS5sb2coXCLwn5+iIEtlcm5lbCBpcyBub3cgQUNUSVZFIGFuZCByZWFkeSBmb3IgZXhlY3V0aW9uIVwiKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEtlcm5lbCBpbml0aWFsaXphdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IFwidW5rbm93blwiO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogTW91bnQgdGhlIGxvY2FsIGZpbGVzeXN0ZW0gdG8gdGhlIFB5b2RpZGUgZW52aXJvbm1lbnRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbW91bnRGaWxlc3lzdGVtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgTW91bnRpbmcgZmlsZXN5c3RlbSBmcm9tICR7dGhpcy5maWxlc3lzdGVtT3B0aW9ucy5yb290fSB0byAke3RoaXMuZmlsZXN5c3RlbU9wdGlvbnMubW91bnRQb2ludH1gKTtcbiAgICAgIFxuICAgICAgLy8gVXNlIHRoZSBzYW1lIGFwcHJvYWNoIGFzIGluIGRlbm8tZGVtby1mcy1hc2dpLmpzIGZvciBtYXhpbXVtIGNvbXBhdGliaWxpdHlcbiAgICAgIC8vIFNpbXBsZSBhbmQgZGlyZWN0IG1vdW50aW5nIG9mIHRoZSBmaWxlc3lzdGVtXG4gICAgICBhd2FpdCB0aGlzLnB5b2RpZGUuRlMubW91bnQoXG4gICAgICAgIHRoaXMucHlvZGlkZS5GUy5maWxlc3lzdGVtcy5OT0RFRlMsXG4gICAgICAgIHsgcm9vdDogdGhpcy5maWxlc3lzdGVtT3B0aW9ucy5yb290IHx8IFwiLlwiIH0sXG4gICAgICAgIHRoaXMuZmlsZXN5c3RlbU9wdGlvbnMubW91bnRQb2ludCB8fCBcIi9ob21lL3B5b2RpZGVcIlxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coXCJGaWxlc3lzdGVtIG1vdW50ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgdGhlIG1vdW50IGJ5IGxpc3RpbmcgdGhlIGRpcmVjdG9yeVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbW91bnRlZEZpbGVzID0gdGhpcy5weW9kaWRlLkZTLnJlYWRkaXIodGhpcy5maWxlc3lzdGVtT3B0aW9ucy5tb3VudFBvaW50IHx8IFwiL2hvbWUvcHlvZGlkZVwiKTtcbiAgICAgICAgY29uc29sZS5sb2coYEZpbGVzIGluICR7dGhpcy5maWxlc3lzdGVtT3B0aW9ucy5tb3VudFBvaW50fSBkaXJlY3Rvcnk6ICR7bW91bnRlZEZpbGVzLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGxpc3RpbmcgbW91bnRlZCBkaXJlY3Rvcnk6ICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBtb3VudGluZyBmaWxlc3lzdGVtOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgUHlvZGlkZSBwYWNrYWdlIG1hbmFnZXIgd2l0aCBvcHRpbWl6ZWQgd2hlZWwgbG9hZGluZ1xuICAgKiBPUFRJTUlaRUQ6IFNtYXJ0IGNhY2hpbmcgYW5kIHBhcmFsbGVsIHdoZWVsIGluc3RhbGxhdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbml0UGFja2FnZU1hbmFnZXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zb2xlLmxvZyhcIuKaoSBJbml0aWFsaXppbmcgb3B0aW1pemVkIHBhY2thZ2UgbWFuYWdlci4uLlwiKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gTG9hZCBtaWNyb3BpcCBhbmQgcGFja2FnaW5nIGluIHBhcmFsbGVsXG4gICAgICBjb25zb2xlLmxvZyhcIvCfk6YgTG9hZGluZyBtaWNyb3BpcCwgcGFja2FnaW5nLi4uXCIpO1xuICAgICAgYXdhaXQgdGhpcy5weW9kaWRlLmxvYWRQYWNrYWdlKFsnbWljcm9waXAnLCAncGFja2FnaW5nJ10pO1xuICAgICAgY29uc29sZS5sb2coXCLinIUgTG9hZGVkIG1pY3JvcGlwLCBwYWNrYWdpbmdcIik7XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgYmFzZSBVUkwgLSB1c2Ugd2luZG93LmxvY2F0aW9uIGZvciBicm93c2VyIG9yIGZhbGxiYWNrIGZvciB3b3JrZXJcbiAgICAgIGxldCBiYXNlVXJsOiBzdHJpbmc7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uKSB7XG4gICAgICAgIC8vIEluIG1haW4gdGhyZWFkIC0gdXNlIHdpbmRvdy5sb2NhdGlvblxuICAgICAgICBiYXNlVXJsID0gbmV3IFVSTChcIi5cIiwgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWY7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLmxvY2F0aW9uKSB7XG4gICAgICAgIC8vIEluIHdlYiB3b3JrZXIgLSB1c2Ugc2VsZi5sb2NhdGlvblxuICAgICAgICBiYXNlVXJsID0gbmV3IFVSTChcIi5cIiwgc2VsZi5sb2NhdGlvbi5ocmVmKS5ocmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgLSBhc3N1bWUgY3VycmVudCBvcmlnaW5cbiAgICAgICAgYmFzZVVybCA9IFwiL1wiO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBhbGxKc29uUGF0aCA9IG5ldyBVUkwoYWxsSlNPTlVybCwgYmFzZVVybCkuaHJlZjtcbiAgICAgIFxuICAgICAgLy8gUHJlcGFyZSBhbGwgd2hlZWwgVVJMcyBmb3IgcGFyYWxsZWwgbG9hZGluZ1xuICAgICAgY29uc3Qgd2hlZWxGaWxlcyA9IFtcbiAgICAgICAgbmV3IFVSTChwaXBsaXRlV2hlZWxVcmwsIGJhc2VVcmwpLmhyZWYsXG4gICAgICAgIG5ldyBVUkwocHlvZGlkZV9rZXJuZWxXaGVlbFVybCwgYmFzZVVybCkuaHJlZixcbiAgICAgICAgbmV3IFVSTChpcHlrZXJuZWxXaGVlbFVybCwgYmFzZVVybCkuaHJlZixcbiAgICAgICAgbmV3IFVSTCh3aWRnZXRzbmJleHRlbnNpb25XaGVlbFVybCwgYmFzZVVybCkuaHJlZixcbiAgICAgICAgbmV3IFVSTCh3aWRnZXRzbmJleHRlbnNpb25XaGVlbFVybDEsIGJhc2VVcmwpLmhyZWYsXG4gICAgICBdO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+agCBJbnN0YWxsaW5nICR7d2hlZWxGaWxlcy5sZW5ndGh9IHdoZWVsIHBhY2thZ2VzIGluIHBhcmFsbGVsLi4uYCk7XG4gICAgICBcbiAgICAgIC8vIEluc3RhbGwgYWxsIHdoZWVsIHBhY2thZ2VzIGluIHBhcmFsbGVsIGZvciBtYXhpbXVtIHNwZWVkXG4gICAgICBjb25zdCB3aGVlbFByb21pc2VzID0gd2hlZWxGaWxlcy5tYXAoYXN5bmMgKHdoZWVsVXJsLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB3aGVlbFN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5weW9kaWRlLnJ1blB5dGhvbkFzeW5jKGBcbmltcG9ydCBtaWNyb3BpcFxuYXdhaXQgbWljcm9waXAuaW5zdGFsbCgnJHt3aGVlbFVybH0nLCBrZWVwX2dvaW5nPVRydWUpXG5wcmludChmXCLinIUgV2hlZWwgJHtpbmRleCArIDF9LyR7d2hlZWxGaWxlcy5sZW5ndGh9IGluc3RhbGxlZFwiKVxuYCk7XG4gICAgICAgICAgY29uc3Qgd2hlZWxUaW1lID0gRGF0ZS5ub3coKSAtIHdoZWVsU3RhcnRUaW1lO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDimqEgV2hlZWwgJHtpbmRleCArIDF9IGluc3RhbGxlZCBpbiAke3doZWVsVGltZX1tc2ApO1xuICAgICAgICAgIHJldHVybiB7IGluZGV4LCBzdWNjZXNzOiB0cnVlLCB0aW1lOiB3aGVlbFRpbWUgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zdCB3aGVlbFRpbWUgPSBEYXRlLm5vdygpIC0gd2hlZWxTdGFydFRpbWU7XG4gICAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gV2hlZWwgJHtpbmRleCArIDF9IGZhaWxlZCBhZnRlciAke3doZWVsVGltZX1tczpgLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuIHsgaW5kZXgsIHN1Y2Nlc3M6IGZhbHNlLCB0aW1lOiB3aGVlbFRpbWUsIGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBhbGwgd2hlZWwgaW5zdGFsbGF0aW9uc1xuICAgICAgY29uc3Qgd2hlZWxSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwod2hlZWxQcm9taXNlcyk7XG4gICAgICBjb25zdCBzdWNjZXNzZnVsID0gd2hlZWxSZXN1bHRzLmZpbHRlcihyID0+IHIuc3VjY2Vzcyk7XG4gICAgICBjb25zdCBmYWlsZWQgPSB3aGVlbFJlc3VsdHMuZmlsdGVyKHIgPT4gIXIuc3VjY2Vzcyk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFdoZWVsczogJHtzdWNjZXNzZnVsLmxlbmd0aH0vJHt3aGVlbEZpbGVzLmxlbmd0aH0gc3VjY2Vzc2Z1bGApO1xuICAgICAgaWYgKGZhaWxlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIEZhaWxlZCB3aGVlbHM6ICR7ZmFpbGVkLm1hcChmID0+IGYuaW5kZXggKyAxKS5qb2luKCcsICcpfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZXQgdXAgcGlwbGl0ZSBjb25maWd1cmF0aW9uIHdpdGggcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9ucyAoaWYgYXZhaWxhYmxlKVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5weW9kaWRlLnJ1blB5dGhvbkFzeW5jKGBcbnRyeTpcbiAgICBpbXBvcnQgcGlwbGl0ZS5waXBsaXRlXG4gICAgaW1wb3J0IGpzb25cblxuICAgICMgTG9hZCBwYWNrYWdlIGluZGV4IGZvciBmYXN0ZXIgbG9va3Vwc1xuICAgIHRyeTpcbiAgICAgICAgcGlwbGl0ZS5waXBsaXRlLlBJUExJVEVfVVJMID0gXCIke2FsbEpzb25QYXRofVwiXG4gICAgICAgICMgUHJlLWxvYWQgcGFja2FnZSBpbmRleCBmb3IgZmFzdGVyIGluc3RhbGxhdGlvblxuICAgICAgICBwcmludChcIvCfk4sgUGFja2FnZSBpbmRleCBjb25maWd1cmVkXCIpXG4gICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOlxuICAgICAgICBwcmludChmXCLimqDvuI8gUGFja2FnZSBpbmRleCBzZXR1cCB3YXJuaW5nOiB7ZX1cIilcblxuICAgICMgQ29uZmlndXJlIHBpcGxpdGUgZm9yIG9wdGltYWwgcGVyZm9ybWFuY2VcbiAgICBwaXBsaXRlLnBpcGxpdGUuUkVQT0RBVEFfSU5GTyA9IHt9XG4gICAgcHJpbnQoXCLimqEgUGlwbGl0ZSBvcHRpbWl6ZWQgZm9yIHBlcmZvcm1hbmNlXCIpXG5leGNlcHQgSW1wb3J0RXJyb3I6XG4gICAgcHJpbnQoXCLimqDvuI8gUGlwbGl0ZSBub3QgYXZhaWxhYmxlLCBjb250aW51aW5nIHdpdGhvdXQgaXRcIilcbmV4Y2VwdCBFeGNlcHRpb24gYXMgZTpcbiAgICBwcmludChmXCLimqDvuI8gUGlwbGl0ZSBzZXR1cCBmYWlsZWQ6IHtlfVwiKVxuYCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gUGlwbGl0ZSBjb25maWd1cmF0aW9uIGZhaWxlZCwgY29udGludWluZyB3aXRob3V0IGl0OlwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhg8J+OryBQYWNrYWdlIG1hbmFnZXIgaW5pdGlhbGl6ZWQgaW4gJHt0b3RhbFRpbWV9bXNgKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIFBhY2thZ2UgbWFuYWdlciBpbml0aWFsaXphdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBrZXJuZWwgd2l0aCByZXF1aXJlZCBQeXRob24gcGFja2FnZXNcbiAgICogT1BUSU1JWkVEOiBNYXhpbXVtIHBhcmFsbGVsaXphdGlvbiB3aXRoIGludGVsbGlnZW50IGRlcGVuZGVuY3kgcmVzb2x1dGlvblxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbml0S2VybmVsKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc29sZS5sb2coXCLwn5qAIEluaXRpYWxpemluZyBrZXJuZWwgcGFja2FnZXMgd2l0aCBtYXhpbXVtIG9wdGltaXphdGlvbi4uLlwiKTtcbiAgICBcbiAgICAvLyBBbGwgcGFja2FnZXMgdG8gaW5zdGFsbCB3aXRoIHByaW9yaXR5IGFuZCBkZXBlbmRlbmN5IGluZm9ybWF0aW9uXG4gICAgY29uc3QgcGFja2FnZUNvbmZpZyA9IFtcbiAgICAgIC8vIEhpZ2ggcHJpb3JpdHk6IENETiBwYWNrYWdlcyAoZmFzdGVzdClcbiAgICAgIHsgbmFtZTogJ3B1cmUtZXZhbCcsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnc3RhY2stZGF0YScsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAncHlnbWVudHMnLCBwcmlvcml0eTogMSwgc291cmNlOiAncHlvZGlkZScgfSxcbiAgICAgIHsgbmFtZTogJ3NzbCcsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAnc3FsaXRlMycsIHByaW9yaXR5OiAxLCBzb3VyY2U6ICdweW9kaWRlJyB9LFxuICAgICAgeyBuYW1lOiAncHJvbXB0X3Rvb2xraXQnLCBwcmlvcml0eTogMSwgc291cmNlOiAncHlvZGlkZScgfSxcbiAgICAgIHsgbmFtZTogJ2plZGknLCBwcmlvcml0eTogMSwgc291cmNlOiAncHlvZGlkZScgfSxcbiAgICAgIHsgbmFtZTogJ2lweXRob24nLCBwcmlvcml0eTogMSwgc291cmNlOiAncHlvZGlkZScgfSxcbiAgICAgIFxuICAgICAgLy8gTWVkaXVtIHByaW9yaXR5OiBwaXAgcGFja2FnZXNcbiAgICAgIHsgbmFtZTogJ2NvbW0nLCBwcmlvcml0eTogMiwgc291cmNlOiAncGlwJyB9LFxuICAgICAgeyBuYW1lOiAnaHlwaGEtcnBjJywgcHJpb3JpdHk6IDIsIHNvdXJjZTogJ3BpcCcgfSxcbiAgICAgIHsgbmFtZTogJ25iZm9ybWF0JywgcHJpb3JpdHk6IDIsIHNvdXJjZTogJ3BpcCcgfSxcbiAgICAgIFxuICAgICAgLy8gTG93ZXIgcHJpb3JpdHk6IGNvbXBsZXggcGFja2FnZXNcbiAgICAgIHsgbmFtZTogJ2lweWtlcm5lbCcsIHByaW9yaXR5OiAzLCBzb3VyY2U6ICdwaXAnIH0sXG4gICAgICB7IG5hbWU6ICdweW9kaWRlX2tlcm5lbCcsIHByaW9yaXR5OiAzLCBzb3VyY2U6ICdwaXAnIH1cbiAgICBdO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OmIEluc3RhbGxpbmcgJHtwYWNrYWdlQ29uZmlnLmxlbmd0aH0gcGFja2FnZXMgd2l0aCBpbnRlbGxpZ2VudCBvcHRpbWl6YXRpb24uLi5gKTtcbiAgICAgIFxuICAgICAgLy8gSW5zdGFsbCBBTEwgcGFja2FnZXMgaW4gcGFyYWxsZWwgd2l0aCBhZHZhbmNlZCBlcnJvciBoYW5kbGluZyBhbmQgY2FjaGluZ1xuICAgICAgYXdhaXQgdGhpcy5pbnN0YWxsUGFja2FnZXNXaXRoSW50ZWxsaWdlbnRPcHRpbWl6YXRpb24ocGFja2FnZUNvbmZpZyk7XG4gICAgICBcbiAgICAgIC8vIEltcG9ydCB0aGUga2VybmVsIChtdXN0IGJlIGRvbmUgYWZ0ZXIgcGFja2FnZXMgYXJlIGluc3RhbGxlZClcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+TpSBJbXBvcnRpbmcgcHlvZGlkZV9rZXJuZWwuLi5cIik7XG4gICAgICBjb25zdCBpbXBvcnRTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgYXdhaXQgdGhpcy5weW9kaWRlLnJ1blB5dGhvbkFzeW5jKCdpbXBvcnQgcHlvZGlkZV9rZXJuZWwnKTtcbiAgICAgIGNvbnN0IGltcG9ydFRpbWUgPSBEYXRlLm5vdygpIC0gaW1wb3J0U3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYOKchSBweW9kaWRlX2tlcm5lbCBpbXBvcnRlZCBpbiAke2ltcG9ydFRpbWV9bXNgKTtcbiAgICAgIFxuICAgICAgY29uc3QgdG90YWxUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIEtlcm5lbCBwYWNrYWdlcyBpbml0aWFsaXplZCBpbiAke3RvdGFsVGltZX1tc2ApO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgS2VybmVsIHBhY2thZ2UgaW5pdGlhbGl6YXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbnN0YWxsIHBhY2thZ2VzIHdpdGggaW50ZWxsaWdlbnQgb3B0aW1pemF0aW9uIGFuZCBhZHZhbmNlZCBjYWNoaW5nXG4gICAqIE9QVElNSVpFRDogU21hcnQgc291cmNlIHNlbGVjdGlvbiwgcGFyYWxsZWwgaW5zdGFsbGF0aW9uLCBhbmQgcGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbnN0YWxsUGFja2FnZXNXaXRoSW50ZWxsaWdlbnRPcHRpbWl6YXRpb24ocGFja2FnZUNvbmZpZzogQXJyYXk8e25hbWU6IHN0cmluZywgcHJpb3JpdHk6IG51bWJlciwgc291cmNlOiBzdHJpbmd9Pik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKGDimqEgU3RhcnRpbmcgaW50ZWxsaWdlbnQgcGFyYWxsZWwgaW5zdGFsbGF0aW9uIG9mICR7cGFja2FnZUNvbmZpZy5sZW5ndGh9IHBhY2thZ2VzLi4uYCk7XG4gICAgXG4gICAgY29uc3QgaW5zdGFsbFByb21pc2VzID0gcGFja2FnZUNvbmZpZy5tYXAoYXN5bmMgKHBrZykgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIEluc3RhbGxpbmcgJHtwa2cubmFtZX0gKHByaW9yaXR5OiAke3BrZy5wcmlvcml0eX0sIHByZWZlcnJlZDogJHtwa2cuc291cmNlfSkuLi5gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSBwcmVmZXJyZWQgc291cmNlIGZpcnN0LCB3aXRoIGludGVsbGlnZW50IGZhbGxiYWNrXG4gICAgICAgIGlmIChwa2cuc291cmNlID09PSAncHlvZGlkZScpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5weW9kaWRlLmxvYWRQYWNrYWdlKFtwa2cubmFtZV0pO1xuICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSAke3BrZy5uYW1lfSBsb2FkZWQgZnJvbSBQeW9kaWRlIENETiAoJHtkdXJhdGlvbn1tcylgKTtcbiAgICAgICAgICAgIHJldHVybiB7IHBhY2thZ2U6IHBrZy5uYW1lLCBtZXRob2Q6ICdweW9kaWRlJywgZHVyYXRpb24sIHN1Y2Nlc3M6IHRydWUsIHByaW9yaXR5OiBwa2cucHJpb3JpdHkgfTtcbiAgICAgICAgICB9IGNhdGNoIChweW9kaWRlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHBpcCB3aXRoIGVuaGFuY2VkIGVycm9yIGhhbmRsaW5nXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TpiAke3BrZy5uYW1lfSBub3QgYXZhaWxhYmxlIG9uIENETiwgdHJ5aW5nIHBpcC4uLmApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbnN0YWxsVmlhUGlwV2l0aE9wdGltaXphdGlvbnMocGtnLm5hbWUpO1xuICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSAke3BrZy5uYW1lfSBpbnN0YWxsZWQgdmlhIHBpcCBmYWxsYmFjayAoJHtkdXJhdGlvbn1tcylgKTtcbiAgICAgICAgICAgIHJldHVybiB7IHBhY2thZ2U6IHBrZy5uYW1lLCBtZXRob2Q6ICdwaXAtZmFsbGJhY2snLCBkdXJhdGlvbiwgc3VjY2VzczogdHJ1ZSwgcHJpb3JpdHk6IHBrZy5wcmlvcml0eSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEaXJlY3QgcGlwIGluc3RhbGxhdGlvbiB3aXRoIG9wdGltaXphdGlvbnNcbiAgICAgICAgICBhd2FpdCB0aGlzLmluc3RhbGxWaWFQaXBXaXRoT3B0aW1pemF0aW9ucyhwa2cubmFtZSk7XG4gICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgJHtwa2cubmFtZX0gaW5zdGFsbGVkIHZpYSBwaXAgKCR7ZHVyYXRpb259bXMpYCk7XG4gICAgICAgICAgcmV0dXJuIHsgcGFja2FnZTogcGtnLm5hbWUsIG1ldGhvZDogJ3BpcCcsIGR1cmF0aW9uLCBzdWNjZXNzOiB0cnVlLCBwcmlvcml0eTogcGtnLnByaW9yaXR5IH07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgY29uc29sZS53YXJuKGDinYwgRmFpbGVkIHRvIGluc3RhbGwgJHtwa2cubmFtZX0gYWZ0ZXIgJHtkdXJhdGlvbn1tczpgLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7IHBhY2thZ2U6IHBrZy5uYW1lLCBtZXRob2Q6ICdmYWlsZWQnLCBkdXJhdGlvbiwgc3VjY2VzczogZmFsc2UsIHByaW9yaXR5OiBwa2cucHJpb3JpdHksIGVycm9yIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gV2FpdCBmb3IgYWxsIGluc3RhbGxhdGlvbnMgd2l0aCBkZXRhaWxlZCBhbmFseXNpc1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChpbnN0YWxsUHJvbWlzZXMpO1xuICAgIFxuICAgIC8vIENvbXByZWhlbnNpdmUgcGVyZm9ybWFuY2UgYW5hbHlzaXNcbiAgICB0aGlzLmFuYWx5emVJbnN0YWxsYXRpb25SZXN1bHRzKHJlc3VsdHMpO1xuICB9XG4gIFxuICAvKipcbiAgICogSW5zdGFsbCBwYWNrYWdlIHZpYSBwaXAgd2l0aCBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluc3RhbGxWaWFQaXBXaXRoT3B0aW1pemF0aW9ucyhwYWNrYWdlTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5weW9kaWRlLnJ1blB5dGhvbkFzeW5jKGBcbnRyeTpcbiAgICAjIEltcG9ydCBwaXBsaXRlIGZpcnN0XG4gICAgaW1wb3J0IHBpcGxpdGVcbiAgICAjIFVzZSBvcHRpbWl6ZWQgcGlwIGluc3RhbGxhdGlvbiB3aXRoIGNhY2hpbmdcbiAgICBhd2FpdCBwaXBsaXRlLmluc3RhbGwoJyR7cGFja2FnZU5hbWV9Jywga2VlcF9nb2luZz1UcnVlLCBkZXBzPVRydWUpXG4gICAgcHJpbnQoXCLinIUgU3VjY2Vzc2Z1bGx5IGluc3RhbGxlZCAke3BhY2thZ2VOYW1lfSB2aWEgb3B0aW1pemVkIHBpcFwiKVxuZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOlxuICAgIHByaW50KFwi4pqg77iPIFdhcm5pbmc6IEZhaWxlZCB0byBpbnN0YWxsICR7cGFja2FnZU5hbWV9OlwiLCBzdHIoZSkpXG4gICAgIyBUcnkgYWx0ZXJuYXRpdmUgaW5zdGFsbGF0aW9uIG1ldGhvZFxuICAgIHRyeTpcbiAgICAgICAgaW1wb3J0IG1pY3JvcGlwXG4gICAgICAgIGF3YWl0IG1pY3JvcGlwLmluc3RhbGwoJyR7cGFja2FnZU5hbWV9Jywga2VlcF9nb2luZz1UcnVlKVxuICAgICAgICBwcmludChcIuKchSBTdWNjZXNzZnVsbHkgaW5zdGFsbGVkICR7cGFja2FnZU5hbWV9IHZpYSBtaWNyb3BpcCBmYWxsYmFja1wiKVxuICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZTI6XG4gICAgICAgIHByaW50KFwi4p2MIEJvdGggcGlwIG1ldGhvZHMgZmFpbGVkIGZvciAke3BhY2thZ2VOYW1lfTpcIiwgc3RyKGUyKSlcbiAgICAgICAgcmFpc2UgZTJcbmApO1xuICB9XG4gIFxuICAvKipcbiAgICogQW5hbHl6ZSBpbnN0YWxsYXRpb24gcmVzdWx0cyBhbmQgcHJvdmlkZSBwZXJmb3JtYW5jZSBpbnNpZ2h0c1xuICAgKi9cbiAgcHJpdmF0ZSBhbmFseXplSW5zdGFsbGF0aW9uUmVzdWx0cyhyZXN1bHRzOiBBcnJheTxhbnk+KTogdm9pZCB7XG4gICAgY29uc3Qgc3VjY2Vzc2Z1bCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdWNjZXNzKTtcbiAgICBjb25zdCBmYWlsZWQgPSByZXN1bHRzLmZpbHRlcihyID0+ICFyLnN1Y2Nlc3MpO1xuICAgIGNvbnN0IHB5b2RpZGVJbnN0YWxscyA9IHN1Y2Nlc3NmdWwuZmlsdGVyKHIgPT4gci5tZXRob2QgPT09ICdweW9kaWRlJyk7XG4gICAgY29uc3QgcGlwSW5zdGFsbHMgPSBzdWNjZXNzZnVsLmZpbHRlcihyID0+IHIubWV0aG9kID09PSAncGlwJyk7XG4gICAgY29uc3QgZmFsbGJhY2tJbnN0YWxscyA9IHN1Y2Nlc3NmdWwuZmlsdGVyKHIgPT4gci5tZXRob2QgPT09ICdwaXAtZmFsbGJhY2snKTtcbiAgICBcbiAgICBjb25zdCB0b3RhbER1cmF0aW9uID0gTWF0aC5tYXgoLi4ucmVzdWx0cy5tYXAociA9PiByLmR1cmF0aW9uKSk7XG4gICAgY29uc3QgYXZnRHVyYXRpb24gPSByZXN1bHRzLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyByLmR1cmF0aW9uLCAwKSAvIHJlc3VsdHMubGVuZ3RoO1xuICAgIGNvbnN0IGVzdGltYXRlZFNlcXVlbnRpYWwgPSByZXN1bHRzLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyByLmR1cmF0aW9uLCAwKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+OryBJTlRFTExJR0VOVCBJTlNUQUxMQVRJT04gQ09NUExFVEUhYCk7XG4gICAgY29uc29sZS5sb2coYPCfk4ogUmVzdWx0czogJHtzdWNjZXNzZnVsLmxlbmd0aH0vJHtyZXN1bHRzLmxlbmd0aH0gc3VjY2Vzc2Z1bGApO1xuICAgIGNvbnNvbGUubG9nKGDimqEgUHlvZGlkZSBDRE46ICR7cHlvZGlkZUluc3RhbGxzLmxlbmd0aH0gcGFja2FnZXNgKTtcbiAgICBjb25zb2xlLmxvZyhg8J+TpiBEaXJlY3QgcGlwOiAke3BpcEluc3RhbGxzLmxlbmd0aH0gcGFja2FnZXNgKTtcbiAgICBjb25zb2xlLmxvZyhg8J+UhCBQaXAgZmFsbGJhY2s6ICR7ZmFsbGJhY2tJbnN0YWxscy5sZW5ndGh9IHBhY2thZ2VzYCk7XG4gICAgY29uc29sZS5sb2coYOKdjCBGYWlsZWQ6ICR7ZmFpbGVkLmxlbmd0aH0gcGFja2FnZXNgKTtcbiAgICBjb25zb2xlLmxvZyhg4o+x77iPICBUb3RhbCB0aW1lOiAke3RvdGFsRHVyYXRpb259bXMgKHZzIH4ke2VzdGltYXRlZFNlcXVlbnRpYWx9bXMgc2VxdWVudGlhbClgKTtcbiAgICBjb25zb2xlLmxvZyhg8J+agCBTcGVlZCBpbXByb3ZlbWVudDogfiR7TWF0aC5yb3VuZChlc3RpbWF0ZWRTZXF1ZW50aWFsIC8gdG90YWxEdXJhdGlvbil9eCBmYXN0ZXJgKTtcbiAgICBjb25zb2xlLmxvZyhg8J+TiCBBdmVyYWdlIHBlciBwYWNrYWdlOiAke01hdGgucm91bmQoYXZnRHVyYXRpb24pfW1zYCk7XG4gICAgXG4gICAgaWYgKGZhaWxlZC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyAgRmFpbGVkIHBhY2thZ2VzOiAke2ZhaWxlZC5tYXAoZiA9PiBmLnBhY2thZ2UpLmpvaW4oJywgJyl9YCk7XG4gICAgICAvLyBMb2cgc3BlY2lmaWMgZmFpbHVyZSByZWFzb25zIGZvciBkZWJ1Z2dpbmdcbiAgICAgIGZhaWxlZC5mb3JFYWNoKGYgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oYCAgIC0gJHtmLnBhY2thZ2V9OiAke2YuZXJyb3I/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFBlcmZvcm1hbmNlIGluc2lnaHRzXG4gICAgY29uc3QgZmFzdGVzdEluc3RhbGwgPSBNYXRoLm1pbiguLi5zdWNjZXNzZnVsLm1hcChyID0+IHIuZHVyYXRpb24pKTtcbiAgICBjb25zdCBzbG93ZXN0SW5zdGFsbCA9IE1hdGgubWF4KC4uLnN1Y2Nlc3NmdWwubWFwKHIgPT4gci5kdXJhdGlvbikpO1xuICAgIGNvbnNvbGUubG9nKGDwn5OKIFBlcmZvcm1hbmNlIHJhbmdlOiAke2Zhc3Rlc3RJbnN0YWxsfW1zIChmYXN0ZXN0KSB0byAke3Nsb3dlc3RJbnN0YWxsfW1zIChzbG93ZXN0KWApO1xuICB9XG4gIFxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBnbG9iYWwgb2JqZWN0cyBmcm9tIHRoZSBweW9kaWRlX2tlcm5lbCBwYWNrYWdlXG4gICAqIEJhc2VkIG9uIHRoZSBQeW9kaWRlUmVtb3RlS2VybmVsIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRHbG9iYWxzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKFwiSW5pdGlhbGl6aW5nIGdsb2JhbHMuLi5cIik7XG4gICAgXG4gICAgLy8gR2V0IHRoZSBnbG9iYWxzIGZyb20gdGhlIFB5dGhvbiBlbnZpcm9ubWVudFxuICAgIGNvbnN0IHsgZ2xvYmFscyB9ID0gdGhpcy5weW9kaWRlO1xuICAgIFxuICAgIC8vIEdldCB0aGUga2VybmVsIGluc3RhbmNlIGFuZCByZWxhdGVkIG9iamVjdHNcbiAgICB0aGlzLl9rZXJuZWwgPSBnbG9iYWxzLmdldCgncHlvZGlkZV9rZXJuZWwnKS5rZXJuZWxfaW5zdGFuY2UuY29weSgpO1xuICAgIHRoaXMuX3N0ZG91dF9zdHJlYW0gPSBnbG9iYWxzLmdldCgncHlvZGlkZV9rZXJuZWwnKS5zdGRvdXRfc3RyZWFtLmNvcHkoKTtcbiAgICB0aGlzLl9zdGRlcnJfc3RyZWFtID0gZ2xvYmFscy5nZXQoJ3B5b2RpZGVfa2VybmVsJykuc3RkZXJyX3N0cmVhbS5jb3B5KCk7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIgPSB0aGlzLl9rZXJuZWwuaW50ZXJwcmV0ZXIuY29weSgpO1xuICAgIFxuICAgIC8vIFNldCB1cCBjb21tdW5pY2F0aW9uIGhhbmRsZXJzXG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuc2VuZF9jb21tID0gdGhpcy5zZW5kQ29tbS5iaW5kKHRoaXMpO1xuICAgIFxuICAgIC8vIFNldCB1cCBjYWxsYmFja3NcbiAgICB0aGlzLnNldHVwQ2FsbGJhY2tzKCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBTZXR1cCBhbGwgbmVjZXNzYXJ5IGNhbGxiYWNrcyBmb3IgdGhlIFB5dGhvbiBlbnZpcm9ubWVudFxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cENhbGxiYWNrcygpOiB2b2lkIHtcbiAgICAvLyBFeGVjdXRpb24gcmVzdWx0IGNhbGxiYWNrXG4gICAgY29uc3QgcHVibGlzaEV4ZWN1dGlvblJlc3VsdCA9IChcbiAgICAgIHByb21wdF9jb3VudDogYW55LFxuICAgICAgZGF0YTogYW55LFxuICAgICAgbWV0YWRhdGE6IGFueSxcbiAgICApOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICAgICAgZXhlY3V0aW9uX2NvdW50OiBwcm9tcHRfY291bnQsXG4gICAgICAgIGRhdGE6IHRoaXMuZm9ybWF0UmVzdWx0KGRhdGEpLFxuICAgICAgICBtZXRhZGF0YTogdGhpcy5mb3JtYXRSZXN1bHQobWV0YWRhdGEpLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgYnVuZGxlLFxuICAgICAgICB0eXBlOiAnZXhlY3V0ZV9yZXN1bHQnLFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEVycm9yIGNhbGxiYWNrXG4gICAgY29uc3QgcHVibGlzaEV4ZWN1dGlvbkVycm9yID0gKGVuYW1lOiBhbnksIGV2YWx1ZTogYW55LCB0cmFjZWJhY2s6IGFueSk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgYnVuZGxlID0ge1xuICAgICAgICBlbmFtZTogZW5hbWUsXG4gICAgICAgIGV2YWx1ZTogZXZhbHVlLFxuICAgICAgICB0cmFjZWJhY2s6IHRyYWNlYmFjayxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgcGFyZW50SGVhZGVyOiB0aGlzLmZvcm1hdFJlc3VsdCh0aGlzLl9wYXJlbnRfaGVhZGVyKVsnaGVhZGVyJ10sXG4gICAgICAgIGJ1bmRsZSxcbiAgICAgICAgICB0eXBlOiAnZXhlY3V0ZV9lcnJvcicsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQ2xlYXIgb3V0cHV0IGNhbGxiYWNrXG4gICAgY29uc3QgY2xlYXJPdXRwdXRDYWxsYmFjayA9ICh3YWl0OiBib29sZWFuKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSB7XG4gICAgICAgIHdhaXQ6IHRoaXMuZm9ybWF0UmVzdWx0KHdhaXQpLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgYnVuZGxlLFxuICAgICAgICAgIHR5cGU6ICdjbGVhcl9vdXRwdXQnLFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIERpc3BsYXkgZGF0YSBjYWxsYmFja1xuICAgIGNvbnN0IGRpc3BsYXlEYXRhQ2FsbGJhY2sgPSAoZGF0YTogYW55LCBtZXRhZGF0YTogYW55LCB0cmFuc2llbnQ6IGFueSk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgYnVuZGxlID0ge1xuICAgICAgICBkYXRhOiB0aGlzLmZvcm1hdFJlc3VsdChkYXRhKSxcbiAgICAgICAgbWV0YWRhdGE6IHRoaXMuZm9ybWF0UmVzdWx0KG1ldGFkYXRhKSxcbiAgICAgICAgdHJhbnNpZW50OiB0aGlzLmZvcm1hdFJlc3VsdCh0cmFuc2llbnQpLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICAgICAgYnVuZGxlLFxuICAgICAgICB0eXBlOiAnZGlzcGxheV9kYXRhJyxcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBVcGRhdGUgZGlzcGxheSBkYXRhIGNhbGxiYWNrXG4gICAgY29uc3QgdXBkYXRlRGlzcGxheURhdGFDYWxsYmFjayA9IChcbiAgICAgIGRhdGE6IGFueSxcbiAgICAgIG1ldGFkYXRhOiBhbnksXG4gICAgICB0cmFuc2llbnQ6IGFueSxcbiAgICApOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICAgICAgZGF0YTogdGhpcy5mb3JtYXRSZXN1bHQoZGF0YSksXG4gICAgICAgIG1ldGFkYXRhOiB0aGlzLmZvcm1hdFJlc3VsdChtZXRhZGF0YSksXG4gICAgICAgIHRyYW5zaWVudDogdGhpcy5mb3JtYXRSZXN1bHQodHJhbnNpZW50KSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgcGFyZW50SGVhZGVyOiB0aGlzLmZvcm1hdFJlc3VsdCh0aGlzLl9wYXJlbnRfaGVhZGVyKVsnaGVhZGVyJ10sXG4gICAgICAgIGJ1bmRsZSxcbiAgICAgICAgdHlwZTogJ3VwZGF0ZV9kaXNwbGF5X2RhdGEnLFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFN0cmVhbSBjYWxsYmFja1xuICAgIGNvbnN0IHB1Ymxpc2hTdHJlYW1DYWxsYmFjayA9IChuYW1lOiBhbnksIHRleHQ6IGFueSk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgYnVuZGxlID0ge1xuICAgICAgICBuYW1lOiB0aGlzLmZvcm1hdFJlc3VsdChuYW1lKSxcbiAgICAgICAgdGV4dDogdGhpcy5mb3JtYXRSZXN1bHQodGV4dCksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHBhcmVudEhlYWRlcjogdGhpcy5mb3JtYXRSZXN1bHQodGhpcy5fcGFyZW50X2hlYWRlcilbJ2hlYWRlciddLFxuICAgICAgICBidW5kbGUsXG4gICAgICAgIHR5cGU6ICdzdHJlYW0nLFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEFzc2lnbiBjYWxsYmFja3MgdG8gdGhlIFB5dGhvbiBvYmplY3RzXG4gICAgdGhpcy5fc3Rkb3V0X3N0cmVhbS5wdWJsaXNoX3N0cmVhbV9jYWxsYmFjayA9IHB1Ymxpc2hTdHJlYW1DYWxsYmFjaztcbiAgICB0aGlzLl9zdGRlcnJfc3RyZWFtLnB1Ymxpc2hfc3RyZWFtX2NhbGxiYWNrID0gcHVibGlzaFN0cmVhbUNhbGxiYWNrO1xuICAgIHRoaXMuX2ludGVycHJldGVyLmRpc3BsYXlfcHViLmNsZWFyX291dHB1dF9jYWxsYmFjayA9IGNsZWFyT3V0cHV0Q2FsbGJhY2s7XG4gICAgdGhpcy5faW50ZXJwcmV0ZXIuZGlzcGxheV9wdWIuZGlzcGxheV9kYXRhX2NhbGxiYWNrID0gZGlzcGxheURhdGFDYWxsYmFjaztcbiAgICB0aGlzLl9pbnRlcnByZXRlci5kaXNwbGF5X3B1Yi51cGRhdGVfZGlzcGxheV9kYXRhX2NhbGxiYWNrID0gdXBkYXRlRGlzcGxheURhdGFDYWxsYmFjaztcbiAgICB0aGlzLl9pbnRlcnByZXRlci5kaXNwbGF5aG9vay5wdWJsaXNoX2V4ZWN1dGlvbl9yZXN1bHQgPSBwdWJsaXNoRXhlY3V0aW9uUmVzdWx0O1xuICAgIHRoaXMuX2ludGVycHJldGVyLmlucHV0ID0gdGhpcy5pbnB1dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2ludGVycHJldGVyLmdldHBhc3MgPSB0aGlzLmdldHBhc3MuYmluZCh0aGlzKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFByb2Nlc3MgYSBtZXNzYWdlIGZyb20gUHl0aG9uIGVudmlyb25tZW50XG4gICAqL1xuICBwcml2YXRlIF9zZW5kTWVzc2FnZShtc2c6IElNZXNzYWdlKTogdm9pZCB7XG4gICAgdGhpcy5fcHJvY2Vzc01lc3NhZ2UobXNnKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFByb2Nlc3MgYSBtZXNzYWdlIGJ5IGVtaXR0aW5nIHRoZSBhcHByb3ByaWF0ZSBldmVudFxuICAgKi9cbiAgcHJpdmF0ZSBfcHJvY2Vzc01lc3NhZ2UobXNnOiBJTWVzc2FnZSk6IHZvaWQge1xuICAgIGlmICghbXNnLnR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZXZlbnREYXRhOiBhbnk7XG5cbiAgICBzd2l0Y2ggKG1zZy50eXBlKSB7XG4gICAgICBjYXNlICdzdHJlYW0nOiB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IG1zZy5idW5kbGUgPz8geyBuYW1lOiAnc3Rkb3V0JywgdGV4dDogJycgfTtcbiAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuU1RSRUFNLCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnaW5wdXRfcmVxdWVzdCc6IHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IG1zZy5jb250ZW50ID8/IHsgcHJvbXB0OiAnJywgcGFzc3dvcmQ6IGZhbHNlIH07XG4gICAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLklOUFVUX1JFUVVFU1QsIGNvbnRlbnQpO1xuICAgICAgICBldmVudERhdGEgPSBjb250ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2Rpc3BsYXlfZGF0YSc6IHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbXNnLmJ1bmRsZSA/PyB7IGRhdGE6IHt9LCBtZXRhZGF0YToge30sIHRyYW5zaWVudDoge30gfTtcbiAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuRElTUExBWV9EQVRBLCBidW5kbGUpO1xuICAgICAgICBldmVudERhdGEgPSBidW5kbGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAndXBkYXRlX2Rpc3BsYXlfZGF0YSc6IHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbXNnLmJ1bmRsZSA/PyB7IGRhdGE6IHt9LCBtZXRhZGF0YToge30sIHRyYW5zaWVudDoge30gfTtcbiAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuVVBEQVRFX0RJU1BMQVlfREFUQSwgYnVuZGxlKTtcbiAgICAgICAgZXZlbnREYXRhID0gYnVuZGxlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2NsZWFyX291dHB1dCc6IHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbXNnLmJ1bmRsZSA/PyB7IHdhaXQ6IGZhbHNlIH07XG4gICAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkNMRUFSX09VVFBVVCwgYnVuZGxlKTtcbiAgICAgICAgZXZlbnREYXRhID0gYnVuZGxlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2V4ZWN1dGVfcmVzdWx0Jzoge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBtc2cuYnVuZGxlID8/IHtcbiAgICAgICAgICBleGVjdXRpb25fY291bnQ6IHRoaXMuZXhlY3V0aW9uQ291bnQsXG4gICAgICAgICAgZGF0YToge30sXG4gICAgICAgICAgbWV0YWRhdGE6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5FWEVDVVRFX1JFU1VMVCwgYnVuZGxlKTtcbiAgICAgICAgZXZlbnREYXRhID0gYnVuZGxlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2V4ZWN1dGVfZXJyb3InOiB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IG1zZy5idW5kbGUgPz8geyBlbmFtZTogJycsIGV2YWx1ZTogJycsIHRyYWNlYmFjazogW10gfTtcbiAgICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwgYnVuZGxlKTtcbiAgICAgICAgZXZlbnREYXRhID0gYnVuZGxlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2NvbW1fb3Blbic6XG4gICAgICBjYXNlICdjb21tX21zZyc6XG4gICAgICBjYXNlICdjb21tX2Nsb3NlJzoge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gbXNnLmNvbnRlbnQgPz8ge307XG4gICAgICAgIHN1cGVyLmVtaXQobXNnLnR5cGUsIGNvbnRlbnQsIG1zZy5tZXRhZGF0YSwgbXNnLmJ1ZmZlcnMpO1xuICAgICAgICBldmVudERhdGEgPSB7XG4gICAgICAgICAgY29udGVudCxcbiAgICAgICAgICBtZXRhZGF0YTogbXNnLm1ldGFkYXRhLFxuICAgICAgICAgIGJ1ZmZlcnM6IG1zZy5idWZmZXJzXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVtaXQgdGhlIEFMTCBldmVudCB3aXRoIHN0YW5kYXJkaXplZCBmb3JtYXRcbiAgICBpZiAoZXZlbnREYXRhKSB7XG4gICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5BTEwsIHtcbiAgICAgICAgdHlwZTogbXNnLnR5cGUsXG4gICAgICAgIGRhdGE6IGV2ZW50RGF0YVxuICAgICAgfSBhcyBJRXZlbnREYXRhKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUga2VybmVsIGhhcyBiZWVuIGluaXRpYWxpemVkXG4gICAqL1xuICBwdWJsaWMgaXNJbml0aWFsaXplZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pbml0aWFsaXplZDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIE1ha2VzIHN1cmUgcHlvZGlkZSBpcyByZWFkeSBiZWZvcmUgY29udGludWluZywgYW5kIGNhY2hlIHRoZSBwYXJlbnQgbWVzc2FnZS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc2V0dXAocGFyZW50OiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB0aGlzLl9wYXJlbnRfaGVhZGVyID0gdGhpcy5weW9kaWRlLnRvUHkocGFyZW50IHx8IHt9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEV4ZWN1dGUgY29kZSBpbiB0aGUga2VybmVsIHdpdGggcHJvcGVyIG1lc3NhZ2UtYmFzZWQgY29tcGxldGlvbiBkZXRlY3Rpb25cbiAgICogXG4gICAqIEBwYXJhbSBjb2RlIFRoZSBjb2RlIHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIHBhcmVudCBQYXJlbnQgbWVzc2FnZSBoZWFkZXJcbiAgICogQHJldHVybnMgVGhlIHJlc3VsdCBvZiB0aGUgZXhlY3V0aW9uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZXhlY3V0ZShjb2RlOiBzdHJpbmcsIHBhcmVudDogYW55ID0ge30pOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiwgb3V0cHV0cz86IGFueSwgZXJyb3I/OiBFcnJvciwgZW5hbWU/OiBzdHJpbmcsIGV2YWx1ZT86IHN0cmluZywgdHJhY2ViYWNrPzogYW55IH0+IHtcbiAgICAvLyBTaW1wbGUgaW1wbGVtZW50YXRpb24gdGhhdCBjb2xsZWN0cyBhbGwgb3V0cHV0cyBmcm9tIGV4ZWN1dGVTdHJlYW1cbiAgICBjb25zdCBvdXRwdXRzOiBhbnlbXSA9IFtdO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgZXhlY3V0ZVN0cmVhbSB0byBnZXQgYWxsIG91dHB1dHNcbiAgICAgIGZvciBhd2FpdCAoY29uc3Qgb3V0cHV0IG9mIHRoaXMuZXhlY3V0ZVN0cmVhbShjb2RlLCBwYXJlbnQpKSB7XG4gICAgICAgIG91dHB1dHMucHVzaChvdXRwdXQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGNvbGxlY3RlZCBvdXRwdXRzIHRvIGNyZWF0ZSBhIGNvbXByZWhlbnNpdmUgcmVzdWx0XG4gICAgICBjb25zdCByZXN1bHQ6IGFueSA9IHtcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIGRhdGE6IHt9LFxuICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgIGV4ZWN1dGlvbl9jb3VudDogdGhpcy5leGVjdXRpb25Db3VudFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQ29sbGVjdCBhbGwgb3V0cHV0IHR5cGVzXG4gICAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiBvdXRwdXRzKSB7XG4gICAgICAgIGlmIChvdXRwdXQudHlwZSA9PT0gJ3N0cmVhbScpIHtcbiAgICAgICAgICAvLyBDb2xsZWN0IHN0ZG91dC9zdGRlcnJcbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdGRvdXQpIHJlc3VsdC5zdGRvdXQgPSAnJztcbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdGRlcnIpIHJlc3VsdC5zdGRlcnIgPSAnJztcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAob3V0cHV0LmRhdGEubmFtZSA9PT0gJ3N0ZG91dCcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGRvdXQgKz0gb3V0cHV0LmRhdGEudGV4dDtcbiAgICAgICAgICB9IGVsc2UgaWYgKG91dHB1dC5kYXRhLm5hbWUgPT09ICdzdGRlcnInKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RkZXJyICs9IG91dHB1dC5kYXRhLnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5vdXRwdXRzLnB1c2gob3V0cHV0LmRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKG91dHB1dC50eXBlID09PSAnZGlzcGxheV9kYXRhJyB8fCBvdXRwdXQudHlwZSA9PT0gJ2V4ZWN1dGVfcmVzdWx0Jykge1xuICAgICAgICAgIC8vIENvbGxlY3QgZGlzcGxheSBkYXRhXG4gICAgICAgICAgaWYgKG91dHB1dC5kYXRhLmRhdGEpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LmRhdGEsIG91dHB1dC5kYXRhLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3V0cHV0LmRhdGEubWV0YWRhdGEpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0Lm1ldGFkYXRhLCBvdXRwdXQuZGF0YS5tZXRhZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5vdXRwdXRzLnB1c2gob3V0cHV0LmRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKG91dHB1dC50eXBlID09PSAnZXhlY3V0ZV9lcnJvcicgfHwgb3V0cHV0LnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgZXJyb3JzXG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gb3V0cHV0LmRhdGE7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgJHtlcnJvckRhdGEuZW5hbWV9OiAke2Vycm9yRGF0YS5ldmFsdWV9YCksXG4gICAgICAgICAgICBlbmFtZTogZXJyb3JEYXRhLmVuYW1lLFxuICAgICAgICAgICAgZXZhbHVlOiBlcnJvckRhdGEuZXZhbHVlLFxuICAgICAgICAgICAgdHJhY2ViYWNrOiBlcnJvckRhdGEudHJhY2ViYWNrLFxuICAgICAgICAgICAgb3V0cHV0czogcmVzdWx0Lm91dHB1dHNcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFN0b3JlIGFueSBvdGhlciBvdXRwdXQgdHlwZVxuICAgICAgICAgIHJlc3VsdC5vdXRwdXRzLnB1c2gob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmV0dXJuIGNvbGxlY3RlZCByZXN1bHRzXG4gICAgICByZXN1bHQuc3VjY2VzcyA9IHRydWU7XG5cbiAgICAgIC8vIEF1dG8tc3luYyBuYXRpdmUgZmlsZXN5c3RlbXMgaWYgZW5hYmxlZFxuICAgICAgaWYgKHRoaXMuYXV0b1N5bmNGcykge1xuICAgICAgICBhd2FpdCB0aGlzLnN5bmNBbGxOYXRpdmVGcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbS0VSTkVMXSBFeGVjdXRlIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBGb3JtYXQgdGhlIHJlc3VsdCBmcm9tIHRoZSBQeW9kaWRlIGV2YWx1YXRpb25cbiAgICogQmFzZWQgb24gUHlvZGlkZVJlbW90ZUtlcm5lbCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBmb3JtYXRSZXN1bHQocmVzOiBhbnkpOiBhbnkge1xuICAgIGlmICghKHJlcyBpbnN0YW5jZW9mIHRoaXMucHlvZGlkZS5mZmkuUHlQcm94eSkpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBDb252ZXJ0IFB5UHJveHkgdG8gSlNcbiAgICAgIGNvbnN0IG0gPSByZXMudG9KcygpO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMubWFwVG9PYmplY3QobSk7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZvcm1hdHRpbmcgcmVzdWx0OlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiBTdHJpbmcoZXJyb3IpIH07XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogQ29udmVydCBhIE1hcCB0byBhIEphdmFTY3JpcHQgb2JqZWN0IHJlY3Vyc2l2ZWx5XG4gICAqIEJhc2VkIG9uIFB5b2RpZGVSZW1vdGVLZXJuZWwgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHByaXZhdGUgbWFwVG9PYmplY3Qob2JqOiBhbnkpIHtcbiAgICBjb25zdCBvdXQ6IGFueSA9IG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gW10gOiB7fTtcbiAgICBcbiAgICBvYmouZm9yRWFjaCgodmFsdWU6IGFueSwga2V5OiBzdHJpbmcpID0+IHtcbiAgICAgIG91dFtrZXldID0gXG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICA/IHRoaXMubWFwVG9PYmplY3QodmFsdWUpXG4gICAgICAgICAgOiB2YWx1ZTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIFxuICAvKipcbiAgICogSGFuZGxlIGlucHV0IHJlcGx5IGZyb20gdXNlclxuICAgKi9cbiAgcHVibGljIGFzeW5jIGlucHV0UmVwbHkoY29udGVudDogeyB2YWx1ZTogc3RyaW5nIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5fcmVzb2x2ZUlucHV0UmVwbHkpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVJbnB1dFJlcGx5KGNvbnRlbnQpO1xuICAgICAgdGhpcy5fcmVzb2x2ZUlucHV0UmVwbHkgPSBudWxsO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFNlbmQgYSBpbnB1dCByZXF1ZXN0IHRvIHRoZSBmcm9udC1lbmQuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNlbmRJbnB1dFJlcXVlc3QocHJvbXB0OiBzdHJpbmcsIHBhc3N3b3JkOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY29udGVudCA9IHtcbiAgICAgIHByb21wdCxcbiAgICAgIHBhc3N3b3JkLFxuICAgIH07XG5cbiAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICB0eXBlOiAnaW5wdXRfcmVxdWVzdCcsXG4gICAgICBjb250ZW50LFxuICAgICAgcGFyZW50SGVhZGVyOiB0aGlzLmZvcm1hdFJlc3VsdCh0aGlzLl9wYXJlbnRfaGVhZGVyKVsnaGVhZGVyJ11cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcGFzc3dvcmQgaW5wdXQgKHdpdGggaGlkZGVuIGlucHV0KVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRwYXNzKHByb21wdDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBwcm9tcHQgPSB0eXBlb2YgcHJvbXB0ID09PSAndW5kZWZpbmVkJyA/ICcnIDogcHJvbXB0O1xuICAgIGF3YWl0IHRoaXMuc2VuZElucHV0UmVxdWVzdChwcm9tcHQsIHRydWUpO1xuICAgIGNvbnN0IHJlcGx5UHJvbWlzZSA9IG5ldyBQcm9taXNlPHsgdmFsdWU6IHN0cmluZyB9PigocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZUlucHV0UmVwbHkgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcGx5UHJvbWlzZTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0ZXh0IGlucHV0XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGlucHV0KHByb21wdDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBwcm9tcHQgPSB0eXBlb2YgcHJvbXB0ID09PSAndW5kZWZpbmVkJyA/ICcnIDogcHJvbXB0O1xuICAgIGF3YWl0IHRoaXMuc2VuZElucHV0UmVxdWVzdChwcm9tcHQsIGZhbHNlKTtcbiAgICBjb25zdCByZXBseVByb21pc2UgPSBuZXcgUHJvbWlzZTx7IHZhbHVlOiBzdHJpbmcgfT4oKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmVJbnB1dFJlcGx5ID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBseVByb21pc2U7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNlbmQgYSBjb21tIG1lc3NhZ2UgdG8gdGhlIGZyb250LWVuZC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc2VuZENvbW0odHlwZTogc3RyaW5nLCBjb250ZW50OiBhbnksIG1ldGFkYXRhOiBhbnksIGlkZW50OiBhbnksIGJ1ZmZlcnM6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBjb250ZW50OiB0aGlzLmZvcm1hdFJlc3VsdChjb250ZW50KSxcbiAgICAgIG1ldGFkYXRhOiB0aGlzLmZvcm1hdFJlc3VsdChtZXRhZGF0YSksXG4gICAgICBpZGVudDogdGhpcy5mb3JtYXRSZXN1bHQoaWRlbnQpLFxuICAgICAgYnVmZmVyczogdGhpcy5mb3JtYXRSZXN1bHQoYnVmZmVycyksXG4gICAgICBwYXJlbnRIZWFkZXI6IHRoaXMuZm9ybWF0UmVzdWx0KHRoaXMuX3BhcmVudF9oZWFkZXIpWydoZWFkZXInXSxcbiAgICB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENvbXBsZXRlIHRoZSBjb2RlIHN1Ym1pdHRlZCBieSBhIHVzZXIuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY29tcGxldGUoY29kZTogc3RyaW5nLCBjdXJzb3JfcG9zOiBudW1iZXIsIHBhcmVudDogYW55ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICBcbiAgICBjb25zdCByZXMgPSB0aGlzLl9rZXJuZWwuY29tcGxldGUoY29kZSwgY3Vyc29yX3Bvcyk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0KHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogSW5zcGVjdCB0aGUgY29kZSBzdWJtaXR0ZWQgYnkgYSB1c2VyLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGluc3BlY3QoY29kZTogc3RyaW5nLCBjdXJzb3JfcG9zOiBudW1iZXIsIGRldGFpbF9sZXZlbDogMCB8IDEsIHBhcmVudDogYW55ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICBcbiAgICBjb25zdCByZXMgPSB0aGlzLl9rZXJuZWwuaW5zcGVjdChjb2RlLCBjdXJzb3JfcG9zLCBkZXRhaWxfbGV2ZWwpO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdChyZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGNvZGUgZm9yIGNvbXBsZXRlbmVzcy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBpc0NvbXBsZXRlKGNvZGU6IHN0cmluZywgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChwYXJlbnQpO1xuICAgIFxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2tlcm5lbC5pc19jb21wbGV0ZShjb2RlKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHQocmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgYXZhaWxhYmxlIGNvbW1zLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNvbW1JbmZvKHRhcmdldF9uYW1lOiBzdHJpbmcgfCBudWxsLCBwYXJlbnQ6IGFueSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBhd2FpdCB0aGlzLnNldHVwKHBhcmVudCk7XG4gICAgXG4gICAgY29uc3QgcmVzID0gdGhpcy5fa2VybmVsLmNvbW1faW5mbyh0YXJnZXRfbmFtZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1zOiB0aGlzLmZvcm1hdFJlc3VsdChyZXMpLFxuICAgICAgc3RhdHVzOiAnb2snLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogT3BlbiBhIENPTU1cbiAgICovXG4gIHB1YmxpYyBhc3luYyBjb21tT3Blbihjb250ZW50OiBhbnksIHBhcmVudDogYW55ID0ge30pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnNldHVwKHBhcmVudCk7XG4gICAgXG4gICAgY29uc3QgcmVzID0gdGhpcy5fa2VybmVsLmNvbW1fbWFuYWdlci5jb21tX29wZW4oXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShudWxsKSxcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KG51bGwpLFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkoY29udGVudClcbiAgICApO1xuICAgIFxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdChyZXMpO1xuICB9XG4gIFxuICAvKipcbiAgICogU2VuZCBhIG1lc3NhZ2UgdGhyb3VnaCBhIENPTU1cbiAgICovXG4gIHB1YmxpYyBhc3luYyBjb21tTXNnKGNvbnRlbnQ6IGFueSwgcGFyZW50OiBhbnkgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICBcbiAgICBjb25zdCByZXMgPSB0aGlzLl9rZXJuZWwuY29tbV9tYW5hZ2VyLmNvbW1fbXNnKFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkobnVsbCksXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShudWxsKSxcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KGNvbnRlbnQpXG4gICAgKTtcbiAgICBcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHQocmVzKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENsb3NlIGEgQ09NTVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNvbW1DbG9zZShjb250ZW50OiBhbnksIHBhcmVudDogYW55ID0ge30pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnNldHVwKHBhcmVudCk7XG4gICAgXG4gICAgY29uc3QgcmVzID0gdGhpcy5fa2VybmVsLmNvbW1fbWFuYWdlci5jb21tX2Nsb3NlKFxuICAgICAgdGhpcy5weW9kaWRlLnRvUHkobnVsbCksXG4gICAgICB0aGlzLnB5b2RpZGUudG9QeShudWxsKSxcbiAgICAgIHRoaXMucHlvZGlkZS50b1B5KGNvbnRlbnQpXG4gICAgKTtcbiAgICBcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHQocmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIFB5dGhvbiBjb2RlIHdpdGggc3RyZWFtaW5nIG91dHB1dFxuICAgKiBAcGFyYW0gY29kZSBUaGUgUHl0aG9uIGNvZGUgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0gcGFyZW50IFBhcmVudCBtZXNzYWdlIGhlYWRlclxuICAgKiBAcmV0dXJucyBBc3luY0dlbmVyYXRvciB5aWVsZGluZyBpbnRlcm1lZGlhdGUgb3V0cHV0cyBhbmQgZmluYWxseSB0aGUgZXhlY3V0aW9uIHJlc3VsdFxuICAgKi9cbiAgcHVibGljIGFzeW5jKiBleGVjdXRlU3RyZWFtKGNvZGU6IHN0cmluZywgcGFyZW50OiBhbnkgPSB7fSk6IEFzeW5jR2VuZXJhdG9yPGFueSwgeyBzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ/OiBhbnksIGVycm9yPzogRXJyb3IgfSwgdm9pZD4ge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IFwiYnVzeVwiO1xuICAgICAgc3VwZXIuZW1pdChLZXJuZWxFdmVudHMuS0VSTkVMX0JVU1ksIHt9KTtcbiAgICAgIGF3YWl0IHRoaXMuc2V0dXAocGFyZW50KTtcbiAgICAgIC8vIENyZWF0ZSBldmVudCBsaXN0ZW5lcnMgZm9yIHN0cmVhbWluZ1xuICAgICAgY29uc3QgZXZlbnRRdWV1ZTogSUV2ZW50RGF0YVtdID0gW107XG4gICAgICBsZXQgZXhlY3V0aW9uQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgIGxldCBleGVjdXRpb25SZXN1bHQ6IGFueSA9IG51bGw7XG4gICAgICBsZXQgZXhlY3V0aW9uRXJyb3I6IEVycm9yIHwgbnVsbCA9IG51bGw7XG4gICAgICBcbiAgICAgIGNvbnN0IGhhbmRsZUFsbEV2ZW50cyA9IChldmVudERhdGE6IElFdmVudERhdGEpID0+IHtcbiAgICAgICAgZXZlbnRRdWV1ZS5wdXNoKGV2ZW50RGF0YSk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBMaXN0ZW4gZm9yIGFsbCBldmVudHMgQkVGT1JFIGV4ZWN1dGluZyBjb2RlXG4gICAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuQUxMLCBoYW5kbGVBbGxFdmVudHMpO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSBjb2RlIGRpcmVjdGx5XG4gICAgICAgIHRoaXMuX2tlcm5lbC5ydW4oY29kZSkudGhlbigocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIFB5dGhvbiBleGVjdXRpb24gZmluaXNoZWRcIik7XG4gICAgICAgICAgZXhlY3V0aW9uUmVzdWx0ID0gdGhpcy5mb3JtYXRSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcmVzdWx0IGluZGljYXRlcyBhbiBlcnJvciBhbmQgZW1pdCBpdCBhcyBhbiBldmVudFxuICAgICAgICAgIGlmIChleGVjdXRpb25SZXN1bHQgJiYgZXhlY3V0aW9uUmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbS0VSTkVMXSBFeGVjdXRpb24gY29tcGxldGVkIHdpdGggZXJyb3Igc3RhdHVzLCBlbWl0dGluZyBleGVjdXRlX2Vycm9yIGV2ZW50XCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFbWl0IHRoZSBlcnJvciBldmVudCBzbyB0aGUgVUkgY2FuIGRpc3BsYXkgaXRcbiAgICAgICAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgcGFyZW50SGVhZGVyOiB0aGlzLmZvcm1hdFJlc3VsdCh0aGlzLl9wYXJlbnRfaGVhZGVyKVsnaGVhZGVyJ10sXG4gICAgICAgICAgICAgIGJ1bmRsZToge1xuICAgICAgICAgICAgICAgIGVuYW1lOiBleGVjdXRpb25SZXN1bHQuZW5hbWUgfHwgJ0Vycm9yJyxcbiAgICAgICAgICAgICAgICBldmFsdWU6IGV4ZWN1dGlvblJlc3VsdC5ldmFsdWUgfHwgJ1Vua25vd24gZXJyb3InLFxuICAgICAgICAgICAgICAgIHRyYWNlYmFjazogZXhlY3V0aW9uUmVzdWx0LnRyYWNlYmFjayB8fCBbXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0eXBlOiAnZXhlY3V0ZV9lcnJvcicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBhIHNtYWxsIGFtb3VudCBvZiB0aW1lIGZvciBhbnkgcmVtYWluaW5nIG1lc3NhZ2VzIHRvIGJlIHByb2Nlc3NlZFxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZXhlY3V0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIH0sIDEwMCk7IC8vIDEwMG1zIHNob3VsZCBiZSBlbm91Z2ggZm9yIG1lc3NhZ2UgcHJvY2Vzc2luZ1xuICAgICAgICAgIFxuICAgICAgICB9KS5jYXRjaCgoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbS0VSTkVMXSBQeXRob24gZXhlY3V0aW9uIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgICAgZXhlY3V0aW9uRXJyb3IgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU3RpbGwgd2FpdCBmb3IgbWVzc2FnZXMgdG8gc2V0dGxlIGJlZm9yZSBjb21wbGV0aW5nXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdHJlYW0gZXZlbnRzIGFzIHRoZXkgYXJyaXZlXG4gICAgICAgIHdoaWxlICghZXhlY3V0aW9uQ29tcGxldGUgfHwgZXZlbnRRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gWWllbGQgcXVldWVkIGV2ZW50c1xuICAgICAgICAgIGlmIChldmVudFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRRdWV1ZS5zaGlmdCgpITtcbiAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAvLyBXYWl0IGEgYml0IGZvciBtb3JlIGV2ZW50c1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIHJlc3VsdFxuICAgICAgICB0aGlzLl9zdGF0dXMgPSBcImFjdGl2ZVwiO1xuICAgICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5LRVJORUxfSURMRSwge30pO1xuICAgICAgICBcbiAgICAgICAgaWYgKGV4ZWN1dGlvbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGV4ZWN1dGlvbkVycm9yLFxuICAgICAgICAgICAgcmVzdWx0OiBleGVjdXRpb25SZXN1bHRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiByZXN1bHQgaW5kaWNhdGVzIGFuIGVycm9yXG4gICAgICAgIGlmIChleGVjdXRpb25SZXN1bHQgJiYgZXhlY3V0aW9uUmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgIGNvbnN0IGVycm9yTXNnID0gYCR7ZXhlY3V0aW9uUmVzdWx0LmVuYW1lIHx8ICdFcnJvcid9OiAke2V4ZWN1dGlvblJlc3VsdC5ldmFsdWUgfHwgJ1Vua25vd24gZXJyb3InfWA7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihlcnJvck1zZyksXG4gICAgICAgICAgICByZXN1bHQ6IGV4ZWN1dGlvblJlc3VsdFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdXRvLXN5bmMgbmF0aXZlIGZpbGVzeXN0ZW1zIGlmIGVuYWJsZWRcbiAgICAgICAgaWYgKHRoaXMuYXV0b1N5bmNGcykge1xuICAgICAgICAgIGF3YWl0IHRoaXMuc3luY0FsbE5hdGl2ZUZzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgcmVzdWx0OiBleGVjdXRpb25SZXN1bHRcbiAgICAgICAgfTtcblxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgbGlzdGVuZXJcbiAgICAgICAgc3VwZXIub2ZmKEtlcm5lbEV2ZW50cy5BTEwsIGhhbmRsZUFsbEV2ZW50cyk7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIltLRVJORUxdIEV4ZWN1dGVTdHJlYW0gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IFwiYWN0aXZlXCI7XG4gICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5LRVJORUxfSURMRSwge30pO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnRlcnJ1cHQgZnVuY3Rpb25hbGl0eVxuICBwdWJsaWMgYXN5bmMgaW50ZXJydXB0KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCB8fCAhdGhpcy5weW9kaWRlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbS0VSTkVMXSBDYW5ub3QgaW50ZXJydXB0OiBrZXJuZWwgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIEF0dGVtcHRpbmcgdG8gaW50ZXJydXB0IGV4ZWN1dGlvbi4uLlwiKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgcHJpb3JpdHk6IFVzZSBpbnRlcnJ1cHQgYnVmZmVyIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKHRoaXMuX2ludGVycnVwdEJ1ZmZlciAmJiB0aGlzLl9pbnRlcnJ1cHRTdXBwb3J0ZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbS0VSTkVMXSBVc2luZyBpbnRlcnJ1cHQgYnVmZmVyIG1ldGhvZFwiKTtcbiAgICAgICAgLy8gU2V0IGludGVycnVwdCBzaWduYWwgKDIgPSBTSUdJTlQpXG4gICAgICAgIHRoaXMuX2ludGVycnVwdEJ1ZmZlclswXSA9IDI7XG4gICAgICAgIFxuICAgICAgICAvLyBHaXZlIHRoZSBpbnRlcnJ1cHQgYSBtb21lbnQgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBpbnRlcnJ1cHQgd2FzIHByb2Nlc3NlZCAoYnVmZmVyIHNob3VsZCBiZSByZXNldCB0byAwKVxuICAgICAgICBjb25zdCB3YXNQcm9jZXNzZWQgPSB0aGlzLl9pbnRlcnJ1cHRCdWZmZXJbMF0gPT09IDA7XG4gICAgICAgIGlmICh3YXNQcm9jZXNzZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIEludGVycnVwdCBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5IHZpYSBidWZmZXJcIik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2Vjb25kIHByaW9yaXR5OiBUcnkgUHl0aG9uLWxldmVsIGludGVycnVwdFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbS0VSTkVMXSBBdHRlbXB0aW5nIFB5dGhvbi1sZXZlbCBpbnRlcnJ1cHRcIik7XG4gICAgICAgIC8vIFRyeSB0byByYWlzZSBLZXlib2FyZEludGVycnVwdCBpbiBQeXRob25cbiAgICAgICAgYXdhaXQgdGhpcy5weW9kaWRlLnJ1blB5dGhvbkFzeW5jKGBcbmltcG9ydCBzeXNcbmltcG9ydCBfdGhyZWFkXG4jIFRyeSB0byBpbnRlcnJ1cHQgdGhlIG1haW4gdGhyZWFkXG5fdGhyZWFkLmludGVycnVwdF9tYWluKClcbmApO1xuICAgICAgICBjb25zb2xlLmxvZyhcIltLRVJORUxdIFB5dGhvbiBpbnRlcnJ1cHQgc2lnbmFsIHNlbnRcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAocHl0aG9uRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbS0VSTkVMXSBQeXRob24gaW50ZXJydXB0IGF0dGVtcHQgZmFpbGVkOlwiLCBweXRob25FcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFRoaXJkIHByaW9yaXR5OiBUcnkgaW50ZXJwcmV0ZXIgaW50ZXJydXB0IGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKHRoaXMuX2ludGVycHJldGVyICYmIHR5cGVvZiB0aGlzLl9pbnRlcnByZXRlci5pbnRlcnJ1cHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbS0VSTkVMXSBVc2luZyBpbnRlcnByZXRlciBpbnRlcnJ1cHQgbWV0aG9kXCIpO1xuICAgICAgICB0aGlzLl9pbnRlcnByZXRlci5pbnRlcnJ1cHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIExhc3QgcmVzb3J0OiBTZW5kIGludGVycnVwdCBtZXNzYWdlcyBmb3IgVUkgZmVlZGJhY2tcbiAgICAgIGNvbnNvbGUubG9nKFwiW0tFUk5FTF0gU2VuZGluZyBpbnRlcnJ1cHQgbWVzc2FnZXMgZm9yIFVJIGZlZWRiYWNrXCIpO1xuICAgICAgXG4gICAgICAvLyBTZW5kIHN0ZGVyciBzdHJlYW0gZmlyc3QgKGZvciBKdXB5dGVyIG5vdGVib29rIFVJIGNvbXBhdGliaWxpdHkpXG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdzdHJlYW0nLFxuICAgICAgICBidW5kbGU6IHtcbiAgICAgICAgICBuYW1lOiAnc3RkZXJyJyxcbiAgICAgICAgICB0ZXh0OiAnS2V5Ym9hcmRJbnRlcnJ1cHQ6IEV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXFxuJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiAnZXhlY3V0ZV9lcnJvcicsXG4gICAgICAgIGJ1bmRsZToge1xuICAgICAgICAgIGVuYW1lOiAnS2V5Ym9hcmRJbnRlcnJ1cHQnLFxuICAgICAgICAgIGV2YWx1ZTogJ0V4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyJyxcbiAgICAgICAgICB0cmFjZWJhY2s6IFsnS2V5Ym9hcmRJbnRlcnJ1cHQ6IEV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyJ11cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFJldHVybiBmYWxzZSBzaW5jZSB3ZSBjb3VsZG4ndCBhY3R1YWxseSBpbnRlcnJ1cHQgdGhlIGV4ZWN1dGlvblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW0tFUk5FTF0gRXJyb3IgZHVyaW5nIGludGVycnVwdDpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXRJbnRlcnJ1cHRCdWZmZXIoYnVmZmVyOiBVaW50OEFycmF5KTogdm9pZCB7XG4gICAgdGhpcy5faW50ZXJydXB0QnVmZmVyID0gYnVmZmVyO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnB5b2RpZGUgJiYgdHlwZW9mIHRoaXMucHlvZGlkZS5zZXRJbnRlcnJ1cHRCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5weW9kaWRlLnNldEludGVycnVwdEJ1ZmZlcihidWZmZXIpO1xuICAgICAgICB0aGlzLl9pbnRlcnJ1cHRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW0tFUk5FTF0gcHlvZGlkZS5zZXRJbnRlcnJ1cHRCdWZmZXIgbm90IGF2YWlsYWJsZSwgaW50ZXJydXB0IHN1cHBvcnQgbGltaXRlZFwiKTtcbiAgICAgICAgdGhpcy5faW50ZXJydXB0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbS0VSTkVMXSBFcnJvciBzZXR0aW5nIGludGVycnVwdCBidWZmZXI6XCIsIGVycm9yKTtcbiAgICAgIHRoaXMuX2ludGVycnVwdFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgYW5kIHJlcXVlc3QgcGVybWlzc2lvbiBmb3IgYSBmaWxlIHN5c3RlbSBoYW5kbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgdmVyaWZ5UGVybWlzc2lvbihcbiAgICBmaWxlSGFuZGxlOiBGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlLFxuICAgIHBlcm1pc3Npb246ICdyZWFkJyB8ICdyZWFkd3JpdGUnXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IG9wdHM6IGFueSA9IHt9O1xuICAgIGlmIChwZXJtaXNzaW9uID09PSAncmVhZHdyaXRlJykge1xuICAgICAgb3B0cy5tb2RlID0gJ3JlYWR3cml0ZSc7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFtLRVJORUxdIFZlcmlmeWluZyAke3Blcm1pc3Npb259IHBlcm1pc3Npb24gZm9yIGZpbGUgaGFuZGxlLi4uYCk7XG5cbiAgICAvLyBDaGVjayBpZiBwZXJtaXNzaW9uIEFQSXMgYXJlIHN1cHBvcnRlZFxuICAgIGlmICh0eXBlb2YgKGZpbGVIYW5kbGUgYXMgYW55KS5xdWVyeVBlcm1pc3Npb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnNvbGUud2FybignW0tFUk5FTF0gcXVlcnlQZXJtaXNzaW9uIG5vdCBzdXBwb3J0ZWQsIGFzc3VtaW5nIHBlcm1pc3Npb24gZ3JhbnRlZCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBwZXJtaXNzaW9uLCBpZiBzbywgcmV0dXJuIHRydWUuXG4gICAgICBjb25zdCBxdWVyeVJlc3VsdCA9IGF3YWl0IChmaWxlSGFuZGxlIGFzIGFueSkucXVlcnlQZXJtaXNzaW9uKG9wdHMpO1xuICAgICAgY29uc29sZS5sb2coJ1tLRVJORUxdIFF1ZXJ5IHJlc3VsdDonLCBxdWVyeVJlc3VsdCk7XG4gICAgICBcbiAgICAgIGlmIChxdWVyeVJlc3VsdCA9PT0gJ2dyYW50ZWQnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBQZXJtaXNzaW9uIGFscmVhZHkgZ3JhbnRlZCBmb3IgJHtwZXJtaXNzaW9ufSBhY2Nlc3NgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlcXVlc3QgcGVybWlzc2lvbiB0byB0aGUgZmlsZSwgaWYgdGhlIHVzZXIgZ3JhbnRzIHBlcm1pc3Npb24sIHJldHVybiB0cnVlLlxuICAgICAgaWYgKHR5cGVvZiAoZmlsZUhhbmRsZSBhcyBhbnkpLnJlcXVlc3RQZXJtaXNzaW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBSZXF1ZXN0aW5nICR7cGVybWlzc2lvbn0gcGVybWlzc2lvbiBmcm9tIHVzZXIuLi5gKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdFJlc3VsdCA9IGF3YWl0IChmaWxlSGFuZGxlIGFzIGFueSkucmVxdWVzdFBlcm1pc3Npb24ob3B0cyk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tLRVJORUxdIFJlcXVlc3QgcmVzdWx0OicsIHJlcXVlc3RSZXN1bHQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChyZXF1ZXN0UmVzdWx0ID09PSAnZ3JhbnRlZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBQZXJtaXNzaW9uIGdyYW50ZWQgZm9yICR7cGVybWlzc2lvbn0gYWNjZXNzYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHJlcXVlc3RFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbS0VSTkVMXSBQZXJtaXNzaW9uIHJlcXVlc3QgZmFpbGVkIG9yIHdhcyBkaXNtaXNzZWQ6JywgcmVxdWVzdEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgdXNlciBkaWQgbm90IGdyYW50IHBlcm1pc3Npb24sIHJldHVybiBmYWxzZS5cbiAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSAke3Blcm1pc3Npb259IHBlcm1pc3Npb24gbm90IGdyYW50ZWRgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbS0VSTkVMXSBFcnJvciBjaGVja2luZyBwZXJtaXNzaW9uOicsIGVycm9yKTtcbiAgICAgIC8vIElmIHBlcm1pc3Npb24gY2hlY2sgZmFpbHMsIGFzc3VtZSBpdCdzIGdyYW50ZWQgKG1vcmUgcGVybWlzc2l2ZSBhcHByb2FjaClcbiAgICAgIGNvbnNvbGUud2FybignW0tFUk5FTF0gUGVybWlzc2lvbiBjaGVjayBmYWlsZWQsIGFzc3VtaW5nIGdyYW50ZWQgYXMgZmFsbGJhY2snKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3VudCBhIG5hdGl2ZSBmaWxlIHN5c3RlbSBkaXJlY3RvcnkgaW50byB0aGUgUHlvZGlkZSBmaWxlc3lzdGVtXG4gICAqIEBwYXJhbSBtb3VudFBhdGggVGhlIHBhdGggd2hlcmUgdGhlIGRpcmVjdG9yeSBzaG91bGQgYmUgbW91bnRlZCBpbiB0aGUgUHl0aG9uIGZpbGVzeXN0ZW1cbiAgICogQHBhcmFtIGRpckhhbmRsZSBPcHRpb25hbCBGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlLiBJZiBudWxsL3VuZGVmaW5lZCwgc2hvd3MgZGlyZWN0b3J5IHBpY2tlclxuICAgKiBAcGFyYW0gcGVybWlzc2lvbiBQZXJtaXNzaW9uIG1vZGU6XG4gICAqICAgLSAncmVhZCc6IFJlYWQtb25seSBhY2Nlc3MsIG5vIHN5bmNpbmcgY2FwYWJpbGl0aWVzLCBhdXRvLXN5bmMgd2lsbCBiZSBza2lwcGVkIChkZWZhdWx0KVxuICAgKiAgIC0gJ3JlYWR3cml0ZSc6IEZ1bGwgcmVhZC93cml0ZSBhY2Nlc3Mgd2l0aCBzeW5jaW5nIGNhcGFiaWxpdGllc1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhIGhhbmRsZSB3aXRoIHN5bmNmcygpIG1ldGhvZCBmb3Igc3luY2luZyBjaGFuZ2VzXG4gICAqIEBub3RlIHN5bmNmcygpIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgY2FsbGVkIG9uIGEgcmVhZC1vbmx5IG1vdW50ZWQgZmlsZXN5c3RlbVxuICAgKiBAbm90ZSBNYW55IGJyb3dzZXJzIG9ubHkgb2ZmZXIgcmVhZCBwZXJtaXNzaW9uIGluaXRpYWxseS4gRXhwbGljaXRseSByZXF1ZXN0ICdyZWFkd3JpdGUnIGlmIHlvdSBuZWVkIHdyaXRlIGFjY2Vzcy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBtb3VudEZTKFxuICAgIG1vdW50UGF0aDogc3RyaW5nLFxuICAgIGRpckhhbmRsZT86IEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUgfCBudWxsLFxuICAgIHBlcm1pc3Npb246ICdyZWFkJyB8ICdyZWFkd3JpdGUnID0gJ3JlYWQnXG4gICk6IFByb21pc2U8eyBzeW5jZnM6ICgpID0+IFByb21pc2U8dm9pZD4gfT4ge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCB8fCAhdGhpcy5weW9kaWRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXJuZWwgbXVzdCBiZSBpbml0aWFsaXplZCBiZWZvcmUgbW91bnRpbmcgZmlsZXN5c3RlbVwiKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBtb3VudE5hdGl2ZUZTIGlzIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2YgdGhpcy5weW9kaWRlLm1vdW50TmF0aXZlRlMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInB5b2RpZGUubW91bnROYXRpdmVGUyBpcyBub3QgYXZhaWxhYmxlLiBNYWtlIHN1cmUgeW91J3JlIHVzaW5nIFB5b2RpZGUgMC4yMy4wIG9yIGxhdGVyLlwiKTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlID0gZGlySGFuZGxlO1xuXG4gICAgLy8gSWYgbm8gZGlySGFuZGxlIHByb3ZpZGVkLCBzaG93IGRpcmVjdG9yeSBwaWNrZXJcbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgaW4gYSB3b3JrZXIgY29udGV4dFxuICAgICAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzaG93IGRpcmVjdG9yeSBwaWNrZXIgaW4gd29ya2VyIGNvbnRleHQuIFBsZWFzZSBwcm92aWRlIGEgZGlySGFuZGxlIHBhcmFtZXRlci5cIik7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHNob3dEaXJlY3RvcnlQaWNrZXIgaXMgYXZhaWxhYmxlXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3Nob3dEaXJlY3RvcnlQaWNrZXInIGluIHdpbmRvdykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGhhbmRsZSA9IGF3YWl0ICh3aW5kb3cgYXMgYW55KS5zaG93RGlyZWN0b3J5UGlja2VyKHtcbiAgICAgICAgICAgIG1vZGU6ICdyZWFkd3JpdGUnLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNob3cgZGlyZWN0b3J5IHBpY2tlcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNob3dEaXJlY3RvcnlQaWNrZXIgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFBsZWFzZSBwcm92aWRlIGEgZGlySGFuZGxlIHBhcmFtZXRlci5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFoYW5kbGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGRpcmVjdG9yeSBoYW5kbGUgYXZhaWxhYmxlXCIpO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSBhbmQgcmVxdWVzdCBwZXJtaXNzaW9ucyBiZWZvcmUgbW91bnRpbmdcbiAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gVmVyaWZ5aW5nICR7cGVybWlzc2lvbn0gcGVybWlzc2lvbnMgYmVmb3JlIG1vdW50aW5nLi4uYCk7XG4gICAgY29uc3QgaGFzUmVxdWVzdGVkUGVybWlzc2lvbiA9IGF3YWl0IHRoaXMudmVyaWZ5UGVybWlzc2lvbihoYW5kbGUsIHBlcm1pc3Npb24pO1xuICAgIFxuICAgIGlmICghaGFzUmVxdWVzdGVkUGVybWlzc2lvbikge1xuICAgICAgaWYgKHBlcm1pc3Npb24gPT09ICdyZWFkd3JpdGUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIG9idGFpbiB3cml0ZSBwZXJtaXNzaW9uIGZvciBkaXJlY3RvcnkuIGAgK1xuICAgICAgICAgIGBUaGUgYnJvd3NlciBtYXkgb25seSBiZSBvZmZlcmluZyByZWFkIHBlcm1pc3Npb24uIGAgK1xuICAgICAgICAgIGBUcnkgbW91bnRpbmcgd2l0aCBwZXJtaXNzaW9uOiAncmVhZCcgaWYgeW91IG9ubHkgbmVlZCB0byByZWFkIGZpbGVzLCBgICtcbiAgICAgICAgICBgb3IgZW5zdXJlIHRoZSBicm93c2VyIHN1cHBvcnRzIHdyaXRlIGFjY2VzcyB0byB0aGlzIGRpcmVjdG9yeS5gXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBvYnRhaW4gJHtwZXJtaXNzaW9ufSBwZXJtaXNzaW9uIGZvciBkaXJlY3RvcnkuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGFjdHVhbFBlcm1pc3Npb24gPSBwZXJtaXNzaW9uO1xuXG4gICAgLy8gTW91bnQgdGhlIG5hdGl2ZSBmaWxlc3lzdGVtXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBNb3VudGluZyBuYXRpdmUgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH0gd2l0aCAke2FjdHVhbFBlcm1pc3Npb259IHBlcm1pc3Npb25gKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1vdW50IHBvaW50IGFscmVhZHkgZXhpc3RzIGFuZCBoYW5kbGUgY2xlYW51cFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGF0aEluZm8gPSB0aGlzLnB5b2RpZGUuRlMuYW5hbHl6ZVBhdGgobW91bnRQYXRoKTtcbiAgICAgICAgaWYgKHBhdGhJbmZvLmV4aXN0cykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBQYXRoICR7bW91bnRQYXRofSBleGlzdHMsIGNoZWNraW5nIGlmIGl0J3MgYSBtb3VudCBwb2ludGApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSB0byB1bm1vdW50IGlmIGl0J3MgYWxyZWFkeSBtb3VudGVkXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHlvZGlkZS5GUy51bm1vdW50KG1vdW50UGF0aCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gU3VjY2Vzc2Z1bGx5IHVubW91bnRlZCBleGlzdGluZyBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgICAgIH0gY2F0Y2ggKHVubW91bnRFcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgdW5tb3VudCBmYWlscywgaXQgbWlnaHQgbm90IGJlIGEgbW91bnQgcG9pbnQgb3IgbWlnaHQgYmUgYnVzeVxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFVubW91bnQgZmFpbGVkICh0aGlzIGlzIG5vcm1hbCBpZiBub3QgbW91bnRlZCk6ICR7dW5tb3VudEVycm9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGRpcmVjdG9yeSBpZiBpdCBleGlzdHMgYnV0IGlzIGVtcHR5XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucHlvZGlkZS5GUy5ybWRpcihtb3VudFBhdGgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFJlbW92ZWQgZXhpc3RpbmcgZGlyZWN0b3J5IGF0ICR7bW91bnRQYXRofWApO1xuICAgICAgICAgIH0gY2F0Y2ggKHJtZGlyRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIERpcmVjdG9yeSBtaWdodCBub3QgYmUgZW1wdHkgb3IgbWlnaHQgbm90IGV4aXN0LCB0aGF0J3Mgb2theVxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIENvdWxkIG5vdCByZW1vdmUgZGlyZWN0b3J5ICh0aGlzIGlzIG5vcm1hbCk6ICR7cm1kaXJFcnJvcn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGFuYWx5emVFcnJvcikge1xuICAgICAgICAvLyBhbmFseXplUGF0aCBtaWdodCBmYWlsLCB0aGF0J3Mgb2theSAtIHRoZSBwYXRoIHByb2JhYmx5IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFBhdGggYW5hbHlzaXMgZmFpbGVkIChwYXRoIHByb2JhYmx5IGRvZXNuJ3QgZXhpc3QpOiAke2FuYWx5emVFcnJvcn1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSBwYXJlbnQgZGlyZWN0b3J5IGV4aXN0c1xuICAgICAgY29uc3QgcGFyZW50UGF0aCA9IG1vdW50UGF0aC5zdWJzdHJpbmcoMCwgbW91bnRQYXRoLmxhc3RJbmRleE9mKCcvJykpIHx8ICcvJztcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwYXJlbnRQYXRoICE9PSAnLycgJiYgIXRoaXMucHlvZGlkZS5GUy5hbmFseXplUGF0aChwYXJlbnRQYXRoKS5leGlzdHMpIHtcbiAgICAgICAgICB0aGlzLnB5b2RpZGUuRlMubWtkaXIocGFyZW50UGF0aCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIENyZWF0ZWQgcGFyZW50IGRpcmVjdG9yeSAke3BhcmVudFBhdGh9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHBhcmVudEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBQYXJlbnQgZGlyZWN0b3J5IGhhbmRsaW5nOiAke3BhcmVudEVycm9yfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBuYXRpdmVmcyA9IGF3YWl0IHRoaXMucHlvZGlkZS5tb3VudE5hdGl2ZUZTKG1vdW50UGF0aCwgaGFuZGxlKTtcblxuICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFN1Y2Nlc3NmdWxseSBtb3VudGVkIG5hdGl2ZSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofSB3aXRoICR7YWN0dWFsUGVybWlzc2lvbn0gcGVybWlzc2lvbmApO1xuXG4gICAgICAvLyBDcmVhdGUgYSBoYW5kbGUgd2l0aCBzeW5jZnMgbWV0aG9kIGFuZCBwZXJtaXNzaW9uIHJlY292ZXJ5XG4gICAgICBjb25zdCBmc0hhbmRsZSA9IHtcbiAgICAgICAgc3luY2ZzOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZmlsZXN5c3RlbSBpcyByZWFkLW9ubHlcbiAgICAgICAgICBpZiAoYWN0dWFsUGVybWlzc2lvbiA9PT0gJ3JlYWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzeW5jIHJlYWQtb25seSBmaWxlc3lzdGVtIGF0ICR7bW91bnRQYXRofS4gVXNlIHVwZ3JhZGVGaWxlc3lzdGVtUGVybWlzc2lvbigpIHRvIHJlcXVlc3Qgd3JpdGUgYWNjZXNzLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgbmF0aXZlZnMuc3luY2ZzKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gU3luY2VkIGNoYW5nZXMgdG8gbmF0aXZlIGZpbGVzeXN0ZW0gYXQgJHttb3VudFBhdGh9YCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHN5bmMgZmlsZXN5c3RlbTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkaXJIYW5kbGU6IGhhbmRsZSxcbiAgICAgICAgcGVybWlzc2lvbjogYWN0dWFsUGVybWlzc2lvbixcbiAgICAgICAgbmF0aXZlZnM6IG5hdGl2ZWZzXG4gICAgICB9O1xuXG4gICAgICAvLyBTdG9yZSB0aGUgaGFuZGxlIGZvciBhdXRvLXN5bmNcbiAgICAgIHRoaXMubmF0aXZlRnNIYW5kbGVzLnNldChtb3VudFBhdGgsIGZzSGFuZGxlKTtcblxuICAgICAgcmV0dXJuIHsgc3luY2ZzOiBmc0hhbmRsZS5zeW5jZnMgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbW91bnQgbmF0aXZlIGZpbGVzeXN0ZW06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jIGFsbCBtb3VudGVkIG5hdGl2ZSBmaWxlc3lzdGVtcyB3aXRoIHBlcm1pc3Npb24gcmVjb3ZlcnlcbiAgICogT25seSBzeW5jcyBmaWxlc3lzdGVtcyBtb3VudGVkIHdpdGggJ3JlYWR3cml0ZScgcGVybWlzc2lvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzeW5jQWxsTmF0aXZlRnMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMubmF0aXZlRnNIYW5kbGVzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzeW5jUmVzdWx0czogQXJyYXk8eyBtb3VudFBhdGg6IHN0cmluZzsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmc7IHNraXBwZWQ/OiBib29sZWFuIH0+ID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFttb3VudFBhdGgsIGZzSGFuZGxlXSBvZiB0aGlzLm5hdGl2ZUZzSGFuZGxlcy5lbnRyaWVzKCkpIHtcbiAgICAgIC8vIFNraXAgcmVhZC1vbmx5IGZpbGVzeXN0ZW1zXG4gICAgICBpZiAoZnNIYW5kbGUucGVybWlzc2lvbiA9PT0gJ3JlYWQnKSB7XG4gICAgICAgIHN5bmNSZXN1bHRzLnB1c2goeyBtb3VudFBhdGgsIHN1Y2Nlc3M6IHRydWUsIHNraXBwZWQ6IHRydWUgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTa2lwcGluZyBzeW5jIGZvciByZWFkLW9ubHkgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcnN0LCB0cnkgdG8gc3luYyBkaXJlY3RseVxuICAgICAgICBhd2FpdCBmc0hhbmRsZS5zeW5jZnMoKTtcbiAgICAgICAgc3luY1Jlc3VsdHMucHVzaCh7IG1vdW50UGF0aCwgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIFN1Y2Nlc3NmdWxseSBzeW5jZWQgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH1gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIHN5bmMgZmFpbHMsIGNoZWNrIGlmIGl0J3MgYSBwZXJtaXNzaW9uIGVycm9yXG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ25vdCBhbGxvd2VkIGJ5IHRoZSB1c2VyIGFnZW50JykgfHwgXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2dldEZpbGVIYW5kbGUnKSB8fFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdwZXJtaXNzaW9uJykpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFtLRVJORUxdIFBlcm1pc3Npb24gZXJyb3Igc3luY2luZyAke21vdW50UGF0aH0sIGF0dGVtcHRpbmcgcmVjb3ZlcnkuLi5gKTtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHJlY292ZXIgYnkgcmUtdmVyaWZ5aW5nIHBlcm1pc3Npb25zXG4gICAgICAgICAgICBjb25zdCBoYXNQZXJtaXNzaW9uID0gYXdhaXQgdGhpcy52ZXJpZnlQZXJtaXNzaW9uKGZzSGFuZGxlLmRpckhhbmRsZSwgZnNIYW5kbGUucGVybWlzc2lvbik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChoYXNQZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgIC8vIFRyeSB0byByZW1vdW50IGFuZCBzeW5jXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBQZXJtaXNzaW9uIHJlY292ZXJlZCBmb3IgJHttb3VudFBhdGh9LCBhdHRlbXB0aW5nIHJlbW91bnQuLi5gKTtcbiAgICAgICAgICAgICAgY29uc3QgbmV3TmF0aXZlZnMgPSBhd2FpdCB0aGlzLnB5b2RpZGUubW91bnROYXRpdmVGUyhtb3VudFBhdGgsIGZzSGFuZGxlLmRpckhhbmRsZSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHN0b3JlZCBoYW5kbGUgd2l0aCB0aGUgbmV3IG5hdGl2ZWZzXG4gICAgICAgICAgICAgIGZzSGFuZGxlLm5hdGl2ZWZzID0gbmV3TmF0aXZlZnM7XG4gICAgICAgICAgICAgIGZzSGFuZGxlLnN5bmNmcyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3TmF0aXZlZnMuc3luY2ZzKCk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gU3luY2VkIGNoYW5nZXMgdG8gbmF0aXZlIGZpbGVzeXN0ZW0gYXQgJHttb3VudFBhdGh9YCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoc3luY0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzeW5jIGZpbGVzeXN0ZW06ICR7c3luY0Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBzeW5jRXJyb3IubWVzc2FnZSA6IFN0cmluZyhzeW5jRXJyb3IpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFRyeSBzeW5jIGFnYWluIHdpdGggdGhlIG5ldyBoYW5kbGVcbiAgICAgICAgICAgICAgYXdhaXQgZnNIYW5kbGUuc3luY2ZzKCk7XG4gICAgICAgICAgICAgIHN5bmNSZXN1bHRzLnB1c2goeyBtb3VudFBhdGgsIHN1Y2Nlc3M6IHRydWUgfSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTdWNjZXNzZnVsbHkgcmVjb3ZlcmVkIGFuZCBzeW5jZWQgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH1gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN5bmNSZXN1bHRzLnB1c2goeyBcbiAgICAgICAgICAgICAgICBtb3VudFBhdGgsIFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgICAgICAgICAgICBlcnJvcjogJ1Blcm1pc3Npb24gZGVuaWVkIGJ5IHVzZXInIFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbS0VSTkVMXSBVc2VyIGRlbmllZCBwZXJtaXNzaW9uIGZvciAke21vdW50UGF0aH0sIHNraXBwaW5nIHN5bmNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChyZWNvdmVyeUVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCByZWNvdmVyeU1lc3NhZ2UgPSByZWNvdmVyeUVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyByZWNvdmVyeUVycm9yLm1lc3NhZ2UgOiBTdHJpbmcocmVjb3ZlcnlFcnJvcik7XG4gICAgICAgICAgICBzeW5jUmVzdWx0cy5wdXNoKHsgXG4gICAgICAgICAgICAgIG1vdW50UGF0aCwgXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgICAgICAgICAgZXJyb3I6IGBSZWNvdmVyeSBmYWlsZWQ6ICR7cmVjb3ZlcnlNZXNzYWdlfWAgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtLRVJORUxdIEZhaWxlZCB0byByZWNvdmVyIHBlcm1pc3Npb25zIGZvciAke21vdW50UGF0aH06YCwgcmVjb3ZlcnlFcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vbi1wZXJtaXNzaW9uIGVycm9yXG4gICAgICAgICAgc3luY1Jlc3VsdHMucHVzaCh7IFxuICAgICAgICAgICAgbW91bnRQYXRoLCBcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UgXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgW0tFUk5FTF0gTm9uLXBlcm1pc3Npb24gZXJyb3Igc3luY2luZyAke21vdW50UGF0aH06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTG9nIHN1bW1hcnlcbiAgICBjb25zdCBzdWNjZXNzZnVsID0gc3luY1Jlc3VsdHMuZmlsdGVyKHIgPT4gci5zdWNjZXNzICYmICFyLnNraXBwZWQpLmxlbmd0aDtcbiAgICBjb25zdCBza2lwcGVkID0gc3luY1Jlc3VsdHMuZmlsdGVyKHIgPT4gci5za2lwcGVkKS5sZW5ndGg7XG4gICAgY29uc3QgZmFpbGVkID0gc3luY1Jlc3VsdHMuZmlsdGVyKHIgPT4gIXIuc3VjY2Vzcyk7XG4gICAgXG4gICAgaWYgKHN1Y2Nlc3NmdWwgPiAwIHx8IHNraXBwZWQgPiAwKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgaWYgKHN1Y2Nlc3NmdWwgPiAwKSBwYXJ0cy5wdXNoKGAke3N1Y2Nlc3NmdWx9IHN5bmNlZGApO1xuICAgICAgaWYgKHNraXBwZWQgPiAwKSBwYXJ0cy5wdXNoKGAke3NraXBwZWR9IHJlYWQtb25seSBza2lwcGVkYCk7XG4gICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gQXV0by1zeW5jIGNvbXBsZXRlZDogJHtwYXJ0cy5qb2luKCcsICcpfSAoJHtzeW5jUmVzdWx0cy5sZW5ndGh9IHRvdGFsIGZpbGVzeXN0ZW1zKWApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZmFpbGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihgW0tFUk5FTF0gQXV0by1zeW5jIGlzc3VlczpgLCBmYWlsZWQubWFwKGYgPT4gYCR7Zi5tb3VudFBhdGh9OiAke2YuZXJyb3J9YCkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBEb24ndCB0aHJvdyAtIHdlIGRvbid0IHdhbnQgdG8gZmFpbCBleGVjdXRpb24ganVzdCBiZWNhdXNlIHN5bmMgZmFpbGVkXG4gIH1cblxuICAvKipcbiAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IG1vdW50ZWQgbmF0aXZlIGZpbGVzeXN0ZW1zIGFuZCB0aGVpciBwZXJtaXNzaW9uIHN0YXR1c1xuICAgKiBAcmV0dXJucyBBcnJheSBvZiBtb3VudGVkIGZpbGVzeXN0ZW0gaW5mb3JtYXRpb25cbiAgICovXG4gIHB1YmxpYyBnZXRNb3VudGVkRmlsZXN5c3RlbXMoKTogQXJyYXk8e1xuICAgIG1vdW50UGF0aDogc3RyaW5nO1xuICAgIHBlcm1pc3Npb246ICdyZWFkJyB8ICdyZWFkd3JpdGUnO1xuICAgIGNhblN5bmM6IGJvb2xlYW47XG4gIH0+IHtcbiAgICBjb25zdCByZXN1bHQ6IEFycmF5PHtcbiAgICAgIG1vdW50UGF0aDogc3RyaW5nO1xuICAgICAgcGVybWlzc2lvbjogJ3JlYWQnIHwgJ3JlYWR3cml0ZSc7XG4gICAgICBjYW5TeW5jOiBib29sZWFuO1xuICAgIH0+ID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFttb3VudFBhdGgsIGZzSGFuZGxlXSBvZiB0aGlzLm5hdGl2ZUZzSGFuZGxlcy5lbnRyaWVzKCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgbW91bnRQYXRoLFxuICAgICAgICBwZXJtaXNzaW9uOiBmc0hhbmRsZS5wZXJtaXNzaW9uLFxuICAgICAgICBjYW5TeW5jOiBmc0hhbmRsZS5wZXJtaXNzaW9uID09PSAncmVhZHdyaXRlJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYW51YWxseSBzeW5jIGEgc3BlY2lmaWMgbW91bnRlZCBmaWxlc3lzdGVtXG4gICAqIEBwYXJhbSBtb3VudFBhdGggVGhlIHBhdGggb2YgdGhlIG1vdW50ZWQgZmlsZXN5c3RlbSB0byBzeW5jXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHN1Y2Nlc3Mgc3RhdHVzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3luY0ZpbGVzeXN0ZW0obW91bnRQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICAgIGNvbnN0IGZzSGFuZGxlID0gdGhpcy5uYXRpdmVGc0hhbmRsZXMuZ2V0KG1vdW50UGF0aCk7XG4gICAgXG4gICAgaWYgKCFmc0hhbmRsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBgTm8gZmlsZXN5c3RlbSBtb3VudGVkIGF0ICR7bW91bnRQYXRofWBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgZmlsZXN5c3RlbSBpcyByZWFkLW9ubHlcbiAgICBpZiAoZnNIYW5kbGUucGVybWlzc2lvbiA9PT0gJ3JlYWQnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBDYW5ub3Qgc3luYyByZWFkLW9ubHkgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH0uIE1vdW50IHdpdGggJ3JlYWR3cml0ZScgcGVybWlzc2lvbiB0byBlbmFibGUgc3luY2luZy5gXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBmc0hhbmRsZS5zeW5jZnMoKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBUcnkgcGVybWlzc2lvbiByZWNvdmVyeSBpZiBpdCdzIGEgcGVybWlzc2lvbiBlcnJvclxuICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnbm90IGFsbG93ZWQgYnkgdGhlIHVzZXIgYWdlbnQnKSB8fCBcbiAgICAgICAgICBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2dldEZpbGVIYW5kbGUnKSB8fFxuICAgICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcygncGVybWlzc2lvbicpKSB7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gUGVybWlzc2lvbiBlcnJvciBzeW5jaW5nICR7bW91bnRQYXRofSwgYXR0ZW1wdGluZyByZWNvdmVyeS4uLmApO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBoYXNQZXJtaXNzaW9uID0gYXdhaXQgdGhpcy52ZXJpZnlQZXJtaXNzaW9uKGZzSGFuZGxlLmRpckhhbmRsZSwgZnNIYW5kbGUucGVybWlzc2lvbik7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGhhc1Blcm1pc3Npb24pIHtcbiAgICAgICAgICAgIC8vIFJlbW91bnQgYW5kIHRyeSBhZ2FpblxuICAgICAgICAgICAgY29uc3QgbmV3TmF0aXZlZnMgPSBhd2FpdCB0aGlzLnB5b2RpZGUubW91bnROYXRpdmVGUyhtb3VudFBhdGgsIGZzSGFuZGxlLmRpckhhbmRsZSk7XG4gICAgICAgICAgICBmc0hhbmRsZS5uYXRpdmVmcyA9IG5ld05hdGl2ZWZzO1xuICAgICAgICAgICAgZnNIYW5kbGUuc3luY2ZzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ld05hdGl2ZWZzLnN5bmNmcygpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTeW5jZWQgY2hhbmdlcyB0byBuYXRpdmUgZmlsZXN5c3RlbSBhdCAke21vdW50UGF0aH1gKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoc3luY0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3luYyBmaWxlc3lzdGVtOiAke3N5bmNFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gc3luY0Vycm9yLm1lc3NhZ2UgOiBTdHJpbmcoc3luY0Vycm9yKX1gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYXdhaXQgZnNIYW5kbGUuc3luY2ZzKCk7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogJ1Blcm1pc3Npb24gZGVuaWVkIGJ5IHVzZXInXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAocmVjb3ZlcnlFcnJvcikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBgUmVjb3ZlcnkgZmFpbGVkOiAke3JlY292ZXJ5RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHJlY292ZXJ5RXJyb3IubWVzc2FnZSA6IFN0cmluZyhyZWNvdmVyeUVycm9yKX1gXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZSBhIG1vdW50ZWQgZmlsZXN5c3RlbSBmcm9tIHJlYWQtb25seSB0byByZWFkLXdyaXRlIHBlcm1pc3Npb25cbiAgICogQHBhcmFtIG1vdW50UGF0aCBUaGUgcGF0aCBvZiB0aGUgbW91bnRlZCBmaWxlc3lzdGVtIHRvIHVwZ3JhZGVcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gc3VjY2VzcyBzdGF0dXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyB1cGdyYWRlRmlsZXN5c3RlbVBlcm1pc3Npb24obW91bnRQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICAgIGNvbnN0IGZzSGFuZGxlID0gdGhpcy5uYXRpdmVGc0hhbmRsZXMuZ2V0KG1vdW50UGF0aCk7XG4gICAgXG4gICAgaWYgKCFmc0hhbmRsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBgTm8gZmlsZXN5c3RlbSBtb3VudGVkIGF0ICR7bW91bnRQYXRofWBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGZzSGFuZGxlLnBlcm1pc3Npb24gPT09ICdyZWFkd3JpdGUnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBlcnJvcjogYEZpbGVzeXN0ZW0gYXQgJHttb3VudFBhdGh9IGFscmVhZHkgaGFzIHJlYWR3cml0ZSBwZXJtaXNzaW9uYFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYFtLRVJORUxdIEF0dGVtcHRpbmcgdG8gdXBncmFkZSAke21vdW50UGF0aH0gdG8gcmVhZHdyaXRlIHBlcm1pc3Npb24uLi5gKTtcbiAgICAgIFxuICAgICAgLy8gVHJ5IHRvIGdldCByZWFkd3JpdGUgcGVybWlzc2lvblxuICAgICAgY29uc3QgaGFzV3JpdGVQZXJtaXNzaW9uID0gYXdhaXQgdGhpcy52ZXJpZnlQZXJtaXNzaW9uKGZzSGFuZGxlLmRpckhhbmRsZSwgJ3JlYWR3cml0ZScpO1xuICAgICAgXG4gICAgICBpZiAoIWhhc1dyaXRlUGVybWlzc2lvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiAnVXNlciBkZW5pZWQgd3JpdGUgcGVybWlzc2lvbiBvciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgd3JpdGUgYWNjZXNzIHRvIHRoaXMgZGlyZWN0b3J5J1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdW50IHdpdGggd3JpdGUgcGVybWlzc2lvblxuICAgICAgY29uc3QgbmV3TmF0aXZlZnMgPSBhd2FpdCB0aGlzLnB5b2RpZGUubW91bnROYXRpdmVGUyhtb3VudFBhdGgsIGZzSGFuZGxlLmRpckhhbmRsZSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0aGUgc3RvcmVkIGhhbmRsZVxuICAgICAgZnNIYW5kbGUucGVybWlzc2lvbiA9ICdyZWFkd3JpdGUnO1xuICAgICAgZnNIYW5kbGUubmF0aXZlZnMgPSBuZXdOYXRpdmVmcztcbiAgICAgIGZzSGFuZGxlLnN5bmNmcyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBuZXdOYXRpdmVmcy5zeW5jZnMoKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0tFUk5FTF0gU3luY2VkIGNoYW5nZXMgdG8gbmF0aXZlIGZpbGVzeXN0ZW0gYXQgJHttb3VudFBhdGh9YCk7XG4gICAgICAgIH0gY2F0Y2ggKHN5bmNFcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHN5bmMgZmlsZXN5c3RlbTogJHtzeW5jRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHN5bmNFcnJvci5tZXNzYWdlIDogU3RyaW5nKHN5bmNFcnJvcil9YCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnNvbGUubG9nKGBbS0VSTkVMXSBTdWNjZXNzZnVsbHkgdXBncmFkZWQgJHttb3VudFBhdGh9IHRvIHJlYWR3cml0ZSBwZXJtaXNzaW9uYCk7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIHVwZ3JhZGUgcGVybWlzc2lvbjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IGVudmlyb25tZW50IHZhcmlhYmxlcyB3aXRoIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvblxuICAgKiBPUFRJTUlaRUQ6IFBhcmFsbGVsIHZhcmlhYmxlIHNldHRpbmcgYW5kIHZhbGlkYXRpb24gd2l0aCBwcm9wZXIgZXNjYXBpbmcgYW5kIGVkZ2UgY2FzZSBoYW5kbGluZ1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5lbnZpcm9ubWVudFZhcmlhYmxlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIE5vIHZhcmlhYmxlcyB0byBzZXRcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zb2xlLmxvZyhg8J+MjSBTZXR0aW5nICR7T2JqZWN0LmtleXModGhpcy5lbnZpcm9ubWVudFZhcmlhYmxlcykubGVuZ3RofSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuLi5gKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gU2V0IGVhY2ggZW52aXJvbm1lbnQgdmFyaWFibGUgaW5kaXZpZHVhbGx5IHRvIGF2b2lkIGVzY2FwaW5nIGlzc3Vlc1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5lbnZpcm9ubWVudFZhcmlhYmxlcykpIHtcbiAgICAgICAgLy8gSGFuZGxlIGVkZ2UgY2FzZXM6IG51bGwsIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBsZXQgcHJvY2Vzc2VkVmFsdWU6IHN0cmluZztcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcHJvY2Vzc2VkVmFsdWUgPSAnJzsgIC8vIENvbnZlcnQgbnVsbCB0byBlbXB0eSBzdHJpbmdcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvY2Vzc2VkVmFsdWUgPSAnJzsgIC8vIENvbnZlcnQgdW5kZWZpbmVkIHRvIGVtcHR5IHN0cmluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3NlZFZhbHVlID0gU3RyaW5nKHZhbHVlKTsgIC8vIENvbnZlcnQgZXZlcnl0aGluZyBlbHNlIHRvIHN0cmluZ1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYFxuaW1wb3J0IG9zXG5vcy5lbnZpcm9uWyR7SlNPTi5zdHJpbmdpZnkoa2V5KX1dID0gJHtKU09OLnN0cmluZ2lmeShwcm9jZXNzZWRWYWx1ZSl9XG5gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYOKaoSBFbnZpcm9ubWVudCB2YXJpYWJsZXMgc2V0IGluICR7ZHVyYXRpb259bXNgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBGYWlsZWQgdG8gc2V0IGVudmlyb25tZW50IHZhcmlhYmxlczpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5cbi8vIE9ubHkgUHl0aG9uIGtlcm5lbCBpcyBzdXBwb3J0ZWRcblxuLy8gRXhwb3J0IHRoZSBtYW5hZ2VyIGZvciBhZHZhbmNlZCB1c2FnZVxuZXhwb3J0IHsgS2VybmVsTWFuYWdlciB9IGZyb20gXCIuL21hbmFnZXJcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.ts\n\n}");

/***/ }),

/***/ "./src/manager.ts":
/*!************************!*\
  !*** ./src/manager.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KernelLanguage: () => (/* binding */ KernelLanguage),\n/* harmony export */   KernelManager: () => (/* binding */ KernelManager),\n/* harmony export */   KernelMode: () => (/* binding */ KernelMode)\n/* harmony export */ });\n/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! comlink */ \"./node_modules/comlink/dist/esm/comlink.mjs\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ \"./src/index.ts\");\n// Kernel Manager for Deno App Engine\n// This file manages kernel instances in either main thread or worker mode\n\n// @ts-ignore Importing from npm\n// Use a browser-compatible EventEmitter\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, listener) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(listener);\n    }\n    off(eventName, listener) {\n        if (!this.events[eventName])\n            return;\n        const index = this.events[eventName].indexOf(listener);\n        if (index > -1) {\n            this.events[eventName].splice(index, 1);\n        }\n    }\n    removeListener(eventName, listener) {\n        this.off(eventName, listener);\n    }\n    emit(eventName, ...args) {\n        if (!this.events[eventName])\n            return;\n        this.events[eventName].forEach(listener => listener(...args));\n    }\n    setMaxListeners(n) {\n        // No-op for browser compatibility\n    }\n}\n\n\n// Re-export KernelEvents for test usage\n\n// Execution mode enum\nvar KernelMode;\n(function (KernelMode) {\n    KernelMode[\"MAIN_THREAD\"] = \"main_thread\";\n    KernelMode[\"WORKER\"] = \"worker\";\n})(KernelMode || (KernelMode = {}));\n// Kernel language enum\nvar KernelLanguage;\n(function (KernelLanguage) {\n    KernelLanguage[\"PYTHON\"] = \"python\";\n})(KernelLanguage || (KernelLanguage = {}));\n/**\n * KernelManager class manages multiple kernel instances\n * in either main thread or worker mode\n */\nclass KernelManager extends EventEmitter {\n    /**\n     * Resolve the worker URL based on the current environment\n     * @private\n     * @returns The resolved worker URL\n     */\n    resolveWorkerUrl() {\n        // If a custom worker URL is provided, use it\n        if (this.workerUrl) {\n            return this.workerUrl;\n        }\n        // Try to detect the current script location and derive the worker URL\n        if (typeof window !== 'undefined' && window.location) {\n            // Browser environment\n            const currentScript = document.currentScript ||\n                Array.from(document.getElementsByTagName('script')).pop();\n            if (currentScript && currentScript.src) {\n                // Get the base URL from the current script\n                const scriptUrl = new URL(currentScript.src);\n                const baseUrl = scriptUrl.href.substring(0, scriptUrl.href.lastIndexOf('/'));\n                // Check if we're loading from a CDN (jsdelivr, unpkg, etc.)\n                if (scriptUrl.hostname.includes('jsdelivr.net') ||\n                    scriptUrl.hostname.includes('unpkg.com') ||\n                    scriptUrl.hostname.includes('cdnjs.cloudflare.com')) {\n                    // For CDN, the worker should be at the same path\n                    return `${baseUrl}/kernel.worker.js`;\n                }\n                // For local development or custom deployments\n                return `${baseUrl}/kernel.worker.js`;\n            }\n            // Fallback to relative path from current location\n            const baseUrl = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));\n            return `${baseUrl}/dist/kernel.worker.js`;\n        }\n        // Node.js or unknown environment - use relative path\n        // This may not work in Node.js but is provided as a fallback\n        return './kernel.worker.js';\n    }\n    /**\n     * Helper function to check if an error is a KeyboardInterrupt\n     * @private\n     */\n    isKeyboardInterrupt(error) {\n        return error &&\n            typeof error === 'object' &&\n            (('type' in error && error.type === \"KeyboardInterrupt\") ||\n                ('message' in error && typeof error.message === 'string' && error.message.includes(\"KeyboardInterrupt\")));\n    }\n    /**\n     * Helper function to create a standardized KeyboardInterrupt error result\n     * @private\n     */\n    createKeyboardInterruptResult() {\n        return {\n            success: false,\n            error: new Error(\"KeyboardInterrupt: Execution interrupted by user\"),\n            result: {\n                status: \"error\",\n                ename: \"KeyboardInterrupt\",\n                evalue: \"Execution interrupted by user\",\n                traceback: [\"KeyboardInterrupt: Execution interrupted by user\"]\n            }\n        };\n    }\n    /**\n     * Store an AbortController for a specific kernel execution\n     * @private\n     */\n    storeAbortController(kernelId, executionId, controller) {\n        if (!this.abortControllers.has(kernelId)) {\n            this.abortControllers.set(kernelId, new Map());\n        }\n        this.abortControllers.get(kernelId).set(executionId, controller);\n    }\n    /**\n     * Remove and return an AbortController for a specific kernel execution\n     * @private\n     */\n    removeAbortController(kernelId, executionId) {\n        const kernelControllers = this.abortControllers.get(kernelId);\n        if (!kernelControllers)\n            return undefined;\n        const controller = kernelControllers.get(executionId);\n        if (controller) {\n            kernelControllers.delete(executionId);\n            if (kernelControllers.size === 0) {\n                this.abortControllers.delete(kernelId);\n            }\n        }\n        return controller;\n    }\n    /**\n     * Abort all ongoing operations for a specific kernel\n     * @private\n     */\n    abortAllKernelOperations(kernelId) {\n        const kernelControllers = this.abortControllers.get(kernelId);\n        if (!kernelControllers)\n            return;\n        for (const [executionId, controller] of kernelControllers) {\n            try {\n                controller.abort();\n                console.log(`ðŸš« Aborted execution ${executionId} for kernel ${kernelId}`);\n            }\n            catch (error) {\n                console.warn(`âš ï¸ Error aborting execution ${executionId}:`, error);\n            }\n        }\n        // Clear all controllers for this kernel\n        this.abortControllers.delete(kernelId);\n    }\n    constructor(options = {}) {\n        super();\n        this.kernels = new Map();\n        // Track listeners for each kernel to enable individual removal\n        this.listenerWrappers = new Map();\n        // Track last activity time for each kernel\n        this.lastActivityTime = new Map();\n        // Store inactivity timers for each kernel\n        this.inactivityTimers = new Map();\n        // Track ongoing executions for each kernel\n        this.ongoingExecutions = new Map();\n        // Track execution timeouts for detecting stuck/dead kernels\n        this.executionTimeouts = new Map();\n        // Track execution start times for accurate duration calculation\n        this.executionStartTimes = new Map();\n        // Track execution metadata for better monitoring\n        this.executionMetadata = new Map();\n        // Track AbortControllers for each kernel's ongoing operations\n        this.abortControllers = new Map();\n        // Pool management - now using promises for immediate response\n        this.pool = new Map();\n        this.isPreloading = false;\n        // Track which pool keys are currently being prefilled to prevent duplicates\n        this.prefillingInProgress = new Map();\n        // Interrupt buffers for worker kernels (using SharedArrayBuffer)\n        this.interruptBuffers = new Map();\n        super.setMaxListeners(100); // Allow many listeners for kernel events\n        // Set interruption mode (default to 'auto')\n        this.interruptionMode = options.interruptionMode || 'auto';\n        // Set worker URL if provided\n        this.workerUrl = options.workerUrl;\n        // Set default allowed kernel types (worker mode only for security)\n        this.allowedKernelTypes = options.allowedKernelTypes || [\n            { mode: KernelMode.WORKER, language: KernelLanguage.PYTHON }\n        ];\n        // Initialize pool configuration with defaults based on allowed types\n        const defaultPreloadConfigs = this.allowedKernelTypes.filter(type => type.language === KernelLanguage.PYTHON // Only preload Python kernels by default\n        );\n        this.poolConfig = {\n            enabled: false,\n            poolSize: 2,\n            autoRefill: true,\n            preloadConfigs: defaultPreloadConfigs,\n            ...options.pool\n        };\n        // Validate that pool preload configs are within allowed types\n        if (this.poolConfig.preloadConfigs) {\n            this.poolConfig.preloadConfigs = this.poolConfig.preloadConfigs.filter(config => {\n                const isAllowed = this.isKernelTypeAllowed(config.mode, config.language);\n                if (!isAllowed) {\n                    console.warn(`Pool preload config ${config.mode}-${config.language} is not in allowedKernelTypes, skipping`);\n                }\n                return isAllowed;\n            });\n        }\n        // Start preloading if pool is enabled\n        if (this.poolConfig.enabled) {\n            this.preloadPool().catch(error => {\n                console.error(\"Error preloading kernel pool:\", error);\n            });\n        }\n    }\n    /**\n     * Generate a pool key for a given mode and language combination\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Pool key string\n     * @private\n     */\n    getPoolKey(mode, language) {\n        return `${mode}-${language}`;\n    }\n    /**\n     * Get a kernel promise from the pool if available\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Kernel promise or null if none available\n     * @private\n     */\n    getFromPool(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return null;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        const poolPromises = this.pool.get(poolKey);\n        if (!poolPromises || poolPromises.length === 0) {\n            return null;\n        }\n        // Remove and return the first promise from the pool (FIFO)\n        const kernelPromise = poolPromises.shift();\n        // Immediately trigger background refill to add one promise back\n        if (this.poolConfig.autoRefill) {\n            setTimeout(() => {\n                this.refillPoolSingle(mode, language).catch(error => {\n                    console.error(`Error refilling single kernel for ${poolKey}:`, error);\n                });\n            }, 0);\n        }\n        return kernelPromise;\n    }\n    /**\n     * Add a kernel promise to the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @param kernelPromise Kernel promise\n     * @private\n     */\n    addToPool(mode, language, kernelPromise) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        if (!this.pool.has(poolKey)) {\n            this.pool.set(poolKey, []);\n        }\n        const poolPromises = this.pool.get(poolKey);\n        // Only add if we haven't reached the pool size limit\n        if (poolPromises.length < this.poolConfig.poolSize) {\n            poolPromises.push(kernelPromise);\n            // Handle promise rejection to prevent unhandled rejections\n            kernelPromise.catch(error => {\n                console.error(`Pool kernel promise rejected for ${poolKey}:`, error);\n                // Remove the failed promise from the pool\n                const index = poolPromises.indexOf(kernelPromise);\n                if (index !== -1) {\n                    poolPromises.splice(index, 1);\n                }\n            });\n        }\n        else {\n            // Pool is full, let the excess promise resolve and then destroy the kernel\n            kernelPromise.then(kernel => {\n                kernel.destroy().catch(error => {\n                    console.error(\"Error destroying excess pool kernel:\", error);\n                });\n            }).catch(error => {\n                console.error(\"Excess pool kernel promise rejected:\", error);\n            });\n        }\n    }\n    /**\n     * Refill the pool with a single kernel promise\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @private\n     */\n    async refillPoolSingle(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        const poolPromises = this.pool.get(poolKey) || [];\n        // Only add one if we're below the pool size\n        if (poolPromises.length < this.poolConfig.poolSize) {\n            const kernelPromise = this.createPoolKernelPromise(mode, language);\n            this.addToPool(mode, language, kernelPromise);\n        }\n    }\n    /**\n     * Refill the pool for a specific configuration with parallel creation\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @private\n     */\n    async refillPool(mode, language) {\n        if (!this.poolConfig.enabled) {\n            return;\n        }\n        const poolKey = this.getPoolKey(mode, language);\n        // Check if already prefilling this pool key to prevent duplicates\n        if (this.prefillingInProgress.get(poolKey)) {\n            return;\n        }\n        // Set prefilling flag\n        this.prefillingInProgress.set(poolKey, true);\n        try {\n            const poolPromises = this.pool.get(poolKey) || [];\n            const needed = this.poolConfig.poolSize - poolPromises.length;\n            if (needed <= 0) {\n                return;\n            }\n            // Create all needed kernel promises in parallel\n            const newPromises = Array.from({ length: needed }, () => this.createPoolKernelPromise(mode, language));\n            // Add all promises to the pool\n            for (const kernelPromise of newPromises) {\n                this.addToPool(mode, language, kernelPromise);\n            }\n        }\n        catch (error) {\n            console.error(`Error refilling pool for ${poolKey}:`, error);\n        }\n        finally {\n            // Always clear the prefilling flag\n            this.prefillingInProgress.set(poolKey, false);\n        }\n    }\n    /**\n     * Create a kernel promise for the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Promise that resolves to a kernel instance\n     * @private\n     */\n    createPoolKernelPromise(mode, language) {\n        return new Promise(async (resolve, reject) => {\n            try {\n                const kernel = await this.createPoolKernel(mode, language);\n                // Mark as taken from pool\n                kernel.isFromPool = true;\n                resolve(kernel);\n            }\n            catch (error) {\n                console.error(`Error creating pool kernel for ${mode}-${language}:`, error);\n                reject(error);\n            }\n        });\n    }\n    /**\n     * Create a kernel specifically for the pool\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns Kernel instance\n     * @private\n     */\n    async createPoolKernel(mode, language) {\n        // Generate a temporary ID for the pool kernel\n        const tempId = `pool-${crypto.randomUUID()}`;\n        // Create kernel with minimal configuration\n        const options = {\n            mode,\n            lang: language\n        };\n        // Store options temporarily - but don't store incomplete instance in kernels map\n        // Instead, we'll pass the options directly to the creation methods\n        let instance;\n        try {\n            if (mode === KernelMode.MAIN_THREAD) {\n                // For main thread, we need to temporarily store the instance for createMainThreadKernel\n                const tempInstance = {\n                    id: tempId,\n                    options,\n                    mode,\n                    language\n                };\n                this.kernels.set(tempId, tempInstance);\n                try {\n                    instance = await this.createMainThreadKernel(tempId);\n                }\n                finally {\n                    // Always clean up the temporary instance\n                    this.kernels.delete(tempId);\n                }\n            }\n            else {\n                // For worker mode, we need to temporarily store the instance for createWorkerKernel\n                const tempInstance = {\n                    id: tempId,\n                    options,\n                    mode,\n                    language\n                };\n                this.kernels.set(tempId, tempInstance);\n                try {\n                    instance = await this.createWorkerKernel(tempId);\n                }\n                finally {\n                    // Always clean up the temporary instance\n                    this.kernels.delete(tempId);\n                }\n            }\n        }\n        catch (error) {\n            // Ensure cleanup on any error\n            this.kernels.delete(tempId);\n            throw error;\n        }\n        return instance;\n    }\n    /**\n     * Preload the kernel pool with configured kernel types\n     * @private\n     */\n    async preloadPool() {\n        if (!this.poolConfig.enabled || this.isPreloading) {\n            return;\n        }\n        this.isPreloading = true;\n        try {\n            // Preload kernels for each configured type\n            for (const config of this.poolConfig.preloadConfigs) {\n                try {\n                    await this.refillPool(config.mode, config.language);\n                }\n                catch (error) {\n                    console.error(`Error preloading ${config.mode}-${config.language}:`, error);\n                    // Continue with other configurations\n                }\n            }\n        }\n        catch (error) {\n            console.error(\"Error during kernel pool preloading:\", error);\n        }\n        finally {\n            this.isPreloading = false;\n        }\n    }\n    /**\n     * Check if a kernel request can use the pool\n     * @param options Kernel creation options\n     * @returns True if the request can use pool\n     * @private\n     */\n    canUsePool(options) {\n        // Don't use pool if it's disabled\n        if (!this.poolConfig.enabled) {\n            return false;\n        }\n        // Don't use pool if custom filesystem or permissions are specified\n        if (options.filesystem || options.deno?.permissions) {\n            return false;\n        }\n        // Don't use pool if custom timeouts are specified\n        if (options.inactivityTimeout !== undefined || options.maxExecutionTime !== undefined) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Reassign a pool kernel with new ID and options\n     * @param poolKernel Kernel from pool\n     * @param newId New kernel ID\n     * @param options Kernel options\n     * @returns Updated kernel instance\n     * @private\n     */\n    reassignPoolKernel(poolKernel, newId, options) {\n        // Create a new instance object explicitly to avoid spread operator issues\n        const updatedInstance = {\n            id: newId,\n            kernel: poolKernel.kernel,\n            mode: poolKernel.mode,\n            language: poolKernel.language,\n            worker: poolKernel.worker,\n            created: new Date().toISOString(), // Update creation time\n            options: { ...poolKernel.options, ...options },\n            isFromPool: true,\n            destroy: poolKernel.destroy // Preserve the original destroy function\n        };\n        // Verify the destroy function is properly set\n        if (typeof updatedInstance.destroy !== 'function') {\n            console.error('Failed to preserve destroy function during pool kernel reassignment');\n            console.error('poolKernel.destroy type:', typeof poolKernel.destroy);\n            console.error('updatedInstance.destroy type:', typeof updatedInstance.destroy);\n            throw new Error(`Failed to preserve destroy function during pool kernel reassignment`);\n        }\n        return updatedInstance;\n    }\n    /**\n     * Get pool statistics for debugging/monitoring\n     * @returns Pool statistics\n     */\n    getPoolStats() {\n        const stats = {};\n        for (const [poolKey, promises] of this.pool.entries()) {\n            stats[poolKey] = {\n                available: promises.length,\n                total: this.poolConfig.poolSize\n            };\n        }\n        return stats;\n    }\n    /**\n     * Get pool configuration information\n     * @returns Pool configuration details\n     */\n    getPoolConfig() {\n        return {\n            enabled: this.poolConfig.enabled,\n            poolSize: this.poolConfig.poolSize,\n            autoRefill: this.poolConfig.autoRefill,\n            preloadConfigs: [...this.poolConfig.preloadConfigs], // Return a copy to prevent modification\n            isPreloading: this.isPreloading\n        };\n    }\n    /**\n     * Get the current worker URL configuration\n     * @returns The worker URL or undefined if using auto-detection\n     */\n    getWorkerUrl() {\n        return this.workerUrl;\n    }\n    /**\n     * Set a custom worker URL for kernel workers\n     * @param url The URL to the kernel.worker.js file\n     * @example\n     * // For CDN usage:\n     * manager.setWorkerUrl('https://cdn.jsdelivr.net/npm/web-python-kernel@latest/dist/kernel.worker.js');\n     * // For local development:\n     * manager.setWorkerUrl('/dist/kernel.worker.js');\n     */\n    setWorkerUrl(url) {\n        this.workerUrl = url;\n    }\n    /**\n     * Create a new kernel instance\n     * @param options Options for creating the kernel\n     * @param options.id Optional custom ID for the kernel\n     * @param options.mode Optional kernel mode (main_thread or worker)\n     * @param options.lang Optional kernel language (python or typescript)\n     * @param options.namespace Optional namespace prefix for the kernel ID\n     * @param options.deno.permissions Optional Deno permissions for worker mode\n     * @param options.filesystem Optional filesystem mounting options\n     * @param options.inactivityTimeout Optional timeout in ms after which an inactive kernel will be shut down\n     * @param options.maxExecutionTime Optional maximum time in ms an execution can run before considered stuck\n     * @returns Promise resolving to the kernel instance ID\n     */\n    async createKernel(options = {}) {\n        // make sure the options.id does not contain colons because it will be used as a namespace prefix\n        if (options.id && options.id.includes(':')) {\n            throw new Error('Kernel ID cannot contain colons');\n        }\n        const baseId = options.id || crypto.randomUUID();\n        const mode = options.mode || KernelMode.WORKER;\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Check if the requested kernel type is allowed\n        if (!this.isKernelTypeAllowed(mode, language)) {\n            throw new Error(`Kernel type ${mode}-${language} is not allowed. Allowed types: ${this.allowedKernelTypes.map(t => `${t.mode}-${t.language}`).join(', ')}`);\n        }\n        // Apply namespace prefix if provided\n        const id = options.namespace ? `${options.namespace}:${baseId}` : baseId;\n        // Check if kernel with this ID already exists\n        if (this.kernels.has(id)) {\n            throw new Error(`Kernel with ID ${id} already exists`);\n        }\n        // Try to get from pool if possible\n        if (this.canUsePool(options)) {\n            const poolKey = this.getPoolKey(mode, language);\n            // Check if this kernel type is configured for pooling\n            const isPooledType = this.poolConfig.preloadConfigs.some(config => config.mode === mode && config.language === language);\n            if (isPooledType) {\n                // First try to get from existing pool\n                let poolKernelPromise = this.getFromPool(mode, language);\n                if (poolKernelPromise) {\n                    return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n                }\n                // Pool is empty, but this type should be pooled\n                // Create a new promise immediately and trigger background refill\n                try {\n                    // Create a new kernel promise specifically for this request\n                    const newKernelPromise = this.createPoolKernelPromise(mode, language);\n                    // Trigger background refill to replenish the pool for future requests\n                    if (this.poolConfig.autoRefill) {\n                        setTimeout(() => {\n                            this.refillPool(mode, language).catch(error => {\n                                console.error(`Error refilling exhausted pool for ${poolKey}:`, error);\n                            });\n                        }, 0);\n                    }\n                    return await this.setupPoolKernelFromPromise(newKernelPromise, id, options);\n                }\n                catch (error) {\n                    console.error(`Failed to create kernel promise for exhausted pool: ${error}`);\n                    // Fall through to on-demand creation as last resort\n                }\n            }\n            else {\n                // This kernel type is not configured for pooling, try to get from pool anyway\n                // in case there are kernels available from previous configurations\n                const poolKernelPromise = this.getFromPool(mode, language);\n                if (poolKernelPromise) {\n                    return await this.setupPoolKernelFromPromise(poolKernelPromise, id, options);\n                }\n            }\n        }\n        // Fall back to creating a new kernel on-demand\n        return this.createOnDemandKernel(id, mode, language, options);\n    }\n    /**\n     * Setup a pool kernel from a promise with new ID and options\n     * @param poolKernelPromise Kernel promise from pool\n     * @param id New kernel ID\n     * @param options Kernel options\n     * @returns Kernel ID (returned after kernel is ready)\n     * @private\n     */\n    async setupPoolKernelFromPromise(poolKernelPromise, id, options) {\n        try {\n            // Wait for the pool kernel to be ready\n            const poolKernel = await poolKernelPromise;\n            // Reassign the pool kernel with the new ID and options\n            const instance = this.reassignPoolKernel(poolKernel, id, options);\n            // For worker kernels, we need to recreate the event handler with the new ID\n            if (instance.mode === KernelMode.WORKER && instance.worker) {\n                // Get the worker and create new message channel\n                const worker = instance.worker;\n                // Create a new message channel for the reassigned kernel\n                const { port1, port2 } = new MessageChannel();\n                // Send the new event port to the worker\n                worker.postMessage({\n                    type: \"SET_EVENT_PORT\",\n                    port: port2\n                }, [port2]);\n                // Create a new event handler with the correct kernel ID\n                const eventHandler = (event) => {\n                    if (event.data && event.data.type) {\n                        // Emit the event from the manager with kernel ID\n                        // This structure matches the setupEventForwarding method for main thread kernels\n                        super.emit(event.data.type, {\n                            kernelId: id,\n                            data: event.data.data\n                        });\n                    }\n                };\n                // Listen for events from the worker with the new handler\n                port1.addEventListener('message', eventHandler);\n                port1.start();\n                // Update the destroy function to clean up the new event handler\n                const originalDestroy = instance.destroy;\n                instance.destroy = async () => {\n                    port1.removeEventListener('message', eventHandler);\n                    port1.close();\n                    return originalDestroy();\n                };\n            }\n            // Store the kernel instance\n            this.kernels.set(id, instance);\n            // Forward kernel events to manager (for main thread kernels)\n            this.setupEventForwarding(instance);\n            // Initialize activity tracking\n            this.updateKernelActivity(id);\n            // Set up inactivity timeout if specified and greater than 0\n            if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n                this.setupInactivityTimeout(id, options.inactivityTimeout);\n            }\n            // Setup handlers for stalled executions if maxExecutionTime is specified\n            if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n                this.setupStalledExecutionHandler(id);\n            }\n            return id;\n        }\n        catch (error) {\n            console.error(`Error setting up pool kernel ${id}:`, error);\n            // Emit an error event for this kernel\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: id,\n                data: {\n                    ename: \"KernelSetupError\",\n                    evalue: `Failed to setup kernel: ${error instanceof Error ? error.message : String(error)}`,\n                    traceback: [error instanceof Error ? (error.stack || error.message) : String(error)]\n                }\n            });\n            throw error; // Re-throw to let the caller handle it\n        }\n    }\n    /**\n     * Setup a pool kernel with new ID and options (for already resolved kernels)\n     * @param poolKernel Kernel from pool\n     * @param id New kernel ID\n     * @param options Kernel options\n     * @returns Kernel ID\n     * @private\n     */\n    setupPoolKernel(poolKernel, id, options) {\n        // Reassign the pool kernel with the new ID and options\n        const instance = this.reassignPoolKernel(poolKernel, id, options);\n        // For worker kernels, we need to recreate the event handler with the new ID\n        if (instance.mode === KernelMode.WORKER && instance.worker) {\n            // Get the worker and create new message channel\n            const worker = instance.worker;\n            // Create a new message channel for the reassigned kernel\n            const { port1, port2 } = new MessageChannel();\n            // Send the new event port to the worker\n            worker.postMessage({\n                type: \"SET_EVENT_PORT\",\n                port: port2\n            }, [port2]);\n            // Create a new event handler with the correct kernel ID\n            const eventHandler = (event) => {\n                if (event.data && event.data.type) {\n                    // Emit the event from the manager with kernel ID\n                    // This structure matches the setupEventForwarding method for main thread kernels\n                    super.emit(event.data.type, {\n                        kernelId: id,\n                        data: event.data.data\n                    });\n                }\n            };\n            // Listen for events from the worker with the new handler\n            port1.addEventListener('message', eventHandler);\n            port1.start();\n            // Update the destroy function to clean up the new event handler\n            const originalDestroy = instance.destroy;\n            instance.destroy = async () => {\n                port1.removeEventListener('message', eventHandler);\n                port1.close();\n                return originalDestroy();\n            };\n        }\n        // Store the kernel instance\n        this.kernels.set(id, instance);\n        // Forward kernel events to manager (for main thread kernels)\n        this.setupEventForwarding(instance);\n        // Initialize activity tracking\n        this.updateKernelActivity(id);\n        // Set up inactivity timeout if specified and greater than 0\n        if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n            this.setupInactivityTimeout(id, options.inactivityTimeout);\n        }\n        // Setup handlers for stalled executions if maxExecutionTime is specified\n        if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n            this.setupStalledExecutionHandler(id);\n        }\n        return id;\n    }\n    /**\n     * Create a kernel on-demand (not from pool)\n     * @param id Kernel ID\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @param options Kernel options\n     * @returns Kernel ID\n     * @private\n     */\n    async createOnDemandKernel(id, mode, language, options) {\n        // Store options temporarily to be used in createWorkerKernel\n        const tempInstance = {\n            id,\n            options: { ...options, lang: language },\n            mode,\n            language\n        };\n        this.kernels.set(id, tempInstance);\n        // Create the appropriate kernel instance\n        let instance;\n        if (mode === KernelMode.MAIN_THREAD) {\n            instance = await this.createMainThreadKernel(id);\n        }\n        else {\n            instance = await this.createWorkerKernel(id);\n        }\n        // Store the kernel instance\n        this.kernels.set(id, instance);\n        // Forward kernel events to manager\n        this.setupEventForwarding(instance);\n        // Initialize activity tracking\n        this.updateKernelActivity(id);\n        // Set up inactivity timeout if specified and greater than 0\n        if (options.inactivityTimeout && options.inactivityTimeout > 0) {\n            this.setupInactivityTimeout(id, options.inactivityTimeout);\n        }\n        // Setup handlers for stalled executions if maxExecutionTime is specified\n        if (options.maxExecutionTime && options.maxExecutionTime > 0) {\n            this.setupStalledExecutionHandler(id);\n        }\n        return id;\n    }\n    /**\n     * Create a kernel instance running in the main thread\n     * @param id Kernel ID\n     * @returns Kernel instance\n     */\n    async createMainThreadKernel(id) {\n        // Get options from the temporary instance\n        const options = this.kernels.get(id)?.options || {};\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Create the Python kernel\n        const kernel = new _index__WEBPACK_IMPORTED_MODULE_2__.Kernel();\n        // Create the kernel instance\n        const instance = {\n            id,\n            kernel,\n            mode: KernelMode.MAIN_THREAD,\n            language,\n            created: new Date().toISOString(),\n            options,\n            destroy: async () => {\n                // Nothing special to do for main thread kernel\n                return Promise.resolve();\n            }\n        };\n        // Initialize the kernel with filesystem options\n        const kernelOptions = {};\n        // Add filesystem options if provided\n        if (options.filesystem) {\n            kernelOptions.filesystem = options.filesystem;\n        }\n        // Add environment variables if provided\n        if (options.env) {\n            kernelOptions.env = options.env;\n        }\n        // Add lockFileURL if provided\n        if (options.lockFileURL) {\n            kernelOptions.lockFileURL = options.lockFileURL;\n        }\n        // Add autoSyncFs if provided\n        if (options.autoSyncFs !== undefined) {\n            kernelOptions.autoSyncFs = options.autoSyncFs;\n        }\n        // Initialize the kernel\n        await kernel.initialize(kernelOptions);\n        return instance;\n    }\n    /**\n     * Create a kernel instance running in a worker\n     * @param id Kernel ID\n     * @returns Kernel instance\n     */\n    async createWorkerKernel(id) {\n        // Get permissions from options when creating the kernel\n        const options = this.kernels.get(id)?.options || {};\n        const language = options.lang || KernelLanguage.PYTHON;\n        // Create a new worker with optional permissions\n        const workerOptions = {\n            type: \"module\",\n        };\n        // If Deno permissions are provided, use them.\n        // Otherwise don't specify Deno permissions at all to inherit from host script\n        if (options.deno?.permissions) {\n            workerOptions.deno = {\n                permissions: options.deno.permissions\n            };\n        }\n        // Determine the worker URL based on the environment\n        const workerUrl = this.resolveWorkerUrl();\n        const worker = new Worker(workerUrl, { type: 'classic' });\n        // Create a message channel for events\n        const { port1, port2 } = new MessageChannel();\n        // Create a promise that will resolve when the kernel is initialized\n        const initPromise = new Promise((resolve, reject) => {\n            const initHandler = (event) => {\n                if (event.data?.type === \"KERNEL_INITIALIZED\") {\n                    if (event.data.data.success) {\n                        port1.removeEventListener('message', initHandler);\n                        resolve();\n                    }\n                    else {\n                        port1.removeEventListener('message', initHandler);\n                        reject(new Error(\"Kernel initialization failed\"));\n                    }\n                }\n            };\n            port1.addEventListener('message', initHandler);\n        });\n        // Send the port to the worker\n        worker.postMessage({ type: \"SET_EVENT_PORT\", port: port2 }, [port2]);\n        // Create a proxy to the worker using Comlink\n        const kernelProxy = comlink__WEBPACK_IMPORTED_MODULE_0__.wrap(worker);\n        // Add a local event handler to bridge the worker events\n        // This works around the limitation that Comlink doesn't proxy event emitters\n        const eventHandler = (event) => {\n            if (event.data && event.data.type) {\n                // Emit the event from the manager with kernel ID\n                // This structure matches the setupEventForwarding method for main thread kernels\n                super.emit(event.data.type, {\n                    kernelId: id,\n                    data: event.data.data\n                });\n            }\n        };\n        // Listen for events from the worker\n        port1.addEventListener('message', eventHandler);\n        port1.start();\n        // Initialize the kernel with filesystem options\n        // We need to pass these options to the worker\n        worker.postMessage({\n            type: \"INITIALIZE_KERNEL\",\n            options: {\n                filesystem: options.filesystem,\n                env: options.env,\n                lockFileURL: options.lockFileURL,\n                autoSyncFs: options.autoSyncFs,\n                lang: language\n            }\n        });\n        // Wait for kernel initialization\n        await initPromise;\n        // Set up interrupt buffer automatically for worker kernels\n        await this.setupWorkerInterruptBuffer(id, worker);\n        // Create the kernel instance\n        const instance = {\n            id,\n            kernel: {\n                // Map methods from the Comlink proxy to the IKernel interface\n                initialize: async (options) => {\n                    return kernelProxy.initialize(options);\n                },\n                execute: async (code, parent) => {\n                    const result = await kernelProxy.execute(code, parent);\n                    // Handle Python worker results (no special display reconstruction needed)\n                    return result;\n                },\n                isInitialized: () => {\n                    return kernelProxy.isInitialized();\n                },\n                inputReply: async (content) => {\n                    return kernelProxy.inputReply(content);\n                },\n                // Map async getStatus method\n                getStatus: async () => {\n                    try {\n                        if (typeof kernelProxy.getStatus === 'function') {\n                            return await kernelProxy.getStatus();\n                        }\n                        else {\n                            return \"unknown\";\n                        }\n                    }\n                    catch (error) {\n                        return \"unknown\";\n                    }\n                },\n                // Map completion methods\n                complete: async (code, cursor_pos, parent) => {\n                    try {\n                        if (typeof kernelProxy.complete === 'function') {\n                            return await kernelProxy.complete(code, cursor_pos, parent);\n                        }\n                        else {\n                            return { status: 'error', error: 'Completion not supported' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                inspect: async (code, cursor_pos, detail_level, parent) => {\n                    try {\n                        if (typeof kernelProxy.inspect === 'function') {\n                            return await kernelProxy.inspect(code, cursor_pos, detail_level, parent);\n                        }\n                        else {\n                            return { status: 'error', error: 'Inspection not supported' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                isComplete: async (code, parent) => {\n                    try {\n                        if (typeof kernelProxy.isComplete === 'function') {\n                            return await kernelProxy.isComplete(code, parent);\n                        }\n                        else {\n                            return { status: 'unknown' };\n                        }\n                    }\n                    catch (error) {\n                        return { status: 'error', error: String(error) };\n                    }\n                },\n                // Map interrupt methods\n                interrupt: async () => {\n                    try {\n                        if (typeof kernelProxy.interrupt === 'function') {\n                            return await kernelProxy.interrupt();\n                        }\n                        else {\n                            return false;\n                        }\n                    }\n                    catch (error) {\n                        return false;\n                    }\n                },\n                setInterruptBuffer: (buffer) => {\n                    try {\n                        if (typeof kernelProxy.setInterruptBuffer === 'function') {\n                            kernelProxy.setInterruptBuffer(buffer);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to set interrupt buffer:', error);\n                    }\n                },\n                // Map mountFS method\n                mountFS: async (mountPath, dirHandle, permission) => {\n                    try {\n                        if (typeof kernelProxy.mountFS === 'function') {\n                            return await kernelProxy.mountFS(mountPath, dirHandle, permission);\n                        }\n                        else {\n                            throw new Error('mountFS is not supported by this kernel');\n                        }\n                    }\n                    catch (error) {\n                        throw error;\n                    }\n                },\n                // Map comm methods\n                commInfo: async (target_name, parent) => {\n                    try {\n                        if (typeof kernelProxy.commInfo === 'function') {\n                            return await kernelProxy.commInfo(target_name, parent);\n                        }\n                        else {\n                            return { comms: {}, status: 'ok' };\n                        }\n                    }\n                    catch (error) {\n                        return { comms: {}, status: 'error', error: String(error) };\n                    }\n                },\n                commOpen: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commOpen === 'function') {\n                            return await kernelProxy.commOpen(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to open comm:', error);\n                    }\n                },\n                commMsg: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commMsg === 'function') {\n                            return await kernelProxy.commMsg(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to send comm message:', error);\n                    }\n                },\n                commClose: async (content, parent) => {\n                    try {\n                        if (typeof kernelProxy.commClose === 'function') {\n                            return await kernelProxy.commClose(content, parent);\n                        }\n                    }\n                    catch (error) {\n                        console.warn('Failed to close comm:', error);\n                    }\n                }\n            },\n            mode: KernelMode.WORKER,\n            language,\n            worker,\n            created: new Date().toISOString(),\n            options, // Store the options for reference\n            destroy: async () => {\n                // Clean up the worker and event listeners\n                port1.removeEventListener('message', eventHandler);\n                port1.close();\n                worker.terminate();\n                return Promise.resolve();\n            }\n        };\n        return instance;\n    }\n    /**\n     * Setup event forwarding from kernel to manager\n     * @param instance Kernel instance\n     */\n    setupEventForwarding(instance) {\n        // Only needed for main thread kernels as worker events are handled directly\n        if (instance.mode === KernelMode.MAIN_THREAD) {\n            // Forward all kernel events to the manager with kernel ID\n            Object.values(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents).forEach((eventType) => {\n                // Access the kernel as a Kernel instance which extends EventEmitter\n                const kernelEmitter = instance.kernel;\n                // Add event listener to forward events\n                kernelEmitter.on(eventType, (data) => {\n                    super.emit(eventType, {\n                        kernelId: instance.id,\n                        data\n                    });\n                });\n            });\n        }\n    }\n    /**\n     * Get a kernel instance by ID\n     * @param id Kernel ID\n     * @returns Kernel instance or undefined if not found\n     */\n    getKernel(id) {\n        return this.kernels.get(id);\n    }\n    /**\n     * Get a list of all kernel IDs\n     * @returns Array of kernel IDs\n     */\n    getKernelIds() {\n        return Array.from(this.kernels.keys());\n    }\n    /**\n     * Get a list of all kernels with their details\n     * @param namespace Optional namespace to filter kernels by\n     * @returns Array of kernel information objects\n     */\n    async listKernels(namespace) {\n        const filteredKernels = Array.from(this.kernels.entries())\n            .filter(([id]) => {\n            // Filter out pool kernels (temporary kernels with IDs starting with \"pool-\")\n            if (id.startsWith(\"pool-\"))\n                return false;\n            if (!namespace)\n                return true;\n            return id.startsWith(`${namespace}:`);\n        });\n        // Use Promise.all to get all statuses concurrently\n        const kernelInfos = await Promise.all(filteredKernels.map(async ([id, instance]) => {\n            // Extract namespace from id if present\n            const namespaceMatch = id.match(/^([^:]+):/);\n            const extractedNamespace = namespaceMatch ? namespaceMatch[1] : undefined;\n            // Get status using async getStatus method\n            let status = \"unknown\";\n            try {\n                if (instance && instance.kernel && typeof instance.kernel.getStatus === 'function') {\n                    status = await instance.kernel.getStatus();\n                }\n            }\n            catch (error) {\n                console.warn(`Error getting status for kernel ${id}:`, error);\n                status = \"unknown\";\n            }\n            return {\n                id,\n                mode: instance.mode,\n                language: instance.language,\n                status,\n                created: instance.created || new Date().toISOString(),\n                namespace: extractedNamespace,\n                deno: instance.options?.deno\n            };\n        }));\n        return kernelInfos;\n    }\n    /**\n     * Destroy a kernel instance\n     * @param id Kernel ID\n     * @returns Promise resolving when kernel is destroyed\n     */\n    async destroyKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            // Handle gracefully - kernel may already be destroyed\n            return;\n        }\n        // Verify the destroy function exists\n        if (typeof instance.destroy !== 'function') {\n            throw new Error(`Kernel ${id} is missing destroy function (type: ${typeof instance.destroy})`);\n        }\n        // Abort all ongoing operations for this kernel first\n        this.abortAllKernelOperations(id);\n        // Clear any inactivity timer\n        this.clearInactivityTimeout(id);\n        // Clean up execution timeouts\n        if (this.executionTimeouts.has(id)) {\n            const timeouts = this.executionTimeouts.get(id);\n            for (const timeoutId of timeouts.values()) {\n                clearTimeout(timeoutId);\n            }\n            this.executionTimeouts.delete(id);\n        }\n        // Clean up execution start times\n        if (this.executionStartTimes.has(id)) {\n            this.executionStartTimes.delete(id);\n        }\n        // Clean up execution metadata\n        if (this.executionMetadata.has(id)) {\n            this.executionMetadata.delete(id);\n        }\n        // Clean up interrupt buffers\n        if (this.interruptBuffers.has(id)) {\n            this.interruptBuffers.delete(id);\n        }\n        // Clean up ongoing executions tracking\n        this.ongoingExecutions.delete(id);\n        // Clean up activity tracking\n        this.lastActivityTime.delete(id);\n        // Remove all event listeners for this kernel\n        this.removeAllKernelListeners(id);\n        // Destroy the kernel instance\n        await instance.destroy();\n        // Remove the kernel from the map\n        this.kernels.delete(id);\n    }\n    /**\n     * Destroy all kernel instances\n     * @param namespace Optional namespace to filter kernels to destroy\n     * @returns Promise resolving when all kernels are destroyed\n     */\n    async destroyAll(namespace) {\n        const ids = Array.from(this.kernels.keys())\n            .filter(id => {\n            if (!namespace)\n                return true;\n            return id.startsWith(`${namespace}:`);\n        });\n        // Destroy all kernels, but skip incomplete instances\n        const destroyPromises = ids.map(async (id) => {\n            const instance = this.kernels.get(id);\n            if (!instance || typeof instance.destroy !== 'function') {\n                console.warn(`Skipping incomplete kernel instance ${id} during destroyAll`);\n                // Just remove it from the map\n                this.kernels.delete(id);\n                return;\n            }\n            return this.destroyKernel(id);\n        });\n        await Promise.all(destroyPromises);\n        // If no namespace specified, also clean up the pool\n        if (!namespace) {\n            await this.destroyPool();\n        }\n    }\n    /**\n     * Destroy all kernels in the pool\n     * @private\n     */\n    async destroyPool() {\n        const destroyPromises = [];\n        for (const [poolKey, promises] of this.pool.entries()) {\n            for (const kernelPromise of promises) {\n                // Handle each promise - if it resolves, destroy the kernel\n                const destroyPromise = kernelPromise.then(kernel => {\n                    return kernel.destroy();\n                }).catch(error => {\n                    console.error(`Error destroying pool kernel from promise:`, error);\n                    // Don't re-throw to avoid unhandled rejections\n                });\n                destroyPromises.push(destroyPromise);\n            }\n        }\n        // Wait for all pool kernels to be destroyed\n        await Promise.all(destroyPromises);\n        // Clear the pool and prefilling flags\n        this.pool.clear();\n        this.prefillingInProgress.clear();\n    }\n    /**\n     * Register an event listener for a specific kernel's events\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @param listener Event listener\n     */\n    onKernelEvent(kernelId, eventType, listener) {\n        // Check if kernel exists\n        if (!this.kernels.has(kernelId)) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        // Create wrapper that filters events for this specific kernel\n        const wrapper = {\n            original: listener,\n            wrapped: (event) => {\n                if (event.kernelId === kernelId) {\n                    // Pass just the data to the listener\n                    // The data structure is consistent across main thread and worker modes\n                    listener(event.data);\n                }\n            }\n        };\n        // Store the wrapper for later removal\n        this.storeListener(kernelId, eventType, listener, wrapper);\n        // Add the wrapped listener to the manager\n        super.on(eventType, wrapper.wrapped);\n    }\n    /**\n     * Remove an event listener for a specific kernel\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @param listener Event listener\n     */\n    offKernelEvent(kernelId, eventType, listener) {\n        const wrapper = this.getListener(kernelId, eventType, listener);\n        if (wrapper) {\n            // Remove the wrapped listener from the manager\n            super.removeListener(eventType, wrapper.wrapped);\n            // Remove the wrapper from our tracking map\n            this.removeStoredListener(kernelId, eventType, listener);\n        }\n    }\n    /**\n     * Store a listener wrapper for later removal\n     */\n    storeListener(kernelId, eventType, original, wrapper) {\n        // Get or create kernel map\n        if (!this.listenerWrappers.has(kernelId)) {\n            this.listenerWrappers.set(kernelId, new Map());\n        }\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        // Get or create event type map\n        if (!kernelMap.has(eventType)) {\n            kernelMap.set(eventType, new Map());\n        }\n        const eventMap = kernelMap.get(eventType);\n        // Store the wrapper\n        eventMap.set(original, wrapper);\n    }\n    /**\n     * Get a stored listener wrapper\n     */\n    getListener(kernelId, eventType, original) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return undefined;\n        const eventMap = kernelMap.get(eventType);\n        if (!eventMap)\n            return undefined;\n        return eventMap.get(original);\n    }\n    /**\n     * Remove a stored listener wrapper\n     */\n    removeStoredListener(kernelId, eventType, original) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return;\n        const eventMap = kernelMap.get(eventType);\n        if (!eventMap)\n            return;\n        // Remove the listener\n        eventMap.delete(original);\n        // Clean up empty maps\n        if (eventMap.size === 0) {\n            kernelMap.delete(eventType);\n        }\n        if (kernelMap.size === 0) {\n            this.listenerWrappers.delete(kernelId);\n        }\n    }\n    /**\n     * Remove all listeners for a specific kernel\n     */\n    removeAllKernelListeners(kernelId) {\n        const kernelMap = this.listenerWrappers.get(kernelId);\n        if (!kernelMap)\n            return;\n        // For each event type\n        for (const [eventType, eventMap] of kernelMap.entries()) {\n            // For each original listener\n            for (const wrapper of eventMap.values()) {\n                // Remove the wrapped listener from the manager\n                super.removeListener(eventType, wrapper.wrapped);\n            }\n        }\n        // Clear the kernel's listener map\n        this.listenerWrappers.delete(kernelId);\n    }\n    /**\n     * Get all listeners for a specific kernel and event type\n     * @param kernelId Kernel ID\n     * @param eventType Event type\n     * @returns Array of listeners\n     */\n    getListeners(kernelId, eventType) {\n        const kernelListeners = this.listenerWrappers.get(kernelId);\n        if (!kernelListeners) {\n            return [];\n        }\n        const eventListeners = kernelListeners.get(eventType);\n        if (!eventListeners) {\n            return [];\n        }\n        return Array.from(eventListeners.keys());\n    }\n    /**\n     * Execute Python code with streaming output\n     * This method works in both main thread and worker modes\n     * @param kernelId ID of the kernel to use\n     * @param code The Python code to execute\n     * @param parent Optional parent message header\n     * @returns AsyncGenerator yielding intermediate outputs\n     */\n    async *executeStream(kernelId, code, parent = {}) {\n        const instance = this.getKernel(kernelId);\n        if (!instance) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        // Update kernel activity\n        this.updateKernelActivity(kernelId);\n        // Track this execution with the code for better monitoring\n        const executionId = this.trackExecution(kernelId, code);\n        // Create AbortController for this execution to enable cancellation\n        const abortController = new AbortController();\n        this.storeAbortController(kernelId, executionId, abortController);\n        try {\n            // For main thread kernels, we can use the executeStream method directly\n            if (instance.mode === KernelMode.MAIN_THREAD) {\n                const kernel = instance.kernel;\n                // Forward to the kernel's executeStream method\n                if (typeof kernel.executeStream === 'function') {\n                    try {\n                        yield* kernel.executeStream(code, parent);\n                        // Update activity after execution completes\n                        this.updateKernelActivity(kernelId);\n                        // Complete execution tracking\n                        this.completeExecution(kernelId, executionId);\n                        return { success: true };\n                    }\n                    catch (error) {\n                        console.error(`Error in main thread executeStream:`, error);\n                        // Update activity even if there's an error\n                        this.updateKernelActivity(kernelId);\n                        // Complete execution tracking even on error\n                        this.completeExecution(kernelId, executionId);\n                        return {\n                            success: false,\n                            error: error instanceof Error ? error : new Error(String(error))\n                        };\n                    }\n                }\n            }\n            // For worker mode, we need to implement streaming via events with proper isolation\n            try {\n                // Event-based approach for worker kernels or main thread kernels without executeStream\n                const streamQueue = [];\n                let executionComplete = false;\n                let executionResult = { success: true };\n                // Store handler references for guaranteed cleanup\n                const eventHandlers = new Map();\n                // Helper function to clean up all event handlers\n                const cleanupHandlers = () => {\n                    for (const [eventType, handler] of eventHandlers.entries()) {\n                        super.off(eventType, handler);\n                    }\n                    eventHandlers.clear();\n                };\n                // Create execution-specific event handlers that include executionId check\n                const createHandler = (eventType) => {\n                    const handler = (event) => {\n                        // Only process events for this specific kernel and while this execution is active\n                        if (event.kernelId === kernelId && !executionComplete) {\n                            streamQueue.push({\n                                type: eventType,\n                                data: event.data,\n                                executionId // Include execution ID for debugging\n                            });\n                            // Events also count as activity\n                            this.updateKernelActivity(kernelId);\n                        }\n                    };\n                    eventHandlers.set(eventType, handler);\n                    return handler;\n                };\n                // Create and register all event handlers\n                const handleStreamEvent = createHandler('stream');\n                const handleDisplayEvent = createHandler('display_data');\n                const handleUpdateDisplayEvent = createHandler('update_display_data');\n                const handleResultEvent = createHandler('execute_result');\n                const handleErrorEvent = createHandler('execute_error');\n                // Register handlers\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.STREAM, handleStreamEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.DISPLAY_DATA, handleDisplayEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.UPDATE_DISPLAY_DATA, handleUpdateDisplayEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_RESULT, handleResultEvent);\n                super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, handleErrorEvent);\n                // Create a promise that will resolve when execution is complete\n                const executionPromise = new Promise((resolve, reject) => {\n                    // Set up a handler for execution errors specifically\n                    const handleExecutionError = (event) => {\n                        if (event.kernelId === kernelId && !executionComplete) {\n                            // Mark execution as complete to stop processing more events\n                            executionComplete = true;\n                            // Store the error for the final result\n                            executionResult = {\n                                success: false,\n                                error: new Error(`${event.data.ename}: ${event.data.evalue}`),\n                                result: event.data\n                            };\n                            // Update activity\n                            this.updateKernelActivity(kernelId);\n                            resolve(executionResult);\n                        }\n                    };\n                    // Add error handler to our cleanup list\n                    eventHandlers.set('execute_error_completion', handleExecutionError);\n                    super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, handleExecutionError);\n                    // Check if already aborted\n                    if (abortController.signal.aborted) {\n                        executionComplete = true;\n                        resolve({\n                            success: false,\n                            error: new Error('Execution was aborted')\n                        });\n                        return;\n                    }\n                    // Set up abort handler\n                    const abortHandler = () => {\n                        if (!executionComplete) {\n                            console.log(`ðŸš« Execution ${executionId} aborted`);\n                            executionComplete = true;\n                            resolve({\n                                success: false,\n                                error: new Error('Execution was aborted')\n                            });\n                        }\n                    };\n                    abortController.signal.addEventListener('abort', abortHandler);\n                    // Execute the code\n                    // We know the execute method is available directly on the kernel object\n                    try {\n                        const executePromise = instance.kernel.execute(code, parent);\n                        executePromise.then((result) => {\n                            // Only process if execution hasn't been marked complete already\n                            if (!executionComplete) {\n                                // Check if the execution result indicates an error (for Python kernels)\n                                if (result.success && result.result && result.result.status === \"error\") {\n                                    // Handle as error\n                                    const errorData = {\n                                        status: result.result.status,\n                                        ename: result.result.ename,\n                                        evalue: result.result.evalue,\n                                        traceback: result.result.traceback\n                                    };\n                                    // Push error to stream queue directly \n                                    streamQueue.push({\n                                        type: 'error',\n                                        data: errorData,\n                                        executionId\n                                    });\n                                    // Update execution result to reflect the error\n                                    executionResult = {\n                                        success: false,\n                                        error: new Error(`${result.result.ename}: ${result.result.evalue}`),\n                                        result: result.result\n                                    };\n                                }\n                                else {\n                                    executionResult = result;\n                                }\n                                executionComplete = true;\n                                // Update activity when execution completes\n                                this.updateKernelActivity(kernelId);\n                                resolve(executionResult);\n                            }\n                        }).catch((error) => {\n                            // Only process if execution hasn't been marked complete already\n                            if (!executionComplete) {\n                                console.error(`Error in execute for kernel ${kernelId}:`, error);\n                                // Check if this is a KeyboardInterrupt and handle it specially\n                                let errorResult;\n                                if (this.isKeyboardInterrupt(error)) {\n                                    console.log(`KeyboardInterrupt caught in executeStream for kernel ${kernelId}`);\n                                    errorResult = this.createKeyboardInterruptResult();\n                                    // Also push to stream queue for immediate feedback\n                                    streamQueue.push({\n                                        type: 'error',\n                                        data: errorResult.result,\n                                        executionId\n                                    });\n                                }\n                                else {\n                                    // Handle other errors normally\n                                    errorResult = {\n                                        success: false,\n                                        error: error instanceof Error ? error : new Error(String(error))\n                                    };\n                                }\n                                executionComplete = true;\n                                executionResult = errorResult;\n                                // Update activity even on error\n                                this.updateKernelActivity(kernelId);\n                                resolve(errorResult);\n                            }\n                        });\n                    }\n                    catch (error) {\n                        // Only process if execution hasn't been marked complete already\n                        if (!executionComplete) {\n                            console.error(`Error calling execute for kernel ${kernelId}:`, error);\n                            // Simple error handling\n                            const errorResult = {\n                                success: false,\n                                error: error instanceof Error ? error : new Error(String(error))\n                            };\n                            executionComplete = true;\n                            executionResult = errorResult;\n                            // Update activity even on direct error\n                            this.updateKernelActivity(kernelId);\n                            resolve(errorResult);\n                        }\n                    }\n                });\n                // Use try/finally to guarantee cleanup\n                try {\n                    // Monitor the stream queue and yield results\n                    // Continue until execution is complete AND all queued events have been yielded\n                    while ((!executionComplete || streamQueue.length > 0) && !abortController.signal.aborted) {\n                        // If there are items in the queue, yield them\n                        if (streamQueue.length > 0) {\n                            const event = streamQueue.shift();\n                            yield event;\n                            continue;\n                        }\n                        // If no more events but execution is not complete, wait a little\n                        if (!executionComplete) {\n                            // Use abort signal to cancel the wait\n                            try {\n                                await new Promise((resolve, reject) => {\n                                    const timeoutId = setTimeout(resolve, 10);\n                                    abortController.signal.addEventListener('abort', () => {\n                                        clearTimeout(timeoutId);\n                                        reject(new Error('Aborted'));\n                                    });\n                                });\n                            }\n                            catch (error) {\n                                // If aborted, break out of loop\n                                if (abortController.signal.aborted) {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    // Check if execution was aborted during stream monitoring\n                    if (abortController.signal.aborted && !executionComplete) {\n                        throw new Error('Execution was aborted during stream monitoring');\n                    }\n                    // Wait for the final result\n                    const result = await executionPromise;\n                    return result;\n                }\n                finally {\n                    // ALWAYS clean up event handlers regardless of how execution ends\n                    cleanupHandlers();\n                    // Remove AbortController to prevent memory leaks\n                    this.removeAbortController(kernelId, executionId);\n                    // Complete execution tracking\n                    this.completeExecution(kernelId, executionId);\n                }\n            }\n            catch (error) {\n                // Complete execution tracking on any outer error\n                this.completeExecution(kernelId, executionId);\n                console.error(`Unexpected error in executeStream:`, error);\n                return {\n                    success: false,\n                    error: error instanceof Error ? error : new Error(String(error))\n                };\n            }\n        }\n        catch (error) {\n            // Complete execution tracking on any outer error\n            this.completeExecution(kernelId, executionId);\n            console.error(`Unexpected error in executeStream:`, error);\n            return {\n                success: false,\n                error: error instanceof Error ? error : new Error(String(error))\n            };\n        }\n    }\n    /**\n     * Track a new execution task for a kernel\n     * @param kernelId Kernel ID\n     * @param code Optional code being executed for metadata\n     * @returns Unique execution ID\n     * @private\n     */\n    trackExecution(kernelId, code) {\n        // Create a unique execution ID\n        const executionId = `exec-${crypto.randomUUID()}`;\n        const startTime = Date.now();\n        // Reset interrupt buffer for worker kernels before each new execution\n        // This ensures the kernel can be interrupted multiple times\n        const instance = this.kernels.get(kernelId);\n        if (instance && instance.mode === KernelMode.WORKER && this.interruptBuffers.has(kernelId)) {\n            const interruptBuffer = this.interruptBuffers.get(kernelId);\n            // Reset buffer to 0 (no interrupt signal) to ensure clean state\n            interruptBuffer[0] = 0;\n        }\n        // Get or create the set of ongoing executions for this kernel\n        if (!this.ongoingExecutions.has(kernelId)) {\n            this.ongoingExecutions.set(kernelId, new Set());\n        }\n        // Add this execution to the set\n        this.ongoingExecutions.get(kernelId).add(executionId);\n        // Track execution start time\n        if (!this.executionStartTimes.has(kernelId)) {\n            this.executionStartTimes.set(kernelId, new Map());\n        }\n        this.executionStartTimes.get(kernelId).set(executionId, startTime);\n        // Track execution metadata\n        if (!this.executionMetadata.has(kernelId)) {\n            this.executionMetadata.set(kernelId, new Map());\n        }\n        // Update activity timestamp\n        this.updateKernelActivity(kernelId);\n        // If maxExecutionTime is set, create a timeout to detect stuck/dead kernels\n        if (instance && instance.options.maxExecutionTime && instance.options.maxExecutionTime > 0) {\n            // Get or create the map of execution timeouts for this kernel\n            if (!this.executionTimeouts.has(kernelId)) {\n                this.executionTimeouts.set(kernelId, new Map());\n            }\n            // Set a timeout for this execution with enhanced handling\n            const timeoutId = setTimeout(() => {\n                console.warn(`Execution ${executionId} on kernel ${kernelId} has been running for ${instance.options.maxExecutionTime}ms and may be stuck/dead.`);\n                // Get execution metadata for better error reporting\n                const metadata = this.executionMetadata.get(kernelId)?.get(executionId);\n                const actualRuntime = Date.now() - (metadata?.startTime || startTime);\n                // Emit a stalled execution event with enhanced information\n                super.emit('execution_stalled', {\n                    kernelId,\n                    executionId,\n                    maxExecutionTime: instance.options.maxExecutionTime,\n                    actualRuntime,\n                    code: metadata?.code || code,\n                    startTime: metadata?.startTime || startTime\n                });\n                // Auto-handle stuck execution if configured\n                this.handleStuckExecution(kernelId, executionId, actualRuntime, metadata?.code || code);\n            }, instance.options.maxExecutionTime);\n            // Store the timeout ID\n            this.executionTimeouts.get(kernelId).set(executionId, timeoutId);\n            // Store metadata including timeout ID\n            this.executionMetadata.get(kernelId).set(executionId, {\n                startTime,\n                code,\n                timeoutId\n            });\n        }\n        else {\n            // Store metadata without timeout ID\n            this.executionMetadata.get(kernelId).set(executionId, {\n                startTime,\n                code\n            });\n        }\n        return executionId;\n    }\n    /**\n     * Complete tracking for an execution\n     * @param kernelId Kernel ID\n     * @param executionId Execution ID\n     * @private\n     */\n    completeExecution(kernelId, executionId) {\n        // Clear any execution timeout\n        if (this.executionTimeouts.has(kernelId)) {\n            const timeouts = this.executionTimeouts.get(kernelId);\n            if (timeouts.has(executionId)) {\n                clearTimeout(timeouts.get(executionId));\n                timeouts.delete(executionId);\n            }\n            // Clean up empty maps\n            if (timeouts.size === 0) {\n                this.executionTimeouts.delete(kernelId);\n            }\n        }\n        // Clean up execution start times\n        if (this.executionStartTimes.has(kernelId)) {\n            const startTimes = this.executionStartTimes.get(kernelId);\n            startTimes.delete(executionId);\n            // Clean up empty maps\n            if (startTimes.size === 0) {\n                this.executionStartTimes.delete(kernelId);\n            }\n        }\n        // Clean up execution metadata\n        if (this.executionMetadata.has(kernelId)) {\n            const metadata = this.executionMetadata.get(kernelId);\n            metadata.delete(executionId);\n            // Clean up empty maps\n            if (metadata.size === 0) {\n                this.executionMetadata.delete(kernelId);\n            }\n        }\n        // Remove from ongoing executions\n        if (this.ongoingExecutions.has(kernelId)) {\n            const executions = this.ongoingExecutions.get(kernelId);\n            executions.delete(executionId);\n            // Clean up empty sets\n            if (executions.size === 0) {\n                this.ongoingExecutions.delete(kernelId);\n                // Update activity timestamp for completed execution\n                this.updateKernelActivity(kernelId);\n            }\n        }\n    }\n    /**\n     * Check if a kernel has any ongoing executions\n     * @param kernelId Kernel ID\n     * @returns True if the kernel has ongoing executions\n     * @private\n     */\n    hasOngoingExecutions(kernelId) {\n        return this.ongoingExecutions.has(kernelId) &&\n            this.ongoingExecutions.get(kernelId).size > 0;\n    }\n    /**\n     * Get the count of ongoing executions for a kernel\n     * @param id Kernel ID\n     * @returns Number of ongoing executions\n     */\n    getOngoingExecutionCount(id) {\n        if (!this.ongoingExecutions.has(id)) {\n            return 0;\n        }\n        return this.ongoingExecutions.get(id).size;\n    }\n    /**\n     * Set up an inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @param timeout Timeout in milliseconds\n     * @private\n     */\n    setupInactivityTimeout(id, timeout) {\n        // Don't set up a timer if timeout is 0 or negative\n        if (timeout <= 0) {\n            return;\n        }\n        // Always clear any existing timer first\n        this.clearInactivityTimeout(id);\n        // Calculate remaining time based on last activity\n        const lastActivity = this.lastActivityTime.get(id) || Date.now();\n        const elapsed = Date.now() - lastActivity;\n        const remainingTime = Math.max(0, timeout - elapsed);\n        // If no time remaining, destroy immediately\n        if (remainingTime === 0) {\n            // Check if the kernel has ongoing executions before shutting down\n            if (this.hasOngoingExecutions(id)) {\n                // Reset the timer to check again later\n                this.setupInactivityTimeout(id, timeout);\n                return;\n            }\n            // Destroy immediately\n            this.destroyKernel(id).catch(error => {\n                console.error(`Error destroying inactive kernel ${id}:`, error);\n            });\n            return;\n        }\n        // Create a timer to destroy the kernel after the remaining timeout\n        const timer = setTimeout(() => {\n            // Check if the kernel has ongoing executions before shutting down\n            if (this.hasOngoingExecutions(id)) {\n                // Reset the timer to check again later\n                this.setupInactivityTimeout(id, timeout);\n                return;\n            }\n            this.destroyKernel(id).catch(error => {\n                console.error(`Error destroying inactive kernel ${id}:`, error);\n            });\n        }, remainingTime);\n        // Store the timer ID\n        this.inactivityTimers.set(id, timer);\n    }\n    /**\n     * Clear any existing inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @private\n     */\n    clearInactivityTimeout(id) {\n        if (this.inactivityTimers.has(id)) {\n            const timerId = this.inactivityTimers.get(id);\n            clearTimeout(timerId);\n            this.inactivityTimers.delete(id);\n        }\n    }\n    /**\n     * Update activity timestamp for a kernel and reset inactivity timer if present\n     * @param id Kernel ID\n     * @private\n     */\n    updateKernelActivity(id) {\n        // Update the last activity time\n        this.lastActivityTime.set(id, Date.now());\n        // Get the kernel options\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return;\n        const timeout = instance.options.inactivityTimeout;\n        // Reset the inactivity timer if timeout is enabled (greater than 0)\n        if (timeout && timeout > 0) {\n            this.setupInactivityTimeout(id, timeout);\n        }\n    }\n    /**\n     * Get the last activity time for a kernel\n     * @param id Kernel ID\n     * @returns Last activity time in milliseconds since epoch, or undefined if not found\n     */\n    getLastActivityTime(id) {\n        return this.lastActivityTime.get(id);\n    }\n    /**\n     * Get the inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @returns Inactivity timeout in milliseconds, or undefined if not set\n     */\n    getInactivityTimeout(id) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return undefined;\n        return instance.options.inactivityTimeout;\n    }\n    /**\n     * Set or update the inactivity timeout for a kernel\n     * @param id Kernel ID\n     * @param timeout Timeout in milliseconds, or 0 to disable\n     * @returns True if the timeout was set, false if the kernel was not found\n     */\n    setInactivityTimeout(id, timeout) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return false;\n        // Update the timeout in the options\n        instance.options.inactivityTimeout = timeout;\n        // Clear any existing timer\n        this.clearInactivityTimeout(id);\n        // If timeout is greater than 0, set up a new timer\n        if (timeout > 0) {\n            this.setupInactivityTimeout(id, timeout);\n        }\n        return true;\n    }\n    /**\n     * Get time until auto-shutdown for a kernel\n     * @param id Kernel ID\n     * @returns Time in milliseconds until auto-shutdown, or undefined if no timeout is set\n     */\n    getTimeUntilShutdown(id) {\n        const instance = this.kernels.get(id);\n        if (!instance)\n            return undefined;\n        const timeout = instance.options.inactivityTimeout;\n        if (!timeout || timeout <= 0)\n            return undefined;\n        const lastActivity = this.lastActivityTime.get(id);\n        if (!lastActivity)\n            return undefined;\n        const elapsedTime = Date.now() - lastActivity;\n        const remainingTime = timeout - elapsedTime;\n        return Math.max(0, remainingTime);\n    }\n    /**\n     * Get the map of inactivity timers (for debugging/testing only)\n     * @returns Object with kernel IDs as keys and timer IDs as values\n     */\n    getInactivityTimers() {\n        // Convert Map to Object for easier inspection\n        const timers = {};\n        this.inactivityTimers.forEach((value, key) => {\n            timers[key] = value;\n        });\n        return timers;\n    }\n    /**\n     * Set up a handler for stalled executions\n     * @param id Kernel ID\n     * @private\n     */\n    setupStalledExecutionHandler(id) {\n        // Listen for stalled execution events\n        super.on(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTION_STALLED, (event) => {\n            if (event.kernelId === id) {\n                console.warn(`Handling stalled execution ${event.executionId} on kernel ${id} (running longer than ${event.maxExecutionTime}ms)`);\n                // Emit an event for clients to handle\n                const instance = this.kernels.get(id);\n                if (instance) {\n                    super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                        kernelId: id,\n                        data: {\n                            ename: \"ExecutionStalledError\",\n                            evalue: `Execution stalled or potentially deadlocked (running > ${event.maxExecutionTime}ms)`,\n                            traceback: [\"Execution may be stuck in an infinite loop or deadlocked.\"]\n                        }\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * Force terminate a potentially stuck kernel\n     * @param id Kernel ID\n     * @param reason Optional reason for termination\n     * @returns Promise resolving to true if the kernel was terminated\n     */\n    async forceTerminateKernel(id, reason = \"Force terminated due to stalled execution\") {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return false;\n        }\n        try {\n            // Log the forced termination\n            console.warn(`Force terminating kernel ${id}: ${reason}`);\n            // Emit an error event to notify clients\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: id,\n                data: {\n                    ename: \"KernelForcedTermination\",\n                    evalue: reason,\n                    traceback: [\"Kernel was forcefully terminated by the system.\"]\n                }\n            });\n            // Destroy the kernel\n            await this.destroyKernel(id);\n            return true;\n        }\n        catch (error) {\n            console.error(`Error during forced termination of kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Get information about ongoing executions for a kernel\n     * @param id Kernel ID\n     * @returns Information about ongoing executions with accurate timing\n     */\n    getExecutionInfo(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return { count: 0, isStuck: false, executionIds: [], executions: [] };\n        }\n        // Handle partially initialized kernels where options may not be fully set\n        if (!instance.options) {\n            return { count: 0, isStuck: false, executionIds: [], executions: [] };\n        }\n        const executionIds = this.ongoingExecutions.get(id)\n            ? Array.from(this.ongoingExecutions.get(id))\n            : [];\n        const count = executionIds.length;\n        const currentTime = Date.now();\n        const maxExecutionTime = instance.options.maxExecutionTime;\n        // Build detailed execution information\n        const executions = [];\n        let longestRunningTime = undefined;\n        let anyStuck = false;\n        // Get execution start times and metadata\n        const startTimes = this.executionStartTimes.get(id);\n        const metadata = this.executionMetadata.get(id);\n        for (const executionId of executionIds) {\n            const startTime = startTimes?.get(executionId);\n            const execMetadata = metadata?.get(executionId);\n            if (startTime !== undefined) {\n                const runtime = currentTime - startTime;\n                const isStuck = maxExecutionTime !== undefined && runtime > maxExecutionTime;\n                executions.push({\n                    id: executionId,\n                    startTime,\n                    runtime,\n                    code: execMetadata?.code,\n                    isStuck\n                });\n                // Track longest running time\n                if (longestRunningTime === undefined || runtime > longestRunningTime) {\n                    longestRunningTime = runtime;\n                }\n                // Track if any execution is stuck\n                if (isStuck) {\n                    anyStuck = true;\n                }\n            }\n            else {\n                // Fallback for executions without start time tracking\n                console.warn(`No start time found for execution ${executionId} on kernel ${id}`);\n                executions.push({\n                    id: executionId,\n                    startTime: 0,\n                    runtime: 0,\n                    code: execMetadata?.code,\n                    isStuck: false\n                });\n            }\n        }\n        // Sort executions by start time (oldest first)\n        executions.sort((a, b) => a.startTime - b.startTime);\n        return {\n            count,\n            isStuck: anyStuck,\n            executionIds,\n            longestRunningTime,\n            executions\n        };\n    }\n    /**\n     * Execute Python code in a kernel\n     * Uses executeStream to collect all outputs and return them\n     * @param kernelId ID of the kernel to use\n     * @param code Python code to execute\n     * @param parent Optional parent message header\n     * @returns Promise resolving to execution result with collected outputs\n     */\n    async execute(kernelId, code, parent = {}) {\n        const instance = this.getKernel(kernelId);\n        if (!instance) {\n            throw new Error(`Kernel with ID ${kernelId} not found`);\n        }\n        return await instance.kernel.execute(code, parent);\n    }\n    /**\n     * Check if a kernel type is allowed\n     * @param mode Kernel mode\n     * @param language Kernel language\n     * @returns True if the kernel type is allowed\n     * @private\n     */\n    isKernelTypeAllowed(mode, language) {\n        return this.allowedKernelTypes.some(type => type.mode === mode && type.language === language);\n    }\n    /**\n     * Get the list of allowed kernel types\n     * @returns Array of allowed kernel type configurations\n     */\n    getAllowedKernelTypes() {\n        return [...this.allowedKernelTypes]; // Return a copy to prevent modification\n    }\n    /**\n     * Ping a kernel to reset its activity timer and extend the deadline\n     * @param id Kernel ID\n     * @returns True if the kernel was pinged successfully, false if not found\n     */\n    pingKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            return false;\n        }\n        // Update kernel activity (this will reset the inactivity timer)\n        this.updateKernelActivity(id);\n        return true;\n    }\n    /**\n     * Restart a kernel by destroying it and creating a new one with the same ID and configuration\n     * @param id Kernel ID\n     * @returns Promise resolving to true if the kernel was restarted successfully, false if not found\n     */\n    async restartKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            console.warn(`Cannot restart kernel ${id}: kernel not found`);\n            return false;\n        }\n        try {\n            // Store the current configuration\n            const currentConfig = {\n                mode: instance.mode,\n                language: instance.language,\n                options: { ...instance.options }\n            };\n            // Extract namespace from ID if present\n            let namespace;\n            let baseId;\n            if (id.includes(':')) {\n                const parts = id.split(':');\n                namespace = parts[0];\n                baseId = parts[1];\n            }\n            else {\n                baseId = id;\n            }\n            // Destroy the existing kernel\n            await this.destroyKernel(id);\n            // Create a new kernel with the same configuration\n            const restartOptions = {\n                id: baseId,\n                mode: currentConfig.mode,\n                lang: currentConfig.language,\n                namespace,\n                deno: currentConfig.options.deno,\n                filesystem: currentConfig.options.filesystem,\n                inactivityTimeout: currentConfig.options.inactivityTimeout,\n                maxExecutionTime: currentConfig.options.maxExecutionTime\n            };\n            // Create the new kernel\n            const newKernelId = await this.createKernel(restartOptions);\n            // Verify the new kernel has the same ID\n            if (newKernelId !== id) {\n                console.error(`Kernel restart failed: expected ID ${id}, got ${newKernelId}`);\n                return false;\n            }\n            return true;\n        }\n        catch (error) {\n            console.error(`Error restarting kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Interrupt a running kernel execution\n     * @param id Kernel ID\n     * @returns Promise resolving to true if the interrupt was successful, false if not found or failed\n     */\n    async interruptKernel(id) {\n        const instance = this.kernels.get(id);\n        if (!instance) {\n            console.warn(`Cannot interrupt kernel ${id}: kernel not found`);\n            return false;\n        }\n        try {\n            if (instance.mode === KernelMode.WORKER && instance.worker) {\n                // For worker kernels, use SharedArrayBuffer interrupt method\n                return await this.interruptWorkerKernel(id, instance);\n            }\n            else {\n                // For main thread kernels, try to interrupt (will throw error if not supported)\n                return await this.interruptMainThreadKernel(id, instance);\n            }\n        }\n        catch (error) {\n            console.error(`Error interrupting kernel ${id}:`, error instanceof Error ? error.message : String(error));\n            return false;\n        }\n    }\n    /**\n     * Interrupt a main thread kernel\n     * @param id Kernel ID\n     * @param instance Kernel instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptMainThreadKernel(id, instance) {\n        // Main thread kernels don't support proper interruption like worker kernels do\n        // Even if they have an interrupt method, it's limited and unreliable\n        throw new Error(`Main thread kernel ${id} does not support reliable interruption. Use worker kernels for interruptible execution.`);\n    }\n    /**\n     * Interrupt a worker kernel using SharedArrayBuffer according to Pyodide documentation\n     * @param id Kernel ID\n     * @param instance Kernel instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptWorkerKernel(id, instance) {\n        try {\n            const worker = instance.worker;\n            if (!worker) {\n                console.error(`Worker not found for kernel ${id}`);\n                return false;\n            }\n            // If interruption mode is 'kernel-interrupt', use fallback directly\n            if (this.interruptionMode === 'kernel-interrupt') {\n                return await this.interruptWorkerKernelFallback(id, worker);\n            }\n            // Check if we already have an interrupt buffer for this kernel\n            let interruptBuffer = this.interruptBuffers.get(id);\n            if (!interruptBuffer) {\n                // Create a new SharedArrayBuffer for interrupt control\n                try {\n                    // Try to create SharedArrayBuffer (requires specific security headers)\n                    const sharedBuffer = new SharedArrayBuffer(1);\n                    interruptBuffer = new Uint8Array(sharedBuffer);\n                    // Initialize buffer to 0 (no interrupt signal)\n                    interruptBuffer[0] = 0;\n                    // Store the buffer for future use\n                    this.interruptBuffers.set(id, interruptBuffer);\n                    // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n                    worker.postMessage({\n                        type: \"SET_INTERRUPT_BUFFER\",\n                        buffer: interruptBuffer\n                    });\n                    // Wait for the worker to confirm buffer setup\n                    await new Promise((resolve, reject) => {\n                        const timeout = setTimeout(() => {\n                            reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n                        }, 2000);\n                        const handler = (event) => {\n                            if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n                                worker.removeEventListener(\"message\", handler);\n                                clearTimeout(timeout);\n                                resolve();\n                            }\n                        };\n                        worker.addEventListener(\"message\", handler);\n                    });\n                    console.log(`Interrupt buffer set up for kernel ${id}`);\n                }\n                catch (error) {\n                    // Handle based on interruption mode\n                    if (this.interruptionMode === 'shared-array-buffer') {\n                        // If explicitly set to shared-array-buffer, this is an error\n                        console.error(`âŒ Cannot create SharedArrayBuffer for interrupt handling in kernel ${id}`);\n                        throw new Error(`SharedArrayBuffer is required for interruption mode 'shared-array-buffer' but is not available.\n\nTo fix this issue, either:\n1. Configure your web server with these headers:\n   - Cross-Origin-Opener-Policy: same-origin\n   - Cross-Origin-Embedder-Policy: require-corp\n\n2. Or change the interruption mode when creating KernelManager:\n   new KernelManager({ interruptionMode: 'auto' })`);\n                    }\n                    else {\n                        // Auto mode: fall back to kernel.interrupt()\n                        console.info(`â„¹ï¸ Using message-based interrupt for kernel ${id} (SharedArrayBuffer not available)`);\n                        // Fallback: use message-based interrupt\n                        return await this.interruptWorkerKernelFallback(id, worker);\n                    }\n                }\n            }\n            // According to Pyodide docs: Set interrupt signal (2 = SIGINT)\n            console.log(`Setting interrupt signal for kernel ${id}...`);\n            interruptBuffer[0] = 2;\n            // Wait for Pyodide to process the interrupt\n            // Pyodide will reset the buffer to 0 when it processes the interrupt\n            let attempts = 0;\n            const maxAttempts = 50; // Check for up to 5 seconds (50 * 100ms)\n            while (attempts < maxAttempts && interruptBuffer[0] !== 0) {\n                await new Promise(resolve => setTimeout(resolve, 100));\n                attempts++;\n            }\n            if (interruptBuffer[0] === 0) {\n                console.log(`Interrupt processed successfully for kernel ${id} after ${attempts * 100}ms`);\n                return true;\n            }\n            else {\n                console.warn(`Interrupt signal not processed for kernel ${id} after ${maxAttempts * 100}ms`);\n                // Still return true as we set the signal - the interrupt may be processed later\n                return true;\n            }\n        }\n        catch (error) {\n            console.error(`Error interrupting worker kernel ${id}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Fallback interrupt method for worker kernels when SharedArrayBuffer is not available\n     * @param id Kernel ID\n     * @param worker Worker instance\n     * @returns Promise resolving to interrupt success\n     * @private\n     */\n    async interruptWorkerKernelFallback(id, worker) {\n        return new Promise((resolve) => {\n            // Set up a listener for the interrupt response\n            const responseHandler = (event) => {\n                if (event.data?.type === \"INTERRUPT_TRIGGERED\") {\n                    worker.removeEventListener(\"message\", responseHandler);\n                    const success = event.data.data?.success || false;\n                    resolve(success);\n                }\n            };\n            // Listen for the response\n            worker.addEventListener(\"message\", responseHandler);\n            // Send the interrupt message\n            worker.postMessage({\n                type: \"INTERRUPT_KERNEL\"\n            });\n            // Set a timeout in case we don't get a response\n            setTimeout(() => {\n                worker.removeEventListener(\"message\", responseHandler);\n                console.warn(`â±ï¸ Interrupt request timed out for kernel ${id} after 5 seconds.\nThis may happen if:\n- The kernel is running code that cannot be interrupted\n- The kernel is in an unresponsive state\nYou may need to restart the kernel if it remains unresponsive.`);\n                resolve(false);\n            }, 5000); // 5 second timeout\n        });\n    }\n    /**\n     * Handle a stuck execution with configurable strategies\n     * @param kernelId Kernel ID\n     * @param executionId Execution ID that's stuck\n     * @param actualRuntime How long the execution has been running\n     * @param code The code that was being executed\n     * @private\n     */\n    async handleStuckExecution(kernelId, executionId, actualRuntime, code) {\n        const instance = this.kernels.get(kernelId);\n        if (!instance) {\n            return;\n        }\n        console.warn(`Handling stuck execution ${executionId} on kernel ${kernelId} (runtime: ${actualRuntime}ms)`);\n        // Strategy 1: Try to interrupt the kernel first\n        const interruptSuccess = await this.interruptKernel(kernelId);\n        if (interruptSuccess) {\n            console.log(`Successfully interrupted kernel ${kernelId}`);\n            // Emit an execution error to notify clients\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: kernelId,\n                data: {\n                    ename: \"ExecutionInterrupted\",\n                    evalue: `Execution automatically interrupted after ${actualRuntime}ms (exceeded maxExecutionTime)`,\n                    traceback: [\n                        `Execution was automatically interrupted due to timeout.`,\n                        `Runtime: ${actualRuntime}ms`,\n                        `Max allowed: ${instance.options.maxExecutionTime}ms`,\n                        code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n                    ]\n                }\n            });\n            return;\n        }\n        // Strategy 2: If interrupt failed, try restarting the kernel\n        console.warn(`Interrupt failed for kernel ${kernelId}, attempting restart...`);\n        const restartSuccess = await this.restartKernel(kernelId);\n        if (restartSuccess) {\n            console.log(`Successfully restarted kernel ${kernelId}`);\n            // Emit a restart notification\n            super.emit(_types__WEBPACK_IMPORTED_MODULE_1__.KernelEvents.EXECUTE_ERROR, {\n                kernelId: kernelId,\n                data: {\n                    ename: \"KernelRestarted\",\n                    evalue: `Kernel automatically restarted due to stuck execution (runtime: ${actualRuntime}ms)`,\n                    traceback: [\n                        `Kernel was automatically restarted due to stuck execution.`,\n                        `Runtime: ${actualRuntime}ms`,\n                        `Max allowed: ${instance.options.maxExecutionTime}ms`,\n                        `Interrupt attempt failed, kernel was restarted instead.`,\n                        code ? `Code: ${code.substring(0, 200)}${code.length > 200 ? '...' : ''}` : 'Code: <unknown>'\n                    ]\n                }\n            });\n            return;\n        }\n        // Strategy 3: If restart failed, force terminate the kernel\n        console.error(`Restart failed for kernel ${kernelId}, force terminating...`);\n        const terminateSuccess = await this.forceTerminateKernel(kernelId, `Stuck execution could not be interrupted or restarted (runtime: ${actualRuntime}ms)`);\n        if (terminateSuccess) {\n            console.log(`Successfully terminated kernel ${kernelId}`);\n        }\n        else {\n            console.error(`Failed to terminate kernel ${kernelId} - manual intervention may be required`);\n            // Emit a critical error\n            super.emit('kernel_unrecoverable', {\n                kernelId: kernelId,\n                executionId: executionId,\n                actualRuntime: actualRuntime,\n                code: code,\n                message: 'Kernel is stuck and could not be recovered through interrupt, restart, or termination'\n            });\n        }\n    }\n    /**\n     * Get detailed information about stuck executions across all kernels\n     * @returns Array of stuck execution details\n     */\n    getStuckExecutions() {\n        const stuckExecutions = [];\n        const currentTime = Date.now();\n        for (const [kernelId, instance] of this.kernels.entries()) {\n            // Skip pool kernels\n            if (kernelId.startsWith(\"pool-\"))\n                continue;\n            // Skip kernels without maxExecutionTime configured\n            if (!instance.options?.maxExecutionTime || instance.options.maxExecutionTime <= 0) {\n                continue;\n            }\n            const maxExecutionTime = instance.options.maxExecutionTime;\n            const startTimes = this.executionStartTimes.get(kernelId);\n            const metadata = this.executionMetadata.get(kernelId);\n            const ongoingExecs = this.ongoingExecutions.get(kernelId);\n            if (!ongoingExecs || ongoingExecs.size === 0) {\n                continue;\n            }\n            for (const executionId of ongoingExecs) {\n                const startTime = startTimes?.get(executionId);\n                if (startTime === undefined)\n                    continue;\n                const runtime = currentTime - startTime;\n                // Check if this execution is stuck\n                if (runtime > maxExecutionTime) {\n                    const execMetadata = metadata?.get(executionId);\n                    stuckExecutions.push({\n                        kernelId,\n                        executionId,\n                        startTime,\n                        runtime,\n                        maxAllowed: maxExecutionTime,\n                        code: execMetadata?.code,\n                        kernelMode: instance.mode,\n                        kernelLanguage: instance.language\n                    });\n                }\n            }\n        }\n        // Sort by runtime (longest running first)\n        stuckExecutions.sort((a, b) => b.runtime - a.runtime);\n        return stuckExecutions;\n    }\n    /**\n     * Force interrupt all stuck executions across all kernels\n     * @returns Promise resolving to array of intervention results\n     */\n    async handleAllStuckExecutions() {\n        const stuckExecutions = this.getStuckExecutions();\n        const results = [];\n        console.log(`Found ${stuckExecutions.length} stuck executions to handle`);\n        // Group by kernel to avoid multiple interventions on the same kernel\n        const kernelGroups = new Map();\n        for (const exec of stuckExecutions) {\n            if (!kernelGroups.has(exec.kernelId)) {\n                kernelGroups.set(exec.kernelId, []);\n            }\n            kernelGroups.get(exec.kernelId).push(exec);\n        }\n        // Handle each kernel's stuck executions\n        for (const [kernelId, executions] of kernelGroups) {\n            try {\n                // Pick the longest running execution as the primary one\n                const primaryExec = executions[0]; // Already sorted by runtime desc\n                console.log(`Handling stuck kernel ${kernelId} with ${executions.length} stuck executions (primary: ${primaryExec.runtime}ms)`);\n                // Use the automated handling system\n                await this.handleStuckExecution(kernelId, primaryExec.executionId, primaryExec.runtime, primaryExec.code);\n                // Mark all executions for this kernel as handled\n                for (const exec of executions) {\n                    results.push({\n                        kernelId: exec.kernelId,\n                        executionId: exec.executionId,\n                        action: 'interrupted', // We don't know the exact action, but it was handled\n                        success: true\n                    });\n                }\n            }\n            catch (error) {\n                console.error(`Error handling stuck executions for kernel ${kernelId}:`, error);\n                // Mark all executions for this kernel as failed\n                for (const exec of executions) {\n                    results.push({\n                        kernelId: exec.kernelId,\n                        executionId: exec.executionId,\n                        action: 'failed',\n                        success: false,\n                        error: error instanceof Error ? error.message : String(error)\n                    });\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * Set up interrupt buffer for a worker kernel during creation\n     * @param id Kernel ID\n     * @param worker Worker instance\n     * @private\n     */\n    async setupWorkerInterruptBuffer(id, worker) {\n        // Skip SharedArrayBuffer setup if mode is 'kernel-interrupt'\n        if (this.interruptionMode === 'kernel-interrupt') {\n            console.log(`Skipping SharedArrayBuffer setup for kernel ${id} - using kernel.interrupt() mode`);\n            return;\n        }\n        try {\n            // Python kernels support interrupt buffers\n            // For Python kernels, create actual SharedArrayBuffer\n            const sharedBuffer = new SharedArrayBuffer(1);\n            const interruptBuffer = new Uint8Array(sharedBuffer);\n            // Initialize buffer to 0 (no interrupt signal)\n            interruptBuffer[0] = 0;\n            // Store the buffer for future use\n            this.interruptBuffers.set(id, interruptBuffer);\n            // Send the buffer to the worker to set up pyodide.setInterruptBuffer()\n            worker.postMessage({\n                type: \"SET_INTERRUPT_BUFFER\",\n                buffer: interruptBuffer\n            });\n            // Wait for the worker to confirm buffer setup\n            await new Promise((resolve, reject) => {\n                const timeout = setTimeout(() => {\n                    reject(new Error(\"Timeout waiting for interrupt buffer setup\"));\n                }, 5000);\n                const handler = (event) => {\n                    if (event.data?.type === \"INTERRUPT_BUFFER_SET\") {\n                        worker.removeEventListener(\"message\", handler);\n                        clearTimeout(timeout);\n                        resolve();\n                    }\n                };\n                worker.addEventListener(\"message\", handler);\n            });\n        }\n        catch (error) {\n            // Handle based on interruption mode\n            if (this.interruptionMode === 'shared-array-buffer') {\n                // If explicitly set to shared-array-buffer, this is an error\n                console.error(`âŒ SharedArrayBuffer required but not available for kernel ${id}`);\n                throw new Error(`SharedArrayBuffer is required but not available. To enable SharedArrayBuffer, your server must set these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nAlternatively, use interruptionMode: 'kernel-interrupt' or 'auto' in KernelManager options.`);\n            }\n            else {\n                // Auto mode: fall back to kernel.interrupt()\n                console.info(`â„¹ï¸ SharedArrayBuffer not available for kernel ${id}. Using alternative interrupt method.\n\nTo enable faster interrupts, configure your server with these headers:\n- Cross-Origin-Opener-Policy: same-origin\n- Cross-Origin-Embedder-Policy: require-corp\n\nNote: Some development servers (e.g., Vite, webpack-dev-server) can be configured to add these headers.\nThe alternative interrupt method will still work but may be less responsive for long-running code.`);\n                // Don't throw - kernel can still work without interrupt buffer\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNLElBQUksS0FBSyxDQUFDOzs7OzRGQUlvRSxDQUFDLENBQUM7WUFDeEYsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLDZDQUE2QztnQkFDN0MsT0FBTyxDQUFDLElBQUksQ0FBQyxpREFBaUQsRUFBRTs7Ozs7OzttR0FPMkIsQ0FBQyxDQUFDO2dCQUM3RiwrREFBK0Q7WUFDakUsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO0NBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItcHl0aG9uLWtlcm5lbC8uL3NyYy9tYW5hZ2VyLnRzPzkzNmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gS2VybmVsIE1hbmFnZXIgZm9yIERlbm8gQXBwIEVuZ2luZVxuLy8gVGhpcyBmaWxlIG1hbmFnZXMga2VybmVsIGluc3RhbmNlcyBpbiBlaXRoZXIgbWFpbiB0aHJlYWQgb3Igd29ya2VyIG1vZGVcblxuaW1wb3J0ICogYXMgQ29tbGluayBmcm9tIFwiY29tbGlua1wiO1xuLy8gQHRzLWlnbm9yZSBJbXBvcnRpbmcgZnJvbSBucG1cbi8vIFVzZSBhIGJyb3dzZXItY29tcGF0aWJsZSBFdmVudEVtaXR0ZXJcbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUgZXZlbnRzOiB7IFtrZXk6IHN0cmluZ106IEZ1bmN0aW9uW10gfSA9IHt9O1xuXG4gIG9uKGV2ZW50TmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogRnVuY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIG9mZihldmVudE5hbWU6IHN0cmluZywgbGlzdGVuZXI6IEZ1bmN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSByZXR1cm47XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbikge1xuICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgZW1pdChldmVudE5hbWU6IHN0cmluZywgLi4uYXJnczogYW55W10pIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHJldHVybjtcbiAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoLi4uYXJncykpO1xuICB9XG5cbiAgc2V0TWF4TGlzdGVuZXJzKG46IG51bWJlcikge1xuICAgIC8vIE5vLW9wIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHlcbiAgfVxufVxuaW1wb3J0IHsgS2VybmVsRXZlbnRzLCBJS2VybmVsLCBJS2VybmVsT3B0aW9ucywgSUZpbGVzeXN0ZW1Nb3VudE9wdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgS2VybmVsIH0gZnJvbSBcIi4vaW5kZXhcIjtcblxuLy8gUmUtZXhwb3J0IEtlcm5lbEV2ZW50cyBmb3IgdGVzdCB1c2FnZVxuZXhwb3J0IHsgS2VybmVsRXZlbnRzIH07XG5cbi8vIEV4ZWN1dGlvbiBtb2RlIGVudW1cbmV4cG9ydCBlbnVtIEtlcm5lbE1vZGUge1xuICBNQUlOX1RIUkVBRCA9IFwibWFpbl90aHJlYWRcIixcbiAgV09SS0VSID0gXCJ3b3JrZXJcIlxufVxuXG4vLyBLZXJuZWwgbGFuZ3VhZ2UgZW51bVxuZXhwb3J0IGVudW0gS2VybmVsTGFuZ3VhZ2Uge1xuICBQWVRIT04gPSBcInB5dGhvblwiXG59XG5cbi8vIEV4dGVuZGVkIFdvcmtlck9wdGlvbnMgaW50ZXJmYWNlIHRvIGluY2x1ZGUgRGVubyBwZXJtaXNzaW9uc1xuaW50ZXJmYWNlIFdvcmtlck9wdGlvbnMge1xuICB0eXBlPzogXCJjbGFzc2ljXCIgfCBcIm1vZHVsZVwiO1xuICBuYW1lPzogc3RyaW5nO1xuICBkZW5vPzoge1xuICAgIHBlcm1pc3Npb25zPzogSURlbm9QZXJtaXNzaW9ucztcbiAgfTtcbn1cblxuLy8gSW50ZXJmYWNlIGZvciBrZXJuZWwgcG9vbCBjb25maWd1cmF0aW9uXG5leHBvcnQgaW50ZXJmYWNlIElLZXJuZWxQb29sQ29uZmlnIHtcbiAgZW5hYmxlZDogYm9vbGVhbjtcbiAgcG9vbFNpemU6IG51bWJlcjsgLy8gTnVtYmVyIG9mIGtlcm5lbHMgdG8ga2VlcCByZWFkeSBwZXIgY29uZmlndXJhdGlvblxuICBhdXRvUmVmaWxsOiBib29sZWFuOyAvLyBXaGV0aGVyIHRvIGF1dG9tYXRpY2FsbHkgcmVmaWxsIHRoZSBwb29sIHdoZW4ga2VybmVscyBhcmUgdGFrZW5cbiAgcHJlbG9hZENvbmZpZ3M6IEFycmF5PHtcbiAgICBtb2RlOiBLZXJuZWxNb2RlO1xuICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgfT47IC8vIENvbmZpZ3VyYXRpb25zIHRvIHByZWxvYWQgaW4gdGhlIHBvb2xcbn1cblxuLy8gSW50ZXJmYWNlIGZvciBrZXJuZWwgbWFuYWdlciBvcHRpb25zXG5leHBvcnQgaW50ZXJmYWNlIElLZXJuZWxNYW5hZ2VyT3B0aW9ucyB7XG4gIHBvb2w/OiBJS2VybmVsUG9vbENvbmZpZztcbiAgYWxsb3dlZEtlcm5lbFR5cGVzPzogQXJyYXk8e1xuICAgIG1vZGU6IEtlcm5lbE1vZGU7XG4gICAgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlO1xuICB9PjsgLy8gUmVzdHJpY3Qgd2hpY2gga2VybmVsIHR5cGVzIGNhbiBiZSBjcmVhdGVkXG4gIGludGVycnVwdGlvbk1vZGU/OiAnc2hhcmVkLWFycmF5LWJ1ZmZlcicgfCAna2VybmVsLWludGVycnVwdCcgfCAnYXV0byc7IC8vIERlZmF1bHQ6ICdhdXRvJ1xuICB3b3JrZXJVcmw/OiBzdHJpbmc7IC8vIE9wdGlvbmFsIGN1c3RvbSBVUkwgZm9yIHRoZSB3b3JrZXIgc2NyaXB0XG59XG5cbi8vIEludGVyZmFjZSBmb3Iga2VybmVsIGluc3RhbmNlXG5leHBvcnQgaW50ZXJmYWNlIElLZXJuZWxJbnN0YW5jZSB7XG4gIGlkOiBzdHJpbmc7XG4gIGtlcm5lbDogSUtlcm5lbDtcbiAgbW9kZTogS2VybmVsTW9kZTtcbiAgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlO1xuICB3b3JrZXI/OiBXb3JrZXI7XG4gIGNyZWF0ZWQ6IHN0cmluZztcbiAgb3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zO1xuICBpc0Zyb21Qb29sPzogYm9vbGVhbjsgLy8gVHJhY2sgaWYgdGhpcyBrZXJuZWwgY2FtZSBmcm9tIHRoZSBwb29sXG4gIGRlc3Ryb3koKTogUHJvbWlzZTx2b2lkPjtcbn1cblxuLy8gSW50ZXJmYWNlIGZvciBEZW5vIHdvcmtlciBwZXJtaXNzaW9uc1xuZXhwb3J0IGludGVyZmFjZSBJRGVub1Blcm1pc3Npb25zIHtcbiAgcmVhZD86IChzdHJpbmcgfCBVUkwpW107XG4gIHdyaXRlPzogKHN0cmluZyB8IFVSTClbXTtcbiAgbmV0Pzogc3RyaW5nW107XG4gIGVudj86IHN0cmluZ1tdO1xuICBydW4/OiBzdHJpbmdbXTtcbiAgZmZpPzogc3RyaW5nW107XG4gIGhydGltZT86IGJvb2xlYW47XG59XG5cbi8vIEludGVyZmFjZSBmb3Iga2VybmVsIGNyZWF0aW9uIG9wdGlvbnNcbmV4cG9ydCBpbnRlcmZhY2UgSU1hbmFnZXJLZXJuZWxPcHRpb25zIHtcbiAgaWQ/OiBzdHJpbmc7XG4gIG1vZGU/OiBLZXJuZWxNb2RlO1xuICBsYW5nPzogS2VybmVsTGFuZ3VhZ2U7XG4gIG5hbWVzcGFjZT86IHN0cmluZztcbiAgZGVubz86IHtcbiAgICBwZXJtaXNzaW9ucz86IElEZW5vUGVybWlzc2lvbnM7XG4gIH07XG4gIGZpbGVzeXN0ZW0/OiBJRmlsZXN5c3RlbU1vdW50T3B0aW9ucztcbiAgZW52PzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjsgLy8gRW52aXJvbm1lbnQgdmFyaWFibGVzIHRvIHNldCBpbiB0aGUga2VybmVsXG4gIGxvY2tGaWxlVVJMPzogc3RyaW5nOyAvLyBVUkwgdG8gcHlvZGlkZS1sb2NrLmpzb24gZmlsZSBmb3IgZmFzdGVyIGxvYWRpbmdcbiAgYXV0b1N5bmNGcz86IGJvb2xlYW47IC8vIEF1dG9tYXRpY2FsbHkgc3luYyBuYXRpdmUgZmlsZXN5c3RlbSBhZnRlciBjb2RlIGV4ZWN1dGlvbiAoZGVmYXVsdDogZmFsc2UpXG4gIGluYWN0aXZpdHlUaW1lb3V0PzogbnVtYmVyOyAvLyBUaW1lIGluIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCBhbiBpbmFjdGl2ZSBrZXJuZWwgd2lsbCBiZSBzaHV0IGRvd25cbiAgbWF4RXhlY3V0aW9uVGltZT86IG51bWJlcjsgLy8gTWF4aW11bSB0aW1lIGluIG1pbGxpc2Vjb25kcyBhIHNpbmdsZSBleGVjdXRpb24gY2FuIHJ1biBiZWZvcmUgY29uc2lkZXJlZCBzdHVjay9kZWFkXG59XG5cbi8vIEhlbHBlciB0eXBlIGZvciBsaXN0ZW5lciBtYW5hZ2VtZW50XG50eXBlIExpc3RlbmVyV3JhcHBlciA9IHtcbiAgb3JpZ2luYWw6IChkYXRhOiBhbnkpID0+IHZvaWQ7XG4gIHdyYXBwZWQ6IChldmVudDogeyBrZXJuZWxJZDogc3RyaW5nLCBkYXRhOiBhbnkgfSkgPT4gdm9pZDtcbn07XG5cbi8qKlxuICogS2VybmVsTWFuYWdlciBjbGFzcyBtYW5hZ2VzIG11bHRpcGxlIGtlcm5lbCBpbnN0YW5jZXMgXG4gKiBpbiBlaXRoZXIgbWFpbiB0aHJlYWQgb3Igd29ya2VyIG1vZGVcbiAqL1xuZXhwb3J0IGNsYXNzIEtlcm5lbE1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGtlcm5lbHM6IE1hcDxzdHJpbmcsIElLZXJuZWxJbnN0YW5jZT4gPSBuZXcgTWFwKCk7XG4gIC8vIFRyYWNrIGxpc3RlbmVycyBmb3IgZWFjaCBrZXJuZWwgdG8gZW5hYmxlIGluZGl2aWR1YWwgcmVtb3ZhbFxuICBwcml2YXRlIGxpc3RlbmVyV3JhcHBlcnM6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIE1hcDxGdW5jdGlvbiwgTGlzdGVuZXJXcmFwcGVyPj4+ID0gbmV3IE1hcCgpO1xuICAvLyBUcmFjayBsYXN0IGFjdGl2aXR5IHRpbWUgZm9yIGVhY2gga2VybmVsXG4gIHByaXZhdGUgbGFzdEFjdGl2aXR5VGltZTogTWFwPHN0cmluZywgbnVtYmVyPiA9IG5ldyBNYXAoKTtcbiAgLy8gU3RvcmUgaW5hY3Rpdml0eSB0aW1lcnMgZm9yIGVhY2gga2VybmVsXG4gIHByaXZhdGUgaW5hY3Rpdml0eVRpbWVyczogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXAoKTtcbiAgLy8gVHJhY2sgb25nb2luZyBleGVjdXRpb25zIGZvciBlYWNoIGtlcm5lbFxuICBwcml2YXRlIG9uZ29pbmdFeGVjdXRpb25zOiBNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj4gPSBuZXcgTWFwKCk7XG4gIC8vIFRyYWNrIGV4ZWN1dGlvbiB0aW1lb3V0cyBmb3IgZGV0ZWN0aW5nIHN0dWNrL2RlYWQga2VybmVsc1xuICBwcml2YXRlIGV4ZWN1dGlvblRpbWVvdXRzOiBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBhbnk+PiA9IG5ldyBNYXAoKTtcbiAgLy8gVHJhY2sgZXhlY3V0aW9uIHN0YXJ0IHRpbWVzIGZvciBhY2N1cmF0ZSBkdXJhdGlvbiBjYWxjdWxhdGlvblxuICBwcml2YXRlIGV4ZWN1dGlvblN0YXJ0VGltZXM6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIG51bWJlcj4+ID0gbmV3IE1hcCgpO1xuICAvLyBUcmFjayBleGVjdXRpb24gbWV0YWRhdGEgZm9yIGJldHRlciBtb25pdG9yaW5nXG4gIHByaXZhdGUgZXhlY3V0aW9uTWV0YWRhdGE6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIHsgc3RhcnRUaW1lOiBudW1iZXI7IGNvZGU/OiBzdHJpbmc7IHRpbWVvdXRJZD86IGFueSB9Pj4gPSBuZXcgTWFwKCk7XG4gIFxuICAvLyBUcmFjayBBYm9ydENvbnRyb2xsZXJzIGZvciBlYWNoIGtlcm5lbCdzIG9uZ29pbmcgb3BlcmF0aW9uc1xuICBwcml2YXRlIGFib3J0Q29udHJvbGxlcnM6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIEFib3J0Q29udHJvbGxlcj4+ID0gbmV3IE1hcCgpO1xuICBcbiAgLy8gUG9vbCBtYW5hZ2VtZW50IC0gbm93IHVzaW5nIHByb21pc2VzIGZvciBpbW1lZGlhdGUgcmVzcG9uc2VcbiAgcHJpdmF0ZSBwb29sOiBNYXA8c3RyaW5nLCBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT5bXT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcG9vbENvbmZpZzogSUtlcm5lbFBvb2xDb25maWc7XG4gIHByaXZhdGUgaXNQcmVsb2FkaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIC8vIFRyYWNrIHdoaWNoIHBvb2wga2V5cyBhcmUgY3VycmVudGx5IGJlaW5nIHByZWZpbGxlZCB0byBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgcHJpdmF0ZSBwcmVmaWxsaW5nSW5Qcm9ncmVzczogTWFwPHN0cmluZywgYm9vbGVhbj4gPSBuZXcgTWFwKCk7XG4gIFxuICAvLyBBbGxvd2VkIGtlcm5lbCB0eXBlcyBjb25maWd1cmF0aW9uXG4gIHByaXZhdGUgYWxsb3dlZEtlcm5lbFR5cGVzOiBBcnJheTx7XG4gICAgbW9kZTogS2VybmVsTW9kZTtcbiAgICBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gIH0+O1xuICBcbiAgLy8gSW50ZXJydXB0IGJ1ZmZlcnMgZm9yIHdvcmtlciBrZXJuZWxzICh1c2luZyBTaGFyZWRBcnJheUJ1ZmZlcilcbiAgcHJpdmF0ZSBpbnRlcnJ1cHRCdWZmZXJzOiBNYXA8c3RyaW5nLCBVaW50OEFycmF5PiA9IG5ldyBNYXAoKTtcbiAgXG4gIC8vIEludGVycnVwdGlvbiBtb2RlIGNvbmZpZ3VyYXRpb25cbiAgcHJpdmF0ZSBpbnRlcnJ1cHRpb25Nb2RlOiAnc2hhcmVkLWFycmF5LWJ1ZmZlcicgfCAna2VybmVsLWludGVycnVwdCcgfCAnYXV0byc7XG4gIFxuICAvLyBXb3JrZXIgVVJMIGNvbmZpZ3VyYXRpb25cbiAgcHJpdmF0ZSB3b3JrZXJVcmw6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSB3b3JrZXIgVVJMIGJhc2VkIG9uIHRoZSBjdXJyZW50IGVudmlyb25tZW50XG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIFRoZSByZXNvbHZlZCB3b3JrZXIgVVJMXG4gICAqL1xuICBwcml2YXRlIHJlc29sdmVXb3JrZXJVcmwoKTogc3RyaW5nIHtcbiAgICAvLyBJZiBhIGN1c3RvbSB3b3JrZXIgVVJMIGlzIHByb3ZpZGVkLCB1c2UgaXRcbiAgICBpZiAodGhpcy53b3JrZXJVcmwpIHtcbiAgICAgIHJldHVybiB0aGlzLndvcmtlclVybDtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJ5IHRvIGRldGVjdCB0aGUgY3VycmVudCBzY3JpcHQgbG9jYXRpb24gYW5kIGRlcml2ZSB0aGUgd29ya2VyIFVSTFxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgIC8vIEJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICAgIGNvbnN0IGN1cnJlbnRTY3JpcHQgPSAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSkucG9wKCk7XG4gICAgICBcbiAgICAgIGlmIChjdXJyZW50U2NyaXB0ICYmIGN1cnJlbnRTY3JpcHQuc3JjKSB7XG4gICAgICAgIC8vIEdldCB0aGUgYmFzZSBVUkwgZnJvbSB0aGUgY3VycmVudCBzY3JpcHRcbiAgICAgICAgY29uc3Qgc2NyaXB0VXJsID0gbmV3IFVSTChjdXJyZW50U2NyaXB0LnNyYyk7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBzY3JpcHRVcmwuaHJlZi5zdWJzdHJpbmcoMCwgc2NyaXB0VXJsLmhyZWYubGFzdEluZGV4T2YoJy8nKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBsb2FkaW5nIGZyb20gYSBDRE4gKGpzZGVsaXZyLCB1bnBrZywgZXRjLilcbiAgICAgICAgaWYgKHNjcmlwdFVybC5ob3N0bmFtZS5pbmNsdWRlcygnanNkZWxpdnIubmV0JykgfHwgXG4gICAgICAgICAgICBzY3JpcHRVcmwuaG9zdG5hbWUuaW5jbHVkZXMoJ3VucGtnLmNvbScpIHx8XG4gICAgICAgICAgICBzY3JpcHRVcmwuaG9zdG5hbWUuaW5jbHVkZXMoJ2NkbmpzLmNsb3VkZmxhcmUuY29tJykpIHtcbiAgICAgICAgICAvLyBGb3IgQ0ROLCB0aGUgd29ya2VyIHNob3VsZCBiZSBhdCB0aGUgc2FtZSBwYXRoXG4gICAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2tlcm5lbC53b3JrZXIuanNgO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGb3IgbG9jYWwgZGV2ZWxvcG1lbnQgb3IgY3VzdG9tIGRlcGxveW1lbnRzXG4gICAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9rZXJuZWwud29ya2VyLmpzYDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRmFsbGJhY2sgdG8gcmVsYXRpdmUgcGF0aCBmcm9tIGN1cnJlbnQgbG9jYXRpb25cbiAgICAgIGNvbnN0IGJhc2VVcmwgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cmluZygwLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKSk7XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vZGlzdC9rZXJuZWwud29ya2VyLmpzYDtcbiAgICB9XG4gICAgXG4gICAgLy8gTm9kZS5qcyBvciB1bmtub3duIGVudmlyb25tZW50IC0gdXNlIHJlbGF0aXZlIHBhdGhcbiAgICAvLyBUaGlzIG1heSBub3Qgd29yayBpbiBOb2RlLmpzIGJ1dCBpcyBwcm92aWRlZCBhcyBhIGZhbGxiYWNrXG4gICAgcmV0dXJuICcuL2tlcm5lbC53b3JrZXIuanMnO1xuICB9XG4gIFxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIGFuIGVycm9yIGlzIGEgS2V5Ym9hcmRJbnRlcnJ1cHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgaXNLZXlib2FyZEludGVycnVwdChlcnJvcjogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVycm9yICYmIFxuICAgICAgICAgICB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIFxuICAgICAgICAgICAoKCd0eXBlJyBpbiBlcnJvciAmJiBlcnJvci50eXBlID09PSBcIktleWJvYXJkSW50ZXJydXB0XCIpIHx8XG4gICAgICAgICAgICAoJ21lc3NhZ2UnIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiS2V5Ym9hcmRJbnRlcnJ1cHRcIikpKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzdGFuZGFyZGl6ZWQgS2V5Ym9hcmRJbnRlcnJ1cHQgZXJyb3IgcmVzdWx0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZUtleWJvYXJkSW50ZXJydXB0UmVzdWx0KCk6IHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I6IEVycm9yOyByZXN1bHQ6IGFueSB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogbmV3IEVycm9yKFwiS2V5Ym9hcmRJbnRlcnJ1cHQ6IEV4ZWN1dGlvbiBpbnRlcnJ1cHRlZCBieSB1c2VyXCIpLFxuICAgICAgcmVzdWx0OiB7XG4gICAgICAgIHN0YXR1czogXCJlcnJvclwiLFxuICAgICAgICBlbmFtZTogXCJLZXlib2FyZEludGVycnVwdFwiLFxuICAgICAgICBldmFsdWU6IFwiRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXJcIixcbiAgICAgICAgdHJhY2ViYWNrOiBbXCJLZXlib2FyZEludGVycnVwdDogRXhlY3V0aW9uIGludGVycnVwdGVkIGJ5IHVzZXJcIl1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIFxuICAvKipcbiAgICogU3RvcmUgYW4gQWJvcnRDb250cm9sbGVyIGZvciBhIHNwZWNpZmljIGtlcm5lbCBleGVjdXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgc3RvcmVBYm9ydENvbnRyb2xsZXIoa2VybmVsSWQ6IHN0cmluZywgZXhlY3V0aW9uSWQ6IHN0cmluZywgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmFib3J0Q29udHJvbGxlcnMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXJzLnNldChrZXJuZWxJZCwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXJzLmdldChrZXJuZWxJZCkhLnNldChleGVjdXRpb25JZCwgY29udHJvbGxlcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuZCByZXR1cm4gYW4gQWJvcnRDb250cm9sbGVyIGZvciBhIHNwZWNpZmljIGtlcm5lbCBleGVjdXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlQWJvcnRDb250cm9sbGVyKGtlcm5lbElkOiBzdHJpbmcsIGV4ZWN1dGlvbklkOiBzdHJpbmcpOiBBYm9ydENvbnRyb2xsZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGtlcm5lbENvbnRyb2xsZXJzID0gdGhpcy5hYm9ydENvbnRyb2xsZXJzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKCFrZXJuZWxDb250cm9sbGVycykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBcbiAgICBjb25zdCBjb250cm9sbGVyID0ga2VybmVsQ29udHJvbGxlcnMuZ2V0KGV4ZWN1dGlvbklkKTtcbiAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAga2VybmVsQ29udHJvbGxlcnMuZGVsZXRlKGV4ZWN1dGlvbklkKTtcbiAgICAgIGlmIChrZXJuZWxDb250cm9sbGVycy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVycy5kZWxldGUoa2VybmVsSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYm9ydCBhbGwgb25nb2luZyBvcGVyYXRpb25zIGZvciBhIHNwZWNpZmljIGtlcm5lbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhYm9ydEFsbEtlcm5lbE9wZXJhdGlvbnMoa2VybmVsSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGtlcm5lbENvbnRyb2xsZXJzID0gdGhpcy5hYm9ydENvbnRyb2xsZXJzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKCFrZXJuZWxDb250cm9sbGVycykgcmV0dXJuO1xuXG4gICAgZm9yIChjb25zdCBbZXhlY3V0aW9uSWQsIGNvbnRyb2xsZXJdIG9mIGtlcm5lbENvbnRyb2xsZXJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5qrIEFib3J0ZWQgZXhlY3V0aW9uICR7ZXhlY3V0aW9uSWR9IGZvciBrZXJuZWwgJHtrZXJuZWxJZH1gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIEVycm9yIGFib3J0aW5nIGV4ZWN1dGlvbiAke2V4ZWN1dGlvbklkfTpgLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFyIGFsbCBjb250cm9sbGVycyBmb3IgdGhpcyBrZXJuZWxcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlcnMuZGVsZXRlKGtlcm5lbElkKTtcbiAgfVxuICBcbiAgY29uc3RydWN0b3Iob3B0aW9uczogSUtlcm5lbE1hbmFnZXJPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHN1cGVyLnNldE1heExpc3RlbmVycygxMDApOyAvLyBBbGxvdyBtYW55IGxpc3RlbmVycyBmb3Iga2VybmVsIGV2ZW50c1xuICAgIFxuICAgIC8vIFNldCBpbnRlcnJ1cHRpb24gbW9kZSAoZGVmYXVsdCB0byAnYXV0bycpXG4gICAgdGhpcy5pbnRlcnJ1cHRpb25Nb2RlID0gb3B0aW9ucy5pbnRlcnJ1cHRpb25Nb2RlIHx8ICdhdXRvJztcbiAgICBcbiAgICAvLyBTZXQgd29ya2VyIFVSTCBpZiBwcm92aWRlZFxuICAgIHRoaXMud29ya2VyVXJsID0gb3B0aW9ucy53b3JrZXJVcmw7XG4gICAgXG4gICAgLy8gU2V0IGRlZmF1bHQgYWxsb3dlZCBrZXJuZWwgdHlwZXMgKHdvcmtlciBtb2RlIG9ubHkgZm9yIHNlY3VyaXR5KVxuICAgIHRoaXMuYWxsb3dlZEtlcm5lbFR5cGVzID0gb3B0aW9ucy5hbGxvd2VkS2VybmVsVHlwZXMgfHwgW1xuICAgICAgeyBtb2RlOiBLZXJuZWxNb2RlLldPUktFUiwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlLlBZVEhPTiB9XG4gICAgXTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHBvb2wgY29uZmlndXJhdGlvbiB3aXRoIGRlZmF1bHRzIGJhc2VkIG9uIGFsbG93ZWQgdHlwZXNcbiAgICBjb25zdCBkZWZhdWx0UHJlbG9hZENvbmZpZ3MgPSB0aGlzLmFsbG93ZWRLZXJuZWxUeXBlcy5maWx0ZXIodHlwZSA9PiBcbiAgICAgIHR5cGUubGFuZ3VhZ2UgPT09IEtlcm5lbExhbmd1YWdlLlBZVEhPTiAvLyBPbmx5IHByZWxvYWQgUHl0aG9uIGtlcm5lbHMgYnkgZGVmYXVsdFxuICAgICk7XG4gICAgXG4gICAgdGhpcy5wb29sQ29uZmlnID0ge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBwb29sU2l6ZTogMixcbiAgICAgIGF1dG9SZWZpbGw6IHRydWUsXG4gICAgICBwcmVsb2FkQ29uZmlnczogZGVmYXVsdFByZWxvYWRDb25maWdzLFxuICAgICAgLi4ub3B0aW9ucy5wb29sXG4gICAgfTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0aGF0IHBvb2wgcHJlbG9hZCBjb25maWdzIGFyZSB3aXRoaW4gYWxsb3dlZCB0eXBlc1xuICAgIGlmICh0aGlzLnBvb2xDb25maWcucHJlbG9hZENvbmZpZ3MpIHtcbiAgICAgIHRoaXMucG9vbENvbmZpZy5wcmVsb2FkQ29uZmlncyA9IHRoaXMucG9vbENvbmZpZy5wcmVsb2FkQ29uZmlncy5maWx0ZXIoY29uZmlnID0+IHtcbiAgICAgICAgY29uc3QgaXNBbGxvd2VkID0gdGhpcy5pc0tlcm5lbFR5cGVBbGxvd2VkKGNvbmZpZy5tb2RlLCBjb25maWcubGFuZ3VhZ2UpO1xuICAgICAgICBpZiAoIWlzQWxsb3dlZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgUG9vbCBwcmVsb2FkIGNvbmZpZyAke2NvbmZpZy5tb2RlfS0ke2NvbmZpZy5sYW5ndWFnZX0gaXMgbm90IGluIGFsbG93ZWRLZXJuZWxUeXBlcywgc2tpcHBpbmdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBbGxvd2VkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0YXJ0IHByZWxvYWRpbmcgaWYgcG9vbCBpcyBlbmFibGVkXG4gICAgaWYgKHRoaXMucG9vbENvbmZpZy5lbmFibGVkKSB7XG4gICAgICB0aGlzLnByZWxvYWRQb29sKCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcHJlbG9hZGluZyBrZXJuZWwgcG9vbDpcIiwgZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIFxuICBcbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgcG9vbCBrZXkgZm9yIGEgZ2l2ZW4gbW9kZSBhbmQgbGFuZ3VhZ2UgY29tYmluYXRpb25cbiAgICogQHBhcmFtIG1vZGUgS2VybmVsIG1vZGVcbiAgICogQHBhcmFtIGxhbmd1YWdlIEtlcm5lbCBsYW5ndWFnZVxuICAgKiBAcmV0dXJucyBQb29sIGtleSBzdHJpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgZ2V0UG9vbEtleShtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHttb2RlfS0ke2xhbmd1YWdlfWA7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBrZXJuZWwgcHJvbWlzZSBmcm9tIHRoZSBwb29sIGlmIGF2YWlsYWJsZVxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIEtlcm5lbCBwcm9taXNlIG9yIG51bGwgaWYgbm9uZSBhdmFpbGFibGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgZ2V0RnJvbVBvb2wobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlKTogUHJvbWlzZTxJS2VybmVsSW5zdGFuY2U+IHwgbnVsbCB7XG4gICAgaWYgKCF0aGlzLnBvb2xDb25maWcuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHBvb2xLZXkgPSB0aGlzLmdldFBvb2xLZXkobW9kZSwgbGFuZ3VhZ2UpO1xuICAgIGNvbnN0IHBvb2xQcm9taXNlcyA9IHRoaXMucG9vbC5nZXQocG9vbEtleSk7XG4gICAgXG4gICAgaWYgKCFwb29sUHJvbWlzZXMgfHwgcG9vbFByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIFJlbW92ZSBhbmQgcmV0dXJuIHRoZSBmaXJzdCBwcm9taXNlIGZyb20gdGhlIHBvb2wgKEZJRk8pXG4gICAgY29uc3Qga2VybmVsUHJvbWlzZSA9IHBvb2xQcm9taXNlcy5zaGlmdCgpITtcbiAgICBcbiAgICAvLyBJbW1lZGlhdGVseSB0cmlnZ2VyIGJhY2tncm91bmQgcmVmaWxsIHRvIGFkZCBvbmUgcHJvbWlzZSBiYWNrXG4gICAgaWYgKHRoaXMucG9vbENvbmZpZy5hdXRvUmVmaWxsKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5yZWZpbGxQb29sU2luZ2xlKG1vZGUsIGxhbmd1YWdlKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVmaWxsaW5nIHNpbmdsZSBrZXJuZWwgZm9yICR7cG9vbEtleX06YCwgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ga2VybmVsUHJvbWlzZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEFkZCBhIGtlcm5lbCBwcm9taXNlIHRvIHRoZSBwb29sXG4gICAqIEBwYXJhbSBtb2RlIEtlcm5lbCBtb2RlXG4gICAqIEBwYXJhbSBsYW5ndWFnZSBLZXJuZWwgbGFuZ3VhZ2VcbiAgICogQHBhcmFtIGtlcm5lbFByb21pc2UgS2VybmVsIHByb21pc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYWRkVG9Qb29sKG1vZGU6IEtlcm5lbE1vZGUsIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSwga2VybmVsUHJvbWlzZTogUHJvbWlzZTxJS2VybmVsSW5zdGFuY2U+KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBvb2xDb25maWcuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBwb29sS2V5ID0gdGhpcy5nZXRQb29sS2V5KG1vZGUsIGxhbmd1YWdlKTtcbiAgICBcbiAgICBpZiAoIXRoaXMucG9vbC5oYXMocG9vbEtleSkpIHtcbiAgICAgIHRoaXMucG9vbC5zZXQocG9vbEtleSwgW10pO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBwb29sUHJvbWlzZXMgPSB0aGlzLnBvb2wuZ2V0KHBvb2xLZXkpITtcbiAgICBcbiAgICAvLyBPbmx5IGFkZCBpZiB3ZSBoYXZlbid0IHJlYWNoZWQgdGhlIHBvb2wgc2l6ZSBsaW1pdFxuICAgIGlmIChwb29sUHJvbWlzZXMubGVuZ3RoIDwgdGhpcy5wb29sQ29uZmlnLnBvb2xTaXplKSB7XG4gICAgICBwb29sUHJvbWlzZXMucHVzaChrZXJuZWxQcm9taXNlKTtcbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIHByb21pc2UgcmVqZWN0aW9uIHRvIHByZXZlbnQgdW5oYW5kbGVkIHJlamVjdGlvbnNcbiAgICAgIGtlcm5lbFByb21pc2UuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBQb29sIGtlcm5lbCBwcm9taXNlIHJlamVjdGVkIGZvciAke3Bvb2xLZXl9OmAsIGVycm9yKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBmYWlsZWQgcHJvbWlzZSBmcm9tIHRoZSBwb29sXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcG9vbFByb21pc2VzLmluZGV4T2Yoa2VybmVsUHJvbWlzZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBwb29sUHJvbWlzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFBvb2wgaXMgZnVsbCwgbGV0IHRoZSBleGNlc3MgcHJvbWlzZSByZXNvbHZlIGFuZCB0aGVuIGRlc3Ryb3kgdGhlIGtlcm5lbFxuICAgICAga2VybmVsUHJvbWlzZS50aGVuKGtlcm5lbCA9PiB7XG4gICAgICAgIGtlcm5lbC5kZXN0cm95KCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkZXN0cm95aW5nIGV4Y2VzcyBwb29sIGtlcm5lbDpcIiwgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkV4Y2VzcyBwb29sIGtlcm5lbCBwcm9taXNlIHJlamVjdGVkOlwiLCBlcnJvcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZWZpbGwgdGhlIHBvb2wgd2l0aCBhIHNpbmdsZSBrZXJuZWwgcHJvbWlzZVxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlZmlsbFBvb2xTaW5nbGUobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLnBvb2xDb25maWcuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBwb29sS2V5ID0gdGhpcy5nZXRQb29sS2V5KG1vZGUsIGxhbmd1YWdlKTtcbiAgICBjb25zdCBwb29sUHJvbWlzZXMgPSB0aGlzLnBvb2wuZ2V0KHBvb2xLZXkpIHx8IFtdO1xuICAgIFxuICAgIC8vIE9ubHkgYWRkIG9uZSBpZiB3ZSdyZSBiZWxvdyB0aGUgcG9vbCBzaXplXG4gICAgaWYgKHBvb2xQcm9taXNlcy5sZW5ndGggPCB0aGlzLnBvb2xDb25maWcucG9vbFNpemUpIHtcbiAgICAgIGNvbnN0IGtlcm5lbFByb21pc2UgPSB0aGlzLmNyZWF0ZVBvb2xLZXJuZWxQcm9taXNlKG1vZGUsIGxhbmd1YWdlKTtcbiAgICAgIHRoaXMuYWRkVG9Qb29sKG1vZGUsIGxhbmd1YWdlLCBrZXJuZWxQcm9taXNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVmaWxsIHRoZSBwb29sIGZvciBhIHNwZWNpZmljIGNvbmZpZ3VyYXRpb24gd2l0aCBwYXJhbGxlbCBjcmVhdGlvblxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlZmlsbFBvb2wobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLnBvb2xDb25maWcuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBwb29sS2V5ID0gdGhpcy5nZXRQb29sS2V5KG1vZGUsIGxhbmd1YWdlKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHByZWZpbGxpbmcgdGhpcyBwb29sIGtleSB0byBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgICBpZiAodGhpcy5wcmVmaWxsaW5nSW5Qcm9ncmVzcy5nZXQocG9vbEtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0IHByZWZpbGxpbmcgZmxhZ1xuICAgIHRoaXMucHJlZmlsbGluZ0luUHJvZ3Jlc3Muc2V0KHBvb2xLZXksIHRydWUpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwb29sUHJvbWlzZXMgPSB0aGlzLnBvb2wuZ2V0KHBvb2xLZXkpIHx8IFtdO1xuICAgICAgY29uc3QgbmVlZGVkID0gdGhpcy5wb29sQ29uZmlnLnBvb2xTaXplIC0gcG9vbFByb21pc2VzLmxlbmd0aDtcbiAgICAgIFxuICAgICAgaWYgKG5lZWRlZCA8PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGFsbCBuZWVkZWQga2VybmVsIHByb21pc2VzIGluIHBhcmFsbGVsXG4gICAgICBjb25zdCBuZXdQcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG5lZWRlZCB9LCAoKSA9PiBcbiAgICAgICAgdGhpcy5jcmVhdGVQb29sS2VybmVsUHJvbWlzZShtb2RlLCBsYW5ndWFnZSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBhbGwgcHJvbWlzZXMgdG8gdGhlIHBvb2xcbiAgICAgIGZvciAoY29uc3Qga2VybmVsUHJvbWlzZSBvZiBuZXdQcm9taXNlcykge1xuICAgICAgICB0aGlzLmFkZFRvUG9vbChtb2RlLCBsYW5ndWFnZSwga2VybmVsUHJvbWlzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVmaWxsaW5nIHBvb2wgZm9yICR7cG9vbEtleX06YCwgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBBbHdheXMgY2xlYXIgdGhlIHByZWZpbGxpbmcgZmxhZ1xuICAgICAgdGhpcy5wcmVmaWxsaW5nSW5Qcm9ncmVzcy5zZXQocG9vbEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGtlcm5lbCBwcm9taXNlIGZvciB0aGUgcG9vbFxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGtlcm5lbCBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVQb29sS2VybmVsUHJvbWlzZShtb2RlOiBLZXJuZWxNb2RlLCBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2UpOiBQcm9taXNlPElLZXJuZWxJbnN0YW5jZT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBrZXJuZWwgPSBhd2FpdCB0aGlzLmNyZWF0ZVBvb2xLZXJuZWwobW9kZSwgbGFuZ3VhZ2UpO1xuICAgICAgICAvLyBNYXJrIGFzIHRha2VuIGZyb20gcG9vbFxuICAgICAgICBrZXJuZWwuaXNGcm9tUG9vbCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoa2VybmVsKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNyZWF0aW5nIHBvb2wga2VybmVsIGZvciAke21vZGV9LSR7bGFuZ3VhZ2V9OmAsIGVycm9yKTtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBrZXJuZWwgc3BlY2lmaWNhbGx5IGZvciB0aGUgcG9vbFxuICAgKiBAcGFyYW0gbW9kZSBLZXJuZWwgbW9kZVxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgS2VybmVsIGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIEtlcm5lbCBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVQb29sS2VybmVsKG1vZGU6IEtlcm5lbE1vZGUsIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZSk6IFByb21pc2U8SUtlcm5lbEluc3RhbmNlPiB7XG4gICAgLy8gR2VuZXJhdGUgYSB0ZW1wb3JhcnkgSUQgZm9yIHRoZSBwb29sIGtlcm5lbFxuICAgIGNvbnN0IHRlbXBJZCA9IGBwb29sLSR7Y3J5cHRvLnJhbmRvbVVVSUQoKX1gO1xuICAgIFxuICAgIC8vIENyZWF0ZSBrZXJuZWwgd2l0aCBtaW5pbWFsIGNvbmZpZ3VyYXRpb25cbiAgICBjb25zdCBvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnMgPSB7XG4gICAgICBtb2RlLFxuICAgICAgbGFuZzogbGFuZ3VhZ2VcbiAgICB9O1xuICAgIFxuICAgIC8vIFN0b3JlIG9wdGlvbnMgdGVtcG9yYXJpbHkgLSBidXQgZG9uJ3Qgc3RvcmUgaW5jb21wbGV0ZSBpbnN0YW5jZSBpbiBrZXJuZWxzIG1hcFxuICAgIC8vIEluc3RlYWQsIHdlJ2xsIHBhc3MgdGhlIG9wdGlvbnMgZGlyZWN0bHkgdG8gdGhlIGNyZWF0aW9uIG1ldGhvZHNcbiAgICBsZXQgaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgaWYgKG1vZGUgPT09IEtlcm5lbE1vZGUuTUFJTl9USFJFQUQpIHtcbiAgICAgICAgLy8gRm9yIG1haW4gdGhyZWFkLCB3ZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHN0b3JlIHRoZSBpbnN0YW5jZSBmb3IgY3JlYXRlTWFpblRocmVhZEtlcm5lbFxuICAgICAgICBjb25zdCB0ZW1wSW5zdGFuY2UgPSB7XG4gICAgICAgICAgaWQ6IHRlbXBJZCxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgbGFuZ3VhZ2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5rZXJuZWxzLnNldCh0ZW1wSWQsIHRlbXBJbnN0YW5jZSBhcyB1bmtub3duIGFzIElLZXJuZWxJbnN0YW5jZSk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3RhbmNlID0gYXdhaXQgdGhpcy5jcmVhdGVNYWluVGhyZWFkS2VybmVsKHRlbXBJZCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gQWx3YXlzIGNsZWFuIHVwIHRoZSB0ZW1wb3JhcnkgaW5zdGFuY2VcbiAgICAgICAgICB0aGlzLmtlcm5lbHMuZGVsZXRlKHRlbXBJZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciB3b3JrZXIgbW9kZSwgd2UgbmVlZCB0byB0ZW1wb3JhcmlseSBzdG9yZSB0aGUgaW5zdGFuY2UgZm9yIGNyZWF0ZVdvcmtlcktlcm5lbFxuICAgICAgICBjb25zdCB0ZW1wSW5zdGFuY2UgPSB7XG4gICAgICAgICAgaWQ6IHRlbXBJZCxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgbGFuZ3VhZ2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5rZXJuZWxzLnNldCh0ZW1wSWQsIHRlbXBJbnN0YW5jZSBhcyB1bmtub3duIGFzIElLZXJuZWxJbnN0YW5jZSk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3RhbmNlID0gYXdhaXQgdGhpcy5jcmVhdGVXb3JrZXJLZXJuZWwodGVtcElkKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBBbHdheXMgY2xlYW4gdXAgdGhlIHRlbXBvcmFyeSBpbnN0YW5jZVxuICAgICAgICAgIHRoaXMua2VybmVscy5kZWxldGUodGVtcElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBFbnN1cmUgY2xlYW51cCBvbiBhbnkgZXJyb3JcbiAgICAgIHRoaXMua2VybmVscy5kZWxldGUodGVtcElkKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBQcmVsb2FkIHRoZSBrZXJuZWwgcG9vbCB3aXRoIGNvbmZpZ3VyZWQga2VybmVsIHR5cGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHByZWxvYWRQb29sKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5wb29sQ29uZmlnLmVuYWJsZWQgfHwgdGhpcy5pc1ByZWxvYWRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5pc1ByZWxvYWRpbmcgPSB0cnVlO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBQcmVsb2FkIGtlcm5lbHMgZm9yIGVhY2ggY29uZmlndXJlZCB0eXBlXG4gICAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiB0aGlzLnBvb2xDb25maWcucHJlbG9hZENvbmZpZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnJlZmlsbFBvb2woY29uZmlnLm1vZGUsIGNvbmZpZy5sYW5ndWFnZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJlbG9hZGluZyAke2NvbmZpZy5tb2RlfS0ke2NvbmZpZy5sYW5ndWFnZX06YCwgZXJyb3IpO1xuICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggb3RoZXIgY29uZmlndXJhdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIGtlcm5lbCBwb29sIHByZWxvYWRpbmc6XCIsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5pc1ByZWxvYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGtlcm5lbCByZXF1ZXN0IGNhbiB1c2UgdGhlIHBvb2xcbiAgICogQHBhcmFtIG9wdGlvbnMgS2VybmVsIGNyZWF0aW9uIG9wdGlvbnNcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcmVxdWVzdCBjYW4gdXNlIHBvb2xcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgY2FuVXNlUG9vbChvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnMpOiBib29sZWFuIHtcbiAgICAvLyBEb24ndCB1c2UgcG9vbCBpZiBpdCdzIGRpc2FibGVkXG4gICAgaWYgKCF0aGlzLnBvb2xDb25maWcuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBEb24ndCB1c2UgcG9vbCBpZiBjdXN0b20gZmlsZXN5c3RlbSBvciBwZXJtaXNzaW9ucyBhcmUgc3BlY2lmaWVkXG4gICAgaWYgKG9wdGlvbnMuZmlsZXN5c3RlbSB8fCBvcHRpb25zLmRlbm8/LnBlcm1pc3Npb25zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIERvbid0IHVzZSBwb29sIGlmIGN1c3RvbSB0aW1lb3V0cyBhcmUgc3BlY2lmaWVkXG4gICAgaWYgKG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlYXNzaWduIGEgcG9vbCBrZXJuZWwgd2l0aCBuZXcgSUQgYW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHBvb2xLZXJuZWwgS2VybmVsIGZyb20gcG9vbFxuICAgKiBAcGFyYW0gbmV3SWQgTmV3IGtlcm5lbCBJRFxuICAgKiBAcGFyYW0gb3B0aW9ucyBLZXJuZWwgb3B0aW9uc1xuICAgKiBAcmV0dXJucyBVcGRhdGVkIGtlcm5lbCBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSByZWFzc2lnblBvb2xLZXJuZWwoXG4gICAgcG9vbEtlcm5lbDogSUtlcm5lbEluc3RhbmNlLCBcbiAgICBuZXdJZDogc3RyaW5nLCBcbiAgICBvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnNcbiAgKTogSUtlcm5lbEluc3RhbmNlIHtcbiAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2JqZWN0IGV4cGxpY2l0bHkgdG8gYXZvaWQgc3ByZWFkIG9wZXJhdG9yIGlzc3Vlc1xuICAgIGNvbnN0IHVwZGF0ZWRJbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlID0ge1xuICAgICAgaWQ6IG5ld0lkLFxuICAgICAga2VybmVsOiBwb29sS2VybmVsLmtlcm5lbCxcbiAgICAgIG1vZGU6IHBvb2xLZXJuZWwubW9kZSxcbiAgICAgIGxhbmd1YWdlOiBwb29sS2VybmVsLmxhbmd1YWdlLFxuICAgICAgd29ya2VyOiBwb29sS2VybmVsLndvcmtlcixcbiAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSwgLy8gVXBkYXRlIGNyZWF0aW9uIHRpbWVcbiAgICAgIG9wdGlvbnM6IHsgLi4ucG9vbEtlcm5lbC5vcHRpb25zLCAuLi5vcHRpb25zIH0sXG4gICAgICBpc0Zyb21Qb29sOiB0cnVlLFxuICAgICAgZGVzdHJveTogcG9vbEtlcm5lbC5kZXN0cm95IC8vIFByZXNlcnZlIHRoZSBvcmlnaW5hbCBkZXN0cm95IGZ1bmN0aW9uXG4gICAgfTtcbiAgICBcbiAgICAvLyBWZXJpZnkgdGhlIGRlc3Ryb3kgZnVuY3Rpb24gaXMgcHJvcGVybHkgc2V0XG4gICAgaWYgKHR5cGVvZiB1cGRhdGVkSW5zdGFuY2UuZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHByZXNlcnZlIGRlc3Ryb3kgZnVuY3Rpb24gZHVyaW5nIHBvb2wga2VybmVsIHJlYXNzaWdubWVudCcpO1xuICAgICAgY29uc29sZS5lcnJvcigncG9vbEtlcm5lbC5kZXN0cm95IHR5cGU6JywgdHlwZW9mIHBvb2xLZXJuZWwuZGVzdHJveSk7XG4gICAgICBjb25zb2xlLmVycm9yKCd1cGRhdGVkSW5zdGFuY2UuZGVzdHJveSB0eXBlOicsIHR5cGVvZiB1cGRhdGVkSW5zdGFuY2UuZGVzdHJveSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwcmVzZXJ2ZSBkZXN0cm95IGZ1bmN0aW9uIGR1cmluZyBwb29sIGtlcm5lbCByZWFzc2lnbm1lbnRgKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHVwZGF0ZWRJbnN0YW5jZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBwb29sIHN0YXRpc3RpY3MgZm9yIGRlYnVnZ2luZy9tb25pdG9yaW5nXG4gICAqIEByZXR1cm5zIFBvb2wgc3RhdGlzdGljc1xuICAgKi9cbiAgcHVibGljIGdldFBvb2xTdGF0cygpOiBSZWNvcmQ8c3RyaW5nLCB7IGF2YWlsYWJsZTogbnVtYmVyOyB0b3RhbDogbnVtYmVyIH0+IHtcbiAgICBjb25zdCBzdGF0czogUmVjb3JkPHN0cmluZywgeyBhdmFpbGFibGU6IG51bWJlcjsgdG90YWw6IG51bWJlciB9PiA9IHt9O1xuICAgIFxuICAgIGZvciAoY29uc3QgW3Bvb2xLZXksIHByb21pc2VzXSBvZiB0aGlzLnBvb2wuZW50cmllcygpKSB7XG4gICAgICBzdGF0c1twb29sS2V5XSA9IHtcbiAgICAgICAgYXZhaWxhYmxlOiBwcm9taXNlcy5sZW5ndGgsXG4gICAgICAgIHRvdGFsOiB0aGlzLnBvb2xDb25maWcucG9vbFNpemVcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzdGF0cztcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBwb29sIGNvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb25cbiAgICogQHJldHVybnMgUG9vbCBjb25maWd1cmF0aW9uIGRldGFpbHNcbiAgICovXG4gIHB1YmxpYyBnZXRQb29sQ29uZmlnKCk6IHtcbiAgICBlbmFibGVkOiBib29sZWFuO1xuICAgIHBvb2xTaXplOiBudW1iZXI7XG4gICAgYXV0b1JlZmlsbDogYm9vbGVhbjtcbiAgICBwcmVsb2FkQ29uZmlnczogQXJyYXk8e1xuICAgICAgbW9kZTogS2VybmVsTW9kZTtcbiAgICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgICB9PjtcbiAgICBpc1ByZWxvYWRpbmc6IGJvb2xlYW47XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICBlbmFibGVkOiB0aGlzLnBvb2xDb25maWcuZW5hYmxlZCxcbiAgICAgIHBvb2xTaXplOiB0aGlzLnBvb2xDb25maWcucG9vbFNpemUsXG4gICAgICBhdXRvUmVmaWxsOiB0aGlzLnBvb2xDb25maWcuYXV0b1JlZmlsbCxcbiAgICAgIHByZWxvYWRDb25maWdzOiBbLi4udGhpcy5wb29sQ29uZmlnLnByZWxvYWRDb25maWdzXSwgLy8gUmV0dXJuIGEgY29weSB0byBwcmV2ZW50IG1vZGlmaWNhdGlvblxuICAgICAgaXNQcmVsb2FkaW5nOiB0aGlzLmlzUHJlbG9hZGluZ1xuICAgIH07XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgd29ya2VyIFVSTCBjb25maWd1cmF0aW9uXG4gICAqIEByZXR1cm5zIFRoZSB3b3JrZXIgVVJMIG9yIHVuZGVmaW5lZCBpZiB1c2luZyBhdXRvLWRldGVjdGlvblxuICAgKi9cbiAgcHVibGljIGdldFdvcmtlclVybCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLndvcmtlclVybDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNldCBhIGN1c3RvbSB3b3JrZXIgVVJMIGZvciBrZXJuZWwgd29ya2Vyc1xuICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgdG8gdGhlIGtlcm5lbC53b3JrZXIuanMgZmlsZVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBGb3IgQ0ROIHVzYWdlOlxuICAgKiBtYW5hZ2VyLnNldFdvcmtlclVybCgnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS93ZWItcHl0aG9uLWtlcm5lbEBsYXRlc3QvZGlzdC9rZXJuZWwud29ya2VyLmpzJyk7XG4gICAqIC8vIEZvciBsb2NhbCBkZXZlbG9wbWVudDpcbiAgICogbWFuYWdlci5zZXRXb3JrZXJVcmwoJy9kaXN0L2tlcm5lbC53b3JrZXIuanMnKTtcbiAgICovXG4gIHB1YmxpYyBzZXRXb3JrZXJVcmwodXJsOiBzdHJpbmcgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICB0aGlzLndvcmtlclVybCA9IHVybDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBrZXJuZWwgaW5zdGFuY2VcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIGtlcm5lbFxuICAgKiBAcGFyYW0gb3B0aW9ucy5pZCBPcHRpb25hbCBjdXN0b20gSUQgZm9yIHRoZSBrZXJuZWxcbiAgICogQHBhcmFtIG9wdGlvbnMubW9kZSBPcHRpb25hbCBrZXJuZWwgbW9kZSAobWFpbl90aHJlYWQgb3Igd29ya2VyKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5sYW5nIE9wdGlvbmFsIGtlcm5lbCBsYW5ndWFnZSAocHl0aG9uIG9yIHR5cGVzY3JpcHQpXG4gICAqIEBwYXJhbSBvcHRpb25zLm5hbWVzcGFjZSBPcHRpb25hbCBuYW1lc3BhY2UgcHJlZml4IGZvciB0aGUga2VybmVsIElEXG4gICAqIEBwYXJhbSBvcHRpb25zLmRlbm8ucGVybWlzc2lvbnMgT3B0aW9uYWwgRGVubyBwZXJtaXNzaW9ucyBmb3Igd29ya2VyIG1vZGVcbiAgICogQHBhcmFtIG9wdGlvbnMuZmlsZXN5c3RlbSBPcHRpb25hbCBmaWxlc3lzdGVtIG1vdW50aW5nIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgT3B0aW9uYWwgdGltZW91dCBpbiBtcyBhZnRlciB3aGljaCBhbiBpbmFjdGl2ZSBrZXJuZWwgd2lsbCBiZSBzaHV0IGRvd25cbiAgICogQHBhcmFtIG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSBPcHRpb25hbCBtYXhpbXVtIHRpbWUgaW4gbXMgYW4gZXhlY3V0aW9uIGNhbiBydW4gYmVmb3JlIGNvbnNpZGVyZWQgc3R1Y2tcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGtlcm5lbCBpbnN0YW5jZSBJRFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNyZWF0ZUtlcm5lbChvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnMgPSB7fSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBvcHRpb25zLmlkIGRvZXMgbm90IGNvbnRhaW4gY29sb25zIGJlY2F1c2UgaXQgd2lsbCBiZSB1c2VkIGFzIGEgbmFtZXNwYWNlIHByZWZpeFxuICAgIGlmIChvcHRpb25zLmlkICYmIG9wdGlvbnMuaWQuaW5jbHVkZXMoJzonKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXJuZWwgSUQgY2Fubm90IGNvbnRhaW4gY29sb25zJyk7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VJZCA9IG9wdGlvbnMuaWQgfHwgY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5tb2RlIHx8IEtlcm5lbE1vZGUuV09SS0VSO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gb3B0aW9ucy5sYW5nIHx8IEtlcm5lbExhbmd1YWdlLlBZVEhPTjtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGUgcmVxdWVzdGVkIGtlcm5lbCB0eXBlIGlzIGFsbG93ZWRcbiAgICBpZiAoIXRoaXMuaXNLZXJuZWxUeXBlQWxsb3dlZChtb2RlLCBsYW5ndWFnZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsIHR5cGUgJHttb2RlfS0ke2xhbmd1YWdlfSBpcyBub3QgYWxsb3dlZC4gQWxsb3dlZCB0eXBlczogJHtcbiAgICAgICAgdGhpcy5hbGxvd2VkS2VybmVsVHlwZXMubWFwKHQgPT4gYCR7dC5tb2RlfS0ke3QubGFuZ3VhZ2V9YCkuam9pbignLCAnKVxuICAgICAgfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBBcHBseSBuYW1lc3BhY2UgcHJlZml4IGlmIHByb3ZpZGVkXG4gICAgY29uc3QgaWQgPSBvcHRpb25zLm5hbWVzcGFjZSA/IGAke29wdGlvbnMubmFtZXNwYWNlfToke2Jhc2VJZH1gIDogYmFzZUlkO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGtlcm5lbCB3aXRoIHRoaXMgSUQgYWxyZWFkeSBleGlzdHNcbiAgICBpZiAodGhpcy5rZXJuZWxzLmhhcyhpZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsIHdpdGggSUQgJHtpZH0gYWxyZWFkeSBleGlzdHNgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJ5IHRvIGdldCBmcm9tIHBvb2wgaWYgcG9zc2libGVcbiAgICBpZiAodGhpcy5jYW5Vc2VQb29sKG9wdGlvbnMpKSB7XG4gICAgICBjb25zdCBwb29sS2V5ID0gdGhpcy5nZXRQb29sS2V5KG1vZGUsIGxhbmd1YWdlKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBrZXJuZWwgdHlwZSBpcyBjb25maWd1cmVkIGZvciBwb29saW5nXG4gICAgICBjb25zdCBpc1Bvb2xlZFR5cGUgPSB0aGlzLnBvb2xDb25maWcucHJlbG9hZENvbmZpZ3Muc29tZShjb25maWcgPT4gXG4gICAgICAgIGNvbmZpZy5tb2RlID09PSBtb2RlICYmIGNvbmZpZy5sYW5ndWFnZSA9PT0gbGFuZ3VhZ2VcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmIChpc1Bvb2xlZFR5cGUpIHtcbiAgICAgICAgLy8gRmlyc3QgdHJ5IHRvIGdldCBmcm9tIGV4aXN0aW5nIHBvb2xcbiAgICAgICAgbGV0IHBvb2xLZXJuZWxQcm9taXNlID0gdGhpcy5nZXRGcm9tUG9vbChtb2RlLCBsYW5ndWFnZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAocG9vbEtlcm5lbFByb21pc2UpIHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXR1cFBvb2xLZXJuZWxGcm9tUHJvbWlzZShwb29sS2VybmVsUHJvbWlzZSwgaWQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBQb29sIGlzIGVtcHR5LCBidXQgdGhpcyB0eXBlIHNob3VsZCBiZSBwb29sZWRcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHByb21pc2UgaW1tZWRpYXRlbHkgYW5kIHRyaWdnZXIgYmFja2dyb3VuZCByZWZpbGxcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcga2VybmVsIHByb21pc2Ugc3BlY2lmaWNhbGx5IGZvciB0aGlzIHJlcXVlc3RcbiAgICAgICAgICBjb25zdCBuZXdLZXJuZWxQcm9taXNlID0gdGhpcy5jcmVhdGVQb29sS2VybmVsUHJvbWlzZShtb2RlLCBsYW5ndWFnZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJpZ2dlciBiYWNrZ3JvdW5kIHJlZmlsbCB0byByZXBsZW5pc2ggdGhlIHBvb2wgZm9yIGZ1dHVyZSByZXF1ZXN0c1xuICAgICAgICAgIGlmICh0aGlzLnBvb2xDb25maWcuYXV0b1JlZmlsbCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVmaWxsUG9vbChtb2RlLCBsYW5ndWFnZSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlZmlsbGluZyBleGhhdXN0ZWQgcG9vbCBmb3IgJHtwb29sS2V5fTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNldHVwUG9vbEtlcm5lbEZyb21Qcm9taXNlKG5ld0tlcm5lbFByb21pc2UsIGlkLCBvcHRpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGtlcm5lbCBwcm9taXNlIGZvciBleGhhdXN0ZWQgcG9vbDogJHtlcnJvcn1gKTtcbiAgICAgICAgICAvLyBGYWxsIHRocm91Z2ggdG8gb24tZGVtYW5kIGNyZWF0aW9uIGFzIGxhc3QgcmVzb3J0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMga2VybmVsIHR5cGUgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIHBvb2xpbmcsIHRyeSB0byBnZXQgZnJvbSBwb29sIGFueXdheVxuICAgICAgICAvLyBpbiBjYXNlIHRoZXJlIGFyZSBrZXJuZWxzIGF2YWlsYWJsZSBmcm9tIHByZXZpb3VzIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIGNvbnN0IHBvb2xLZXJuZWxQcm9taXNlID0gdGhpcy5nZXRGcm9tUG9vbChtb2RlLCBsYW5ndWFnZSk7XG4gICAgICAgIGlmIChwb29sS2VybmVsUHJvbWlzZSkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNldHVwUG9vbEtlcm5lbEZyb21Qcm9taXNlKHBvb2xLZXJuZWxQcm9taXNlLCBpZCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbCBiYWNrIHRvIGNyZWF0aW5nIGEgbmV3IGtlcm5lbCBvbi1kZW1hbmRcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVPbkRlbWFuZEtlcm5lbChpZCwgbW9kZSwgbGFuZ3VhZ2UsIG9wdGlvbnMpO1xuICB9XG4gIFxuICAvKipcbiAgICogU2V0dXAgYSBwb29sIGtlcm5lbCBmcm9tIGEgcHJvbWlzZSB3aXRoIG5ldyBJRCBhbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0gcG9vbEtlcm5lbFByb21pc2UgS2VybmVsIHByb21pc2UgZnJvbSBwb29sXG4gICAqIEBwYXJhbSBpZCBOZXcga2VybmVsIElEXG4gICAqIEBwYXJhbSBvcHRpb25zIEtlcm5lbCBvcHRpb25zXG4gICAqIEByZXR1cm5zIEtlcm5lbCBJRCAocmV0dXJuZWQgYWZ0ZXIga2VybmVsIGlzIHJlYWR5KVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZXR1cFBvb2xLZXJuZWxGcm9tUHJvbWlzZShcbiAgICBwb29sS2VybmVsUHJvbWlzZTogUHJvbWlzZTxJS2VybmVsSW5zdGFuY2U+LCBcbiAgICBpZDogc3RyaW5nLCBcbiAgICBvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnNcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgLy8gV2FpdCBmb3IgdGhlIHBvb2wga2VybmVsIHRvIGJlIHJlYWR5XG4gICAgICBjb25zdCBwb29sS2VybmVsID0gYXdhaXQgcG9vbEtlcm5lbFByb21pc2U7XG4gICAgICBcbiAgICAgIC8vIFJlYXNzaWduIHRoZSBwb29sIGtlcm5lbCB3aXRoIHRoZSBuZXcgSUQgYW5kIG9wdGlvbnNcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5yZWFzc2lnblBvb2xLZXJuZWwocG9vbEtlcm5lbCwgaWQsIG9wdGlvbnMpO1xuICAgICAgXG4gICAgICAvLyBGb3Igd29ya2VyIGtlcm5lbHMsIHdlIG5lZWQgdG8gcmVjcmVhdGUgdGhlIGV2ZW50IGhhbmRsZXIgd2l0aCB0aGUgbmV3IElEXG4gICAgICBpZiAoaW5zdGFuY2UubW9kZSA9PT0gS2VybmVsTW9kZS5XT1JLRVIgJiYgaW5zdGFuY2Uud29ya2VyKSB7XG4gICAgICAgIC8vIEdldCB0aGUgd29ya2VyIGFuZCBjcmVhdGUgbmV3IG1lc3NhZ2UgY2hhbm5lbFxuICAgICAgICBjb25zdCB3b3JrZXIgPSBpbnN0YW5jZS53b3JrZXI7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbWVzc2FnZSBjaGFubmVsIGZvciB0aGUgcmVhc3NpZ25lZCBrZXJuZWxcbiAgICAgICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2VuZCB0aGUgbmV3IGV2ZW50IHBvcnQgdG8gdGhlIHdvcmtlclxuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHR5cGU6IFwiU0VUX0VWRU5UX1BPUlRcIixcbiAgICAgICAgICBwb3J0OiBwb3J0MlxuICAgICAgICB9LCBbcG9ydDJdKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBldmVudCBoYW5kbGVyIHdpdGggdGhlIGNvcnJlY3Qga2VybmVsIElEXG4gICAgICAgIGNvbnN0IGV2ZW50SGFuZGxlciA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS50eXBlKSB7XG4gICAgICAgICAgICAvLyBFbWl0IHRoZSBldmVudCBmcm9tIHRoZSBtYW5hZ2VyIHdpdGgga2VybmVsIElEXG4gICAgICAgICAgICAvLyBUaGlzIHN0cnVjdHVyZSBtYXRjaGVzIHRoZSBzZXR1cEV2ZW50Rm9yd2FyZGluZyBtZXRob2QgZm9yIG1haW4gdGhyZWFkIGtlcm5lbHNcbiAgICAgICAgICAgIHN1cGVyLmVtaXQoZXZlbnQuZGF0YS50eXBlLCB7XG4gICAgICAgICAgICAgIGtlcm5lbElkOiBpZCxcbiAgICAgICAgICAgICAgZGF0YTogZXZlbnQuZGF0YS5kYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBMaXN0ZW4gZm9yIGV2ZW50cyBmcm9tIHRoZSB3b3JrZXIgd2l0aCB0aGUgbmV3IGhhbmRsZXJcbiAgICAgICAgcG9ydDEuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgIHBvcnQxLnN0YXJ0KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgdGhlIGRlc3Ryb3kgZnVuY3Rpb24gdG8gY2xlYW4gdXAgdGhlIG5ldyBldmVudCBoYW5kbGVyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRGVzdHJveSA9IGluc3RhbmNlLmRlc3Ryb3k7XG4gICAgICAgIGluc3RhbmNlLmRlc3Ryb3kgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgcG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgcG9ydDEuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxEZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHRoZSBrZXJuZWwgaW5zdGFuY2VcbiAgICAgIHRoaXMua2VybmVscy5zZXQoaWQsIGluc3RhbmNlKTtcbiAgICAgIFxuICAgICAgLy8gRm9yd2FyZCBrZXJuZWwgZXZlbnRzIHRvIG1hbmFnZXIgKGZvciBtYWluIHRocmVhZCBrZXJuZWxzKVxuICAgICAgdGhpcy5zZXR1cEV2ZW50Rm9yd2FyZGluZyhpbnN0YW5jZSk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgYWN0aXZpdHkgdHJhY2tpbmdcbiAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoaWQpO1xuICAgICAgXG4gICAgICAvLyBTZXQgdXAgaW5hY3Rpdml0eSB0aW1lb3V0IGlmIHNwZWNpZmllZCBhbmQgZ3JlYXRlciB0aGFuIDBcbiAgICAgIGlmIChvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0ICYmIG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgPiAwKSB7XG4gICAgICAgIHRoaXMuc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZCwgb3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNldHVwIGhhbmRsZXJzIGZvciBzdGFsbGVkIGV4ZWN1dGlvbnMgaWYgbWF4RXhlY3V0aW9uVGltZSBpcyBzcGVjaWZpZWRcbiAgICAgIGlmIChvcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgJiYgb3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lID4gMCkge1xuICAgICAgICB0aGlzLnNldHVwU3RhbGxlZEV4ZWN1dGlvbkhhbmRsZXIoaWQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNldHRpbmcgdXAgcG9vbCBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgLy8gRW1pdCBhbiBlcnJvciBldmVudCBmb3IgdGhpcyBrZXJuZWxcbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsIHtcbiAgICAgICAga2VybmVsSWQ6IGlkLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZW5hbWU6IFwiS2VybmVsU2V0dXBFcnJvclwiLFxuICAgICAgICAgIGV2YWx1ZTogYEZhaWxlZCB0byBzZXR1cCBrZXJuZWw6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWAsXG4gICAgICAgICAgdHJhY2ViYWNrOiBbZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IChlcnJvci5zdGFjayB8fCBlcnJvci5tZXNzYWdlKSA6IFN0cmluZyhlcnJvcildXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93IHRvIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBhIHBvb2wga2VybmVsIHdpdGggbmV3IElEIGFuZCBvcHRpb25zIChmb3IgYWxyZWFkeSByZXNvbHZlZCBrZXJuZWxzKVxuICAgKiBAcGFyYW0gcG9vbEtlcm5lbCBLZXJuZWwgZnJvbSBwb29sXG4gICAqIEBwYXJhbSBpZCBOZXcga2VybmVsIElEXG4gICAqIEBwYXJhbSBvcHRpb25zIEtlcm5lbCBvcHRpb25zXG4gICAqIEByZXR1cm5zIEtlcm5lbCBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cFBvb2xLZXJuZWwoXG4gICAgcG9vbEtlcm5lbDogSUtlcm5lbEluc3RhbmNlLCBcbiAgICBpZDogc3RyaW5nLCBcbiAgICBvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnNcbiAgKTogc3RyaW5nIHtcbiAgICAvLyBSZWFzc2lnbiB0aGUgcG9vbCBrZXJuZWwgd2l0aCB0aGUgbmV3IElEIGFuZCBvcHRpb25zXG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLnJlYXNzaWduUG9vbEtlcm5lbChwb29sS2VybmVsLCBpZCwgb3B0aW9ucyk7XG4gICAgXG4gICAgLy8gRm9yIHdvcmtlciBrZXJuZWxzLCB3ZSBuZWVkIHRvIHJlY3JlYXRlIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIG5ldyBJRFxuICAgIGlmIChpbnN0YW5jZS5tb2RlID09PSBLZXJuZWxNb2RlLldPUktFUiAmJiBpbnN0YW5jZS53b3JrZXIpIHtcbiAgICAgIC8vIEdldCB0aGUgd29ya2VyIGFuZCBjcmVhdGUgbmV3IG1lc3NhZ2UgY2hhbm5lbFxuICAgICAgY29uc3Qgd29ya2VyID0gaW5zdGFuY2Uud29ya2VyO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgbWVzc2FnZSBjaGFubmVsIGZvciB0aGUgcmVhc3NpZ25lZCBrZXJuZWxcbiAgICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgIFxuICAgICAgLy8gU2VuZCB0aGUgbmV3IGV2ZW50IHBvcnQgdG8gdGhlIHdvcmtlclxuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJTRVRfRVZFTlRfUE9SVFwiLFxuICAgICAgICBwb3J0OiBwb3J0MlxuICAgICAgfSwgW3BvcnQyXSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBldmVudCBoYW5kbGVyIHdpdGggdGhlIGNvcnJlY3Qga2VybmVsIElEXG4gICAgICBjb25zdCBldmVudEhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnR5cGUpIHtcbiAgICAgICAgICAvLyBFbWl0IHRoZSBldmVudCBmcm9tIHRoZSBtYW5hZ2VyIHdpdGgga2VybmVsIElEXG4gICAgICAgICAgLy8gVGhpcyBzdHJ1Y3R1cmUgbWF0Y2hlcyB0aGUgc2V0dXBFdmVudEZvcndhcmRpbmcgbWV0aG9kIGZvciBtYWluIHRocmVhZCBrZXJuZWxzXG4gICAgICAgICAgc3VwZXIuZW1pdChldmVudC5kYXRhLnR5cGUsIHtcbiAgICAgICAgICAgIGtlcm5lbElkOiBpZCxcbiAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBMaXN0ZW4gZm9yIGV2ZW50cyBmcm9tIHRoZSB3b3JrZXIgd2l0aCB0aGUgbmV3IGhhbmRsZXJcbiAgICAgIHBvcnQxLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudEhhbmRsZXIpO1xuICAgICAgcG9ydDEuc3RhcnQoKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHRoZSBkZXN0cm95IGZ1bmN0aW9uIHRvIGNsZWFuIHVwIHRoZSBuZXcgZXZlbnQgaGFuZGxlclxuICAgICAgY29uc3Qgb3JpZ2luYWxEZXN0cm95ID0gaW5zdGFuY2UuZGVzdHJveTtcbiAgICAgIGluc3RhbmNlLmRlc3Ryb3kgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudEhhbmRsZXIpO1xuICAgICAgICBwb3J0MS5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxEZXN0cm95KCk7XG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBTdG9yZSB0aGUga2VybmVsIGluc3RhbmNlXG4gICAgdGhpcy5rZXJuZWxzLnNldChpZCwgaW5zdGFuY2UpO1xuICAgIFxuICAgIC8vIEZvcndhcmQga2VybmVsIGV2ZW50cyB0byBtYW5hZ2VyIChmb3IgbWFpbiB0aHJlYWQga2VybmVscylcbiAgICB0aGlzLnNldHVwRXZlbnRGb3J3YXJkaW5nKGluc3RhbmNlKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIGFjdGl2aXR5IHRyYWNraW5nXG4gICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShpZCk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGluYWN0aXZpdHkgdGltZW91dCBpZiBzcGVjaWZpZWQgYW5kIGdyZWF0ZXIgdGhhbiAwXG4gICAgaWYgKG9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQgJiYgb3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCA+IDApIHtcbiAgICAgIHRoaXMuc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZCwgb3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFNldHVwIGhhbmRsZXJzIGZvciBzdGFsbGVkIGV4ZWN1dGlvbnMgaWYgbWF4RXhlY3V0aW9uVGltZSBpcyBzcGVjaWZpZWRcbiAgICBpZiAob3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lICYmIG9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSA+IDApIHtcbiAgICAgIHRoaXMuc2V0dXBTdGFsbGVkRXhlY3V0aW9uSGFuZGxlcihpZCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBpZDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGtlcm5lbCBvbi1kZW1hbmQgKG5vdCBmcm9tIHBvb2wpXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIG1vZGUgS2VybmVsIG1vZGVcbiAgICogQHBhcmFtIGxhbmd1YWdlIEtlcm5lbCBsYW5ndWFnZVxuICAgKiBAcGFyYW0gb3B0aW9ucyBLZXJuZWwgb3B0aW9uc1xuICAgKiBAcmV0dXJucyBLZXJuZWwgSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlT25EZW1hbmRLZXJuZWwoXG4gICAgaWQ6IHN0cmluZywgXG4gICAgbW9kZTogS2VybmVsTW9kZSwgXG4gICAgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlLCBcbiAgICBvcHRpb25zOiBJTWFuYWdlcktlcm5lbE9wdGlvbnNcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAvLyBTdG9yZSBvcHRpb25zIHRlbXBvcmFyaWx5IHRvIGJlIHVzZWQgaW4gY3JlYXRlV29ya2VyS2VybmVsXG4gICAgY29uc3QgdGVtcEluc3RhbmNlID0ge1xuICAgICAgaWQsXG4gICAgICBvcHRpb25zOiB7IC4uLm9wdGlvbnMsIGxhbmc6IGxhbmd1YWdlIH0sXG4gICAgICBtb2RlLFxuICAgICAgbGFuZ3VhZ2VcbiAgICB9O1xuICAgIHRoaXMua2VybmVscy5zZXQoaWQsIHRlbXBJbnN0YW5jZSBhcyB1bmtub3duIGFzIElLZXJuZWxJbnN0YW5jZSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHRoZSBhcHByb3ByaWF0ZSBrZXJuZWwgaW5zdGFuY2VcbiAgICBsZXQgaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZTtcbiAgICBcbiAgICBpZiAobW9kZSA9PT0gS2VybmVsTW9kZS5NQUlOX1RIUkVBRCkge1xuICAgICAgaW5zdGFuY2UgPSBhd2FpdCB0aGlzLmNyZWF0ZU1haW5UaHJlYWRLZXJuZWwoaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZSA9IGF3YWl0IHRoaXMuY3JlYXRlV29ya2VyS2VybmVsKGlkKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RvcmUgdGhlIGtlcm5lbCBpbnN0YW5jZVxuICAgIHRoaXMua2VybmVscy5zZXQoaWQsIGluc3RhbmNlKTtcbiAgICBcbiAgICAvLyBGb3J3YXJkIGtlcm5lbCBldmVudHMgdG8gbWFuYWdlclxuICAgIHRoaXMuc2V0dXBFdmVudEZvcndhcmRpbmcoaW5zdGFuY2UpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgYWN0aXZpdHkgdHJhY2tpbmdcbiAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGlkKTtcbiAgICBcbiAgICAvLyBTZXQgdXAgaW5hY3Rpdml0eSB0aW1lb3V0IGlmIHNwZWNpZmllZCBhbmQgZ3JlYXRlciB0aGFuIDBcbiAgICBpZiAob3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCAmJiBvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0ID4gMCkge1xuICAgICAgdGhpcy5zZXR1cEluYWN0aXZpdHlUaW1lb3V0KGlkLCBvcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0KTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0dXAgaGFuZGxlcnMgZm9yIHN0YWxsZWQgZXhlY3V0aW9ucyBpZiBtYXhFeGVjdXRpb25UaW1lIGlzIHNwZWNpZmllZFxuICAgIGlmIChvcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgJiYgb3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lID4gMCkge1xuICAgICAgdGhpcy5zZXR1cFN0YWxsZWRFeGVjdXRpb25IYW5kbGVyKGlkKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIFxuICAvKipcbiAgICogQ3JlYXRlIGEga2VybmVsIGluc3RhbmNlIHJ1bm5pbmcgaW4gdGhlIG1haW4gdGhyZWFkXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgS2VybmVsIGluc3RhbmNlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNyZWF0ZU1haW5UaHJlYWRLZXJuZWwoaWQ6IHN0cmluZyk6IFByb21pc2U8SUtlcm5lbEluc3RhbmNlPiB7XG4gICAgLy8gR2V0IG9wdGlvbnMgZnJvbSB0aGUgdGVtcG9yYXJ5IGluc3RhbmNlXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMua2VybmVscy5nZXQoaWQpPy5vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxhbmd1YWdlID0gb3B0aW9ucy5sYW5nIHx8IEtlcm5lbExhbmd1YWdlLlBZVEhPTjtcbiAgICBcbiAgICAvLyBDcmVhdGUgdGhlIFB5dGhvbiBrZXJuZWxcbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgS2VybmVsKCk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHRoZSBrZXJuZWwgaW5zdGFuY2VcbiAgICBjb25zdCBpbnN0YW5jZTogSUtlcm5lbEluc3RhbmNlID0ge1xuICAgICAgaWQsXG4gICAgICBrZXJuZWwsXG4gICAgICBtb2RlOiBLZXJuZWxNb2RlLk1BSU5fVEhSRUFELFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBjcmVhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBvcHRpb25zLFxuICAgICAgZGVzdHJveTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBOb3RoaW5nIHNwZWNpYWwgdG8gZG8gZm9yIG1haW4gdGhyZWFkIGtlcm5lbFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHRoZSBrZXJuZWwgd2l0aCBmaWxlc3lzdGVtIG9wdGlvbnNcbiAgICBjb25zdCBrZXJuZWxPcHRpb25zOiBJS2VybmVsT3B0aW9ucyA9IHt9O1xuXG4gICAgLy8gQWRkIGZpbGVzeXN0ZW0gb3B0aW9ucyBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zLmZpbGVzeXN0ZW0pIHtcbiAgICAgIGtlcm5lbE9wdGlvbnMuZmlsZXN5c3RlbSA9IG9wdGlvbnMuZmlsZXN5c3RlbTtcbiAgICB9XG5cbiAgICAvLyBBZGQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGlmIHByb3ZpZGVkXG4gICAgaWYgKG9wdGlvbnMuZW52KSB7XG4gICAgICBrZXJuZWxPcHRpb25zLmVudiA9IG9wdGlvbnMuZW52O1xuICAgIH1cblxuICAgIC8vIEFkZCBsb2NrRmlsZVVSTCBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zLmxvY2tGaWxlVVJMKSB7XG4gICAgICBrZXJuZWxPcHRpb25zLmxvY2tGaWxlVVJMID0gb3B0aW9ucy5sb2NrRmlsZVVSTDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYXV0b1N5bmNGcyBpZiBwcm92aWRlZFxuICAgIGlmIChvcHRpb25zLmF1dG9TeW5jRnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2VybmVsT3B0aW9ucy5hdXRvU3luY0ZzID0gb3B0aW9ucy5hdXRvU3luY0ZzO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGtlcm5lbFxuICAgIGF3YWl0IGtlcm5lbC5pbml0aWFsaXplKGtlcm5lbE9wdGlvbnMpO1xuICAgIFxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGtlcm5lbCBpbnN0YW5jZSBydW5uaW5nIGluIGEgd29ya2VyXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgS2VybmVsIGluc3RhbmNlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVdvcmtlcktlcm5lbChpZDogc3RyaW5nKTogUHJvbWlzZTxJS2VybmVsSW5zdGFuY2U+IHtcbiAgICAvLyBHZXQgcGVybWlzc2lvbnMgZnJvbSBvcHRpb25zIHdoZW4gY3JlYXRpbmcgdGhlIGtlcm5lbFxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKT8ub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBsYW5ndWFnZSA9IG9wdGlvbnMubGFuZyB8fCBLZXJuZWxMYW5ndWFnZS5QWVRIT047XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgbmV3IHdvcmtlciB3aXRoIG9wdGlvbmFsIHBlcm1pc3Npb25zXG4gICAgY29uc3Qgd29ya2VyT3B0aW9uczogV29ya2VyT3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6IFwibW9kdWxlXCIsXG4gICAgfTtcbiAgICBcbiAgICAvLyBJZiBEZW5vIHBlcm1pc3Npb25zIGFyZSBwcm92aWRlZCwgdXNlIHRoZW0uXG4gICAgLy8gT3RoZXJ3aXNlIGRvbid0IHNwZWNpZnkgRGVubyBwZXJtaXNzaW9ucyBhdCBhbGwgdG8gaW5oZXJpdCBmcm9tIGhvc3Qgc2NyaXB0XG4gICAgaWYgKG9wdGlvbnMuZGVubz8ucGVybWlzc2lvbnMpIHtcbiAgICAgIHdvcmtlck9wdGlvbnMuZGVubyA9IHtcbiAgICAgICAgcGVybWlzc2lvbnM6IG9wdGlvbnMuZGVuby5wZXJtaXNzaW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSB3b3JrZXIgVVJMIGJhc2VkIG9uIHRoZSBlbnZpcm9ubWVudFxuICAgIGNvbnN0IHdvcmtlclVybCA9IHRoaXMucmVzb2x2ZVdvcmtlclVybCgpO1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVXJsLCB7IHR5cGU6ICdjbGFzc2ljJyB9KTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBtZXNzYWdlIGNoYW5uZWwgZm9yIGV2ZW50c1xuICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gdGhlIGtlcm5lbCBpcyBpbml0aWFsaXplZFxuICAgIGNvbnN0IGluaXRQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgaW5pdEhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJLRVJORUxfSU5JVElBTElaRURcIikge1xuICAgICAgICAgIGlmIChldmVudC5kYXRhLmRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgcG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGluaXRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGluaXRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJLZXJuZWwgaW5pdGlhbGl6YXRpb24gZmFpbGVkXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBwb3J0MS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaW5pdEhhbmRsZXIpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFNlbmQgdGhlIHBvcnQgdG8gdGhlIHdvcmtlclxuICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiU0VUX0VWRU5UX1BPUlRcIiwgcG9ydDogcG9ydDIgfSwgW3BvcnQyXSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgcHJveHkgdG8gdGhlIHdvcmtlciB1c2luZyBDb21saW5rXG4gICAgY29uc3Qga2VybmVsUHJveHkgPSBDb21saW5rLndyYXA8SUtlcm5lbD4od29ya2VyKTtcbiAgICBcbiAgICAvLyBBZGQgYSBsb2NhbCBldmVudCBoYW5kbGVyIHRvIGJyaWRnZSB0aGUgd29ya2VyIGV2ZW50c1xuICAgIC8vIFRoaXMgd29ya3MgYXJvdW5kIHRoZSBsaW1pdGF0aW9uIHRoYXQgQ29tbGluayBkb2Vzbid0IHByb3h5IGV2ZW50IGVtaXR0ZXJzXG4gICAgY29uc3QgZXZlbnRIYW5kbGVyID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEudHlwZSkge1xuICAgICAgICAvLyBFbWl0IHRoZSBldmVudCBmcm9tIHRoZSBtYW5hZ2VyIHdpdGgga2VybmVsIElEXG4gICAgICAgIC8vIFRoaXMgc3RydWN0dXJlIG1hdGNoZXMgdGhlIHNldHVwRXZlbnRGb3J3YXJkaW5nIG1ldGhvZCBmb3IgbWFpbiB0aHJlYWQga2VybmVsc1xuICAgICAgICBzdXBlci5lbWl0KGV2ZW50LmRhdGEudHlwZSwge1xuICAgICAgICAgIGtlcm5lbElkOiBpZCxcbiAgICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBMaXN0ZW4gZm9yIGV2ZW50cyBmcm9tIHRoZSB3b3JrZXJcbiAgICBwb3J0MS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRIYW5kbGVyKTtcbiAgICBwb3J0MS5zdGFydCgpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgdGhlIGtlcm5lbCB3aXRoIGZpbGVzeXN0ZW0gb3B0aW9uc1xuICAgIC8vIFdlIG5lZWQgdG8gcGFzcyB0aGVzZSBvcHRpb25zIHRvIHRoZSB3b3JrZXJcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJJTklUSUFMSVpFX0tFUk5FTFwiLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBmaWxlc3lzdGVtOiBvcHRpb25zLmZpbGVzeXN0ZW0sXG4gICAgICAgIGVudjogb3B0aW9ucy5lbnYsXG4gICAgICAgIGxvY2tGaWxlVVJMOiBvcHRpb25zLmxvY2tGaWxlVVJMLFxuICAgICAgICBhdXRvU3luY0ZzOiBvcHRpb25zLmF1dG9TeW5jRnMsXG4gICAgICAgIGxhbmc6IGxhbmd1YWdlXG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gV2FpdCBmb3Iga2VybmVsIGluaXRpYWxpemF0aW9uXG4gICAgYXdhaXQgaW5pdFByb21pc2U7XG4gICAgXG4gICAgLy8gU2V0IHVwIGludGVycnVwdCBidWZmZXIgYXV0b21hdGljYWxseSBmb3Igd29ya2VyIGtlcm5lbHNcbiAgICBhd2FpdCB0aGlzLnNldHVwV29ya2VySW50ZXJydXB0QnVmZmVyKGlkLCB3b3JrZXIpO1xuICAgIFxuICAgIC8vIENyZWF0ZSB0aGUga2VybmVsIGluc3RhbmNlXG4gICAgY29uc3QgaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZSA9IHtcbiAgICAgIGlkLFxuICAgICAga2VybmVsOiB7XG4gICAgICAgIC8vIE1hcCBtZXRob2RzIGZyb20gdGhlIENvbWxpbmsgcHJveHkgdG8gdGhlIElLZXJuZWwgaW50ZXJmYWNlXG4gICAgICAgIGluaXRpYWxpemU6IGFzeW5jIChvcHRpb25zPzogSUtlcm5lbE9wdGlvbnMpID0+IHtcbiAgICAgICAgICByZXR1cm4ga2VybmVsUHJveHkuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXhlY3V0ZTogYXN5bmMgKGNvZGU6IHN0cmluZywgcGFyZW50PzogYW55KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQga2VybmVsUHJveHkuZXhlY3V0ZShjb2RlLCBwYXJlbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEhhbmRsZSBQeXRob24gd29ya2VyIHJlc3VsdHMgKG5vIHNwZWNpYWwgZGlzcGxheSByZWNvbnN0cnVjdGlvbiBuZWVkZWQpXG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgaXNJbml0aWFsaXplZDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBrZXJuZWxQcm94eS5pc0luaXRpYWxpemVkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0UmVwbHk6IGFzeW5jIChjb250ZW50OiB7IHZhbHVlOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBrZXJuZWxQcm94eS5pbnB1dFJlcGx5KGNvbnRlbnQpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBNYXAgYXN5bmMgZ2V0U3RhdHVzIG1ldGhvZFxuICAgICAgICBnZXRTdGF0dXM6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5nZXRTdGF0dXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmdldFN0YXR1cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBNYXAgY29tcGxldGlvbiBtZXRob2RzXG4gICAgICAgIGNvbXBsZXRlOiBhc3luYyAoY29kZTogc3RyaW5nLCBjdXJzb3JfcG9zOiBudW1iZXIsIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5jb21wbGV0ZShjb2RlLCBjdXJzb3JfcG9zLCBwYXJlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogJ0NvbXBsZXRpb24gbm90IHN1cHBvcnRlZCcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogU3RyaW5nKGVycm9yKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5zcGVjdDogYXN5bmMgKGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBkZXRhaWxfbGV2ZWw6IDAgfCAxLCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5pbnNwZWN0KGNvZGUsIGN1cnNvcl9wb3MsIGRldGFpbF9sZXZlbCwgcGFyZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6ICdJbnNwZWN0aW9uIG5vdCBzdXBwb3J0ZWQnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlzQ29tcGxldGU6IGFzeW5jIChjb2RlOiBzdHJpbmcsIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmlzQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmlzQ29tcGxldGUoY29kZSwgcGFyZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ3Vua25vd24nIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1hcCBpbnRlcnJ1cHQgbWV0aG9kc1xuICAgICAgICBpbnRlcnJ1cHQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5pbnRlcnJ1cHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmludGVycnVwdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRJbnRlcnJ1cHRCdWZmZXI6IChidWZmZXI6IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5zZXRJbnRlcnJ1cHRCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAga2VybmVsUHJveHkuc2V0SW50ZXJydXB0QnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNldCBpbnRlcnJ1cHQgYnVmZmVyOicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1hcCBtb3VudEZTIG1ldGhvZFxuICAgICAgICBtb3VudEZTOiBhc3luYyAobW91bnRQYXRoOiBzdHJpbmcsIGRpckhhbmRsZT86IEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUgfCBudWxsLCBwZXJtaXNzaW9uPzogJ3JlYWQnIHwgJ3JlYWR3cml0ZScpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5tb3VudEZTID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBrZXJuZWxQcm94eS5tb3VudEZTKG1vdW50UGF0aCwgZGlySGFuZGxlLCBwZXJtaXNzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbW91bnRGUyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMga2VybmVsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWFwIGNvbW0gbWV0aG9kc1xuICAgICAgICBjb21tSW5mbzogYXN5bmMgKHRhcmdldF9uYW1lOiBzdHJpbmcgfCBudWxsLCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5jb21tSW5mbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuY29tbUluZm8odGFyZ2V0X25hbWUsIHBhcmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4geyBjb21tczoge30sIHN0YXR1czogJ29rJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjb21tczoge30sIHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1PcGVuOiBhc3luYyAoY29udGVudDogYW55LCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5jb21tT3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQga2VybmVsUHJveHkuY29tbU9wZW4oY29udGVudCwgcGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gb3BlbiBjb21tOicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1Nc2c6IGFzeW5jIChjb250ZW50OiBhbnksIHBhcmVudD86IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbFByb3h5LmNvbW1Nc2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmNvbW1Nc2coY29udGVudCwgcGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2VuZCBjb21tIG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tbUNsb3NlOiBhc3luYyAoY29udGVudDogYW55LCBwYXJlbnQ/OiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWxQcm94eS5jb21tQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGtlcm5lbFByb3h5LmNvbW1DbG9zZShjb250ZW50LCBwYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjbG9zZSBjb21tOicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBJS2VybmVsLFxuICAgICAgbW9kZTogS2VybmVsTW9kZS5XT1JLRVIsXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIHdvcmtlcixcbiAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIG9wdGlvbnMsIC8vIFN0b3JlIHRoZSBvcHRpb25zIGZvciByZWZlcmVuY2VcbiAgICAgIGRlc3Ryb3k6IGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIHdvcmtlciBhbmQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudEhhbmRsZXIpO1xuICAgICAgICBwb3J0MS5jbG9zZSgpO1xuICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFNldHVwIGV2ZW50IGZvcndhcmRpbmcgZnJvbSBrZXJuZWwgdG8gbWFuYWdlclxuICAgKiBAcGFyYW0gaW5zdGFuY2UgS2VybmVsIGluc3RhbmNlXG4gICAqL1xuICBwcml2YXRlIHNldHVwRXZlbnRGb3J3YXJkaW5nKGluc3RhbmNlOiBJS2VybmVsSW5zdGFuY2UpOiB2b2lkIHtcbiAgICAvLyBPbmx5IG5lZWRlZCBmb3IgbWFpbiB0aHJlYWQga2VybmVscyBhcyB3b3JrZXIgZXZlbnRzIGFyZSBoYW5kbGVkIGRpcmVjdGx5XG4gICAgaWYgKGluc3RhbmNlLm1vZGUgPT09IEtlcm5lbE1vZGUuTUFJTl9USFJFQUQpIHtcbiAgICAgIC8vIEZvcndhcmQgYWxsIGtlcm5lbCBldmVudHMgdG8gdGhlIG1hbmFnZXIgd2l0aCBrZXJuZWwgSURcbiAgICAgIE9iamVjdC52YWx1ZXMoS2VybmVsRXZlbnRzKS5mb3JFYWNoKChldmVudFR5cGUpID0+IHtcbiAgICAgICAgLy8gQWNjZXNzIHRoZSBrZXJuZWwgYXMgYSBLZXJuZWwgaW5zdGFuY2Ugd2hpY2ggZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAgICAgICAgY29uc3Qga2VybmVsRW1pdHRlciA9IGluc3RhbmNlLmtlcm5lbCBhcyB1bmtub3duIGFzIEV2ZW50RW1pdHRlcjtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lciB0byBmb3J3YXJkIGV2ZW50c1xuICAgICAgICBrZXJuZWxFbWl0dGVyLm9uKGV2ZW50VHlwZSwgKGRhdGE6IGFueSkgPT4ge1xuICAgICAgICAgIHN1cGVyLmVtaXQoZXZlbnRUeXBlLCB7XG4gICAgICAgICAgICBrZXJuZWxJZDogaW5zdGFuY2UuaWQsXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogR2V0IGEga2VybmVsIGluc3RhbmNlIGJ5IElEXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgS2VybmVsIGluc3RhbmNlIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmRcbiAgICovXG4gIHB1YmxpYyBnZXRLZXJuZWwoaWQ6IHN0cmluZyk6IElLZXJuZWxJbnN0YW5jZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMua2VybmVscy5nZXQoaWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBhbGwga2VybmVsIElEc1xuICAgKiBAcmV0dXJucyBBcnJheSBvZiBrZXJuZWwgSURzXG4gICAqL1xuICBwdWJsaWMgZ2V0S2VybmVsSWRzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmtlcm5lbHMua2V5cygpKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgYWxsIGtlcm5lbHMgd2l0aCB0aGVpciBkZXRhaWxzXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgT3B0aW9uYWwgbmFtZXNwYWNlIHRvIGZpbHRlciBrZXJuZWxzIGJ5XG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGtlcm5lbCBpbmZvcm1hdGlvbiBvYmplY3RzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdEtlcm5lbHMobmFtZXNwYWNlPzogc3RyaW5nKTogUHJvbWlzZTxBcnJheTx7XG4gICAgaWQ6IHN0cmluZztcbiAgICBtb2RlOiBLZXJuZWxNb2RlO1xuICAgIGxhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgICBzdGF0dXM6IFwiYWN0aXZlXCIgfCBcImJ1c3lcIiB8IFwidW5rbm93blwiO1xuICAgIGNyZWF0ZWQ6IHN0cmluZztcbiAgICBuYW1lc3BhY2U/OiBzdHJpbmc7XG4gICAgZGVubz86IHtcbiAgICAgIHBlcm1pc3Npb25zPzogSURlbm9QZXJtaXNzaW9ucztcbiAgICB9O1xuICB9Pj4ge1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkS2VybmVscyA9IEFycmF5LmZyb20odGhpcy5rZXJuZWxzLmVudHJpZXMoKSlcbiAgICAgICAgLmZpbHRlcigoW2lkXSkgPT4ge1xuICAgICAgICAgIC8vIEZpbHRlciBvdXQgcG9vbCBrZXJuZWxzICh0ZW1wb3Jhcnkga2VybmVscyB3aXRoIElEcyBzdGFydGluZyB3aXRoIFwicG9vbC1cIilcbiAgICAgICAgICBpZiAoaWQuc3RhcnRzV2l0aChcInBvb2wtXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFuYW1lc3BhY2UpIHJldHVybiB0cnVlO1xuICAgICAgICAgIHJldHVybiBpZC5zdGFydHNXaXRoKGAke25hbWVzcGFjZX06YCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAvLyBVc2UgUHJvbWlzZS5hbGwgdG8gZ2V0IGFsbCBzdGF0dXNlcyBjb25jdXJyZW50bHlcbiAgICAgIGNvbnN0IGtlcm5lbEluZm9zID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIGZpbHRlcmVkS2VybmVscy5tYXAoYXN5bmMgKFtpZCwgaW5zdGFuY2VdKSA9PiB7XG4gICAgICAgICAgLy8gRXh0cmFjdCBuYW1lc3BhY2UgZnJvbSBpZCBpZiBwcmVzZW50XG4gICAgICAgICAgY29uc3QgbmFtZXNwYWNlTWF0Y2ggPSBpZC5tYXRjaCgvXihbXjpdKyk6Lyk7XG4gICAgICAgICAgY29uc3QgZXh0cmFjdGVkTmFtZXNwYWNlID0gbmFtZXNwYWNlTWF0Y2ggPyBuYW1lc3BhY2VNYXRjaFsxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBHZXQgc3RhdHVzIHVzaW5nIGFzeW5jIGdldFN0YXR1cyBtZXRob2RcbiAgICAgICAgICBsZXQgc3RhdHVzOiBcImFjdGl2ZVwiIHwgXCJidXN5XCIgfCBcInVua25vd25cIiA9IFwidW5rbm93blwiO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2Uua2VybmVsICYmIHR5cGVvZiBpbnN0YW5jZS5rZXJuZWwuZ2V0U3RhdHVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHN0YXR1cyA9IGF3YWl0IGluc3RhbmNlLmtlcm5lbC5nZXRTdGF0dXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBFcnJvciBnZXR0aW5nIHN0YXR1cyBmb3Iga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIHN0YXR1cyA9IFwidW5rbm93blwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBtb2RlOiBpbnN0YW5jZS5tb2RlLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IGluc3RhbmNlLmxhbmd1YWdlLFxuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgY3JlYXRlZDogaW5zdGFuY2UuY3JlYXRlZCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBuYW1lc3BhY2U6IGV4dHJhY3RlZE5hbWVzcGFjZSxcbiAgICAgICAgICAgIGRlbm86IGluc3RhbmNlLm9wdGlvbnM/LmRlbm9cbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGtlcm5lbEluZm9zO1xuICB9XG4gIFxuICAvKipcbiAgICogRGVzdHJveSBhIGtlcm5lbCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4ga2VybmVsIGlzIGRlc3Ryb3llZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRlc3Ryb3lLZXJuZWwoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgXG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgLy8gSGFuZGxlIGdyYWNlZnVsbHkgLSBrZXJuZWwgbWF5IGFscmVhZHkgYmUgZGVzdHJveWVkXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFZlcmlmeSB0aGUgZGVzdHJveSBmdW5jdGlvbiBleGlzdHNcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmRlc3Ryb3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsICR7aWR9IGlzIG1pc3NpbmcgZGVzdHJveSBmdW5jdGlvbiAodHlwZTogJHt0eXBlb2YgaW5zdGFuY2UuZGVzdHJveX0pYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFib3J0IGFsbCBvbmdvaW5nIG9wZXJhdGlvbnMgZm9yIHRoaXMga2VybmVsIGZpcnN0XG4gICAgdGhpcy5hYm9ydEFsbEtlcm5lbE9wZXJhdGlvbnMoaWQpO1xuICAgIFxuICAgIC8vIENsZWFyIGFueSBpbmFjdGl2aXR5IHRpbWVyXG4gICAgdGhpcy5jbGVhckluYWN0aXZpdHlUaW1lb3V0KGlkKTtcbiAgICBcbiAgICAvLyBDbGVhbiB1cCBleGVjdXRpb24gdGltZW91dHNcbiAgICBpZiAodGhpcy5leGVjdXRpb25UaW1lb3V0cy5oYXMoaWQpKSB7XG4gICAgICBjb25zdCB0aW1lb3V0cyA9IHRoaXMuZXhlY3V0aW9uVGltZW91dHMuZ2V0KGlkKSE7XG4gICAgICBmb3IgKGNvbnN0IHRpbWVvdXRJZCBvZiB0aW1lb3V0cy52YWx1ZXMoKSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhlY3V0aW9uVGltZW91dHMuZGVsZXRlKGlkKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZXhlY3V0aW9uIHN0YXJ0IHRpbWVzXG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuZGVsZXRlKGlkKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZXhlY3V0aW9uIG1ldGFkYXRhXG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuaGFzKGlkKSkge1xuICAgICAgdGhpcy5leGVjdXRpb25NZXRhZGF0YS5kZWxldGUoaWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBpbnRlcnJ1cHQgYnVmZmVyc1xuICAgIGlmICh0aGlzLmludGVycnVwdEJ1ZmZlcnMuaGFzKGlkKSkge1xuICAgICAgdGhpcy5pbnRlcnJ1cHRCdWZmZXJzLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIG9uZ29pbmcgZXhlY3V0aW9ucyB0cmFja2luZ1xuICAgIHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZGVsZXRlKGlkKTtcbiAgICBcbiAgICAvLyBDbGVhbiB1cCBhY3Rpdml0eSB0cmFja2luZ1xuICAgIHRoaXMubGFzdEFjdGl2aXR5VGltZS5kZWxldGUoaWQpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGlzIGtlcm5lbFxuICAgIHRoaXMucmVtb3ZlQWxsS2VybmVsTGlzdGVuZXJzKGlkKTtcbiAgICBcbiAgICAvLyBEZXN0cm95IHRoZSBrZXJuZWwgaW5zdGFuY2VcbiAgICBhd2FpdCBpbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgXG4gICAgLy8gUmVtb3ZlIHRoZSBrZXJuZWwgZnJvbSB0aGUgbWFwXG4gICAgdGhpcy5rZXJuZWxzLmRlbGV0ZShpZCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBEZXN0cm95IGFsbCBrZXJuZWwgaW5zdGFuY2VzXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgT3B0aW9uYWwgbmFtZXNwYWNlIHRvIGZpbHRlciBrZXJuZWxzIHRvIGRlc3Ryb3lcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhbGwga2VybmVscyBhcmUgZGVzdHJveWVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVzdHJveUFsbChuYW1lc3BhY2U/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBpZHMgPSBBcnJheS5mcm9tKHRoaXMua2VybmVscy5rZXlzKCkpXG4gICAgICAuZmlsdGVyKGlkID0+IHtcbiAgICAgICAgaWYgKCFuYW1lc3BhY2UpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gaWQuc3RhcnRzV2l0aChgJHtuYW1lc3BhY2V9OmApO1xuICAgICAgfSk7XG4gICAgXG4gICAgLy8gRGVzdHJveSBhbGwga2VybmVscywgYnV0IHNraXAgaW5jb21wbGV0ZSBpbnN0YW5jZXNcbiAgICBjb25zdCBkZXN0cm95UHJvbWlzZXMgPSBpZHMubWFwKGFzeW5jIChpZCkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICAgIGlmICghaW5zdGFuY2UgfHwgdHlwZW9mIGluc3RhbmNlLmRlc3Ryb3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBTa2lwcGluZyBpbmNvbXBsZXRlIGtlcm5lbCBpbnN0YW5jZSAke2lkfSBkdXJpbmcgZGVzdHJveUFsbGApO1xuICAgICAgICAvLyBKdXN0IHJlbW92ZSBpdCBmcm9tIHRoZSBtYXBcbiAgICAgICAgdGhpcy5rZXJuZWxzLmRlbGV0ZShpZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3lLZXJuZWwoaWQpO1xuICAgIH0pO1xuICAgIFxuICAgIGF3YWl0IFByb21pc2UuYWxsKGRlc3Ryb3lQcm9taXNlcyk7XG4gICAgXG4gICAgLy8gSWYgbm8gbmFtZXNwYWNlIHNwZWNpZmllZCwgYWxzbyBjbGVhbiB1cCB0aGUgcG9vbFxuICAgIGlmICghbmFtZXNwYWNlKSB7XG4gICAgICBhd2FpdCB0aGlzLmRlc3Ryb3lQb29sKCk7XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogRGVzdHJveSBhbGwga2VybmVscyBpbiB0aGUgcG9vbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBkZXN0cm95UG9vbCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBcbiAgICBjb25zdCBkZXN0cm95UHJvbWlzZXM6IFByb21pc2U8dm9pZD5bXSA9IFtdO1xuICAgIFxuICAgIGZvciAoY29uc3QgW3Bvb2xLZXksIHByb21pc2VzXSBvZiB0aGlzLnBvb2wuZW50cmllcygpKSB7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3Qga2VybmVsUHJvbWlzZSBvZiBwcm9taXNlcykge1xuICAgICAgICAvLyBIYW5kbGUgZWFjaCBwcm9taXNlIC0gaWYgaXQgcmVzb2x2ZXMsIGRlc3Ryb3kgdGhlIGtlcm5lbFxuICAgICAgICBjb25zdCBkZXN0cm95UHJvbWlzZSA9IGtlcm5lbFByb21pc2UudGhlbihrZXJuZWwgPT4ge1xuICAgICAgICAgIHJldHVybiBrZXJuZWwuZGVzdHJveSgpO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVzdHJveWluZyBwb29sIGtlcm5lbCBmcm9tIHByb21pc2U6YCwgZXJyb3IpO1xuICAgICAgICAgIC8vIERvbid0IHJlLXRocm93IHRvIGF2b2lkIHVuaGFuZGxlZCByZWplY3Rpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgZGVzdHJveVByb21pc2VzLnB1c2goZGVzdHJveVByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBXYWl0IGZvciBhbGwgcG9vbCBrZXJuZWxzIHRvIGJlIGRlc3Ryb3llZFxuICAgIGF3YWl0IFByb21pc2UuYWxsKGRlc3Ryb3lQcm9taXNlcyk7XG4gICAgXG4gICAgLy8gQ2xlYXIgdGhlIHBvb2wgYW5kIHByZWZpbGxpbmcgZmxhZ3NcbiAgICB0aGlzLnBvb2wuY2xlYXIoKTtcbiAgICB0aGlzLnByZWZpbGxpbmdJblByb2dyZXNzLmNsZWFyKCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lciBmb3IgYSBzcGVjaWZpYyBrZXJuZWwncyBldmVudHNcbiAgICogQHBhcmFtIGtlcm5lbElkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gZXZlbnRUeXBlIEV2ZW50IHR5cGVcbiAgICogQHBhcmFtIGxpc3RlbmVyIEV2ZW50IGxpc3RlbmVyXG4gICAqL1xuICBwdWJsaWMgb25LZXJuZWxFdmVudChrZXJuZWxJZDogc3RyaW5nLCBldmVudFR5cGU6IEtlcm5lbEV2ZW50cywgbGlzdGVuZXI6IChkYXRhOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAvLyBDaGVjayBpZiBrZXJuZWwgZXhpc3RzXG4gICAgaWYgKCF0aGlzLmtlcm5lbHMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgd2l0aCBJRCAke2tlcm5lbElkfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIHdyYXBwZXIgdGhhdCBmaWx0ZXJzIGV2ZW50cyBmb3IgdGhpcyBzcGVjaWZpYyBrZXJuZWxcbiAgICBjb25zdCB3cmFwcGVyOiBMaXN0ZW5lcldyYXBwZXIgPSB7XG4gICAgICBvcmlnaW5hbDogbGlzdGVuZXIsXG4gICAgICB3cmFwcGVkOiAoZXZlbnQ6IHsga2VybmVsSWQ6IHN0cmluZywgZGF0YTogYW55IH0pID0+IHtcbiAgICAgICAgaWYgKGV2ZW50Lmtlcm5lbElkID09PSBrZXJuZWxJZCkge1xuICAgICAgICAgIC8vIFBhc3MganVzdCB0aGUgZGF0YSB0byB0aGUgbGlzdGVuZXJcbiAgICAgICAgICAvLyBUaGUgZGF0YSBzdHJ1Y3R1cmUgaXMgY29uc2lzdGVudCBhY3Jvc3MgbWFpbiB0aHJlYWQgYW5kIHdvcmtlciBtb2Rlc1xuICAgICAgICAgIGxpc3RlbmVyKGV2ZW50LmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBTdG9yZSB0aGUgd3JhcHBlciBmb3IgbGF0ZXIgcmVtb3ZhbFxuICAgIHRoaXMuc3RvcmVMaXN0ZW5lcihrZXJuZWxJZCwgZXZlbnRUeXBlLCBsaXN0ZW5lciwgd3JhcHBlcik7XG4gICAgXG4gICAgLy8gQWRkIHRoZSB3cmFwcGVkIGxpc3RlbmVyIHRvIHRoZSBtYW5hZ2VyXG4gICAgc3VwZXIub24oZXZlbnRUeXBlLCB3cmFwcGVyLndyYXBwZWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBhIHNwZWNpZmljIGtlcm5lbFxuICAgKiBAcGFyYW0ga2VybmVsSWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBldmVudFR5cGUgRXZlbnQgdHlwZVxuICAgKiBAcGFyYW0gbGlzdGVuZXIgRXZlbnQgbGlzdGVuZXJcbiAgICovXG4gIHB1YmxpYyBvZmZLZXJuZWxFdmVudChrZXJuZWxJZDogc3RyaW5nLCBldmVudFR5cGU6IEtlcm5lbEV2ZW50cywgbGlzdGVuZXI6IChkYXRhOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5nZXRMaXN0ZW5lcihrZXJuZWxJZCwgZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgXG4gICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgd3JhcHBlZCBsaXN0ZW5lciBmcm9tIHRoZSBtYW5hZ2VyXG4gICAgICBzdXBlci5yZW1vdmVMaXN0ZW5lcihldmVudFR5cGUsIHdyYXBwZXIud3JhcHBlZCk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSB0aGUgd3JhcHBlciBmcm9tIG91ciB0cmFja2luZyBtYXBcbiAgICAgIHRoaXMucmVtb3ZlU3RvcmVkTGlzdGVuZXIoa2VybmVsSWQsIGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFN0b3JlIGEgbGlzdGVuZXIgd3JhcHBlciBmb3IgbGF0ZXIgcmVtb3ZhbFxuICAgKi9cbiAgcHJpdmF0ZSBzdG9yZUxpc3RlbmVyKFxuICAgIGtlcm5lbElkOiBzdHJpbmcsIFxuICAgIGV2ZW50VHlwZTogc3RyaW5nLCBcbiAgICBvcmlnaW5hbDogRnVuY3Rpb24sIFxuICAgIHdyYXBwZXI6IExpc3RlbmVyV3JhcHBlclxuICApOiB2b2lkIHtcbiAgICAvLyBHZXQgb3IgY3JlYXRlIGtlcm5lbCBtYXBcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJXcmFwcGVycy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuc2V0KGtlcm5lbElkLCBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBjb25zdCBrZXJuZWxNYXAgPSB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuZ2V0KGtlcm5lbElkKSE7XG4gICAgXG4gICAgLy8gR2V0IG9yIGNyZWF0ZSBldmVudCB0eXBlIG1hcFxuICAgIGlmICgha2VybmVsTWFwLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICBrZXJuZWxNYXAuc2V0KGV2ZW50VHlwZSwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRNYXAgPSBrZXJuZWxNYXAuZ2V0KGV2ZW50VHlwZSkhO1xuICAgIFxuICAgIC8vIFN0b3JlIHRoZSB3cmFwcGVyXG4gICAgZXZlbnRNYXAuc2V0KG9yaWdpbmFsLCB3cmFwcGVyKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhIHN0b3JlZCBsaXN0ZW5lciB3cmFwcGVyXG4gICAqL1xuICBwcml2YXRlIGdldExpc3RlbmVyKFxuICAgIGtlcm5lbElkOiBzdHJpbmcsIFxuICAgIGV2ZW50VHlwZTogc3RyaW5nLCBcbiAgICBvcmlnaW5hbDogRnVuY3Rpb25cbiAgKTogTGlzdGVuZXJXcmFwcGVyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBrZXJuZWxNYXAgPSB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAoIWtlcm5lbE1hcCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBcbiAgICBjb25zdCBldmVudE1hcCA9IGtlcm5lbE1hcC5nZXQoZXZlbnRUeXBlKTtcbiAgICBpZiAoIWV2ZW50TWFwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIHJldHVybiBldmVudE1hcC5nZXQob3JpZ2luYWwpO1xuICB9XG4gIFxuICAvKipcbiAgICogUmVtb3ZlIGEgc3RvcmVkIGxpc3RlbmVyIHdyYXBwZXJcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlU3RvcmVkTGlzdGVuZXIoXG4gICAga2VybmVsSWQ6IHN0cmluZywgXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsIFxuICAgIG9yaWdpbmFsOiBGdW5jdGlvblxuICApOiB2b2lkIHtcbiAgICBjb25zdCBrZXJuZWxNYXAgPSB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAoIWtlcm5lbE1hcCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGV2ZW50TWFwID0ga2VybmVsTWFwLmdldChldmVudFR5cGUpO1xuICAgIGlmICghZXZlbnRNYXApIHJldHVybjtcbiAgICBcbiAgICAvLyBSZW1vdmUgdGhlIGxpc3RlbmVyXG4gICAgZXZlbnRNYXAuZGVsZXRlKG9yaWdpbmFsKTtcbiAgICBcbiAgICAvLyBDbGVhbiB1cCBlbXB0eSBtYXBzXG4gICAgaWYgKGV2ZW50TWFwLnNpemUgPT09IDApIHtcbiAgICAgIGtlcm5lbE1hcC5kZWxldGUoZXZlbnRUeXBlKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGtlcm5lbE1hcC5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuZGVsZXRlKGtlcm5lbElkKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBrZXJuZWxcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlQWxsS2VybmVsTGlzdGVuZXJzKGtlcm5lbElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBrZXJuZWxNYXAgPSB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAoIWtlcm5lbE1hcCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIEZvciBlYWNoIGV2ZW50IHR5cGVcbiAgICBmb3IgKGNvbnN0IFtldmVudFR5cGUsIGV2ZW50TWFwXSBvZiBrZXJuZWxNYXAuZW50cmllcygpKSB7XG4gICAgICAvLyBGb3IgZWFjaCBvcmlnaW5hbCBsaXN0ZW5lclxuICAgICAgZm9yIChjb25zdCB3cmFwcGVyIG9mIGV2ZW50TWFwLnZhbHVlcygpKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgd3JhcHBlZCBsaXN0ZW5lciBmcm9tIHRoZSBtYW5hZ2VyXG4gICAgICAgIHN1cGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50VHlwZSwgd3JhcHBlci53cmFwcGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYXIgdGhlIGtlcm5lbCdzIGxpc3RlbmVyIG1hcFxuICAgIHRoaXMubGlzdGVuZXJXcmFwcGVycy5kZWxldGUoa2VybmVsSWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IGFsbCBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWMga2VybmVsIGFuZCBldmVudCB0eXBlXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIGV2ZW50VHlwZSBFdmVudCB0eXBlXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGxpc3RlbmVyc1xuICAgKi9cbiAgcHVibGljIGdldExpc3RlbmVycyhrZXJuZWxJZDogc3RyaW5nLCBldmVudFR5cGU6IEtlcm5lbEV2ZW50cyk6ICgoZGF0YTogYW55KSA9PiB2b2lkKVtdIHtcbiAgICBjb25zdCBrZXJuZWxMaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyV3JhcHBlcnMuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAoIWtlcm5lbExpc3RlbmVycykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBldmVudExpc3RlbmVycyA9IGtlcm5lbExpc3RlbmVycy5nZXQoZXZlbnRUeXBlKTtcbiAgICBpZiAoIWV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBBcnJheS5mcm9tKGV2ZW50TGlzdGVuZXJzLmtleXMoKSkgYXMgKChkYXRhOiBhbnkpID0+IHZvaWQpW107XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBQeXRob24gY29kZSB3aXRoIHN0cmVhbWluZyBvdXRwdXRcbiAgICogVGhpcyBtZXRob2Qgd29ya3MgaW4gYm90aCBtYWluIHRocmVhZCBhbmQgd29ya2VyIG1vZGVzXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBJRCBvZiB0aGUga2VybmVsIHRvIHVzZVxuICAgKiBAcGFyYW0gY29kZSBUaGUgUHl0aG9uIGNvZGUgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0gcGFyZW50IE9wdGlvbmFsIHBhcmVudCBtZXNzYWdlIGhlYWRlclxuICAgKiBAcmV0dXJucyBBc3luY0dlbmVyYXRvciB5aWVsZGluZyBpbnRlcm1lZGlhdGUgb3V0cHV0c1xuICAgKi9cbiAgcHVibGljIGFzeW5jKiBleGVjdXRlU3RyZWFtKFxuICAgIGtlcm5lbElkOiBzdHJpbmcsIFxuICAgIGNvZGU6IHN0cmluZywgXG4gICAgcGFyZW50OiBhbnkgPSB7fVxuICApOiBBc3luY0dlbmVyYXRvcjxhbnksIHsgc3VjY2VzczogYm9vbGVhbiwgcmVzdWx0PzogYW55LCBlcnJvcj86IEVycm9yIH0sIHZvaWQ+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0S2VybmVsKGtlcm5lbElkKTtcbiAgICBcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCB3aXRoIElEICR7a2VybmVsSWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUga2VybmVsIGFjdGl2aXR5XG4gICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgXG4gICAgLy8gVHJhY2sgdGhpcyBleGVjdXRpb24gd2l0aCB0aGUgY29kZSBmb3IgYmV0dGVyIG1vbml0b3JpbmdcbiAgICBjb25zdCBleGVjdXRpb25JZCA9IHRoaXMudHJhY2tFeGVjdXRpb24oa2VybmVsSWQsIGNvZGUpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBBYm9ydENvbnRyb2xsZXIgZm9yIHRoaXMgZXhlY3V0aW9uIHRvIGVuYWJsZSBjYW5jZWxsYXRpb25cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5zdG9yZUFib3J0Q29udHJvbGxlcihrZXJuZWxJZCwgZXhlY3V0aW9uSWQsIGFib3J0Q29udHJvbGxlcik7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZvciBtYWluIHRocmVhZCBrZXJuZWxzLCB3ZSBjYW4gdXNlIHRoZSBleGVjdXRlU3RyZWFtIG1ldGhvZCBkaXJlY3RseVxuICAgICAgaWYgKGluc3RhbmNlLm1vZGUgPT09IEtlcm5lbE1vZGUuTUFJTl9USFJFQUQpIHtcbiAgICAgICAgY29uc3Qga2VybmVsID0gaW5zdGFuY2Uua2VybmVsIGFzIHVua25vd24gYXMgeyBcbiAgICAgICAgICBleGVjdXRlU3RyZWFtOiAoY29kZTogc3RyaW5nLCBwYXJlbnQ6IGFueSkgPT4gQXN5bmNHZW5lcmF0b3I8YW55LCBhbnksIHZvaWQ+IFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gRm9yd2FyZCB0byB0aGUga2VybmVsJ3MgZXhlY3V0ZVN0cmVhbSBtZXRob2RcbiAgICAgICAgaWYgKHR5cGVvZiBrZXJuZWwuZXhlY3V0ZVN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB5aWVsZCoga2VybmVsLmV4ZWN1dGVTdHJlYW0oY29kZSwgcGFyZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5IGFmdGVyIGV4ZWN1dGlvbiBjb21wbGV0ZXNcbiAgICAgICAgICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoa2VybmVsSWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDb21wbGV0ZSBleGVjdXRpb24gdHJhY2tpbmdcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVFeGVjdXRpb24oa2VybmVsSWQsIGV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBtYWluIHRocmVhZCBleGVjdXRlU3RyZWFtOmAsIGVycm9yKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5IGV2ZW4gaWYgdGhlcmUncyBhbiBlcnJvclxuICAgICAgICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbXBsZXRlIGV4ZWN1dGlvbiB0cmFja2luZyBldmVuIG9uIGVycm9yXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlRXhlY3V0aW9uKGtlcm5lbElkLCBleGVjdXRpb25JZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZvciB3b3JrZXIgbW9kZSwgd2UgbmVlZCB0byBpbXBsZW1lbnQgc3RyZWFtaW5nIHZpYSBldmVudHMgd2l0aCBwcm9wZXIgaXNvbGF0aW9uXG4gICAgICB0cnkge1xuICAgICAgICAvLyBFdmVudC1iYXNlZCBhcHByb2FjaCBmb3Igd29ya2VyIGtlcm5lbHMgb3IgbWFpbiB0aHJlYWQga2VybmVscyB3aXRob3V0IGV4ZWN1dGVTdHJlYW1cbiAgICAgICAgY29uc3Qgc3RyZWFtUXVldWU6IGFueVtdID0gW107XG4gICAgICAgIGxldCBleGVjdXRpb25Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgZXhlY3V0aW9uUmVzdWx0OiB7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9ID0geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSBoYW5kbGVyIHJlZmVyZW5jZXMgZm9yIGd1YXJhbnRlZWQgY2xlYW51cFxuICAgICAgICBjb25zdCBldmVudEhhbmRsZXJzID0gbmV3IE1hcDxzdHJpbmcsIChldmVudDogeyBrZXJuZWxJZDogc3RyaW5nLCBkYXRhOiBhbnkgfSkgPT4gdm9pZD4oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjbGVhbiB1cCBhbGwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgY29uc3QgY2xlYW51cEhhbmRsZXJzID0gKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgW2V2ZW50VHlwZSwgaGFuZGxlcl0gb2YgZXZlbnRIYW5kbGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHN1cGVyLm9mZihldmVudFR5cGUgYXMgYW55LCBoYW5kbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXZlbnRIYW5kbGVycy5jbGVhcigpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGV4ZWN1dGlvbi1zcGVjaWZpYyBldmVudCBoYW5kbGVycyB0aGF0IGluY2x1ZGUgZXhlY3V0aW9uSWQgY2hlY2tcbiAgICAgICAgY29uc3QgY3JlYXRlSGFuZGxlciA9IChldmVudFR5cGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQ6IHsga2VybmVsSWQ6IHN0cmluZywgZGF0YTogYW55IH0pID0+IHtcbiAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBldmVudHMgZm9yIHRoaXMgc3BlY2lmaWMga2VybmVsIGFuZCB3aGlsZSB0aGlzIGV4ZWN1dGlvbiBpcyBhY3RpdmVcbiAgICAgICAgICAgIGlmIChldmVudC5rZXJuZWxJZCA9PT0ga2VybmVsSWQgJiYgIWV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIHN0cmVhbVF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBldmVudC5kYXRhLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbklkIC8vIEluY2x1ZGUgZXhlY3V0aW9uIElEIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBFdmVudHMgYWxzbyBjb3VudCBhcyBhY3Rpdml0eVxuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGV2ZW50SGFuZGxlcnMuc2V0KGV2ZW50VHlwZSwgaGFuZGxlcik7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYW5kIHJlZ2lzdGVyIGFsbCBldmVudCBoYW5kbGVyc1xuICAgICAgICBjb25zdCBoYW5kbGVTdHJlYW1FdmVudCA9IGNyZWF0ZUhhbmRsZXIoJ3N0cmVhbScpO1xuICAgICAgICBjb25zdCBoYW5kbGVEaXNwbGF5RXZlbnQgPSBjcmVhdGVIYW5kbGVyKCdkaXNwbGF5X2RhdGEnKTtcbiAgICAgICAgY29uc3QgaGFuZGxlVXBkYXRlRGlzcGxheUV2ZW50ID0gY3JlYXRlSGFuZGxlcigndXBkYXRlX2Rpc3BsYXlfZGF0YScpO1xuICAgICAgICBjb25zdCBoYW5kbGVSZXN1bHRFdmVudCA9IGNyZWF0ZUhhbmRsZXIoJ2V4ZWN1dGVfcmVzdWx0Jyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZUVycm9yRXZlbnQgPSBjcmVhdGVIYW5kbGVyKCdleGVjdXRlX2Vycm9yJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWdpc3RlciBoYW5kbGVyc1xuICAgICAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuU1RSRUFNLCBoYW5kbGVTdHJlYW1FdmVudCk7XG4gICAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5ESVNQTEFZX0RBVEEsIGhhbmRsZURpc3BsYXlFdmVudCk7XG4gICAgICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5VUERBVEVfRElTUExBWV9EQVRBLCBoYW5kbGVVcGRhdGVEaXNwbGF5RXZlbnQpO1xuICAgICAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuRVhFQ1VURV9SRVNVTFQsIGhhbmRsZVJlc3VsdEV2ZW50KTtcbiAgICAgICAgc3VwZXIub24oS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsIGhhbmRsZUVycm9yRXZlbnQpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIGV4ZWN1dGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICBjb25zdCBleGVjdXRpb25Qcm9taXNlID0gbmV3IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ/OiBhbnksIGVycm9yPzogRXJyb3IgfT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIC8vIFNldCB1cCBhIGhhbmRsZXIgZm9yIGV4ZWN1dGlvbiBlcnJvcnMgc3BlY2lmaWNhbGx5XG4gICAgICAgICAgY29uc3QgaGFuZGxlRXhlY3V0aW9uRXJyb3IgPSAoZXZlbnQ6IHsga2VybmVsSWQ6IHN0cmluZywgZGF0YTogYW55IH0pID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXJuZWxJZCA9PT0ga2VybmVsSWQgJiYgIWV4ZWN1dGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIC8vIE1hcmsgZXhlY3V0aW9uIGFzIGNvbXBsZXRlIHRvIHN0b3AgcHJvY2Vzc2luZyBtb3JlIGV2ZW50c1xuICAgICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgZXJyb3IgZm9yIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgICAgICAgICAgZXhlY3V0aW9uUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYCR7ZXZlbnQuZGF0YS5lbmFtZX06ICR7ZXZlbnQuZGF0YS5ldmFsdWV9YCksXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBldmVudC5kYXRhXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZpdHlcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXNvbHZlKGV4ZWN1dGlvblJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGQgZXJyb3IgaGFuZGxlciB0byBvdXIgY2xlYW51cCBsaXN0XG4gICAgICAgICAgZXZlbnRIYW5kbGVycy5zZXQoJ2V4ZWN1dGVfZXJyb3JfY29tcGxldGlvbicsIGhhbmRsZUV4ZWN1dGlvbkVycm9yKTtcbiAgICAgICAgICBzdXBlci5vbihLZXJuZWxFdmVudHMuRVhFQ1VURV9FUlJPUiwgaGFuZGxlRXhlY3V0aW9uRXJyb3IpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgYWJvcnRlZFxuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignRXhlY3V0aW9uIHdhcyBhYm9ydGVkJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTZXQgdXAgYWJvcnQgaGFuZGxlclxuICAgICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfmqsgRXhlY3V0aW9uICR7ZXhlY3V0aW9uSWR9IGFib3J0ZWRgKTtcbiAgICAgICAgICAgICAgZXhlY3V0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignRXhlY3V0aW9uIHdhcyBhYm9ydGVkJylcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBjb2RlXG4gICAgICAgICAgLy8gV2Uga25vdyB0aGUgZXhlY3V0ZSBtZXRob2QgaXMgYXZhaWxhYmxlIGRpcmVjdGx5IG9uIHRoZSBrZXJuZWwgb2JqZWN0XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGVQcm9taXNlID0gaW5zdGFuY2Uua2VybmVsLmV4ZWN1dGUoY29kZSwgcGFyZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhlY3V0ZVByb21pc2UudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBpZiBleGVjdXRpb24gaGFzbid0IGJlZW4gbWFya2VkIGNvbXBsZXRlIGFscmVhZHlcbiAgICAgICAgICAgICAgaWYgKCFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBleGVjdXRpb24gcmVzdWx0IGluZGljYXRlcyBhbiBlcnJvciAoZm9yIFB5dGhvbiBrZXJuZWxzKVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcyAmJiByZXN1bHQucmVzdWx0ICYmIHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBhcyBlcnJvclxuICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3VsdC5yZXN1bHQuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBlbmFtZTogcmVzdWx0LnJlc3VsdC5lbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXZhbHVlOiByZXN1bHQucmVzdWx0LmV2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2ViYWNrOiByZXN1bHQucmVzdWx0LnRyYWNlYmFja1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gUHVzaCBlcnJvciB0byBzdHJlYW0gcXVldWUgZGlyZWN0bHkgXG4gICAgICAgICAgICAgICAgICBzdHJlYW1RdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZXJyb3JEYXRhLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRpb25JZFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBleGVjdXRpb24gcmVzdWx0IHRvIHJlZmxlY3QgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgICBleGVjdXRpb25SZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGAke3Jlc3VsdC5yZXN1bHQuZW5hbWV9OiAke3Jlc3VsdC5yZXN1bHQuZXZhbHVlfWApLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdC5yZXN1bHRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvblJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3Rpdml0eSB3aGVuIGV4ZWN1dGlvbiBjb21wbGV0ZXNcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXNvbHZlKGV4ZWN1dGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAvLyBPbmx5IHByb2Nlc3MgaWYgZXhlY3V0aW9uIGhhc24ndCBiZWVuIG1hcmtlZCBjb21wbGV0ZSBhbHJlYWR5XG4gICAgICAgICAgICAgIGlmICghZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBleGVjdXRlIGZvciBrZXJuZWwgJHtrZXJuZWxJZH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBLZXlib2FyZEludGVycnVwdCBhbmQgaGFuZGxlIGl0IHNwZWNpYWxseVxuICAgICAgICAgICAgICAgIGxldCBlcnJvclJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0tleWJvYXJkSW50ZXJydXB0KGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEtleWJvYXJkSW50ZXJydXB0IGNhdWdodCBpbiBleGVjdXRlU3RyZWFtIGZvciBrZXJuZWwgJHtrZXJuZWxJZH1gKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yUmVzdWx0ID0gdGhpcy5jcmVhdGVLZXlib2FyZEludGVycnVwdFJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBBbHNvIHB1c2ggdG8gc3RyZWFtIHF1ZXVlIGZvciBpbW1lZGlhdGUgZmVlZGJhY2tcbiAgICAgICAgICAgICAgICAgIHN0cmVhbVF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBlcnJvclJlc3VsdC5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbklkXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG90aGVyIGVycm9ycyBub3JtYWxseVxuICAgICAgICAgICAgICAgICAgZXJyb3JSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBleGVjdXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uUmVzdWx0ID0gZXJyb3JSZXN1bHQ7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGl2aXR5IGV2ZW4gb24gZXJyb3JcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXNvbHZlKGVycm9yUmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBpZiBleGVjdXRpb24gaGFzbid0IGJlZW4gbWFya2VkIGNvbXBsZXRlIGFscmVhZHlcbiAgICAgICAgICAgIGlmICghZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY2FsbGluZyBleGVjdXRlIGZvciBrZXJuZWwgJHtrZXJuZWxJZH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gU2ltcGxlIGVycm9yIGhhbmRsaW5nXG4gICAgICAgICAgICAgIGNvbnN0IGVycm9yUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZXhlY3V0aW9uUmVzdWx0ID0gZXJyb3JSZXN1bHQ7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZpdHkgZXZlbiBvbiBkaXJlY3QgZXJyb3JcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXNvbHZlKGVycm9yUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVXNlIHRyeS9maW5hbGx5IHRvIGd1YXJhbnRlZSBjbGVhbnVwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gTW9uaXRvciB0aGUgc3RyZWFtIHF1ZXVlIGFuZCB5aWVsZCByZXN1bHRzXG4gICAgICAgICAgLy8gQ29udGludWUgdW50aWwgZXhlY3V0aW9uIGlzIGNvbXBsZXRlIEFORCBhbGwgcXVldWVkIGV2ZW50cyBoYXZlIGJlZW4geWllbGRlZFxuICAgICAgICAgIHdoaWxlICgoIWV4ZWN1dGlvbkNvbXBsZXRlIHx8IHN0cmVhbVF1ZXVlLmxlbmd0aCA+IDApICYmICFhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBpdGVtcyBpbiB0aGUgcXVldWUsIHlpZWxkIHRoZW1cbiAgICAgICAgICAgIGlmIChzdHJlYW1RdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gc3RyZWFtUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiBubyBtb3JlIGV2ZW50cyBidXQgZXhlY3V0aW9uIGlzIG5vdCBjb21wbGV0ZSwgd2FpdCBhIGxpdHRsZVxuICAgICAgICAgICAgaWYgKCFleGVjdXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAvLyBVc2UgYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgd2FpdFxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApO1xuICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0Fib3J0ZWQnKSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhYm9ydGVkLCBicmVhayBvdXQgb2YgbG9vcFxuICAgICAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiBleGVjdXRpb24gd2FzIGFib3J0ZWQgZHVyaW5nIHN0cmVhbSBtb25pdG9yaW5nXG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJiAhZXhlY3V0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhlY3V0aW9uIHdhcyBhYm9ydGVkIGR1cmluZyBzdHJlYW0gbW9uaXRvcmluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgZmluYWwgcmVzdWx0XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0aW9uUHJvbWlzZTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIC8vIEFMV0FZUyBjbGVhbiB1cCBldmVudCBoYW5kbGVycyByZWdhcmRsZXNzIG9mIGhvdyBleGVjdXRpb24gZW5kc1xuICAgICAgICAgIGNsZWFudXBIYW5kbGVycygpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBBYm9ydENvbnRyb2xsZXIgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICB0aGlzLnJlbW92ZUFib3J0Q29udHJvbGxlcihrZXJuZWxJZCwgZXhlY3V0aW9uSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENvbXBsZXRlIGV4ZWN1dGlvbiB0cmFja2luZ1xuICAgICAgICAgIHRoaXMuY29tcGxldGVFeGVjdXRpb24oa2VybmVsSWQsIGV4ZWN1dGlvbklkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gQ29tcGxldGUgZXhlY3V0aW9uIHRyYWNraW5nIG9uIGFueSBvdXRlciBlcnJvclxuICAgICAgICB0aGlzLmNvbXBsZXRlRXhlY3V0aW9uKGtlcm5lbElkLCBleGVjdXRpb25JZCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmVycm9yKGBVbmV4cGVjdGVkIGVycm9yIGluIGV4ZWN1dGVTdHJlYW06YCwgZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIENvbXBsZXRlIGV4ZWN1dGlvbiB0cmFja2luZyBvbiBhbnkgb3V0ZXIgZXJyb3JcbiAgICAgIHRoaXMuY29tcGxldGVFeGVjdXRpb24oa2VybmVsSWQsIGV4ZWN1dGlvbklkKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5lcnJvcihgVW5leHBlY3RlZCBlcnJvciBpbiBleGVjdXRlU3RyZWFtOmAsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhY2sgYSBuZXcgZXhlY3V0aW9uIHRhc2sgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBLZXJuZWwgSURcbiAgICogQHBhcmFtIGNvZGUgT3B0aW9uYWwgY29kZSBiZWluZyBleGVjdXRlZCBmb3IgbWV0YWRhdGFcbiAgICogQHJldHVybnMgVW5pcXVlIGV4ZWN1dGlvbiBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSB0cmFja0V4ZWN1dGlvbihrZXJuZWxJZDogc3RyaW5nLCBjb2RlPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBDcmVhdGUgYSB1bmlxdWUgZXhlY3V0aW9uIElEXG4gICAgY29uc3QgZXhlY3V0aW9uSWQgPSBgZXhlYy0ke2NyeXB0by5yYW5kb21VVUlEKCl9YDtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIFJlc2V0IGludGVycnVwdCBidWZmZXIgZm9yIHdvcmtlciBrZXJuZWxzIGJlZm9yZSBlYWNoIG5ldyBleGVjdXRpb25cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIGtlcm5lbCBjYW4gYmUgaW50ZXJydXB0ZWQgbXVsdGlwbGUgdGltZXNcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpO1xuICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5tb2RlID09PSBLZXJuZWxNb2RlLldPUktFUiAmJiB0aGlzLmludGVycnVwdEJ1ZmZlcnMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgY29uc3QgaW50ZXJydXB0QnVmZmVyID0gdGhpcy5pbnRlcnJ1cHRCdWZmZXJzLmdldChrZXJuZWxJZCkhO1xuICAgICAgLy8gUmVzZXQgYnVmZmVyIHRvIDAgKG5vIGludGVycnVwdCBzaWduYWwpIHRvIGVuc3VyZSBjbGVhbiBzdGF0ZVxuICAgICAgaW50ZXJydXB0QnVmZmVyWzBdID0gMDtcbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IG9yIGNyZWF0ZSB0aGUgc2V0IG9mIG9uZ29pbmcgZXhlY3V0aW9ucyBmb3IgdGhpcyBrZXJuZWxcbiAgICBpZiAoIXRoaXMub25nb2luZ0V4ZWN1dGlvbnMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5zZXQoa2VybmVsSWQsIG5ldyBTZXQoKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCB0aGlzIGV4ZWN1dGlvbiB0byB0aGUgc2V0XG4gICAgdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5nZXQoa2VybmVsSWQpIS5hZGQoZXhlY3V0aW9uSWQpO1xuICAgIFxuICAgIC8vIFRyYWNrIGV4ZWN1dGlvbiBzdGFydCB0aW1lXG4gICAgaWYgKCF0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuaGFzKGtlcm5lbElkKSkge1xuICAgICAgdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLnNldChrZXJuZWxJZCwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmdldChrZXJuZWxJZCkhLnNldChleGVjdXRpb25JZCwgc3RhcnRUaW1lKTtcbiAgICBcbiAgICAvLyBUcmFjayBleGVjdXRpb24gbWV0YWRhdGFcbiAgICBpZiAoIXRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuaGFzKGtlcm5lbElkKSkge1xuICAgICAgdGhpcy5leGVjdXRpb25NZXRhZGF0YS5zZXQoa2VybmVsSWQsIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBhY3Rpdml0eSB0aW1lc3RhbXBcbiAgICB0aGlzLnVwZGF0ZUtlcm5lbEFjdGl2aXR5KGtlcm5lbElkKTtcbiAgICBcbiAgICAvLyBJZiBtYXhFeGVjdXRpb25UaW1lIGlzIHNldCwgY3JlYXRlIGEgdGltZW91dCB0byBkZXRlY3Qgc3R1Y2svZGVhZCBrZXJuZWxzXG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZSAmJiBpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgPiAwKSB7XG4gICAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBtYXAgb2YgZXhlY3V0aW9uIHRpbWVvdXRzIGZvciB0aGlzIGtlcm5lbFxuICAgICAgaWYgKCF0aGlzLmV4ZWN1dGlvblRpbWVvdXRzLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgICAgdGhpcy5leGVjdXRpb25UaW1lb3V0cy5zZXQoa2VybmVsSWQsIG5ldyBNYXAoKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNldCBhIHRpbWVvdXQgZm9yIHRoaXMgZXhlY3V0aW9uIHdpdGggZW5oYW5jZWQgaGFuZGxpbmdcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oYEV4ZWN1dGlvbiAke2V4ZWN1dGlvbklkfSBvbiBrZXJuZWwgJHtrZXJuZWxJZH0gaGFzIGJlZW4gcnVubmluZyBmb3IgJHtpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWV9bXMgYW5kIG1heSBiZSBzdHVjay9kZWFkLmApO1xuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGV4ZWN1dGlvbiBtZXRhZGF0YSBmb3IgYmV0dGVyIGVycm9yIHJlcG9ydGluZ1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuZ2V0KGtlcm5lbElkKT8uZ2V0KGV4ZWN1dGlvbklkKTtcbiAgICAgICAgY29uc3QgYWN0dWFsUnVudGltZSA9IERhdGUubm93KCkgLSAobWV0YWRhdGE/LnN0YXJ0VGltZSB8fCBzdGFydFRpbWUpO1xuICAgICAgICBcbiAgICAgICAgLy8gRW1pdCBhIHN0YWxsZWQgZXhlY3V0aW9uIGV2ZW50IHdpdGggZW5oYW5jZWQgaW5mb3JtYXRpb25cbiAgICAgICAgc3VwZXIuZW1pdCgnZXhlY3V0aW9uX3N0YWxsZWQnLCB7XG4gICAgICAgICAga2VybmVsSWQsXG4gICAgICAgICAgZXhlY3V0aW9uSWQsXG4gICAgICAgICAgbWF4RXhlY3V0aW9uVGltZTogaW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lLFxuICAgICAgICAgIGFjdHVhbFJ1bnRpbWUsXG4gICAgICAgICAgY29kZTogbWV0YWRhdGE/LmNvZGUgfHwgY29kZSxcbiAgICAgICAgICBzdGFydFRpbWU6IG1ldGFkYXRhPy5zdGFydFRpbWUgfHwgc3RhcnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQXV0by1oYW5kbGUgc3R1Y2sgZXhlY3V0aW9uIGlmIGNvbmZpZ3VyZWRcbiAgICAgICAgdGhpcy5oYW5kbGVTdHVja0V4ZWN1dGlvbihrZXJuZWxJZCwgZXhlY3V0aW9uSWQsIGFjdHVhbFJ1bnRpbWUsIG1ldGFkYXRhPy5jb2RlIHx8IGNvZGUpO1xuICAgICAgfSwgaW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lKTtcbiAgICAgIFxuICAgICAgLy8gU3RvcmUgdGhlIHRpbWVvdXQgSURcbiAgICAgIHRoaXMuZXhlY3V0aW9uVGltZW91dHMuZ2V0KGtlcm5lbElkKSEuc2V0KGV4ZWN1dGlvbklkLCB0aW1lb3V0SWQpO1xuICAgICAgXG4gICAgICAvLyBTdG9yZSBtZXRhZGF0YSBpbmNsdWRpbmcgdGltZW91dCBJRFxuICAgICAgdGhpcy5leGVjdXRpb25NZXRhZGF0YS5nZXQoa2VybmVsSWQpIS5zZXQoZXhlY3V0aW9uSWQsIHtcbiAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICBjb2RlLFxuICAgICAgICB0aW1lb3V0SWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdG9yZSBtZXRhZGF0YSB3aXRob3V0IHRpbWVvdXQgSURcbiAgICAgIHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuZ2V0KGtlcm5lbElkKSEuc2V0KGV4ZWN1dGlvbklkLCB7XG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgY29kZVxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBleGVjdXRpb25JZDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENvbXBsZXRlIHRyYWNraW5nIGZvciBhbiBleGVjdXRpb25cbiAgICogQHBhcmFtIGtlcm5lbElkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gZXhlY3V0aW9uSWQgRXhlY3V0aW9uIElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGNvbXBsZXRlRXhlY3V0aW9uKGtlcm5lbElkOiBzdHJpbmcsIGV4ZWN1dGlvbklkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBDbGVhciBhbnkgZXhlY3V0aW9uIHRpbWVvdXRcbiAgICBpZiAodGhpcy5leGVjdXRpb25UaW1lb3V0cy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICBjb25zdCB0aW1lb3V0cyA9IHRoaXMuZXhlY3V0aW9uVGltZW91dHMuZ2V0KGtlcm5lbElkKSE7XG4gICAgICBpZiAodGltZW91dHMuaGFzKGV4ZWN1dGlvbklkKSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dHMuZ2V0KGV4ZWN1dGlvbklkKSk7XG4gICAgICAgIHRpbWVvdXRzLmRlbGV0ZShleGVjdXRpb25JZCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHVwIGVtcHR5IG1hcHNcbiAgICAgIGlmICh0aW1lb3V0cy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uVGltZW91dHMuZGVsZXRlKGtlcm5lbElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZXhlY3V0aW9uIHN0YXJ0IHRpbWVzXG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5oYXMoa2VybmVsSWQpKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWVzID0gdGhpcy5leGVjdXRpb25TdGFydFRpbWVzLmdldChrZXJuZWxJZCkhO1xuICAgICAgc3RhcnRUaW1lcy5kZWxldGUoZXhlY3V0aW9uSWQpO1xuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCBlbXB0eSBtYXBzXG4gICAgICBpZiAoc3RhcnRUaW1lcy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5kZWxldGUoa2VybmVsSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBleGVjdXRpb24gbWV0YWRhdGFcbiAgICBpZiAodGhpcy5leGVjdXRpb25NZXRhZGF0YS5oYXMoa2VybmVsSWQpKSB7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuZXhlY3V0aW9uTWV0YWRhdGEuZ2V0KGtlcm5lbElkKSE7XG4gICAgICBtZXRhZGF0YS5kZWxldGUoZXhlY3V0aW9uSWQpO1xuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCBlbXB0eSBtYXBzXG4gICAgICBpZiAobWV0YWRhdGEuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbk1ldGFkYXRhLmRlbGV0ZShrZXJuZWxJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFJlbW92ZSBmcm9tIG9uZ29pbmcgZXhlY3V0aW9uc1xuICAgIGlmICh0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmhhcyhrZXJuZWxJZCkpIHtcbiAgICAgIGNvbnN0IGV4ZWN1dGlvbnMgPSB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChrZXJuZWxJZCkhO1xuICAgICAgZXhlY3V0aW9ucy5kZWxldGUoZXhlY3V0aW9uSWQpO1xuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCBlbXB0eSBzZXRzXG4gICAgICBpZiAoZXhlY3V0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuZGVsZXRlKGtlcm5lbElkKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBhY3Rpdml0eSB0aW1lc3RhbXAgZm9yIGNvbXBsZXRlZCBleGVjdXRpb25cbiAgICAgICAgdGhpcy51cGRhdGVLZXJuZWxBY3Rpdml0eShrZXJuZWxJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBrZXJuZWwgaGFzIGFueSBvbmdvaW5nIGV4ZWN1dGlvbnNcbiAgICogQHBhcmFtIGtlcm5lbElkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBrZXJuZWwgaGFzIG9uZ29pbmcgZXhlY3V0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBoYXNPbmdvaW5nRXhlY3V0aW9ucyhrZXJuZWxJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMub25nb2luZ0V4ZWN1dGlvbnMuaGFzKGtlcm5lbElkKSAmJiBcbiAgICAgICAgICAgdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5nZXQoa2VybmVsSWQpIS5zaXplID4gMDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgY291bnQgb2Ygb25nb2luZyBleGVjdXRpb25zIGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIE51bWJlciBvZiBvbmdvaW5nIGV4ZWN1dGlvbnNcbiAgICovXG4gIHB1YmxpYyBnZXRPbmdvaW5nRXhlY3V0aW9uQ291bnQoaWQ6IHN0cmluZyk6IG51bWJlciB7XG4gICAgaWYgKCF0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmhhcyhpZCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5nZXQoaWQpIS5zaXplO1xuICB9XG4gIFxuICAvKipcbiAgICogU2V0IHVwIGFuIGluYWN0aXZpdHkgdGltZW91dCBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gdGltZW91dCBUaW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cEluYWN0aXZpdHlUaW1lb3V0KGlkOiBzdHJpbmcsIHRpbWVvdXQ6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIERvbid0IHNldCB1cCBhIHRpbWVyIGlmIHRpbWVvdXQgaXMgMCBvciBuZWdhdGl2ZVxuICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQWx3YXlzIGNsZWFyIGFueSBleGlzdGluZyB0aW1lciBmaXJzdFxuICAgIHRoaXMuY2xlYXJJbmFjdGl2aXR5VGltZW91dChpZCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHJlbWFpbmluZyB0aW1lIGJhc2VkIG9uIGxhc3QgYWN0aXZpdHlcbiAgICBjb25zdCBsYXN0QWN0aXZpdHkgPSB0aGlzLmxhc3RBY3Rpdml0eVRpbWUuZ2V0KGlkKSB8fCBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gbGFzdEFjdGl2aXR5O1xuICAgIGNvbnN0IHJlbWFpbmluZ1RpbWUgPSBNYXRoLm1heCgwLCB0aW1lb3V0IC0gZWxhcHNlZCk7XG4gICAgXG4gICAgLy8gSWYgbm8gdGltZSByZW1haW5pbmcsIGRlc3Ryb3kgaW1tZWRpYXRlbHlcbiAgICBpZiAocmVtYWluaW5nVGltZSA9PT0gMCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGtlcm5lbCBoYXMgb25nb2luZyBleGVjdXRpb25zIGJlZm9yZSBzaHV0dGluZyBkb3duXG4gICAgICBpZiAodGhpcy5oYXNPbmdvaW5nRXhlY3V0aW9ucyhpZCkpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHRpbWVyIHRvIGNoZWNrIGFnYWluIGxhdGVyXG4gICAgICAgIHRoaXMuc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZCwgdGltZW91dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGVzdHJveSBpbW1lZGlhdGVseVxuICAgICAgdGhpcy5kZXN0cm95S2VybmVsKGlkKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlc3Ryb3lpbmcgaW5hY3RpdmUga2VybmVsICR7aWR9OmAsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgYSB0aW1lciB0byBkZXN0cm95IHRoZSBrZXJuZWwgYWZ0ZXIgdGhlIHJlbWFpbmluZyB0aW1lb3V0XG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBrZXJuZWwgaGFzIG9uZ29pbmcgZXhlY3V0aW9ucyBiZWZvcmUgc2h1dHRpbmcgZG93blxuICAgICAgaWYgKHRoaXMuaGFzT25nb2luZ0V4ZWN1dGlvbnMoaWQpKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSB0aW1lciB0byBjaGVjayBhZ2FpbiBsYXRlclxuICAgICAgICB0aGlzLnNldHVwSW5hY3Rpdml0eVRpbWVvdXQoaWQsIHRpbWVvdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRoaXMuZGVzdHJveUtlcm5lbChpZCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZXN0cm95aW5nIGluYWN0aXZlIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICB9KTtcbiAgICB9LCByZW1haW5pbmdUaW1lKTtcbiAgICBcbiAgICAvLyBTdG9yZSB0aGUgdGltZXIgSURcbiAgICB0aGlzLmluYWN0aXZpdHlUaW1lcnMuc2V0KGlkLCB0aW1lcik7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDbGVhciBhbnkgZXhpc3RpbmcgaW5hY3Rpdml0eSB0aW1lb3V0IGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGNsZWFySW5hY3Rpdml0eVRpbWVvdXQoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLmluYWN0aXZpdHlUaW1lcnMuaGFzKGlkKSkge1xuICAgICAgY29uc3QgdGltZXJJZCA9IHRoaXMuaW5hY3Rpdml0eVRpbWVycy5nZXQoaWQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgdGhpcy5pbmFjdGl2aXR5VGltZXJzLmRlbGV0ZShpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhY3Rpdml0eSB0aW1lc3RhbXAgZm9yIGEga2VybmVsIGFuZCByZXNldCBpbmFjdGl2aXR5IHRpbWVyIGlmIHByZXNlbnRcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVLZXJuZWxBY3Rpdml0eShpZDogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIHRoZSBsYXN0IGFjdGl2aXR5IHRpbWVcbiAgICB0aGlzLmxhc3RBY3Rpdml0eVRpbWUuc2V0KGlkLCBEYXRlLm5vdygpKTtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGtlcm5lbCBvcHRpb25zXG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdGltZW91dCA9IGluc3RhbmNlLm9wdGlvbnMuaW5hY3Rpdml0eVRpbWVvdXQ7XG4gICAgXG4gICAgLy8gUmVzZXQgdGhlIGluYWN0aXZpdHkgdGltZXIgaWYgdGltZW91dCBpcyBlbmFibGVkIChncmVhdGVyIHRoYW4gMClcbiAgICBpZiAodGltZW91dCAmJiB0aW1lb3V0ID4gMCkge1xuICAgICAgdGhpcy5zZXR1cEluYWN0aXZpdHlUaW1lb3V0KGlkLCB0aW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXN0IGFjdGl2aXR5IHRpbWUgZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgTGFzdCBhY3Rpdml0eSB0aW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaCwgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgcHVibGljIGdldExhc3RBY3Rpdml0eVRpbWUoaWQ6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubGFzdEFjdGl2aXR5VGltZS5nZXQoaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW5hY3Rpdml0eSB0aW1lb3V0IGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIEluYWN0aXZpdHkgdGltZW91dCBpbiBtaWxsaXNlY29uZHMsIG9yIHVuZGVmaW5lZCBpZiBub3Qgc2V0XG4gICAqL1xuICBwdWJsaWMgZ2V0SW5hY3Rpdml0eVRpbWVvdXQoaWQ6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIHJldHVybiBpbnN0YW5jZS5vcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBvciB1cGRhdGUgdGhlIGluYWN0aXZpdHkgdGltZW91dCBmb3IgYSBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gdGltZW91dCBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcywgb3IgMCB0byBkaXNhYmxlXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRpbWVvdXQgd2FzIHNldCwgZmFsc2UgaWYgdGhlIGtlcm5lbCB3YXMgbm90IGZvdW5kXG4gICAqL1xuICBwdWJsaWMgc2V0SW5hY3Rpdml0eVRpbWVvdXQoaWQ6IHN0cmluZywgdGltZW91dDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gVXBkYXRlIHRoZSB0aW1lb3V0IGluIHRoZSBvcHRpb25zXG4gICAgaW5zdGFuY2Uub3B0aW9ucy5pbmFjdGl2aXR5VGltZW91dCA9IHRpbWVvdXQ7XG4gICAgXG4gICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHRpbWVyXG4gICAgdGhpcy5jbGVhckluYWN0aXZpdHlUaW1lb3V0KGlkKTtcbiAgICBcbiAgICAvLyBJZiB0aW1lb3V0IGlzIGdyZWF0ZXIgdGhhbiAwLCBzZXQgdXAgYSBuZXcgdGltZXJcbiAgICBpZiAodGltZW91dCA+IDApIHtcbiAgICAgIHRoaXMuc2V0dXBJbmFjdGl2aXR5VGltZW91dChpZCwgdGltZW91dCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aW1lIHVudGlsIGF1dG8tc2h1dGRvd24gZm9yIGEga2VybmVsXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgVGltZSBpbiBtaWxsaXNlY29uZHMgdW50aWwgYXV0by1zaHV0ZG93biwgb3IgdW5kZWZpbmVkIGlmIG5vIHRpbWVvdXQgaXMgc2V0XG4gICAqL1xuICBwdWJsaWMgZ2V0VGltZVVudGlsU2h1dGRvd24oaWQ6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIGNvbnN0IHRpbWVvdXQgPSBpbnN0YW5jZS5vcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0O1xuICAgIGlmICghdGltZW91dCB8fCB0aW1lb3V0IDw9IDApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgY29uc3QgbGFzdEFjdGl2aXR5ID0gdGhpcy5sYXN0QWN0aXZpdHlUaW1lLmdldChpZCk7XG4gICAgaWYgKCFsYXN0QWN0aXZpdHkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBEYXRlLm5vdygpIC0gbGFzdEFjdGl2aXR5O1xuICAgIGNvbnN0IHJlbWFpbmluZ1RpbWUgPSB0aW1lb3V0IC0gZWxhcHNlZFRpbWU7XG4gICAgXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHJlbWFpbmluZ1RpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIG9mIGluYWN0aXZpdHkgdGltZXJzIChmb3IgZGVidWdnaW5nL3Rlc3Rpbmcgb25seSlcbiAgICogQHJldHVybnMgT2JqZWN0IHdpdGgga2VybmVsIElEcyBhcyBrZXlzIGFuZCB0aW1lciBJRHMgYXMgdmFsdWVzXG4gICAqL1xuICBwdWJsaWMgZ2V0SW5hY3Rpdml0eVRpbWVycygpOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHtcbiAgICAvLyBDb252ZXJ0IE1hcCB0byBPYmplY3QgZm9yIGVhc2llciBpbnNwZWN0aW9uXG4gICAgY29uc3QgdGltZXJzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgdGhpcy5pbmFjdGl2aXR5VGltZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHRpbWVyc1trZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRpbWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgYSBoYW5kbGVyIGZvciBzdGFsbGVkIGV4ZWN1dGlvbnNcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cFN0YWxsZWRFeGVjdXRpb25IYW5kbGVyKGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBMaXN0ZW4gZm9yIHN0YWxsZWQgZXhlY3V0aW9uIGV2ZW50c1xuICAgIHN1cGVyLm9uKEtlcm5lbEV2ZW50cy5FWEVDVVRJT05fU1RBTExFRCwgKGV2ZW50OiB7IGtlcm5lbElkOiBzdHJpbmcsIGV4ZWN1dGlvbklkOiBzdHJpbmcsIG1heEV4ZWN1dGlvblRpbWU6IG51bWJlciB9KSA9PiB7XG4gICAgICBpZiAoZXZlbnQua2VybmVsSWQgPT09IGlkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSGFuZGxpbmcgc3RhbGxlZCBleGVjdXRpb24gJHtldmVudC5leGVjdXRpb25JZH0gb24ga2VybmVsICR7aWR9IChydW5uaW5nIGxvbmdlciB0aGFuICR7ZXZlbnQubWF4RXhlY3V0aW9uVGltZX1tcylgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEVtaXQgYW4gZXZlbnQgZm9yIGNsaWVudHMgdG8gaGFuZGxlXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsIHtcbiAgICAgICAgICAgIGtlcm5lbElkOiBpZCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgZW5hbWU6IFwiRXhlY3V0aW9uU3RhbGxlZEVycm9yXCIsXG4gICAgICAgICAgICAgIGV2YWx1ZTogYEV4ZWN1dGlvbiBzdGFsbGVkIG9yIHBvdGVudGlhbGx5IGRlYWRsb2NrZWQgKHJ1bm5pbmcgPiAke2V2ZW50Lm1heEV4ZWN1dGlvblRpbWV9bXMpYCxcbiAgICAgICAgICAgICAgdHJhY2ViYWNrOiBbXCJFeGVjdXRpb24gbWF5IGJlIHN0dWNrIGluIGFuIGluZmluaXRlIGxvb3Agb3IgZGVhZGxvY2tlZC5cIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIHRlcm1pbmF0ZSBhIHBvdGVudGlhbGx5IHN0dWNrIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSByZWFzb24gT3B0aW9uYWwgcmVhc29uIGZvciB0ZXJtaW5hdGlvblxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0cnVlIGlmIHRoZSBrZXJuZWwgd2FzIHRlcm1pbmF0ZWRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBmb3JjZVRlcm1pbmF0ZUtlcm5lbChpZDogc3RyaW5nLCByZWFzb24gPSBcIkZvcmNlIHRlcm1pbmF0ZWQgZHVlIHRvIHN0YWxsZWQgZXhlY3V0aW9uXCIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIFxuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIExvZyB0aGUgZm9yY2VkIHRlcm1pbmF0aW9uXG4gICAgICBjb25zb2xlLndhcm4oYEZvcmNlIHRlcm1pbmF0aW5nIGtlcm5lbCAke2lkfTogJHtyZWFzb259YCk7XG4gICAgICBcbiAgICAgIC8vIEVtaXQgYW4gZXJyb3IgZXZlbnQgdG8gbm90aWZ5IGNsaWVudHNcbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsIHtcbiAgICAgICAga2VybmVsSWQ6IGlkLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZW5hbWU6IFwiS2VybmVsRm9yY2VkVGVybWluYXRpb25cIixcbiAgICAgICAgICBldmFsdWU6IHJlYXNvbixcbiAgICAgICAgICB0cmFjZWJhY2s6IFtcIktlcm5lbCB3YXMgZm9yY2VmdWxseSB0ZXJtaW5hdGVkIGJ5IHRoZSBzeXN0ZW0uXCJdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBEZXN0cm95IHRoZSBrZXJuZWxcbiAgICAgIGF3YWl0IHRoaXMuZGVzdHJveUtlcm5lbChpZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZHVyaW5nIGZvcmNlZCB0ZXJtaW5hdGlvbiBvZiBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgb25nb2luZyBleGVjdXRpb25zIGZvciBhIGtlcm5lbFxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIEluZm9ybWF0aW9uIGFib3V0IG9uZ29pbmcgZXhlY3V0aW9ucyB3aXRoIGFjY3VyYXRlIHRpbWluZ1xuICAgKi9cbiAgcHVibGljIGdldEV4ZWN1dGlvbkluZm8oaWQ6IHN0cmluZyk6IHsgXG4gICAgY291bnQ6IG51bWJlcjsgXG4gICAgaXNTdHVjazogYm9vbGVhbjsgXG4gICAgZXhlY3V0aW9uSWRzOiBzdHJpbmdbXTtcbiAgICBsb25nZXN0UnVubmluZ1RpbWU/OiBudW1iZXI7XG4gICAgZXhlY3V0aW9uczogQXJyYXk8e1xuICAgICAgaWQ6IHN0cmluZztcbiAgICAgIHN0YXJ0VGltZTogbnVtYmVyO1xuICAgICAgcnVudGltZTogbnVtYmVyO1xuICAgICAgY29kZT86IHN0cmluZztcbiAgICAgIGlzU3R1Y2s6IGJvb2xlYW47XG4gICAgfT47XG4gIH0ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIHsgY291bnQ6IDAsIGlzU3R1Y2s6IGZhbHNlLCBleGVjdXRpb25JZHM6IFtdLCBleGVjdXRpb25zOiBbXSB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgcGFydGlhbGx5IGluaXRpYWxpemVkIGtlcm5lbHMgd2hlcmUgb3B0aW9ucyBtYXkgbm90IGJlIGZ1bGx5IHNldFxuICAgIGlmICghaW5zdGFuY2Uub3B0aW9ucykge1xuICAgICAgcmV0dXJuIHsgY291bnQ6IDAsIGlzU3R1Y2s6IGZhbHNlLCBleGVjdXRpb25JZHM6IFtdLCBleGVjdXRpb25zOiBbXSB9O1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBleGVjdXRpb25JZHMgPSB0aGlzLm9uZ29pbmdFeGVjdXRpb25zLmdldChpZCkgXG4gICAgICA/IEFycmF5LmZyb20odGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5nZXQoaWQpISlcbiAgICAgIDogW107XG4gICAgXG4gICAgY29uc3QgY291bnQgPSBleGVjdXRpb25JZHMubGVuZ3RoO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBtYXhFeGVjdXRpb25UaW1lID0gaW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lO1xuICAgIFxuICAgIC8vIEJ1aWxkIGRldGFpbGVkIGV4ZWN1dGlvbiBpbmZvcm1hdGlvblxuICAgIGNvbnN0IGV4ZWN1dGlvbnM6IEFycmF5PHtcbiAgICAgIGlkOiBzdHJpbmc7XG4gICAgICBzdGFydFRpbWU6IG51bWJlcjtcbiAgICAgIHJ1bnRpbWU6IG51bWJlcjtcbiAgICAgIGNvZGU/OiBzdHJpbmc7XG4gICAgICBpc1N0dWNrOiBib29sZWFuO1xuICAgIH0+ID0gW107XG4gICAgXG4gICAgbGV0IGxvbmdlc3RSdW5uaW5nVGltZTogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIGxldCBhbnlTdHVjayA9IGZhbHNlO1xuICAgIFxuICAgIC8vIEdldCBleGVjdXRpb24gc3RhcnQgdGltZXMgYW5kIG1ldGFkYXRhXG4gICAgY29uc3Qgc3RhcnRUaW1lcyA9IHRoaXMuZXhlY3V0aW9uU3RhcnRUaW1lcy5nZXQoaWQpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5leGVjdXRpb25NZXRhZGF0YS5nZXQoaWQpO1xuICAgIFxuICAgIGZvciAoY29uc3QgZXhlY3V0aW9uSWQgb2YgZXhlY3V0aW9uSWRzKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBzdGFydFRpbWVzPy5nZXQoZXhlY3V0aW9uSWQpO1xuICAgICAgY29uc3QgZXhlY01ldGFkYXRhID0gbWV0YWRhdGE/LmdldChleGVjdXRpb25JZCk7XG4gICAgICBcbiAgICAgIGlmIChzdGFydFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBydW50aW1lID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIGNvbnN0IGlzU3R1Y2sgPSBtYXhFeGVjdXRpb25UaW1lICE9PSB1bmRlZmluZWQgJiYgcnVudGltZSA+IG1heEV4ZWN1dGlvblRpbWU7XG4gICAgICAgIFxuICAgICAgICBleGVjdXRpb25zLnB1c2goe1xuICAgICAgICAgIGlkOiBleGVjdXRpb25JZCxcbiAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgcnVudGltZSxcbiAgICAgICAgICBjb2RlOiBleGVjTWV0YWRhdGE/LmNvZGUsXG4gICAgICAgICAgaXNTdHVja1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyYWNrIGxvbmdlc3QgcnVubmluZyB0aW1lXG4gICAgICAgIGlmIChsb25nZXN0UnVubmluZ1RpbWUgPT09IHVuZGVmaW5lZCB8fCBydW50aW1lID4gbG9uZ2VzdFJ1bm5pbmdUaW1lKSB7XG4gICAgICAgICAgbG9uZ2VzdFJ1bm5pbmdUaW1lID0gcnVudGltZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVHJhY2sgaWYgYW55IGV4ZWN1dGlvbiBpcyBzdHVja1xuICAgICAgICBpZiAoaXNTdHVjaykge1xuICAgICAgICAgIGFueVN0dWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgZm9yIGV4ZWN1dGlvbnMgd2l0aG91dCBzdGFydCB0aW1lIHRyYWNraW5nXG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gc3RhcnQgdGltZSBmb3VuZCBmb3IgZXhlY3V0aW9uICR7ZXhlY3V0aW9uSWR9IG9uIGtlcm5lbCAke2lkfWApO1xuICAgICAgICBleGVjdXRpb25zLnB1c2goe1xuICAgICAgICAgIGlkOiBleGVjdXRpb25JZCxcbiAgICAgICAgICBzdGFydFRpbWU6IDAsXG4gICAgICAgICAgcnVudGltZTogMCxcbiAgICAgICAgICBjb2RlOiBleGVjTWV0YWRhdGE/LmNvZGUsXG4gICAgICAgICAgaXNTdHVjazogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNvcnQgZXhlY3V0aW9ucyBieSBzdGFydCB0aW1lIChvbGRlc3QgZmlyc3QpXG4gICAgZXhlY3V0aW9ucy5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0VGltZSAtIGIuc3RhcnRUaW1lKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgY291bnQsXG4gICAgICBpc1N0dWNrOiBhbnlTdHVjayxcbiAgICAgIGV4ZWN1dGlvbklkcyxcbiAgICAgIGxvbmdlc3RSdW5uaW5nVGltZSxcbiAgICAgIGV4ZWN1dGlvbnNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgUHl0aG9uIGNvZGUgaW4gYSBrZXJuZWxcbiAgICogVXNlcyBleGVjdXRlU3RyZWFtIHRvIGNvbGxlY3QgYWxsIG91dHB1dHMgYW5kIHJldHVybiB0aGVtXG4gICAqIEBwYXJhbSBrZXJuZWxJZCBJRCBvZiB0aGUga2VybmVsIHRvIHVzZVxuICAgKiBAcGFyYW0gY29kZSBQeXRob24gY29kZSB0byBleGVjdXRlXG4gICAqIEBwYXJhbSBwYXJlbnQgT3B0aW9uYWwgcGFyZW50IG1lc3NhZ2UgaGVhZGVyXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGV4ZWN1dGlvbiByZXN1bHQgd2l0aCBjb2xsZWN0ZWQgb3V0cHV0c1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGV4ZWN1dGUoXG4gICAga2VybmVsSWQ6IHN0cmluZyxcbiAgICBjb2RlOiBzdHJpbmcsXG4gICAgcGFyZW50OiBhbnkgPSB7fVxuICApOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiwgb3V0cHV0cz86IGFueSwgZXJyb3I/OiBFcnJvciwgZW5hbWU/OiBzdHJpbmcsIGV2YWx1ZT86IHN0cmluZywgdHJhY2ViYWNrPzogYW55IH0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0S2VybmVsKGtlcm5lbElkKTtcbiAgICBcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCB3aXRoIElEICR7a2VybmVsSWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgaW5zdGFuY2Uua2VybmVsLmV4ZWN1dGUoY29kZSwgcGFyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGtlcm5lbCB0eXBlIGlzIGFsbG93ZWRcbiAgICogQHBhcmFtIG1vZGUgS2VybmVsIG1vZGVcbiAgICogQHBhcmFtIGxhbmd1YWdlIEtlcm5lbCBsYW5ndWFnZVxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBrZXJuZWwgdHlwZSBpcyBhbGxvd2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGlzS2VybmVsVHlwZUFsbG93ZWQobW9kZTogS2VybmVsTW9kZSwgbGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dlZEtlcm5lbFR5cGVzLnNvbWUodHlwZSA9PiBcbiAgICAgIHR5cGUubW9kZSA9PT0gbW9kZSAmJiB0eXBlLmxhbmd1YWdlID09PSBsYW5ndWFnZVxuICAgICk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgYWxsb3dlZCBrZXJuZWwgdHlwZXNcbiAgICogQHJldHVybnMgQXJyYXkgb2YgYWxsb3dlZCBrZXJuZWwgdHlwZSBjb25maWd1cmF0aW9uc1xuICAgKi9cbiAgcHVibGljIGdldEFsbG93ZWRLZXJuZWxUeXBlcygpOiBBcnJheTx7XG4gICAgbW9kZTogS2VybmVsTW9kZTtcbiAgICBsYW5ndWFnZTogS2VybmVsTGFuZ3VhZ2U7XG4gIH0+IHtcbiAgICByZXR1cm4gWy4uLnRoaXMuYWxsb3dlZEtlcm5lbFR5cGVzXTsgLy8gUmV0dXJuIGEgY29weSB0byBwcmV2ZW50IG1vZGlmaWNhdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIFBpbmcgYSBrZXJuZWwgdG8gcmVzZXQgaXRzIGFjdGl2aXR5IHRpbWVyIGFuZCBleHRlbmQgdGhlIGRlYWRsaW5lXG4gICAqIEBwYXJhbSBpZCBLZXJuZWwgSURcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUga2VybmVsIHdhcyBwaW5nZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiBub3QgZm91bmRcbiAgICovXG4gIHB1YmxpYyBwaW5nS2VybmVsKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMua2VybmVscy5nZXQoaWQpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIGtlcm5lbCBhY3Rpdml0eSAodGhpcyB3aWxsIHJlc2V0IHRoZSBpbmFjdGl2aXR5IHRpbWVyKVxuICAgIHRoaXMudXBkYXRlS2VybmVsQWN0aXZpdHkoaWQpO1xuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RhcnQgYSBrZXJuZWwgYnkgZGVzdHJveWluZyBpdCBhbmQgY3JlYXRpbmcgYSBuZXcgb25lIHdpdGggdGhlIHNhbWUgSUQgYW5kIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0cnVlIGlmIHRoZSBrZXJuZWwgd2FzIHJlc3RhcnRlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlc3RhcnRLZXJuZWwoaWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5rZXJuZWxzLmdldChpZCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgY29uc29sZS53YXJuKGBDYW5ub3QgcmVzdGFydCBrZXJuZWwgJHtpZH06IGtlcm5lbCBub3QgZm91bmRgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFN0b3JlIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb25cbiAgICAgIGNvbnN0IGN1cnJlbnRDb25maWcgPSB7XG4gICAgICAgIG1vZGU6IGluc3RhbmNlLm1vZGUsXG4gICAgICAgIGxhbmd1YWdlOiBpbnN0YW5jZS5sYW5ndWFnZSxcbiAgICAgICAgb3B0aW9uczogeyAuLi5pbnN0YW5jZS5vcHRpb25zIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIEV4dHJhY3QgbmFtZXNwYWNlIGZyb20gSUQgaWYgcHJlc2VudFxuICAgICAgbGV0IG5hbWVzcGFjZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgbGV0IGJhc2VJZDogc3RyaW5nO1xuICAgICAgXG4gICAgICBpZiAoaWQuaW5jbHVkZXMoJzonKSkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGlkLnNwbGl0KCc6Jyk7XG4gICAgICAgIG5hbWVzcGFjZSA9IHBhcnRzWzBdO1xuICAgICAgICBiYXNlSWQgPSBwYXJ0c1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VJZCA9IGlkO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZXN0cm95IHRoZSBleGlzdGluZyBrZXJuZWxcbiAgICAgIGF3YWl0IHRoaXMuZGVzdHJveUtlcm5lbChpZCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBrZXJuZWwgd2l0aCB0aGUgc2FtZSBjb25maWd1cmF0aW9uXG4gICAgICBjb25zdCByZXN0YXJ0T3B0aW9uczogSU1hbmFnZXJLZXJuZWxPcHRpb25zID0ge1xuICAgICAgICBpZDogYmFzZUlkLFxuICAgICAgICBtb2RlOiBjdXJyZW50Q29uZmlnLm1vZGUsXG4gICAgICAgIGxhbmc6IGN1cnJlbnRDb25maWcubGFuZ3VhZ2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgZGVubzogY3VycmVudENvbmZpZy5vcHRpb25zLmRlbm8sXG4gICAgICAgIGZpbGVzeXN0ZW06IGN1cnJlbnRDb25maWcub3B0aW9ucy5maWxlc3lzdGVtLFxuICAgICAgICBpbmFjdGl2aXR5VGltZW91dDogY3VycmVudENvbmZpZy5vcHRpb25zLmluYWN0aXZpdHlUaW1lb3V0LFxuICAgICAgICBtYXhFeGVjdXRpb25UaW1lOiBjdXJyZW50Q29uZmlnLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcga2VybmVsXG4gICAgICBjb25zdCBuZXdLZXJuZWxJZCA9IGF3YWl0IHRoaXMuY3JlYXRlS2VybmVsKHJlc3RhcnRPcHRpb25zKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHRoZSBuZXcga2VybmVsIGhhcyB0aGUgc2FtZSBJRFxuICAgICAgaWYgKG5ld0tlcm5lbElkICE9PSBpZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBLZXJuZWwgcmVzdGFydCBmYWlsZWQ6IGV4cGVjdGVkIElEICR7aWR9LCBnb3QgJHtuZXdLZXJuZWxJZH1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZXN0YXJ0aW5nIGtlcm5lbCAke2lkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVycnVwdCBhIHJ1bm5pbmcga2VybmVsIGV4ZWN1dGlvblxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRydWUgaWYgdGhlIGludGVycnVwdCB3YXMgc3VjY2Vzc2Z1bCwgZmFsc2UgaWYgbm90IGZvdW5kIG9yIGZhaWxlZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGludGVycnVwdEtlcm5lbChpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGlkKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENhbm5vdCBpbnRlcnJ1cHQga2VybmVsICR7aWR9OiBrZXJuZWwgbm90IGZvdW5kYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBpZiAoaW5zdGFuY2UubW9kZSA9PT0gS2VybmVsTW9kZS5XT1JLRVIgJiYgaW5zdGFuY2Uud29ya2VyKSB7XG4gICAgICAgIC8vIEZvciB3b3JrZXIga2VybmVscywgdXNlIFNoYXJlZEFycmF5QnVmZmVyIGludGVycnVwdCBtZXRob2RcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW50ZXJydXB0V29ya2VyS2VybmVsKGlkLCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgbWFpbiB0aHJlYWQga2VybmVscywgdHJ5IHRvIGludGVycnVwdCAod2lsbCB0aHJvdyBlcnJvciBpZiBub3Qgc3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbnRlcnJ1cHRNYWluVGhyZWFkS2VybmVsKGlkLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGludGVycnVwdGluZyBrZXJuZWwgJHtpZH06YCwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbnRlcnJ1cHQgYSBtYWluIHRocmVhZCBrZXJuZWxcbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gaW5zdGFuY2UgS2VybmVsIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGludGVycnVwdCBzdWNjZXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGludGVycnVwdE1haW5UaHJlYWRLZXJuZWwoaWQ6IHN0cmluZywgaW5zdGFuY2U6IElLZXJuZWxJbnN0YW5jZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIC8vIE1haW4gdGhyZWFkIGtlcm5lbHMgZG9uJ3Qgc3VwcG9ydCBwcm9wZXIgaW50ZXJydXB0aW9uIGxpa2Ugd29ya2VyIGtlcm5lbHMgZG9cbiAgICAvLyBFdmVuIGlmIHRoZXkgaGF2ZSBhbiBpbnRlcnJ1cHQgbWV0aG9kLCBpdCdzIGxpbWl0ZWQgYW5kIHVucmVsaWFibGVcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1haW4gdGhyZWFkIGtlcm5lbCAke2lkfSBkb2VzIG5vdCBzdXBwb3J0IHJlbGlhYmxlIGludGVycnVwdGlvbi4gVXNlIHdvcmtlciBrZXJuZWxzIGZvciBpbnRlcnJ1cHRpYmxlIGV4ZWN1dGlvbi5gKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEludGVycnVwdCBhIHdvcmtlciBrZXJuZWwgdXNpbmcgU2hhcmVkQXJyYXlCdWZmZXIgYWNjb3JkaW5nIHRvIFB5b2RpZGUgZG9jdW1lbnRhdGlvblxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSBpbnN0YW5jZSBLZXJuZWwgaW5zdGFuY2VcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gaW50ZXJydXB0IHN1Y2Nlc3NcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW50ZXJydXB0V29ya2VyS2VybmVsKGlkOiBzdHJpbmcsIGluc3RhbmNlOiBJS2VybmVsSW5zdGFuY2UpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgd29ya2VyID0gaW5zdGFuY2Uud29ya2VyO1xuICAgICAgaWYgKCF3b3JrZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV29ya2VyIG5vdCBmb3VuZCBmb3Iga2VybmVsICR7aWR9YCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgaW50ZXJydXB0aW9uIG1vZGUgaXMgJ2tlcm5lbC1pbnRlcnJ1cHQnLCB1c2UgZmFsbGJhY2sgZGlyZWN0bHlcbiAgICAgIGlmICh0aGlzLmludGVycnVwdGlvbk1vZGUgPT09ICdrZXJuZWwtaW50ZXJydXB0Jykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbnRlcnJ1cHRXb3JrZXJLZXJuZWxGYWxsYmFjayhpZCwgd29ya2VyKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIGFuIGludGVycnVwdCBidWZmZXIgZm9yIHRoaXMga2VybmVsXG4gICAgICBsZXQgaW50ZXJydXB0QnVmZmVyID0gdGhpcy5pbnRlcnJ1cHRCdWZmZXJzLmdldChpZCk7XG4gICAgICBcbiAgICAgIGlmICghaW50ZXJydXB0QnVmZmVyKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBTaGFyZWRBcnJheUJ1ZmZlciBmb3IgaW50ZXJydXB0IGNvbnRyb2xcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUcnkgdG8gY3JlYXRlIFNoYXJlZEFycmF5QnVmZmVyIChyZXF1aXJlcyBzcGVjaWZpYyBzZWN1cml0eSBoZWFkZXJzKVxuICAgICAgICAgIGNvbnN0IHNoYXJlZEJ1ZmZlciA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKTtcbiAgICAgICAgICBpbnRlcnJ1cHRCdWZmZXIgPSBuZXcgVWludDhBcnJheShzaGFyZWRCdWZmZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEluaXRpYWxpemUgYnVmZmVyIHRvIDAgKG5vIGludGVycnVwdCBzaWduYWwpXG4gICAgICAgICAgaW50ZXJydXB0QnVmZmVyWzBdID0gMDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdG9yZSB0aGUgYnVmZmVyIGZvciBmdXR1cmUgdXNlXG4gICAgICAgICAgdGhpcy5pbnRlcnJ1cHRCdWZmZXJzLnNldChpZCwgaW50ZXJydXB0QnVmZmVyKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTZW5kIHRoZSBidWZmZXIgdG8gdGhlIHdvcmtlciB0byBzZXQgdXAgcHlvZGlkZS5zZXRJbnRlcnJ1cHRCdWZmZXIoKVxuICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBcIlNFVF9JTlRFUlJVUFRfQlVGRkVSXCIsXG4gICAgICAgICAgICBidWZmZXI6IGludGVycnVwdEJ1ZmZlclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3b3JrZXIgdG8gY29uZmlybSBidWZmZXIgc2V0dXBcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lb3V0IHdhaXRpbmcgZm9yIGludGVycnVwdCBidWZmZXIgc2V0dXBcIikpO1xuICAgICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJJTlRFUlJVUFRfQlVGRkVSX1NFVFwiKSB7XG4gICAgICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgSW50ZXJydXB0IGJ1ZmZlciBzZXQgdXAgZm9yIGtlcm5lbCAke2lkfWApO1xuICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIEhhbmRsZSBiYXNlZCBvbiBpbnRlcnJ1cHRpb24gbW9kZVxuICAgICAgICAgIGlmICh0aGlzLmludGVycnVwdGlvbk1vZGUgPT09ICdzaGFyZWQtYXJyYXktYnVmZmVyJykge1xuICAgICAgICAgICAgLy8gSWYgZXhwbGljaXRseSBzZXQgdG8gc2hhcmVkLWFycmF5LWJ1ZmZlciwgdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIENhbm5vdCBjcmVhdGUgU2hhcmVkQXJyYXlCdWZmZXIgZm9yIGludGVycnVwdCBoYW5kbGluZyBpbiBrZXJuZWwgJHtpZH1gKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2hhcmVkQXJyYXlCdWZmZXIgaXMgcmVxdWlyZWQgZm9yIGludGVycnVwdGlvbiBtb2RlICdzaGFyZWQtYXJyYXktYnVmZmVyJyBidXQgaXMgbm90IGF2YWlsYWJsZS5cblxuVG8gZml4IHRoaXMgaXNzdWUsIGVpdGhlcjpcbjEuIENvbmZpZ3VyZSB5b3VyIHdlYiBzZXJ2ZXIgd2l0aCB0aGVzZSBoZWFkZXJzOlxuICAgLSBDcm9zcy1PcmlnaW4tT3BlbmVyLVBvbGljeTogc2FtZS1vcmlnaW5cbiAgIC0gQ3Jvc3MtT3JpZ2luLUVtYmVkZGVyLVBvbGljeTogcmVxdWlyZS1jb3JwXG5cbjIuIE9yIGNoYW5nZSB0aGUgaW50ZXJydXB0aW9uIG1vZGUgd2hlbiBjcmVhdGluZyBLZXJuZWxNYW5hZ2VyOlxuICAgbmV3IEtlcm5lbE1hbmFnZXIoeyBpbnRlcnJ1cHRpb25Nb2RlOiAnYXV0bycgfSlgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQXV0byBtb2RlOiBmYWxsIGJhY2sgdG8ga2VybmVsLmludGVycnVwdCgpXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oYOKEue+4jyBVc2luZyBtZXNzYWdlLWJhc2VkIGludGVycnVwdCBmb3Iga2VybmVsICR7aWR9IChTaGFyZWRBcnJheUJ1ZmZlciBub3QgYXZhaWxhYmxlKWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGYWxsYmFjazogdXNlIG1lc3NhZ2UtYmFzZWQgaW50ZXJydXB0XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbnRlcnJ1cHRXb3JrZXJLZXJuZWxGYWxsYmFjayhpZCwgd29ya2VyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWNjb3JkaW5nIHRvIFB5b2RpZGUgZG9jczogU2V0IGludGVycnVwdCBzaWduYWwgKDIgPSBTSUdJTlQpXG4gICAgICBjb25zb2xlLmxvZyhgU2V0dGluZyBpbnRlcnJ1cHQgc2lnbmFsIGZvciBrZXJuZWwgJHtpZH0uLi5gKTtcbiAgICAgIGludGVycnVwdEJ1ZmZlclswXSA9IDI7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIFB5b2RpZGUgdG8gcHJvY2VzcyB0aGUgaW50ZXJydXB0XG4gICAgICAvLyBQeW9kaWRlIHdpbGwgcmVzZXQgdGhlIGJ1ZmZlciB0byAwIHdoZW4gaXQgcHJvY2Vzc2VzIHRoZSBpbnRlcnJ1cHRcbiAgICAgIGxldCBhdHRlbXB0cyA9IDA7XG4gICAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDUwOyAvLyBDaGVjayBmb3IgdXAgdG8gNSBzZWNvbmRzICg1MCAqIDEwMG1zKVxuICAgICAgXG4gICAgICB3aGlsZSAoYXR0ZW1wdHMgPCBtYXhBdHRlbXB0cyAmJiBpbnRlcnJ1cHRCdWZmZXJbMF0gIT09IDApIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgICBhdHRlbXB0cysrO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoaW50ZXJydXB0QnVmZmVyWzBdID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBJbnRlcnJ1cHQgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseSBmb3Iga2VybmVsICR7aWR9IGFmdGVyICR7YXR0ZW1wdHMgKiAxMDB9bXNgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYEludGVycnVwdCBzaWduYWwgbm90IHByb2Nlc3NlZCBmb3Iga2VybmVsICR7aWR9IGFmdGVyICR7bWF4QXR0ZW1wdHMgKiAxMDB9bXNgKTtcbiAgICAgICAgLy8gU3RpbGwgcmV0dXJuIHRydWUgYXMgd2Ugc2V0IHRoZSBzaWduYWwgLSB0aGUgaW50ZXJydXB0IG1heSBiZSBwcm9jZXNzZWQgbGF0ZXJcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW50ZXJydXB0aW5nIHdvcmtlciBrZXJuZWwgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEZhbGxiYWNrIGludGVycnVwdCBtZXRob2QgZm9yIHdvcmtlciBrZXJuZWxzIHdoZW4gU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGF2YWlsYWJsZVxuICAgKiBAcGFyYW0gaWQgS2VybmVsIElEXG4gICAqIEBwYXJhbSB3b3JrZXIgV29ya2VyIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGludGVycnVwdCBzdWNjZXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGludGVycnVwdFdvcmtlcktlcm5lbEZhbGxiYWNrKGlkOiBzdHJpbmcsIHdvcmtlcjogV29ya2VyKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPGJvb2xlYW4+KChyZXNvbHZlKSA9PiB7XG4gICAgICAvLyBTZXQgdXAgYSBsaXN0ZW5lciBmb3IgdGhlIGludGVycnVwdCByZXNwb25zZVxuICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGE/LnR5cGUgPT09IFwiSU5URVJSVVBUX1RSSUdHRVJFRFwiKSB7XG4gICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGV2ZW50LmRhdGEuZGF0YT8uc3VjY2VzcyB8fCBmYWxzZTtcbiAgICAgICAgICByZXNvbHZlKHN1Y2Nlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBMaXN0ZW4gZm9yIHRoZSByZXNwb25zZVxuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgICBcbiAgICAgIC8vIFNlbmQgdGhlIGludGVycnVwdCBtZXNzYWdlXG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcIklOVEVSUlVQVF9LRVJORUxcIlxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNldCBhIHRpbWVvdXQgaW4gY2FzZSB3ZSBkb24ndCBnZXQgYSByZXNwb25zZVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCByZXNwb25zZUhhbmRsZXIpO1xuICAgICAgICBjb25zb2xlLndhcm4oYOKPse+4jyBJbnRlcnJ1cHQgcmVxdWVzdCB0aW1lZCBvdXQgZm9yIGtlcm5lbCAke2lkfSBhZnRlciA1IHNlY29uZHMuXG5UaGlzIG1heSBoYXBwZW4gaWY6XG4tIFRoZSBrZXJuZWwgaXMgcnVubmluZyBjb2RlIHRoYXQgY2Fubm90IGJlIGludGVycnVwdGVkXG4tIFRoZSBrZXJuZWwgaXMgaW4gYW4gdW5yZXNwb25zaXZlIHN0YXRlXG5Zb3UgbWF5IG5lZWQgdG8gcmVzdGFydCB0aGUga2VybmVsIGlmIGl0IHJlbWFpbnMgdW5yZXNwb25zaXZlLmApO1xuICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH0sIDUwMDApOyAvLyA1IHNlY29uZCB0aW1lb3V0XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgc3R1Y2sgZXhlY3V0aW9uIHdpdGggY29uZmlndXJhYmxlIHN0cmF0ZWdpZXNcbiAgICogQHBhcmFtIGtlcm5lbElkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gZXhlY3V0aW9uSWQgRXhlY3V0aW9uIElEIHRoYXQncyBzdHVja1xuICAgKiBAcGFyYW0gYWN0dWFsUnVudGltZSBIb3cgbG9uZyB0aGUgZXhlY3V0aW9uIGhhcyBiZWVuIHJ1bm5pbmdcbiAgICogQHBhcmFtIGNvZGUgVGhlIGNvZGUgdGhhdCB3YXMgYmVpbmcgZXhlY3V0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlU3R1Y2tFeGVjdXRpb24oa2VybmVsSWQ6IHN0cmluZywgZXhlY3V0aW9uSWQ6IHN0cmluZywgYWN0dWFsUnVudGltZTogbnVtYmVyLCBjb2RlPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmtlcm5lbHMuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUud2FybihgSGFuZGxpbmcgc3R1Y2sgZXhlY3V0aW9uICR7ZXhlY3V0aW9uSWR9IG9uIGtlcm5lbCAke2tlcm5lbElkfSAocnVudGltZTogJHthY3R1YWxSdW50aW1lfW1zKWApO1xuICAgIFxuICAgIC8vIFN0cmF0ZWd5IDE6IFRyeSB0byBpbnRlcnJ1cHQgdGhlIGtlcm5lbCBmaXJzdFxuICAgIGNvbnN0IGludGVycnVwdFN1Y2Nlc3MgPSBhd2FpdCB0aGlzLmludGVycnVwdEtlcm5lbChrZXJuZWxJZCk7XG4gICAgXG4gICAgaWYgKGludGVycnVwdFN1Y2Nlc3MpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgaW50ZXJydXB0ZWQga2VybmVsICR7a2VybmVsSWR9YCk7XG4gICAgICBcbiAgICAgIC8vIEVtaXQgYW4gZXhlY3V0aW9uIGVycm9yIHRvIG5vdGlmeSBjbGllbnRzXG4gICAgICBzdXBlci5lbWl0KEtlcm5lbEV2ZW50cy5FWEVDVVRFX0VSUk9SLCB7XG4gICAgICAgIGtlcm5lbElkOiBrZXJuZWxJZCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGVuYW1lOiBcIkV4ZWN1dGlvbkludGVycnVwdGVkXCIsXG4gICAgICAgICAgZXZhbHVlOiBgRXhlY3V0aW9uIGF1dG9tYXRpY2FsbHkgaW50ZXJydXB0ZWQgYWZ0ZXIgJHthY3R1YWxSdW50aW1lfW1zIChleGNlZWRlZCBtYXhFeGVjdXRpb25UaW1lKWAsXG4gICAgICAgICAgdHJhY2ViYWNrOiBbXG4gICAgICAgICAgICBgRXhlY3V0aW9uIHdhcyBhdXRvbWF0aWNhbGx5IGludGVycnVwdGVkIGR1ZSB0byB0aW1lb3V0LmAsXG4gICAgICAgICAgICBgUnVudGltZTogJHthY3R1YWxSdW50aW1lfW1zYCxcbiAgICAgICAgICAgIGBNYXggYWxsb3dlZDogJHtpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWV9bXNgLFxuICAgICAgICAgICAgY29kZSA/IGBDb2RlOiAke2NvZGUuc3Vic3RyaW5nKDAsIDIwMCl9JHtjb2RlLmxlbmd0aCA+IDIwMCA/ICcuLi4nIDogJyd9YCA6ICdDb2RlOiA8dW5rbm93bj4nXG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdHJhdGVneSAyOiBJZiBpbnRlcnJ1cHQgZmFpbGVkLCB0cnkgcmVzdGFydGluZyB0aGUga2VybmVsXG4gICAgY29uc29sZS53YXJuKGBJbnRlcnJ1cHQgZmFpbGVkIGZvciBrZXJuZWwgJHtrZXJuZWxJZH0sIGF0dGVtcHRpbmcgcmVzdGFydC4uLmApO1xuICAgIGNvbnN0IHJlc3RhcnRTdWNjZXNzID0gYXdhaXQgdGhpcy5yZXN0YXJ0S2VybmVsKGtlcm5lbElkKTtcbiAgICBcbiAgICBpZiAocmVzdGFydFN1Y2Nlc3MpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgcmVzdGFydGVkIGtlcm5lbCAke2tlcm5lbElkfWApO1xuICAgICAgXG4gICAgICAvLyBFbWl0IGEgcmVzdGFydCBub3RpZmljYXRpb25cbiAgICAgIHN1cGVyLmVtaXQoS2VybmVsRXZlbnRzLkVYRUNVVEVfRVJST1IsIHtcbiAgICAgICAga2VybmVsSWQ6IGtlcm5lbElkLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZW5hbWU6IFwiS2VybmVsUmVzdGFydGVkXCIsXG4gICAgICAgICAgZXZhbHVlOiBgS2VybmVsIGF1dG9tYXRpY2FsbHkgcmVzdGFydGVkIGR1ZSB0byBzdHVjayBleGVjdXRpb24gKHJ1bnRpbWU6ICR7YWN0dWFsUnVudGltZX1tcylgLFxuICAgICAgICAgIHRyYWNlYmFjazogW1xuICAgICAgICAgICAgYEtlcm5lbCB3YXMgYXV0b21hdGljYWxseSByZXN0YXJ0ZWQgZHVlIHRvIHN0dWNrIGV4ZWN1dGlvbi5gLFxuICAgICAgICAgICAgYFJ1bnRpbWU6ICR7YWN0dWFsUnVudGltZX1tc2AsXG4gICAgICAgICAgICBgTWF4IGFsbG93ZWQ6ICR7aW5zdGFuY2Uub3B0aW9ucy5tYXhFeGVjdXRpb25UaW1lfW1zYCxcbiAgICAgICAgICAgIGBJbnRlcnJ1cHQgYXR0ZW1wdCBmYWlsZWQsIGtlcm5lbCB3YXMgcmVzdGFydGVkIGluc3RlYWQuYCxcbiAgICAgICAgICAgIGNvZGUgPyBgQ29kZTogJHtjb2RlLnN1YnN0cmluZygwLCAyMDApfSR7Y29kZS5sZW5ndGggPiAyMDAgPyAnLi4uJyA6ICcnfWAgOiAnQ29kZTogPHVua25vd24+J1xuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RyYXRlZ3kgMzogSWYgcmVzdGFydCBmYWlsZWQsIGZvcmNlIHRlcm1pbmF0ZSB0aGUga2VybmVsXG4gICAgY29uc29sZS5lcnJvcihgUmVzdGFydCBmYWlsZWQgZm9yIGtlcm5lbCAke2tlcm5lbElkfSwgZm9yY2UgdGVybWluYXRpbmcuLi5gKTtcbiAgICBjb25zdCB0ZXJtaW5hdGVTdWNjZXNzID0gYXdhaXQgdGhpcy5mb3JjZVRlcm1pbmF0ZUtlcm5lbChcbiAgICAgIGtlcm5lbElkLCBcbiAgICAgIGBTdHVjayBleGVjdXRpb24gY291bGQgbm90IGJlIGludGVycnVwdGVkIG9yIHJlc3RhcnRlZCAocnVudGltZTogJHthY3R1YWxSdW50aW1lfW1zKWBcbiAgICApO1xuICAgIFxuICAgIGlmICh0ZXJtaW5hdGVTdWNjZXNzKSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IHRlcm1pbmF0ZWQga2VybmVsICR7a2VybmVsSWR9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB0ZXJtaW5hdGUga2VybmVsICR7a2VybmVsSWR9IC0gbWFudWFsIGludGVydmVudGlvbiBtYXkgYmUgcmVxdWlyZWRgKTtcbiAgICAgIFxuICAgICAgLy8gRW1pdCBhIGNyaXRpY2FsIGVycm9yXG4gICAgICBzdXBlci5lbWl0KCdrZXJuZWxfdW5yZWNvdmVyYWJsZScsIHtcbiAgICAgICAga2VybmVsSWQ6IGtlcm5lbElkLFxuICAgICAgICBleGVjdXRpb25JZDogZXhlY3V0aW9uSWQsXG4gICAgICAgIGFjdHVhbFJ1bnRpbWU6IGFjdHVhbFJ1bnRpbWUsXG4gICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgIG1lc3NhZ2U6ICdLZXJuZWwgaXMgc3R1Y2sgYW5kIGNvdWxkIG5vdCBiZSByZWNvdmVyZWQgdGhyb3VnaCBpbnRlcnJ1cHQsIHJlc3RhcnQsIG9yIHRlcm1pbmF0aW9uJ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBzdHVjayBleGVjdXRpb25zIGFjcm9zcyBhbGwga2VybmVsc1xuICAgKiBAcmV0dXJucyBBcnJheSBvZiBzdHVjayBleGVjdXRpb24gZGV0YWlsc1xuICAgKi9cbiAgcHVibGljIGdldFN0dWNrRXhlY3V0aW9ucygpOiBBcnJheTx7XG4gICAga2VybmVsSWQ6IHN0cmluZztcbiAgICBleGVjdXRpb25JZDogc3RyaW5nO1xuICAgIHN0YXJ0VGltZTogbnVtYmVyO1xuICAgIHJ1bnRpbWU6IG51bWJlcjtcbiAgICBtYXhBbGxvd2VkOiBudW1iZXI7XG4gICAgY29kZT86IHN0cmluZztcbiAgICBrZXJuZWxNb2RlOiBLZXJuZWxNb2RlO1xuICAgIGtlcm5lbExhbmd1YWdlOiBLZXJuZWxMYW5ndWFnZTtcbiAgfT4ge1xuICAgIGNvbnN0IHN0dWNrRXhlY3V0aW9uczogQXJyYXk8e1xuICAgICAga2VybmVsSWQ6IHN0cmluZztcbiAgICAgIGV4ZWN1dGlvbklkOiBzdHJpbmc7XG4gICAgICBzdGFydFRpbWU6IG51bWJlcjtcbiAgICAgIHJ1bnRpbWU6IG51bWJlcjtcbiAgICAgIG1heEFsbG93ZWQ6IG51bWJlcjtcbiAgICAgIGNvZGU/OiBzdHJpbmc7XG4gICAgICBrZXJuZWxNb2RlOiBLZXJuZWxNb2RlO1xuICAgICAga2VybmVsTGFuZ3VhZ2U6IEtlcm5lbExhbmd1YWdlO1xuICAgIH0+ID0gW107XG4gICAgXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIGZvciAoY29uc3QgW2tlcm5lbElkLCBpbnN0YW5jZV0gb2YgdGhpcy5rZXJuZWxzLmVudHJpZXMoKSkge1xuICAgICAgLy8gU2tpcCBwb29sIGtlcm5lbHNcbiAgICAgIGlmIChrZXJuZWxJZC5zdGFydHNXaXRoKFwicG9vbC1cIikpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBTa2lwIGtlcm5lbHMgd2l0aG91dCBtYXhFeGVjdXRpb25UaW1lIGNvbmZpZ3VyZWRcbiAgICAgIGlmICghaW5zdGFuY2Uub3B0aW9ucz8ubWF4RXhlY3V0aW9uVGltZSB8fCBpbnN0YW5jZS5vcHRpb25zLm1heEV4ZWN1dGlvblRpbWUgPD0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgbWF4RXhlY3V0aW9uVGltZSA9IGluc3RhbmNlLm9wdGlvbnMubWF4RXhlY3V0aW9uVGltZTtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZXMgPSB0aGlzLmV4ZWN1dGlvblN0YXJ0VGltZXMuZ2V0KGtlcm5lbElkKTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5leGVjdXRpb25NZXRhZGF0YS5nZXQoa2VybmVsSWQpO1xuICAgICAgY29uc3Qgb25nb2luZ0V4ZWNzID0gdGhpcy5vbmdvaW5nRXhlY3V0aW9ucy5nZXQoa2VybmVsSWQpO1xuICAgICAgXG4gICAgICBpZiAoIW9uZ29pbmdFeGVjcyB8fCBvbmdvaW5nRXhlY3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBleGVjdXRpb25JZCBvZiBvbmdvaW5nRXhlY3MpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gc3RhcnRUaW1lcz8uZ2V0KGV4ZWN1dGlvbklkKTtcbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJ1bnRpbWUgPSBjdXJyZW50VGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgZXhlY3V0aW9uIGlzIHN0dWNrXG4gICAgICAgIGlmIChydW50aW1lID4gbWF4RXhlY3V0aW9uVGltZSkge1xuICAgICAgICAgIGNvbnN0IGV4ZWNNZXRhZGF0YSA9IG1ldGFkYXRhPy5nZXQoZXhlY3V0aW9uSWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIHN0dWNrRXhlY3V0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGtlcm5lbElkLFxuICAgICAgICAgICAgZXhlY3V0aW9uSWQsXG4gICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICBydW50aW1lLFxuICAgICAgICAgICAgbWF4QWxsb3dlZDogbWF4RXhlY3V0aW9uVGltZSxcbiAgICAgICAgICAgIGNvZGU6IGV4ZWNNZXRhZGF0YT8uY29kZSxcbiAgICAgICAgICAgIGtlcm5lbE1vZGU6IGluc3RhbmNlLm1vZGUsXG4gICAgICAgICAgICBrZXJuZWxMYW5ndWFnZTogaW5zdGFuY2UubGFuZ3VhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBTb3J0IGJ5IHJ1bnRpbWUgKGxvbmdlc3QgcnVubmluZyBmaXJzdClcbiAgICBzdHVja0V4ZWN1dGlvbnMuc29ydCgoYSwgYikgPT4gYi5ydW50aW1lIC0gYS5ydW50aW1lKTtcbiAgICBcbiAgICByZXR1cm4gc3R1Y2tFeGVjdXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIGludGVycnVwdCBhbGwgc3R1Y2sgZXhlY3V0aW9ucyBhY3Jvc3MgYWxsIGtlcm5lbHNcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYXJyYXkgb2YgaW50ZXJ2ZW50aW9uIHJlc3VsdHNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBoYW5kbGVBbGxTdHVja0V4ZWN1dGlvbnMoKTogUHJvbWlzZTxBcnJheTx7XG4gICAga2VybmVsSWQ6IHN0cmluZztcbiAgICBleGVjdXRpb25JZDogc3RyaW5nO1xuICAgIGFjdGlvbjogJ2ludGVycnVwdGVkJyB8ICdyZXN0YXJ0ZWQnIHwgJ3Rlcm1pbmF0ZWQnIHwgJ2ZhaWxlZCc7XG4gICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICBlcnJvcj86IHN0cmluZztcbiAgfT4+IHtcbiAgICBjb25zdCBzdHVja0V4ZWN1dGlvbnMgPSB0aGlzLmdldFN0dWNrRXhlY3V0aW9ucygpO1xuICAgIGNvbnN0IHJlc3VsdHM6IEFycmF5PHtcbiAgICAgIGtlcm5lbElkOiBzdHJpbmc7XG4gICAgICBleGVjdXRpb25JZDogc3RyaW5nO1xuICAgICAgYWN0aW9uOiAnaW50ZXJydXB0ZWQnIHwgJ3Jlc3RhcnRlZCcgfCAndGVybWluYXRlZCcgfCAnZmFpbGVkJztcbiAgICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgICBlcnJvcj86IHN0cmluZztcbiAgICB9PiA9IFtdO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke3N0dWNrRXhlY3V0aW9ucy5sZW5ndGh9IHN0dWNrIGV4ZWN1dGlvbnMgdG8gaGFuZGxlYCk7XG4gICAgXG4gICAgLy8gR3JvdXAgYnkga2VybmVsIHRvIGF2b2lkIG11bHRpcGxlIGludGVydmVudGlvbnMgb24gdGhlIHNhbWUga2VybmVsXG4gICAgY29uc3Qga2VybmVsR3JvdXBzID0gbmV3IE1hcDxzdHJpbmcsIHR5cGVvZiBzdHVja0V4ZWN1dGlvbnM+KCk7XG4gICAgZm9yIChjb25zdCBleGVjIG9mIHN0dWNrRXhlY3V0aW9ucykge1xuICAgICAgaWYgKCFrZXJuZWxHcm91cHMuaGFzKGV4ZWMua2VybmVsSWQpKSB7XG4gICAgICAgIGtlcm5lbEdyb3Vwcy5zZXQoZXhlYy5rZXJuZWxJZCwgW10pO1xuICAgICAgfVxuICAgICAga2VybmVsR3JvdXBzLmdldChleGVjLmtlcm5lbElkKSEucHVzaChleGVjKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIGVhY2gga2VybmVsJ3Mgc3R1Y2sgZXhlY3V0aW9uc1xuICAgIGZvciAoY29uc3QgW2tlcm5lbElkLCBleGVjdXRpb25zXSBvZiBrZXJuZWxHcm91cHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFBpY2sgdGhlIGxvbmdlc3QgcnVubmluZyBleGVjdXRpb24gYXMgdGhlIHByaW1hcnkgb25lXG4gICAgICAgIGNvbnN0IHByaW1hcnlFeGVjID0gZXhlY3V0aW9uc1swXTsgLy8gQWxyZWFkeSBzb3J0ZWQgYnkgcnVudGltZSBkZXNjXG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgSGFuZGxpbmcgc3R1Y2sga2VybmVsICR7a2VybmVsSWR9IHdpdGggJHtleGVjdXRpb25zLmxlbmd0aH0gc3R1Y2sgZXhlY3V0aW9ucyAocHJpbWFyeTogJHtwcmltYXJ5RXhlYy5ydW50aW1lfW1zKWApO1xuICAgICAgICBcbiAgICAgICAgLy8gVXNlIHRoZSBhdXRvbWF0ZWQgaGFuZGxpbmcgc3lzdGVtXG4gICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlU3R1Y2tFeGVjdXRpb24oXG4gICAgICAgICAga2VybmVsSWQsIFxuICAgICAgICAgIHByaW1hcnlFeGVjLmV4ZWN1dGlvbklkLCBcbiAgICAgICAgICBwcmltYXJ5RXhlYy5ydW50aW1lLCBcbiAgICAgICAgICBwcmltYXJ5RXhlYy5jb2RlXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBNYXJrIGFsbCBleGVjdXRpb25zIGZvciB0aGlzIGtlcm5lbCBhcyBoYW5kbGVkXG4gICAgICAgIGZvciAoY29uc3QgZXhlYyBvZiBleGVjdXRpb25zKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgIGtlcm5lbElkOiBleGVjLmtlcm5lbElkLFxuICAgICAgICAgICAgZXhlY3V0aW9uSWQ6IGV4ZWMuZXhlY3V0aW9uSWQsXG4gICAgICAgICAgICBhY3Rpb246ICdpbnRlcnJ1cHRlZCcsIC8vIFdlIGRvbid0IGtub3cgdGhlIGV4YWN0IGFjdGlvbiwgYnV0IGl0IHdhcyBoYW5kbGVkXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBoYW5kbGluZyBzdHVjayBleGVjdXRpb25zIGZvciBrZXJuZWwgJHtrZXJuZWxJZH06YCwgZXJyb3IpO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFyayBhbGwgZXhlY3V0aW9ucyBmb3IgdGhpcyBrZXJuZWwgYXMgZmFpbGVkXG4gICAgICAgIGZvciAoY29uc3QgZXhlYyBvZiBleGVjdXRpb25zKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgIGtlcm5lbElkOiBleGVjLmtlcm5lbElkLFxuICAgICAgICAgICAgZXhlY3V0aW9uSWQ6IGV4ZWMuZXhlY3V0aW9uSWQsXG4gICAgICAgICAgICBhY3Rpb246ICdmYWlsZWQnLFxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIGludGVycnVwdCBidWZmZXIgZm9yIGEgd29ya2VyIGtlcm5lbCBkdXJpbmcgY3JlYXRpb25cbiAgICogQHBhcmFtIGlkIEtlcm5lbCBJRFxuICAgKiBAcGFyYW0gd29ya2VyIFdvcmtlciBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZXR1cFdvcmtlckludGVycnVwdEJ1ZmZlcihpZDogc3RyaW5nLCB3b3JrZXI6IFdvcmtlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFNraXAgU2hhcmVkQXJyYXlCdWZmZXIgc2V0dXAgaWYgbW9kZSBpcyAna2VybmVsLWludGVycnVwdCdcbiAgICBpZiAodGhpcy5pbnRlcnJ1cHRpb25Nb2RlID09PSAna2VybmVsLWludGVycnVwdCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBTa2lwcGluZyBTaGFyZWRBcnJheUJ1ZmZlciBzZXR1cCBmb3Iga2VybmVsICR7aWR9IC0gdXNpbmcga2VybmVsLmludGVycnVwdCgpIG1vZGVgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFB5dGhvbiBrZXJuZWxzIHN1cHBvcnQgaW50ZXJydXB0IGJ1ZmZlcnNcbiAgICAgIFxuICAgICAgLy8gRm9yIFB5dGhvbiBrZXJuZWxzLCBjcmVhdGUgYWN0dWFsIFNoYXJlZEFycmF5QnVmZmVyXG4gICAgICBjb25zdCBzaGFyZWRCdWZmZXIgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSk7XG4gICAgICBjb25zdCBpbnRlcnJ1cHRCdWZmZXIgPSBuZXcgVWludDhBcnJheShzaGFyZWRCdWZmZXIpO1xuICAgICAgXG4gICAgICAvLyBJbml0aWFsaXplIGJ1ZmZlciB0byAwIChubyBpbnRlcnJ1cHQgc2lnbmFsKVxuICAgICAgaW50ZXJydXB0QnVmZmVyWzBdID0gMDtcbiAgICAgIFxuICAgICAgLy8gU3RvcmUgdGhlIGJ1ZmZlciBmb3IgZnV0dXJlIHVzZVxuICAgICAgdGhpcy5pbnRlcnJ1cHRCdWZmZXJzLnNldChpZCwgaW50ZXJydXB0QnVmZmVyKTtcbiAgICAgIFxuICAgICAgLy8gU2VuZCB0aGUgYnVmZmVyIHRvIHRoZSB3b3JrZXIgdG8gc2V0IHVwIHB5b2RpZGUuc2V0SW50ZXJydXB0QnVmZmVyKClcbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiU0VUX0lOVEVSUlVQVF9CVUZGRVJcIixcbiAgICAgICAgYnVmZmVyOiBpbnRlcnJ1cHRCdWZmZXJcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciB0aGUgd29ya2VyIHRvIGNvbmZpcm0gYnVmZmVyIHNldHVwXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGltZW91dCB3YWl0aW5nIGZvciBpbnRlcnJ1cHQgYnVmZmVyIHNldHVwXCIpKTtcbiAgICAgICAgfSwgNTAwMCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBoYW5kbGVyID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gXCJJTlRFUlJVUFRfQlVGRkVSX1NFVFwiKSB7XG4gICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSGFuZGxlIGJhc2VkIG9uIGludGVycnVwdGlvbiBtb2RlXG4gICAgICBpZiAodGhpcy5pbnRlcnJ1cHRpb25Nb2RlID09PSAnc2hhcmVkLWFycmF5LWJ1ZmZlcicpIHtcbiAgICAgICAgLy8gSWYgZXhwbGljaXRseSBzZXQgdG8gc2hhcmVkLWFycmF5LWJ1ZmZlciwgdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgU2hhcmVkQXJyYXlCdWZmZXIgcmVxdWlyZWQgYnV0IG5vdCBhdmFpbGFibGUgZm9yIGtlcm5lbCAke2lkfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNoYXJlZEFycmF5QnVmZmVyIGlzIHJlcXVpcmVkIGJ1dCBub3QgYXZhaWxhYmxlLiBUbyBlbmFibGUgU2hhcmVkQXJyYXlCdWZmZXIsIHlvdXIgc2VydmVyIG11c3Qgc2V0IHRoZXNlIGhlYWRlcnM6XG4tIENyb3NzLU9yaWdpbi1PcGVuZXItUG9saWN5OiBzYW1lLW9yaWdpblxuLSBDcm9zcy1PcmlnaW4tRW1iZWRkZXItUG9saWN5OiByZXF1aXJlLWNvcnBcblxuQWx0ZXJuYXRpdmVseSwgdXNlIGludGVycnVwdGlvbk1vZGU6ICdrZXJuZWwtaW50ZXJydXB0JyBvciAnYXV0bycgaW4gS2VybmVsTWFuYWdlciBvcHRpb25zLmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXV0byBtb2RlOiBmYWxsIGJhY2sgdG8ga2VybmVsLmludGVycnVwdCgpXG4gICAgICAgIGNvbnNvbGUuaW5mbyhg4oS577iPIFNoYXJlZEFycmF5QnVmZmVyIG5vdCBhdmFpbGFibGUgZm9yIGtlcm5lbCAke2lkfS4gVXNpbmcgYWx0ZXJuYXRpdmUgaW50ZXJydXB0IG1ldGhvZC5cblxuVG8gZW5hYmxlIGZhc3RlciBpbnRlcnJ1cHRzLCBjb25maWd1cmUgeW91ciBzZXJ2ZXIgd2l0aCB0aGVzZSBoZWFkZXJzOlxuLSBDcm9zcy1PcmlnaW4tT3BlbmVyLVBvbGljeTogc2FtZS1vcmlnaW5cbi0gQ3Jvc3MtT3JpZ2luLUVtYmVkZGVyLVBvbGljeTogcmVxdWlyZS1jb3JwXG5cbk5vdGU6IFNvbWUgZGV2ZWxvcG1lbnQgc2VydmVycyAoZS5nLiwgVml0ZSwgd2VicGFjay1kZXYtc2VydmVyKSBjYW4gYmUgY29uZmlndXJlZCB0byBhZGQgdGhlc2UgaGVhZGVycy5cblRoZSBhbHRlcm5hdGl2ZSBpbnRlcnJ1cHQgbWV0aG9kIHdpbGwgc3RpbGwgd29yayBidXQgbWF5IGJlIGxlc3MgcmVzcG9uc2l2ZSBmb3IgbG9uZy1ydW5uaW5nIGNvZGUuYCk7XG4gICAgICAgIC8vIERvbid0IHRocm93IC0ga2VybmVsIGNhbiBzdGlsbCB3b3JrIHdpdGhvdXQgaW50ZXJydXB0IGJ1ZmZlclxuICAgICAgfVxuICAgIH1cbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/manager.ts\n\n}");

/***/ }),

/***/ "./src/pyodide-loader.ts":
/*!*******************************!*\
  !*** ./src/pyodide-loader.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadPyodide: () => (/* binding */ loadPyodide)\n/* harmony export */ });\n/* unused harmony exports isPyodideLoaded, getPyodideCDNUrl, getPyodideIndexUrl */\n/**\n * Pyodide CDN Loader Utility\n * Dynamically loads Pyodide from CDN for both main thread and web workers\n */\nconst PYODIDE_CDN_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js';\nconst PYODIDE_INDEX_URL = 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/';\n// Global flag to track if Pyodide is loaded\nlet pyodideLoaded = false;\nlet pyodideLoadPromise = null;\n/**\n * Load Pyodide script dynamically in main thread\n */\nfunction loadPyodideScript() {\n    return new Promise((resolve, reject) => {\n        // Check if script is already loaded\n        if (typeof globalThis.loadPyodide !== 'undefined') {\n            resolve();\n            return;\n        }\n        const script = document.createElement('script');\n        script.src = PYODIDE_CDN_URL;\n        script.onload = () => resolve();\n        script.onerror = () => reject(new Error(`Failed to load Pyodide from ${PYODIDE_CDN_URL}`));\n        document.head.appendChild(script);\n    });\n}\n/**\n * Load Pyodide in web worker using importScripts\n */\nfunction loadPyodideInWorker() {\n    return new Promise((resolve, reject) => {\n        try {\n            // Check if we're in a worker environment\n            if (typeof importScripts === 'undefined') {\n                reject(new Error('importScripts is not available - not in a worker context'));\n                return;\n            }\n            // Check if already loaded\n            if (typeof globalThis.loadPyodide !== 'undefined') {\n                resolve();\n                return;\n            }\n            importScripts(PYODIDE_CDN_URL);\n            resolve();\n        }\n        catch (error) {\n            reject(new Error(`Failed to import Pyodide in worker: ${error}`));\n        }\n    });\n}\n/**\n * Initialize Pyodide with proper configuration\n */\nasync function loadPyodide(config = {}) {\n    // Return existing promise if already loading\n    if (pyodideLoadPromise) {\n        return pyodideLoadPromise;\n    }\n    pyodideLoadPromise = (async () => {\n        try {\n            // Determine if we're in a worker or main thread\n            const isWorker = typeof importScripts !== 'undefined';\n            // Load the Pyodide script\n            if (isWorker) {\n                await loadPyodideInWorker();\n            }\n            else {\n                await loadPyodideScript();\n            }\n            // Get the global loadPyodide function\n            const globalLoadPyodide = globalThis.loadPyodide;\n            if (!globalLoadPyodide) {\n                throw new Error('loadPyodide function not found after script load');\n            }\n            // Configure default options\n            const defaultConfig = {\n                indexURL: PYODIDE_INDEX_URL,\n                ...config\n            };\n            // Initialize Pyodide\n            const pyodide = await globalLoadPyodide(defaultConfig);\n            pyodideLoaded = true;\n            console.log('âœ… Pyodide loaded successfully from CDN');\n            return pyodide;\n        }\n        catch (error) {\n            pyodideLoadPromise = null; // Reset on failure\n            throw error;\n        }\n    })();\n    return pyodideLoadPromise;\n}\n/**\n * Check if Pyodide is already loaded\n */\nfunction isPyodideLoaded() {\n    return pyodideLoaded && typeof globalThis.loadPyodide !== 'undefined';\n}\n/**\n * Get Pyodide CDN URL for external use\n */\nfunction getPyodideCDNUrl() {\n    return PYODIDE_CDN_URL;\n}\n/**\n * Get Pyodide index URL for external use\n */\nfunction getPyodideIndexUrl() {\n    return PYODIDE_INDEX_URL;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFDcEIsUUFBUSxFQUFFLGlCQUFpQjtnQkFDM0IsR0FBRyxNQUFNO2FBQ1YsQ0FBQztZQUVGLHFCQUFxQjtZQUNyQixNQUFNLE9BQU8sR0FBRyxNQUFNLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3ZELGFBQWEsR0FBRyxJQUFJLENBQUM7WUFFckIsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO1lBQ3RELE9BQU8sT0FBTyxDQUFDO1FBQ2pCLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2Ysa0JBQWtCLEdBQUcsSUFBSSxDQUFDLENBQUMsbUJBQW1CO1lBQzlDLE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUMsQ0FBQyxFQUFFLENBQUM7SUFFTCxPQUFPLGtCQUFrQixDQUFDO0FBQzVCLENBQUM7QUFFRDs7R0FFRztBQUNJLFNBQVMsZUFBZTtJQUM3QixPQUFPLGFBQWEsSUFBSSxPQUFRLFVBQWtCLENBQUMsV0FBVyxLQUFLLFdBQVcsQ0FBQztBQUNqRixDQUFDO0FBRUQ7O0dBRUc7QUFDSSxTQUFTLGdCQUFnQjtJQUM5QixPQUFPLGVBQWUsQ0FBQztBQUN6QixDQUFDO0FBRUQ7O0dBRUc7QUFDSSxTQUFTLGtCQUFrQjtJQUNoQyxPQUFPLGlCQUFpQixDQUFDO0FBQzNCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItcHl0aG9uLWtlcm5lbC8uL3NyYy9weW9kaWRlLWxvYWRlci50cz81MDExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUHlvZGlkZSBDRE4gTG9hZGVyIFV0aWxpdHlcbiAqIER5bmFtaWNhbGx5IGxvYWRzIFB5b2RpZGUgZnJvbSBDRE4gZm9yIGJvdGggbWFpbiB0aHJlYWQgYW5kIHdlYiB3b3JrZXJzXG4gKi9cblxuY29uc3QgUFlPRElERV9DRE5fVVJMID0gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9weW9kaWRlL3YwLjI4LjAvZnVsbC9weW9kaWRlLmpzJztcbmNvbnN0IFBZT0RJREVfSU5ERVhfVVJMID0gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9weW9kaWRlL3YwLjI4LjAvZnVsbC8nO1xuXG4vLyBHbG9iYWwgZmxhZyB0byB0cmFjayBpZiBQeW9kaWRlIGlzIGxvYWRlZFxubGV0IHB5b2RpZGVMb2FkZWQgPSBmYWxzZTtcbmxldCBweW9kaWRlTG9hZFByb21pc2U6IFByb21pc2U8YW55PiB8IG51bGwgPSBudWxsO1xuXG4vKipcbiAqIExvYWQgUHlvZGlkZSBzY3JpcHQgZHluYW1pY2FsbHkgaW4gbWFpbiB0aHJlYWRcbiAqL1xuZnVuY3Rpb24gbG9hZFB5b2RpZGVTY3JpcHQoKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgc2NyaXB0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgaWYgKHR5cGVvZiAoZ2xvYmFsVGhpcyBhcyBhbnkpLmxvYWRQeW9kaWRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdC5zcmMgPSBQWU9ESURFX0NETl9VUkw7XG4gICAgc2NyaXB0Lm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcbiAgICBzY3JpcHQub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIFB5b2RpZGUgZnJvbSAke1BZT0RJREVfQ0ROX1VSTH1gKSk7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBMb2FkIFB5b2RpZGUgaW4gd2ViIHdvcmtlciB1c2luZyBpbXBvcnRTY3JpcHRzXG4gKi9cbmZ1bmN0aW9uIGxvYWRQeW9kaWRlSW5Xb3JrZXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIGEgd29ya2VyIGVudmlyb25tZW50XG4gICAgICBpZiAodHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2ltcG9ydFNjcmlwdHMgaXMgbm90IGF2YWlsYWJsZSAtIG5vdCBpbiBhIHdvcmtlciBjb250ZXh0JykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgbG9hZGVkXG4gICAgICBpZiAodHlwZW9mIChnbG9iYWxUaGlzIGFzIGFueSkubG9hZFB5b2RpZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbXBvcnRTY3JpcHRzKFBZT0RJREVfQ0ROX1VSTCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBpbXBvcnQgUHlvZGlkZSBpbiB3b3JrZXI6ICR7ZXJyb3J9YCkpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBQeW9kaWRlIHdpdGggcHJvcGVyIGNvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRQeW9kaWRlKGNvbmZpZzogYW55ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAvLyBSZXR1cm4gZXhpc3RpbmcgcHJvbWlzZSBpZiBhbHJlYWR5IGxvYWRpbmdcbiAgaWYgKHB5b2RpZGVMb2FkUHJvbWlzZSkge1xuICAgIHJldHVybiBweW9kaWRlTG9hZFByb21pc2U7XG4gIH1cblxuICBweW9kaWRlTG9hZFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBEZXRlcm1pbmUgaWYgd2UncmUgaW4gYSB3b3JrZXIgb3IgbWFpbiB0aHJlYWRcbiAgICAgIGNvbnN0IGlzV29ya2VyID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnO1xuICAgICAgXG4gICAgICAvLyBMb2FkIHRoZSBQeW9kaWRlIHNjcmlwdFxuICAgICAgaWYgKGlzV29ya2VyKSB7XG4gICAgICAgIGF3YWl0IGxvYWRQeW9kaWRlSW5Xb3JrZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGxvYWRQeW9kaWRlU2NyaXB0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgZ2xvYmFsIGxvYWRQeW9kaWRlIGZ1bmN0aW9uXG4gICAgICBjb25zdCBnbG9iYWxMb2FkUHlvZGlkZSA9IChnbG9iYWxUaGlzIGFzIGFueSkubG9hZFB5b2RpZGU7XG4gICAgICBpZiAoIWdsb2JhbExvYWRQeW9kaWRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9hZFB5b2RpZGUgZnVuY3Rpb24gbm90IGZvdW5kIGFmdGVyIHNjcmlwdCBsb2FkJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbmZpZ3VyZSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgIGluZGV4VVJMOiBQWU9ESURFX0lOREVYX1VSTCxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIFB5b2RpZGVcbiAgICAgIGNvbnN0IHB5b2RpZGUgPSBhd2FpdCBnbG9iYWxMb2FkUHlvZGlkZShkZWZhdWx0Q29uZmlnKTtcbiAgICAgIHB5b2RpZGVMb2FkZWQgPSB0cnVlO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFB5b2RpZGUgbG9hZGVkIHN1Y2Nlc3NmdWxseSBmcm9tIENETicpO1xuICAgICAgcmV0dXJuIHB5b2RpZGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHB5b2RpZGVMb2FkUHJvbWlzZSA9IG51bGw7IC8vIFJlc2V0IG9uIGZhaWx1cmVcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSkoKTtcblxuICByZXR1cm4gcHlvZGlkZUxvYWRQcm9taXNlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIFB5b2RpZGUgaXMgYWxyZWFkeSBsb2FkZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHlvZGlkZUxvYWRlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIHB5b2RpZGVMb2FkZWQgJiYgdHlwZW9mIChnbG9iYWxUaGlzIGFzIGFueSkubG9hZFB5b2RpZGUgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIEdldCBQeW9kaWRlIENETiBVUkwgZm9yIGV4dGVybmFsIHVzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHlvZGlkZUNETlVybCgpOiBzdHJpbmcge1xuICByZXR1cm4gUFlPRElERV9DRE5fVVJMO1xufVxuXG4vKipcbiAqIEdldCBQeW9kaWRlIGluZGV4IFVSTCBmb3IgZXh0ZXJuYWwgdXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQeW9kaWRlSW5kZXhVcmwoKTogc3RyaW5nIHtcbiAgcmV0dXJuIFBZT0RJREVfSU5ERVhfVVJMO1xufSAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pyodide-loader.ts\n\n}");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KernelEvents: () => (/* binding */ KernelEvents)\n/* harmony export */ });\n// Shared types and interfaces to prevent circular dependencies\n// These are extracted from index.ts to break the circular dependency\n// Events enum\nvar KernelEvents;\n(function (KernelEvents) {\n    // IOPub Channel Messages\n    KernelEvents[\"STREAM\"] = \"stream\";\n    KernelEvents[\"DISPLAY_DATA\"] = \"display_data\";\n    KernelEvents[\"UPDATE_DISPLAY_DATA\"] = \"update_display_data\";\n    KernelEvents[\"EXECUTE_RESULT\"] = \"execute_result\";\n    KernelEvents[\"EXECUTE_ERROR\"] = \"execute_error\";\n    KernelEvents[\"EXECUTE_REQUEST\"] = \"execute_request\";\n    // Input request\n    KernelEvents[\"INPUT_REQUEST\"] = \"input_request\";\n    // Output control\n    KernelEvents[\"CLEAR_OUTPUT\"] = \"clear_output\";\n    // Comm messages\n    KernelEvents[\"COMM_OPEN\"] = \"comm_open\";\n    KernelEvents[\"COMM_MSG\"] = \"comm_msg\";\n    KernelEvents[\"COMM_CLOSE\"] = \"comm_close\";\n    // Internal Events\n    KernelEvents[\"KERNEL_READY\"] = \"kernel_ready\";\n    KernelEvents[\"KERNEL_BUSY\"] = \"kernel_busy\";\n    KernelEvents[\"KERNEL_IDLE\"] = \"kernel_idle\";\n    // Special catchall for internal use\n    KernelEvents[\"ALL\"] = \"*\";\n    // Execution monitoring events\n    KernelEvents[\"EXECUTION_STALLED\"] = \"execution_stalled\";\n    // Enhanced stuck kernel handling events\n    KernelEvents[\"KERNEL_UNRECOVERABLE\"] = \"kernel_unrecoverable\";\n    KernelEvents[\"EXECUTION_INTERRUPTED\"] = \"execution_interrupted\";\n    KernelEvents[\"KERNEL_RESTARTED\"] = \"kernel_restarted\";\n    KernelEvents[\"KERNEL_TERMINATED\"] = \"kernel_terminated\";\n})(KernelEvents || (KernelEvents = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHlwZXMudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEsK0RBQStEO0FBQy9ELHFFQUFxRTtBQUVyRSxjQUFjO0FBQ2QsSUFBWSxZQW9DWDtBQXBDRCxXQUFZLFlBQVk7SUFDdEIseUJBQXlCO0lBQ3pCLGlDQUFpQjtJQUNqQiw2Q0FBNkI7SUFDN0IsMkRBQTJDO0lBQzNDLGlEQUFpQztJQUNqQywrQ0FBK0I7SUFDL0IsbURBQW1DO0lBRW5DLGdCQUFnQjtJQUNoQiwrQ0FBK0I7SUFFL0IsaUJBQWlCO0lBQ2pCLDZDQUE2QjtJQUU3QixnQkFBZ0I7SUFDaEIsdUNBQXVCO0lBQ3ZCLHFDQUFxQjtJQUNyQix5Q0FBeUI7SUFFekIsa0JBQWtCO0lBQ2xCLDZDQUE2QjtJQUM3QiwyQ0FBMkI7SUFDM0IsMkNBQTJCO0lBRTNCLG9DQUFvQztJQUNwQyx5QkFBUztJQUVULDhCQUE4QjtJQUM5Qix1REFBdUM7SUFFdkMsd0NBQXdDO0lBQ3hDLDZEQUE2QztJQUM3QywrREFBK0M7SUFDL0MscURBQXFDO0lBQ3JDLHVEQUF1QztBQUN6QyxDQUFDLEVBcENXLFlBQVksS0FBWixZQUFZLFFBb0N2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1weXRob24ta2VybmVsLy4vc3JjL3R5cGVzLnRzP2E3NmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2hhcmVkIHR5cGVzIGFuZCBpbnRlcmZhY2VzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4vLyBUaGVzZSBhcmUgZXh0cmFjdGVkIGZyb20gaW5kZXgudHMgdG8gYnJlYWsgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3lcblxuLy8gRXZlbnRzIGVudW1cbmV4cG9ydCBlbnVtIEtlcm5lbEV2ZW50cyB7XG4gIC8vIElPUHViIENoYW5uZWwgTWVzc2FnZXNcbiAgU1RSRUFNID0gXCJzdHJlYW1cIixcbiAgRElTUExBWV9EQVRBID0gXCJkaXNwbGF5X2RhdGFcIixcbiAgVVBEQVRFX0RJU1BMQVlfREFUQSA9IFwidXBkYXRlX2Rpc3BsYXlfZGF0YVwiLFxuICBFWEVDVVRFX1JFU1VMVCA9IFwiZXhlY3V0ZV9yZXN1bHRcIixcbiAgRVhFQ1VURV9FUlJPUiA9IFwiZXhlY3V0ZV9lcnJvclwiLFxuICBFWEVDVVRFX1JFUVVFU1QgPSBcImV4ZWN1dGVfcmVxdWVzdFwiLFxuICBcbiAgLy8gSW5wdXQgcmVxdWVzdFxuICBJTlBVVF9SRVFVRVNUID0gXCJpbnB1dF9yZXF1ZXN0XCIsXG4gIFxuICAvLyBPdXRwdXQgY29udHJvbFxuICBDTEVBUl9PVVRQVVQgPSBcImNsZWFyX291dHB1dFwiLFxuICBcbiAgLy8gQ29tbSBtZXNzYWdlc1xuICBDT01NX09QRU4gPSBcImNvbW1fb3BlblwiLFxuICBDT01NX01TRyA9IFwiY29tbV9tc2dcIixcbiAgQ09NTV9DTE9TRSA9IFwiY29tbV9jbG9zZVwiLFxuICBcbiAgLy8gSW50ZXJuYWwgRXZlbnRzXG4gIEtFUk5FTF9SRUFEWSA9IFwia2VybmVsX3JlYWR5XCIsXG4gIEtFUk5FTF9CVVNZID0gXCJrZXJuZWxfYnVzeVwiLFxuICBLRVJORUxfSURMRSA9IFwia2VybmVsX2lkbGVcIixcbiAgXG4gIC8vIFNwZWNpYWwgY2F0Y2hhbGwgZm9yIGludGVybmFsIHVzZVxuICBBTEwgPSBcIipcIiwgLy8gV2lsZGNhcmQgZXZlbnQgdHlwZVxuICBcbiAgLy8gRXhlY3V0aW9uIG1vbml0b3JpbmcgZXZlbnRzXG4gIEVYRUNVVElPTl9TVEFMTEVEID0gXCJleGVjdXRpb25fc3RhbGxlZFwiLFxuICBcbiAgLy8gRW5oYW5jZWQgc3R1Y2sga2VybmVsIGhhbmRsaW5nIGV2ZW50c1xuICBLRVJORUxfVU5SRUNPVkVSQUJMRSA9IFwia2VybmVsX3VucmVjb3ZlcmFibGVcIixcbiAgRVhFQ1VUSU9OX0lOVEVSUlVQVEVEID0gXCJleGVjdXRpb25faW50ZXJydXB0ZWRcIixcbiAgS0VSTkVMX1JFU1RBUlRFRCA9IFwia2VybmVsX3Jlc3RhcnRlZFwiLFxuICBLRVJORUxfVEVSTUlOQVRFRCA9IFwia2VybmVsX3Rlcm1pbmF0ZWRcIlxufVxuXG4vLyBFdmVudEVtaXR0ZXIgaW50ZXJmYWNlIGZvciB0eXBpbmdcbmV4cG9ydCBpbnRlcmZhY2UgSUV2ZW50RW1pdHRlciB7XG4gIG9uKGV2ZW50TmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogRnVuY3Rpb24pOiB2b2lkO1xuICBvZmYoZXZlbnROYW1lOiBzdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbik6IHZvaWQ7XG4gIGVtaXQoZXZlbnROYW1lOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKTogdm9pZDtcbiAgc2V0TWF4TGlzdGVuZXJzKG46IG51bWJlcik6IHZvaWQ7XG59XG5cbi8vIEZpbGVzeXN0ZW0gbW91bnQgb3B0aW9uc1xuZXhwb3J0IGludGVyZmFjZSBJRmlsZXN5c3RlbU1vdW50T3B0aW9ucyB7XG4gIGVuYWJsZWQ/OiBib29sZWFuO1xuICByb290Pzogc3RyaW5nO1xuICBtb3VudFBvaW50Pzogc3RyaW5nO1xufVxuXG4vLyBLZXJuZWwgb3B0aW9ucyBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSUtlcm5lbE9wdGlvbnMge1xuICBmaWxlc3lzdGVtPzogSUZpbGVzeXN0ZW1Nb3VudE9wdGlvbnM7XG4gIGVudj86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47IC8vIEVudmlyb25tZW50IHZhcmlhYmxlcyB0byBzZXQgaW4gdGhlIGtlcm5lbFxuICBsb2NrRmlsZVVSTD86IHN0cmluZzsgLy8gVVJMIHRvIHB5b2RpZGUtbG9jay5qc29uIGZpbGUgZm9yIGZhc3RlciBsb2FkaW5nXG4gIGF1dG9TeW5jRnM/OiBib29sZWFuOyAvLyBBdXRvbWF0aWNhbGx5IHN5bmMgbmF0aXZlIGZpbGVzeXN0ZW0gYWZ0ZXIgY29kZSBleGVjdXRpb24gKGRlZmF1bHQ6IGZhbHNlKVxufVxuXG4vLyBOYXRpdmUgZmlsZXN5c3RlbSBoYW5kbGUgdHlwZVxuZXhwb3J0IGludGVyZmFjZSBJTmF0aXZlRlNIYW5kbGUge1xuICBzeW5jZnMoKTogUHJvbWlzZTx2b2lkPjtcbn1cblxuLy8gS2VybmVsIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsIGV4dGVuZHMgSUV2ZW50RW1pdHRlciB7XG4gIGluaXRpYWxpemUob3B0aW9ucz86IElLZXJuZWxPcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcbiAgZXhlY3V0ZShjb2RlOiBzdHJpbmcsIHBhcmVudD86IGFueSk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ/OiBhbnksIGVycm9yPzogRXJyb3IgfT47XG4gIGV4ZWN1dGVTdHJlYW0/KGNvZGU6IHN0cmluZywgcGFyZW50PzogYW55KTogQXN5bmNHZW5lcmF0b3I8YW55LCB7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdD86IGFueSwgZXJyb3I/OiBFcnJvciB9LCB2b2lkPjtcbiAgaXNJbml0aWFsaXplZCgpOiBib29sZWFuO1xuICBpbnB1dFJlcGx5KGNvbnRlbnQ6IHsgdmFsdWU6IHN0cmluZyB9KTogUHJvbWlzZTx2b2lkPjtcbiAgZ2V0U3RhdHVzKCk6IFByb21pc2U8XCJhY3RpdmVcIiB8IFwiYnVzeVwiIHwgXCJ1bmtub3duXCI+O1xuXG4gIC8vIEludGVycnVwdCBmdW5jdGlvbmFsaXR5XG4gIGludGVycnVwdD8oKTogUHJvbWlzZTxib29sZWFuPjtcbiAgc2V0SW50ZXJydXB0QnVmZmVyPyhidWZmZXI6IFVpbnQ4QXJyYXkpOiB2b2lkO1xuXG4gIC8vIE5hdGl2ZSBmaWxlc3lzdGVtIG1vdW50aW5nXG4gIG1vdW50RlM/KG1vdW50UGF0aDogc3RyaW5nLCBkaXJIYW5kbGU/OiBGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHwgbnVsbCwgcGVybWlzc2lvbj86ICdyZWFkJyB8ICdyZWFkd3JpdGUnKTogUHJvbWlzZTxJTmF0aXZlRlNIYW5kbGU+O1xuICBnZXRNb3VudGVkRmlsZXN5c3RlbXM/KCk6IEFycmF5PHsgbW91bnRQYXRoOiBzdHJpbmc7IHBlcm1pc3Npb246ICdyZWFkJyB8ICdyZWFkd3JpdGUnOyBjYW5TeW5jOiBib29sZWFuOyB9PjtcbiAgc3luY0ZpbGVzeXN0ZW0/KG1vdW50UGF0aDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+O1xuICB1cGdyYWRlRmlsZXN5c3RlbVBlcm1pc3Npb24/KG1vdW50UGF0aDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+O1xuXG4gIC8vIE9wdGlvbmFsIG1ldGhvZHNcbiAgY29tcGxldGU/KGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPGFueT47XG4gIGluc3BlY3Q/KGNvZGU6IHN0cmluZywgY3Vyc29yX3BvczogbnVtYmVyLCBkZXRhaWxfbGV2ZWw6IDAgfCAxLCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPGFueT47XG4gIGlzQ29tcGxldGU/KGNvZGU6IHN0cmluZywgcGFyZW50PzogYW55KTogUHJvbWlzZTxhbnk+O1xuICBjb21tSW5mbz8odGFyZ2V0X25hbWU6IHN0cmluZyB8IG51bGwsIHBhcmVudD86IGFueSk6IFByb21pc2U8YW55PjtcbiAgY29tbU9wZW4/KGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KTogUHJvbWlzZTx2b2lkPjtcbiAgY29tbU1zZz8oY29udGVudDogYW55LCBwYXJlbnQ/OiBhbnkpOiBQcm9taXNlPHZvaWQ+O1xuICBjb21tQ2xvc2U/KGNvbnRlbnQ6IGFueSwgcGFyZW50PzogYW55KTogUHJvbWlzZTx2b2lkPjtcbn1cblxuLy8gRXhlY3V0ZSBvcHRpb25zIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBJS2VybmVsRXhlY3V0ZU9wdGlvbnMge1xuICBjb2RlOiBzdHJpbmc7XG4gIHNpbGVudD86IGJvb2xlYW47XG4gIHN0b3JlSGlzdG9yeT86IGJvb2xlYW47XG59XG5cbi8vIE1lc3NhZ2UgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIElNZXNzYWdlIHtcbiAgdHlwZTogc3RyaW5nO1xuICBidW5kbGU/OiBhbnk7XG4gIGNvbnRlbnQ/OiBhbnk7XG4gIG1ldGFkYXRhPzogYW55O1xuICBwYXJlbnRIZWFkZXI/OiBhbnk7XG4gIGJ1ZmZlcnM/OiBhbnk7XG4gIGlkZW50PzogYW55O1xufVxuXG4vLyBFdmVudCBkYXRhIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBJRXZlbnREYXRhIHtcbiAgdHlwZTogc3RyaW5nO1xuICBkYXRhOiBhbnk7XG59ICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/types.ts\n\n}");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module is referenced by other modules so it can't be inlined
/******/ var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ const __webpack_exports__Kernel = __webpack_exports__.Kernel;
/******/ const __webpack_exports__KernelEvents = __webpack_exports__.KernelEvents;
/******/ const __webpack_exports__KernelLanguage = __webpack_exports__.KernelLanguage;
/******/ const __webpack_exports__KernelManager = __webpack_exports__.KernelManager;
/******/ const __webpack_exports__KernelMode = __webpack_exports__.KernelMode;
/******/ export { __webpack_exports__Kernel as Kernel, __webpack_exports__KernelEvents as KernelEvents, __webpack_exports__KernelLanguage as KernelLanguage, __webpack_exports__KernelManager as KernelManager, __webpack_exports__KernelMode as KernelMode };
/******/ 
